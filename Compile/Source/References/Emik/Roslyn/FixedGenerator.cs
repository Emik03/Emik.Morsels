// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
#pragma warning disable GlobalUsingsAnalyzer
global using static Emik.Morsels.FixedGenerator;

// ReSharper disable once CheckNamespace
namespace Emik.Morsels;
#pragma warning restore GlobalUsingsAnalyzer
/// <summary>Generates the attribute needed to use this analyzer.</summary>
/// <param name="hintName">The file name of the source.</param>
/// <param name="contents">The contents of the source.</param>
public abstract class FixedGenerator(
    [StringSyntax(StringSyntaxAttribute.Uri), UriString] string hintName,
    [StringSyntax("C#")] string contents
) : IIncrementalGenerator
{
    /// <summary>The header for generated files.</summary>
    [StringSyntax("C#")]
    public const string Header =
        """
        // <auto-generated/>
        // ReSharper disable RedundantNameQualifier
        // ReSharper disable once CheckNamespace
        #nullable enable

        """;

    /// <summary>The extension of each generated file.</summary>
    const string Extension = ".g.cs";

    /// <summary>Gets the attribute that indicates source generation from this library.</summary>
    [Pure, StringSyntax("C#")]
    public static string Annotation { get; } =
#if GENERATED_CODE_ABSOLUTE_PATH
        $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{
            typeof(FixedGenerator).Assembly.ManifestModule.FullyQualifiedName}\", \"{
                typeof(FixedGenerator).Assembly.ManifestModule.ModuleVersionId}\")]";
#else
        $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{
            typeof(FixedGenerator).Assembly.GetName().Name}\", \"{
                typeof(FixedGenerator).Assembly.GetName().Version}\")]";
#endif
    /// <summary>Gets the name of the generated attribute.</summary>
    [Pure]
    public string Name => hintName;

    /// <summary>Gets the source.</summary>
    [Pure]
    public (string, SourceText) Source
    {
        get
        {
            var (name, text) = this;

            return ($"{typeof(AttributeGenerator).Namespace}/{typeof(AttributeGenerator)}/{name}",
                SourceText.From(text, Encoding.UTF8));
        }
    }

    /// <summary>Gets the name of the attribute generated specified by <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The kind of <see cref="FixedGenerator"/> to get the <see cref="Name"/> from.</typeparam>
    /// <returns>The <see cref="Name"/> of the <see cref="FixedGenerator"/> <typeparamref name="T"/>.</returns>
    [Pure]
    public static string Of<T>()
        where T : FixedGenerator, new() =>
        new T().Name;

    /// <summary>Deconstructs this instance to source code.</summary>
    /// <param name="name">The name of the generated file.</param>
    /// <param name="text">The contents of the generated file.</param>
    public void Deconstruct(out string name, out string text) =>
        (name, text) = ($"{hintName}{Extension}", $"{Header}{contents}\n");

    /// <inheritdoc />
#pragma warning disable CA1033
    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(AddSource);
#pragma warning restore CA1033
    /// <summary>Adds source code to the context.</summary>
    /// <param name="context">The context to add source code to.</param>
    void AddSource(IncrementalGeneratorPostInitializationContext context)
    {
        var (name, text) = this;
        context.AddSource(name, text);
    }
}
#endif
