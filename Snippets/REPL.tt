<# // SPDX-License-Identifier: MPL-2.0  #>
<#@ output extension=".csx" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ template hostspecific="true" #>
// <auto-generated/>
#pragma warning disable CS0208
#define NET8_0
#define NET80
#define NET8_0_OR_GREATER
#define NET80_OR_GREATER
#define NET7_0_OR_GREATER
#define NET70_OR_GREATER
#define NET6_0_OR_GREATER
#define NET60_OR_GREATER
#define NET5_0_OR_GREATER
#define NET50_OR_GREATER
#define NETCOREAPP
#define NETSTANDARD2_1_OR_GREATER
#define NETSTANDARD2_0_OR_GREATER
#define NETSTANDARD1_6_OR_GREATER
#define NETSTANDARD1_5_OR_GREATER
#define NETSTANDARD1_4_OR_GREATER
#define NETSTANDARD1_3_OR_GREATER
#define NETSTANDARD1_2_OR_GREATER
#define NETSTANDARD1_1_OR_GREATER
#define NETSTANDARD1_0_OR_GREATER
#define NETSTANDARD
#define CSHARPREPL
#define NO_ROSLYN
/* Generated usings:
AllTypes
    .Where(x => !string.IsNullOrWhiteSpace(x.Namespace) && x.FindPathToNull(x => x.BaseType).All(x => x.IsPublic || x.IsNestedPublic))
    .Select(x => $"using {x.Namespace};\n")
    .Distinct()
    .OrderBy(x => x.StartsWith("using System") ? $"a{x}" : x)
    .Conjoin("")
    .Peek(SetText);
*/
using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Buffers.Text;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.CommandLine;
using System.CommandLine.Binding;
using System.CommandLine.Builder;
using System.CommandLine.Completions;
using System.CommandLine.Help;
using System.CommandLine.Invocation;
using System.CommandLine.IO;
using System.CommandLine.Parsing;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.ComponentModel.Design.Serialization;
using System.Composition;
using System.Composition.Convention;
using System.Composition.Hosting;
using System.Composition.Hosting.Core;
using System.Configuration.Assemblies;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Diagnostics.Metrics;
using System.Diagnostics.SymbolStore;
using System.Diagnostics.Tracing;
using System.Drawing;
using System.Dynamic;
using System.Formats.Asn1;
using System.Globalization;
using System.IO;
using System.IO.Abstractions;
using System.IO.Compression;
using System.IO.Enumeration;
using System.IO.MemoryMappedFiles;
using System.IO.Pipes;
using System.Linq;
using System.Linq.Expressions;
using System.Linq.Expressions.Compiler;
using System.Linq.Expressions.Interpreter;
using System.Linq.Parallel;
using System.Net;
using System.Net.Cache;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Http.Metrics;
using System.Net.NetworkInformation;
using System.Net.Security;
using System.Net.Sockets;
using System.Numerics;
using System.Reflection;
using System.Reflection.Emit;
using System.Reflection.Metadata;
using System.Reflection.Metadata.Ecma335;
using System.Reflection.PortableExecutable;
using System.Resources;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.InteropServices.ObjectiveC;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.Arm;
using System.Runtime.Intrinsics.Wasm;
using System.Runtime.Intrinsics.X86;
using System.Runtime.Loader;
using System.Runtime.Remoting;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Authentication;
using System.Security.Authentication.ExtendedProtection;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Text.RegularExpressions;
using System.Text.Unicode;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Sources;
using System.Timers;
using System.Windows.Input;
using System.Windows.Markup;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Resolvers;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.Serialization.Configuration;
using System.Xml.XPath;
using System.Xml.Xsl;
using System.Xml.Xsl.Runtime;
using System.Xml.Xsl.Xslt;
using CSharpRepl.Services;
using CSharpRepl.Services.Completion;
using CSharpRepl.Services.Completion.OpenAI;
using CSharpRepl.Services.Completion.OpenAI.ChatCompletionApi;
using CSharpRepl.Services.Completion.OpenAI.CompletionApi;
using CSharpRepl.Services.Extensions;
using CSharpRepl.Services.Logging;
using CSharpRepl.Services.Roslyn;
using CSharpRepl.Services.Roslyn.Formatting;
using CSharpRepl.Services.Roslyn.MetadataResolvers;
using CSharpRepl.Services.Roslyn.References;
using CSharpRepl.Services.Roslyn.Scripting;
using CSharpRepl.Services.SymbolExploration;
using CSharpRepl.Services.SyntaxHighlighting;
using CSharpRepl.Services.Theming;
using Internal;
using Internal.Runtime.InteropServices;
using Microsoft.Build.Locator;
using Microsoft.Cci;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.BraceCompletion;
using Microsoft.CodeAnalysis.Classification;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CodeGen;
using Microsoft.CodeAnalysis.CodeRefactorings;
using Microsoft.CodeAnalysis.CodeStyle;
using Microsoft.CodeAnalysis.Collections;
using Microsoft.CodeAnalysis.Completion;
using Microsoft.CodeAnalysis.Completion.Providers;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Extensions;
using Microsoft.CodeAnalysis.CSharp.Formatting;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.CSharp.Scripting.Hosting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator;
using Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral;
using Microsoft.CodeAnalysis.DesignerAttribute;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles;
using Microsoft.CodeAnalysis.Diagnostics.Telemetry;
using Microsoft.CodeAnalysis.Differencing;
using Microsoft.CodeAnalysis.Editing;
using Microsoft.CodeAnalysis.EmbeddedLanguages.Common;
using Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.ErrorReporting;
using Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api;
using Microsoft.CodeAnalysis.ExternalAccess.Watch.Api;
using Microsoft.CodeAnalysis.ExtractInterface;
using Microsoft.CodeAnalysis.FindSymbols;
using Microsoft.CodeAnalysis.FindSymbols.SymbolTree;
using Microsoft.CodeAnalysis.FlowAnalysis;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.GenerateConstructorFromMembers;
using Microsoft.CodeAnalysis.Host;
using Microsoft.CodeAnalysis.Host.Mef;
using Microsoft.CodeAnalysis.MoveToNamespace;
using Microsoft.CodeAnalysis.NavigateTo;
using Microsoft.CodeAnalysis.Navigation;
using Microsoft.CodeAnalysis.NavigationBar;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Options;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.QuickInfo;
using Microsoft.CodeAnalysis.Recommendations;
using Microsoft.CodeAnalysis.Remote;
using Microsoft.CodeAnalysis.Rename;
using Microsoft.CodeAnalysis.Scripting;
using Microsoft.CodeAnalysis.Scripting.Hosting;
using Microsoft.CodeAnalysis.Shared.Collections;
using Microsoft.CodeAnalysis.Shared.Extensions;
using Microsoft.CodeAnalysis.Shared.TestHooks;
using Microsoft.CodeAnalysis.Shared.Utilities;
using Microsoft.CodeAnalysis.Simplification;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis.Tags;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.Workspaces.ProjectSystem;
using Microsoft.DiaSymReader;
using Microsoft.DotNet.PlatformAbstractions;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyModel;
using Microsoft.Extensions.DependencyModel.Resolution;
using Microsoft.Extensions.Internal;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Primitives;
using Microsoft.SourceLink.Tools;
using Microsoft.SymbolStore;
using Microsoft.SymbolStore.KeyGenerators;
using Microsoft.SymbolStore.SymbolStores;
using Microsoft.Win32.SafeHandles;
using MS.Internal.Xml.XPath;
using Newtonsoft.Json;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Schema;
using Newtonsoft.Json.Serialization;
using NuGet;
using NuGet.Client;
using NuGet.Commands;
using NuGet.Commands.PackCommand;
using NuGet.Commands.SignCommand;
using NuGet.Common;
using NuGet.Common.Migrations;
using NuGet.Configuration;
using NuGet.ContentModel;
using NuGet.ContentModel.Infrastructure;
using NuGet.DependencyResolver;
using NuGet.Frameworks;
using NuGet.LibraryModel;
using NuGet.PackageManagement;
using NuGet.PackageManagement.Utility;
using NuGet.Packaging;
using NuGet.Packaging.Core;
using NuGet.Packaging.Licenses;
using NuGet.Packaging.PackageExtraction;
using NuGet.Packaging.Rules;
using NuGet.Packaging.Signing;
using NuGet.Packaging.Signing.DerEncoding;
using NuGet.ProjectManagement;
using NuGet.ProjectManagement.Projects;
using NuGet.ProjectModel;
using NuGet.ProjectModel.ProjectLockFile;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;
using NuGet.Protocol.Events;
using NuGet.Protocol.LocalRepositories;
using NuGet.Protocol.Model;
using NuGet.Protocol.Plugins;
using NuGet.Protocol.Providers;
using NuGet.Protocol.Resources;
using NuGet.Protocol.VisualStudio;
using NuGet.Repositories;
using NuGet.Resolver;
using NuGet.RuntimeModel;
using NuGet.Versioning;
using PrettyPrompt;
using PrettyPrompt.Completion;
using PrettyPrompt.Consoles;
using PrettyPrompt.Documents;
using PrettyPrompt.Highlighting;
using PrettyPrompt.Rendering;
using PrettyPrompt.TextSelection;
using Roslyn.Utilities;
using SOS;
using Spectre.Console;
using Spectre.Console.Advanced;
using Spectre.Console.Extensions;
using Spectre.Console.Rendering;
using TextCopy;
global using static Emik.Results.Please;
global using static Emik.Results.Result;
global using static FastGenericNew.FastNew;
global using static TextCopy.ClipboardService;
global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
global using Expression = System.Linq.Expressions.Expression;
global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;

<#
    static string ToFullName(string x) => x switch
    {
        "using static Two;" => "",
        "using static Span;" => "",
        "using static Peeks;" => "",
        "using static EnumMath;" => "",
        "using static SmallList;" => "",
        "using static YesFactory;" => "",
        "using static SpanQueries;" => "",
        "using static SpecialType;" => "",
        "using static SplitFactory;" => "",
        "using Range = System.Range;" => "",
        "using static OperatorCaching;" => "",
        "global using static Unforgiving;" => "",
        "global using static TupleExtracts;" => "",
        "global using static FixedGenerator;" => "",
        "global using static MethodGroupings;" => "",
        "using static Enum;" => "using static System.Enum;",
        "using static Math;" => "using static System.Math;",
        "using FieldInfo = System.Reflection.FieldInfo;" => "",
        "global using static IncludedSyntaxNodeRegistrant;" => "",
        "using Expression = System.Linq.Expressions.Expression;" => "",
        "    public static string[] Split(" => "    public static string[] Chop(",
        "using static Expression;" => "using static System.Linq.Expressions.Expression;",
        "using static SecurityAction;" => "using static System.Security.Permissions.SecurityAction;",
        "using static CollectionAccessType;" => "using static JetBrains.Annotations.CollectionAccessType;",
        "using static SecurityPermissionFlag;" => "using static System.Security.Permissions.SecurityPermissionFlag;",
        _ => x
    };

    string[] typeDeclarations = { "ref", "sealed", "partial", "class", "delegate", "enum", "struct", "record" };

    string Publicize(string x) => typeDeclarations.Any(x.StartsWith) ? $"public {x}"  : x;

    var root = Path.Combine(Host.TemplateFile, "../../Compile/Source/References/Emik");

    const string
        /* language=regexp */ ExtensionMethods = @"(?<=(?<=static\s*)partial\s*class).*?\{(.*?)\n\}",
        FullyQualifiedNone = "CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)";

    var lines = Directory
        .GetFiles(root, "*.cs", SearchOption.AllDirectories)
        .Select(File.ReadAllText)
        .Select(x => x.Replace("namespace Emik.Morsels;", "").Replace("Emik.Morsels.", "").Replace("Whitespaces.", ""))
        .Select(x => x.Replace("CollectionAccess(None)", FullyQualifiedNone))
        .Select(x => Regex.Replace(x, ExtensionMethods, "$1", RegexOptions.Singleline))
        .Select(x => x.Replace("static partial class", "").Replace("Skip.Init(out ", "Init(out "))
        .SelectMany(x => x.Split(Environment.NewLine.ToCharArray()))
        .Select(ToFullName)
        .Select(Publicize)
        .OrderByDescending(x => Regex.IsMatch(x, @"^(global\s*)?using\s*.*?;$", RegexOptions.Singleline))
        .ThenByDescending(x => x.StartsWith("global"));

    var output = string.Join(Environment.NewLine, lines);
#><#= output #>
/// <summary>Methods that creates enumerations from individual items.</summary>
static partial class ManyQueries
{
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(Assembly? assembly) => assembly.TryGetTypes();
}

/// <summary>Signifies to ignore this when determining potential interfaces that can be implemented.</summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Event | AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Struct)]
sealed partial class NoStructuralTypingAttribute : Attribute;

/// <summary>Method to inline.</summary>
[AttributeUsage(AttributeTargets.Method)]
sealed partial class InlineAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
    /// <param name="remove">The value to set.</param>
    public InlineAttribute(bool remove = true) => Remove = remove;

    /// <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
    public bool Remove { get; }
}

/// <summary>Provides stringification methods.</summary>
static class Stringifier
{
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(T? source) => source.Stringify();
}

/// <summary>Polyfill for <c>nameof()</c>.</summary>
static class Morsels;

/// <summary>Gets the nothing value, used when the inner value is unspecified.</summary>
static object None => Emik.Results.Result.None;

