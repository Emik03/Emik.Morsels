<# // SPDX-License-Identifier: MPL-2.0  #>
<#@ output extension=".csx" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ template hostspecific="true" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated/>
#r "nuget: CommunityToolkit.Common"
#r "nuget: CommunityToolkit.Diagnostics"
#r "nuget: CommunityToolkit.HighPerformance"
#r "nuget: FastGenericNew"
#r "nuget: JetBrains.Annotations"
#r "nuget: TextCopy"
#pragma warning disable CS0208
#define NET8_0
#define NET80
#define NET8_0_OR_GREATER
#define NET80_OR_GREATER
#define NET7_0_OR_GREATER
#define NET70_OR_GREATER
#define NET6_0_OR_GREATER
#define NET60_OR_GREATER
#define NET5_0_OR_GREATER
#define NET50_OR_GREATER
#define NETCOREAPP
#define NETSTANDARD2_1_OR_GREATER
#define NETSTANDARD2_0_OR_GREATER
#define NETSTANDARD1_6_OR_GREATER
#define NETSTANDARD1_5_OR_GREATER
#define NETSTANDARD1_4_OR_GREATER
#define NETSTANDARD1_3_OR_GREATER
#define NETSTANDARD1_2_OR_GREATER
#define NETSTANDARD1_1_OR_GREATER
#define NETSTANDARD1_0_OR_GREATER
#define NETSTANDARD
#define NO_ALLOWS_REF_STRUCT
#define CSHARPREPL
#define DEBUG
<# /*

Load all:
(
    typeof(CommunityToolkit.Common.Converters),
    typeof(CommunityToolkit.Diagnostics.Guard),
    typeof(CommunityToolkit.Helpers.ISettingsStorageHelper<>),
    typeof(CommunityToolkit.HighPerformance.Box<>),
    typeof(FastGenericNew.FastNew),
    typeof(JetBrains.Annotations.PureAttribute),
    typeof(Microsoft.Extensions.DependencyInjection.ActivatorUtilities),
    typeof(TextCopy.Clipboard)
)

Generated usings:

TextCopy.ClipboardService.SetText(
    AppDomain
        .CurrentDomain
        .GetAssemblies()
        .SelectMany(x => x.GetTypes())
        .Where(x => x.Namespace is not null and not "" && x.IsPublic)
        .Select(x => $"global using {x.Namespace};\n")
        .Distinct()
        .OrderBy(x => x.StartsWith("global using System") ? $"#{x}" : x)
        .Aggregate("", (x, y) => $"{x}{y}")
) */ #>
global using System;
global using System.Buffers;
global using System.Buffers.Binary;
global using System.Buffers.Text;
global using System.CodeDom.Compiler;
global using System.Collections;
global using System.Collections.Concurrent;
global using System.Collections.Frozen;
global using System.Collections.Generic;
global using System.Collections.Immutable;
global using System.Collections.ObjectModel;
global using System.Collections.Specialized;
global using System.ComponentModel;
global using System.ComponentModel.Design;
global using System.ComponentModel.Design.Serialization;
global using System.Configuration.Assemblies;
global using System.Data;
global using System.Data.Common;
global using System.Data.SqlTypes;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.Diagnostics.Contracts;
global using System.Diagnostics.Eventing;
global using System.Diagnostics.Eventing.Reader;
global using System.Diagnostics.Metrics;
global using System.Diagnostics.SymbolStore;
global using System.Diagnostics.Tracing;
global using System.Drawing;
global using System.Drawing.Configuration;
global using System.Dynamic;
global using System.Formats;
global using System.Formats.Asn1;
global using System.Globalization;
global using System.IO;
global using System.IO.Compression;
global using System.IO.Enumeration;
global using System.IO.IsolatedStorage;
global using System.IO.MemoryMappedFiles;
global using System.IO.Pipes;
global using System.Linq;
global using System.Linq.Expressions;
global using System.Linq.Expressions.Interpreter;
global using System.Net;
global using System.Net.Cache;
global using System.Net.Http;
global using System.Net.Http.Headers;
global using System.Net.Http.Metrics;
global using System.Net.Mail;
global using System.Net.Mime;
global using System.Net.NetworkInformation;
global using System.Net.Security;
global using System.Net.Sockets;
global using System.Net.WebSockets;
global using System.Numerics;
global using System.Reflection;
global using System.Reflection.Emit;
global using System.Reflection.Metadata;
global using System.Reflection.Metadata.Ecma335;
global using System.Reflection.PortableExecutable;
global using System.Resources;
global using System.Runtime;
global using System.Runtime.CompilerServices;
global using System.Runtime.ConstrainedExecution;
global using System.Runtime.ExceptionServices;
global using System.Runtime.InteropServices;
global using System.Runtime.InteropServices.ComTypes;
global using System.Runtime.InteropServices.Marshalling;
global using System.Runtime.InteropServices.ObjectiveC;
global using System.Runtime.Intrinsics;
global using System.Runtime.Intrinsics.Arm;
global using System.Runtime.Intrinsics.Wasm;
global using System.Runtime.Intrinsics.X86;
global using System.Runtime.Loader;
global using System.Runtime.Remoting;
global using System.Runtime.Serialization;
global using System.Runtime.Serialization.Formatters;
global using System.Runtime.Serialization.Formatters.Binary;
global using System.Runtime.Serialization.Json;
global using System.Runtime.Versioning;
global using System.Security;
global using System.Security.Authentication;
global using System.Security.Authentication.ExtendedProtection;
global using System.Security.Claims;
global using System.Security.Cryptography;
global using System.Security.Cryptography.Pkcs;
global using System.Security.Cryptography.X509Certificates;
global using System.Security.Permissions;
global using System.Security.Principal;
global using System.Text;
global using System.Text.Encodings;
global using System.Text.Encodings.Web;
global using System.Text.Json;
global using System.Text.Json.Nodes;
global using System.Text.Json.Serialization;
global using System.Text.Json.Serialization.Metadata;
global using System.Text.RegularExpressions;
global using System.Text.Unicode;
global using System.Threading;
global using System.Threading.Channels;
global using System.Threading.Tasks;
global using System.Threading.Tasks.Sources;
global using System.Timers;
global using System.Transactions;
global using System.Web;
global using System.Windows;
global using System.Windows.Input;
global using System.Windows.Markup;
global using System.Xml;
global using System.Xml.Linq;
global using System.Xml.Resolvers;
global using System.Xml.Schema;
global using System.Xml.Serialization;
global using System.Xml.XPath;
global using System.Xml.Xsl;
global using System.Xml.Xsl.Runtime;
global using CommunityToolkit.Common;
global using CommunityToolkit.Common.Collections;
global using CommunityToolkit.Common.Deferred;
global using CommunityToolkit.Common.Extensions;
global using CommunityToolkit.Common.Helpers;
global using CommunityToolkit.Diagnostics;
global using CommunityToolkit.Helpers;
global using CommunityToolkit.HighPerformance;
global using CommunityToolkit.HighPerformance.Buffers;
global using CommunityToolkit.HighPerformance.Buffers.Views;
global using CommunityToolkit.HighPerformance.Enumerables;
global using CommunityToolkit.HighPerformance.Helpers;
global using CommunityToolkit.HighPerformance.Memory;
global using CommunityToolkit.HighPerformance.Memory.Views;
global using CommunityToolkit.HighPerformance.Streams;
global using FastGenericNew;
global using JetBrains.Annotations;
global using TextCopy;
global using static FastGenericNew.FastNew;
global using static TextCopy.ClipboardService;
global using ComptimeString = System.Buffers.SearchValues<char>;
global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
global using Expression = System.Linq.Expressions.Expression;
global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;
<#
    static string ToFullName(string x) => x switch
    {
        "using static Two;" => "",
        "using static Rent;" => "",
        "using static Span;" => "",
        "using static Peeks;" => "",
        "using static EnumMath;" => "",
        "using static SmallList;" => "",
        "using static PlatformID;" => "",
        "using static YesFactory;" => "",
        "using static SpanQueries;" => "",
        "using static SpecialType;" => "",
        "using Substring = string;" => "",
        "using static SplitFactory;" => "",
        "using Range = System.Range;" => "",
        "global using GamePadStates" => "",
        "global using static Undergo;" => "",
        "using ComptimeString = char;" => "",
        "using static OperatorCaching;" => "",
        "using static SplitSpanFactory;" => "",
        "using static SplitMemoryFactory;" => "",
        "global using static Unforgiving;" => "",
        "global using static TupleExtracts;" => "",
        "global using static FixedGenerator;" => "",
        "global using static MethodGroupings;" => "",
        "using ComptimeString = SearchValues<char>;" => "",
        "using static Enum;" => "using static System.Enum;",
        "using static Math;" => "using static System.Math;",
        "using FieldInfo = System.Reflection.FieldInfo;" => "",
        "global using static IncludedSyntaxNodeRegistrant;" => "",
        "using Expression = System.Linq.Expressions.Expression;" => "",
        "using Unsafe = System.Runtime.CompilerServices.Unsafe;" => "",
        "    public static string[] Split(" => "    public static string[] Chop(",
        "using static Expression;" => "using static System.Linq.Expressions.Expression;",
        "using static SecurityAction;" => "using static System.Security.Permissions.SecurityAction;",
        "using static CollectionAccessType;" => "using static JetBrains.Annotations.CollectionAccessType;",
        "using static SecurityPermissionFlag;" => "using static System.Security.Permissions.SecurityPermissionFlag;",
        _ => x,
    };

    static string FirstGroup(Match x) => x.Groups[1].Value;

    static string RemoveComments(string x)
        => x.IndexOf(" // ", StringComparison.Ordinal) is var i and not -1 ? x.Remove(i) : x;

    static string RemoveNamespaces(string x)
        => x.Replace("namespace Emik.Morsels;", "").Replace("Emik.Morsels.", "").Replace("Whitespaces.", "");

    static string RemoveRemainingStaticPartialClasses(string x) => x.Replace("static partial class", "");

    static string QualifyCollectionAccess(string x)
        => x.Replace("CollectionAccess(None)", "CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)");

    static long GetDjb2HashCode(string x)
        => Path.GetFileName(x).Aggregate(5381, (acc, next) => unchecked((acc << 5) + acc ^ next));

    static bool HasContent(string x) => !string.IsNullOrWhiteSpace(x);

    static bool IsGlobal(string x) => x.StartsWith("global");

    Regex extensionMethods = new(@"static\s+partial\s+class[\s\S]+?\{([\s\S]*?)\n\}", RegexOptions.Compiled);

    string InlineStaticPartialClasses(string x) => extensionMethods.Replace(x, FirstGroup);

    Regex usingStatement = new(@"^(global\s+)?using\s+[\s\S]*?;$", RegexOptions.Compiled);

    bool IsUsingStatement(string x) => usingStatement.IsMatch(x);

    char[] newLines = ['\n', '\r'];

    string[] SplitByNewLine(string x) => x.Split(newLines);

    string[] typeDeclarations = ["ref", "sealed", "partial", "class", "delegate", "enum", "struct", "record", "union"];

    string Publicize(string x) => typeDeclarations.Any(x.StartsWith) ? $"public {x}"  : x;

    var root = Path.Combine(Host.TemplateFile, "../../Compile/Source/References/Emik");

    var lines = Directory
        .EnumerateFiles(root, "*.cs", SearchOption.AllDirectories)
        .OrderBy(GetDjb2HashCode)
        .Select(File.ReadAllText)
        .Select(RemoveNamespaces)
        .Select(QualifyCollectionAccess)
        .Select(InlineStaticPartialClasses)
        .Select(RemoveRemainingStaticPartialClasses)
        .SelectMany(SplitByNewLine)
        .Select(ToFullName)
        .Select(Publicize)
        .Select(RemoveComments)
        .Where(HasContent)
        .OrderByDescending(IsUsingStatement)
        .ThenByDescending(IsGlobal);

    var output = string.Join("\n", lines);
#><#= output #>
/// <summary>Methods that creates enumerations from individual items.</summary>
static partial class ManyQueries
{
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(Assembly? assembly) => assembly.TryGetTypes();
}
/// <summary>Method to inline.</summary>
[AttributeUsage(AttributeTargets.Method)]
partial class InlineAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
    /// <param name="behavior">Export attribute.</param>
    /// <param name="export">InlineMethod behavior.</param>
    public InlineAttribute(InlineBehavior behavior = InlineBehavior.RemovePrivate, bool export = false)
    {
        Behavior = behavior;
        Export = export;
    }
    /// <summary>Export attribute.</summary>
    public bool Export { get; }
    /// <summary>InlineMethod behavior.</summary>
    public InlineBehavior Behavior { get; }
}
/// <summary>InlineMethod behavior.</summary>
enum InlineBehavior
{
    /// <summary>Keep method after inline.</summary>
    Keep,
    /// <summary>Remove method after inline if private.</summary>
    RemovePrivate,
    /// <summary>Remove method after inline.</summary>
    Remove,
}
/// <summary>Resolve delegate parameter.</summary>
[AttributeUsage(AttributeTargets.Parameter)]
partial class ResolveDelegateAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="ResolveDelegateAttribute"/> class.</summary>
    /// <param name="inline">Inline after resolve.</param>
    public ResolveDelegateAttribute(bool inline = true) => Inline = inline;
    /// <summary>Inline after resolve.</summary>
    public bool Inline { get; }
}
/// <summary>Declares a contract that the generic parameter must include the qualified member.</summary>
[global::System.AttributeUsage(global::System.AttributeTargets.Parameter)]
sealed partial class MatchAttribute : global::System.Attribute
{
    /// <summary>Initializes a new instance of the <see cref="Emik.MatchAttribute"/> class.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    public MatchAttribute([global::System.Diagnostics.CodeAnalysis.StringSyntax(global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex)] string pattern)
    {
        Pattern = pattern;
    }

    /// <summary>Initializes a new instance of the <see cref="Emik.MatchAttribute"/> class.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">The bitwise combination of the enumeration values that modify the regular expression.</param>
    public MatchAttribute([global::System.Diagnostics.CodeAnalysis.StringSyntax(global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex)] string pattern, global::System.Text.RegularExpressions.RegexOptions options)
    {
        Pattern = pattern;
        Options = options;
    }

    /// <summary>Initializes a new instance of the <see cref="Emik.MatchAttribute"/> class.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="allowRuntimeValues">The value determining whether to allow runtime values, instead of raising a warning.</param>
    public MatchAttribute([global::System.Diagnostics.CodeAnalysis.StringSyntax(global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex)] string pattern, bool allowRuntimeValues)
    {
        Pattern = pattern;
        AllowRuntimeValues = allowRuntimeValues;
    }

    /// <summary>Initializes a new instance of the <see cref="Emik.MatchAttribute"/> class.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="allowRuntimeValues">The value determining whether to allow runtime values, instead of raising a warning.</param>
    /// <param name="options">The bitwise combination of the enumeration values that modify the regular expression.</param>
    public MatchAttribute([global::System.Diagnostics.CodeAnalysis.StringSyntax(global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex)] string pattern, bool allowRuntimeValues, global::System.Text.RegularExpressions.RegexOptions options)
    {
        Pattern = pattern;
        Options = options;
        AllowRuntimeValues = allowRuntimeValues;
    }

    /// <summary>Initializes a new instance of the <see cref="Emik.MatchAttribute"/> class.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">The bitwise combination of the enumeration values that modify the regular expression.</param>
    /// <param name="allowRuntimeValues">The value determining whether to allow runtime values, instead of raising a warning.</param>
    public MatchAttribute([global::System.Diagnostics.CodeAnalysis.StringSyntax(global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex)] string pattern, global::System.Text.RegularExpressions.RegexOptions options, bool allowRuntimeValues)
    {
        Pattern = pattern;
        Options = options;
        AllowRuntimeValues = allowRuntimeValues;
    }

    /// <summary>Gets the value determining whether to allow runtime values, instead of raising a warning.</summary>
    public bool AllowRuntimeValues { get; }

    /// <summary>Gets the regular expression to match.</summary>
    [global::System.Diagnostics.CodeAnalysis.StringSyntax(global::System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex)]
    public string Pattern { get; }

    /// <summary>Gets the bitwise combination of the enumeration values that modify the regular expression.</summary>
    public global::System.Text.RegularExpressions.RegexOptions Options { get; }
}
/// <summary>Determines whether the specified <see langword="object"/> instances are the same instance.</summary>
/// <remarks><para>This method exists as a polyfill since not all REPLs provide this method.</para></remarks>
/// <param name="l">The first object to compare.</param>
/// <param name="r">The second object to compare.</param>
/// <returns>Whether the objects are equal.</returns>
static bool ReferenceEquals(object? l, object? r) => l == r;