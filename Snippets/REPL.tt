<# // SPDX-License-Identifier: MPL-2.0  #>
<#@ output extension=".csx" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ template hostspecific="true" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated/>
#pragma warning disable CS0208
#define NET8_0
#define NET80
#define NET8_0_OR_GREATER
#define NET80_OR_GREATER
#define NET7_0_OR_GREATER
#define NET70_OR_GREATER
#define NET6_0_OR_GREATER
#define NET60_OR_GREATER
#define NET5_0_OR_GREATER
#define NET50_OR_GREATER
#define NETCOREAPP
#define NETSTANDARD2_1_OR_GREATER
#define NETSTANDARD2_0_OR_GREATER
#define NETSTANDARD1_6_OR_GREATER
#define NETSTANDARD1_5_OR_GREATER
#define NETSTANDARD1_4_OR_GREATER
#define NETSTANDARD1_3_OR_GREATER
#define NETSTANDARD1_2_OR_GREATER
#define NETSTANDARD1_1_OR_GREATER
#define NETSTANDARD1_0_OR_GREATER
#define NETSTANDARD
#define NO_ALLOWS_REF_STRUCT
#define FORCE_SERILOG
#define CSHARPREPL
#define DEBUG
<# /*

Load all:
(
    typeof(CommunityToolkit.Common.Converters),
    typeof(CommunityToolkit.Diagnostics.Guard),
    typeof(CommunityToolkit.Helpers.ISettingsStorageHelper<>),
    typeof(CommunityToolkit.HighPerformance.Box<>),
    typeof(Emik.Results.Please),
    typeof(FastGenericNew.FastNew),
    typeof(JetBrains.Annotations.PureAttribute),
    typeof(Microsoft.Extensions.DependencyInjection.ActivatorUtilities),
    typeof(TextCopy.Clipboard)
)

Generated usings:

TextCopy.ClipboardService.SetText(
    AppDomain
        .CurrentDomain
        .GetAssemblies()
        .SelectMany(x => x.GetTypes())
        .Where(x => x.Namespace is not null and not "" && x.IsPublic)
        .Select(x => $"global using {x.Namespace};\n")
        .Distinct()
        .OrderBy(x => x.StartsWith("global using System") ? $"#{x}" : x)
        .Aggregate("", (x, y) => $"{x}{y}")
) */ #>
global using System;
global using System.Buffers;
global using System.Buffers.Binary;
global using System.Buffers.Text;
global using System.CodeDom.Compiler;
global using System.Collections;
global using System.Collections.Concurrent;
global using System.Collections.Frozen;
global using System.Collections.Generic;
global using System.Collections.Immutable;
global using System.Collections.ObjectModel;
global using System.Collections.Specialized;
global using System.ComponentModel;
global using System.ComponentModel.DataAnnotations;
global using System.ComponentModel.DataAnnotations.Schema;
global using System.ComponentModel.Design;
global using System.ComponentModel.Design.Serialization;
global using System.Configuration.Assemblies;
global using System.Data;
global using System.Data.Common;
global using System.Data.Odbc;
global using System.Data.OleDb;
global using System.Data.Sql;
global using System.Data.SqlClient;
global using System.Data.SqlTypes;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.Diagnostics.Contracts;
global using System.Diagnostics.Eventing;
global using System.Diagnostics.Eventing.Reader;
global using System.Diagnostics.Metrics;
global using System.Diagnostics.PerformanceData;
global using System.Diagnostics.SymbolStore;
global using System.Diagnostics.Tracing;
global using System.Drawing;
global using System.Drawing.Configuration;
global using System.Drawing.Design;
global using System.Drawing.Drawing2D;
global using System.Drawing.Imaging;
global using System.Drawing.Printing;
global using System.Drawing.Text;
global using System.Dynamic;
global using System.Formats;
global using System.Formats.Asn1;
global using System.Globalization;
global using System.IO;
global using System.IO.Compression;
global using System.IO.Enumeration;
global using System.IO.IsolatedStorage;
global using System.IO.MemoryMappedFiles;
global using System.IO.Packaging;
global using System.IO.Pipes;
global using System.IO.Ports;
global using System.Linq;
global using System.Linq.Expressions;
global using System.Linq.Expressions.Interpreter;
global using System.Media;
global using System.Net;
global using System.Net.Cache;
global using System.Net.Http;
global using System.Net.Http.Headers;
global using System.Net.Http.Json;
global using System.Net.Http.Metrics;
global using System.Net.Mail;
global using System.Net.Mime;
global using System.Net.NetworkInformation;
global using System.Net.PeerToPeer;
global using System.Net.PeerToPeer.Collaboration;
global using System.Net.Security;
global using System.Net.Sockets;
global using System.Net.WebSockets;
global using System.Numerics;
global using System.Reflection;
global using System.Reflection.Emit;
global using System.Reflection.Metadata;
global using System.Reflection.Metadata.Ecma335;
global using System.Reflection.PortableExecutable;
global using System.Resources;
global using System.Runtime;
global using System.Runtime.CompilerServices;
global using System.Runtime.ConstrainedExecution;
global using System.Runtime.ExceptionServices;
global using System.Runtime.InteropServices;
global using System.Runtime.InteropServices.ComTypes;
global using System.Runtime.InteropServices.Marshalling;
global using System.Runtime.InteropServices.ObjectiveC;
global using System.Runtime.Intrinsics;
global using System.Runtime.Intrinsics.Arm;
global using System.Runtime.Intrinsics.Wasm;
global using System.Runtime.Intrinsics.X86;
global using System.Runtime.Loader;
global using System.Runtime.Remoting;
global using System.Runtime.Serialization;
global using System.Runtime.Serialization.Formatters;
global using System.Runtime.Serialization.Formatters.Binary;
global using System.Runtime.Serialization.Json;
global using System.Runtime.Versioning;
global using System.Security;
global using System.Security.AccessControl;
global using System.Security.Authentication;
global using System.Security.Authentication.ExtendedProtection;
global using System.Security.Claims;
global using System.Security.Cryptography;
global using System.Security.Cryptography.Pkcs;
global using System.Security.Cryptography.X509Certificates;
global using System.Security.Cryptography.Xml;
global using System.Security.Permissions;
global using System.Security.Policy;
global using System.Security.Principal;
global using System.ServiceModel;
global using System.ServiceModel.Syndication;
global using System.ServiceProcess;
global using System.Text;
global using System.Text.Encodings;
global using System.Text.Encodings.Web;
global using System.Text.Json;
global using System.Text.Json.Nodes;
global using System.Text.Json.Serialization;
global using System.Text.Json.Serialization.Metadata;
global using System.Text.RegularExpressions;
global using System.Text.Unicode;
global using System.Threading;
global using System.Threading.Channels;
global using System.Threading.Tasks;
global using System.Threading.Tasks.Dataflow;
global using System.Threading.Tasks.Sources;
global using System.Timers;
global using System.Transactions;
global using System.Web;
global using System.Windows;
global using System.Windows.Input;
global using System.Windows.Markup;
global using System.Xml;
global using System.Xml.Linq;
global using System.Xml.Resolvers;
global using System.Xml.Schema;
global using System.Xml.Serialization;
global using System.Xml.XPath;
global using System.Xml.Xsl;
global using System.Xml.Xsl.Runtime;
global using CommunityToolkit.Common;
global using CommunityToolkit.Common.Collections;
global using CommunityToolkit.Common.Deferred;
global using CommunityToolkit.Common.Extensions;
global using CommunityToolkit.Common.Helpers;
global using CommunityToolkit.Diagnostics;
global using CommunityToolkit.Helpers;
global using CommunityToolkit.HighPerformance;
global using CommunityToolkit.HighPerformance.Buffers;
global using CommunityToolkit.HighPerformance.Buffers.Views;
global using CommunityToolkit.HighPerformance.Enumerables;
global using CommunityToolkit.HighPerformance.Helpers;
global using CommunityToolkit.HighPerformance.Memory;
global using CommunityToolkit.HighPerformance.Memory.Views;
global using CommunityToolkit.HighPerformance.Streams;
global using Emik.Results;
global using Emik.Results.Extensions;
global using FastGenericNew;
global using JetBrains.Annotations;
global using Serilog;
global using Serilog.Capturing;
global using Serilog.Configuration;
global using Serilog.Context;
global using Serilog.Core;
global using Serilog.Core.Enrichers;
global using Serilog.Core.Filters;
global using Serilog.Core.Pipeline;
global using Serilog.Core.Sinks;
global using Serilog.Data;
global using Serilog.Debugging;
global using Serilog.Events;
global using Serilog.Filters;
global using Serilog.Formatting;
global using Serilog.Formatting.Compact;
global using Serilog.Formatting.Display;
global using Serilog.Formatting.Json;
global using Serilog.Parsing;
global using Serilog.Policies;
global using Serilog.Rendering;
global using Serilog.Settings;
global using Serilog.Settings.KeyValuePairs;
global using Serilog.Sinks;
global using Serilog.Sinks.File;
global using Serilog.Sinks.SystemConsole;
global using Serilog.Sinks.SystemConsole.Formatting;
global using Serilog.Sinks.SystemConsole.Output;
global using Serilog.Sinks.SystemConsole.Platform;
global using Serilog.Sinks.SystemConsole.Rendering;
global using Serilog.Sinks.SystemConsole.Themes;
global using TextCopy;
global using static Emik.Results.Please;
global using static Emik.Results.Result;
global using static FastGenericNew.FastNew;
global using static TextCopy.ClipboardService;
global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
global using Expression = System.Linq.Expressions.Expression;
global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;
<#
    static string ToFullName(string x) => x switch
    {
        "using static Two;" => "",
        "using static Rent;" => "",
        "using static Span;" => "",
        "using static Peeks;" => "",
        "using static EnumMath;" => "",
        "using static SmallList;" => "",
        "using static YesFactory;" => "",
        "using static SpanQueries;" => "",
        "using static SpecialType;" => "",
        "using static SplitFactory;" => "",
        "using Range = System.Range;" => "",
        "global using GamePadStates" => "",
        "global using static Undergo;" => "",
        "using static OperatorCaching;" => "",
        "using static SplitSpanFactory;" => "",
        "using static SplitMemoryFactory;" => "",
        "global using static Unforgiving;" => "",
        "global using static TupleExtracts;" => "",
        "global using static FixedGenerator;" => "",
        "global using static MethodGroupings;" => "",
        "using static Enum;" => "using static System.Enum;",
        "using static Math;" => "using static System.Math;",
        "using FieldInfo = System.Reflection.FieldInfo;" => "",
        "global using static IncludedSyntaxNodeRegistrant;" => "",
        "using Expression = System.Linq.Expressions.Expression;" => "",
        "    public static string[] Split(" => "    public static string[] Chop(",
        "using static Expression;" => "using static System.Linq.Expressions.Expression;",
        "using static SecurityAction;" => "using static System.Security.Permissions.SecurityAction;",
        "using static CollectionAccessType;" => "using static JetBrains.Annotations.CollectionAccessType;",
        "using static SecurityPermissionFlag;" => "using static System.Security.Permissions.SecurityPermissionFlag;",
        _ => x,
    };

    static string FirstGroup(Match x) => x.Groups[1].Value;

    static string RemoveComments(string x)
        => x.IndexOf(" // ", StringComparison.Ordinal) is var i and not -1 ? x.Remove(i) : x;

    static string RemoveNamespaces(string x)
        => x.Replace("namespace Emik.Morsels;", "").Replace("Emik.Morsels.", "").Replace("Whitespaces.", "");

    static string RemoveRemainingStaticPartialClasses(string x) => x.Replace("static partial class", "");

    static string QualifyCollectionAccess(string x)
        => x.Replace("CollectionAccess(None)", "CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)");

    static long GetDjb2HashCode(string x)
        => Path.GetFileName(x).Aggregate(5381, (acc, next) => unchecked((acc << 5) + acc ^ next));

    static bool HasContent(string x) => !string.IsNullOrWhiteSpace(x);

    static bool IsGlobal(string x) => x.StartsWith("global");

    Regex extensionMethods = new(@"static\s+partial\s+class[\s\S]+?\{([\s\S]*?)\n\}", RegexOptions.Compiled);

    string InlineStaticPartialClasses(string x) => extensionMethods.Replace(x, FirstGroup);

    Regex usingStatement = new(@"^(global\s+)?using\s+[\s\S]*?;$", RegexOptions.Compiled);

    bool IsUsingStatement(string x) => usingStatement.IsMatch(x);

    char[] newLines = ['\n', '\r'];

    string[] SplitByNewLine(string x) => x.Split(newLines);

    string[] typeDeclarations = ["ref", "sealed", "partial", "class", "delegate", "enum", "struct", "record", "union"];

    string Publicize(string x) => typeDeclarations.Any(x.StartsWith) ? $"public {x}"  : x;

    var root = Path.Combine(Host.TemplateFile, "../../Compile/Source/References/Emik");

    var lines = Directory
        .EnumerateFiles(root, "*.cs", SearchOption.AllDirectories)
        .OrderBy(GetDjb2HashCode)
        .Select(File.ReadAllText)
        .Select(RemoveNamespaces)
        .Select(QualifyCollectionAccess)
        .Select(InlineStaticPartialClasses)
        .Select(RemoveRemainingStaticPartialClasses)
        .SelectMany(SplitByNewLine)
        .Select(ToFullName)
        .Select(Publicize)
        .Select(RemoveComments)
        .Where(HasContent)
        .OrderByDescending(IsUsingStatement)
        .ThenByDescending(IsGlobal);

    var output = string.Join("\n", lines);
#><#= output #>
/// <summary>Methods that creates enumerations from individual items.</summary>
static partial class ManyQueries
{
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(Assembly? assembly) => assembly.TryGetTypes();
}
/// <summary>Method to inline.</summary>
[AttributeUsage(AttributeTargets.Method)]
partial class InlineAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
    /// <param name="behavior">Export attribute.</param>
    /// <param name="export">InlineMethod behavior.</param>
    public InlineAttribute(InlineBehavior behavior = InlineBehavior.RemovePrivate, bool export = false)
    {
        Behavior = behavior;
        Export = export;
    }
    /// <summary>Export attribute.</summary>
    public bool Export { get; }
    /// <summary>InlineMethod behavior.</summary>
    public InlineBehavior Behavior { get; }
}
/// <summary>InlineMethod behavior.</summary>
enum InlineBehavior
{
    /// <summary>Keep method after inline.</summary>
    Keep,
    /// <summary>Remove method after inline if private.</summary>
    RemovePrivate,
    /// <summary>Remove method after inline.</summary>
    Remove,
}
/// <summary>Resolve delegate parameter.</summary>
[AttributeUsage(AttributeTargets.Parameter)]
partial class ResolveDelegateAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="ResolveDelegateAttribute"/> class.</summary>
    /// <param name="inline">Inline after resolve.</param>
    public ResolveDelegateAttribute(bool inline = true) => Inline = inline;
    /// <summary>Inline after resolve.</summary>
    public bool Inline { get; }
}
/// <summary>Provides stringification methods.</summary>
static class Stringifier
{
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(T? source) => source.Stringify();
}
/// <summary>Polyfill for <c>nameof()</c>.</summary>
static class Morsels;
CatchFatalExceptions = true;
