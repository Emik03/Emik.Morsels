// <auto-generated/>
#pragma warning disable CS0208
#define NET8_0
#define NET80
#define NET8_0_OR_GREATER
#define NET80_OR_GREATER
#define NET7_0_OR_GREATER
#define NET70_OR_GREATER
#define NET6_0_OR_GREATER
#define NET60_OR_GREATER
#define NET5_0_OR_GREATER
#define NET50_OR_GREATER
#define NETCOREAPP
#define NETSTANDARD2_1_OR_GREATER
#define NETSTANDARD2_0_OR_GREATER
#define NETSTANDARD1_6_OR_GREATER
#define NETSTANDARD1_5_OR_GREATER
#define NETSTANDARD1_4_OR_GREATER
#define NETSTANDARD1_3_OR_GREATER
#define NETSTANDARD1_2_OR_GREATER
#define NETSTANDARD1_1_OR_GREATER
#define NETSTANDARD1_0_OR_GREATER
#define NETSTANDARD
#define CSHARPREPL
#define NO_ROSLYN
global using System;
global using System.Buffers;
global using System.Buffers.Binary;
global using System.Buffers.Text;
global using System.CodeDom.Compiler;
global using System.Collections;
global using System.Collections.Concurrent;
global using System.Collections.Frozen;
global using System.Collections.Generic;
global using System.Collections.Immutable;
global using System.Collections.ObjectModel;
global using System.Collections.Specialized;
global using System.ComponentModel;
global using System.ComponentModel.DataAnnotations;
global using System.ComponentModel.DataAnnotations.Schema;
global using System.ComponentModel.Design;
global using System.ComponentModel.Design.Serialization;
global using System.Configuration.Assemblies;
global using System.Data;
global using System.Data.Common;
global using System.Data.Odbc;
global using System.Data.OleDb;
global using System.Data.Sql;
global using System.Data.SqlClient;
global using System.Data.SqlTypes;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.Diagnostics.Contracts;
global using System.Diagnostics.Eventing;
global using System.Diagnostics.Eventing.Reader;
global using System.Diagnostics.Metrics;
global using System.Diagnostics.PerformanceData;
global using System.Diagnostics.SymbolStore;
global using System.Diagnostics.Tracing;
global using System.Drawing;
global using System.Drawing.Configuration;
global using System.Drawing.Design;
global using System.Drawing.Drawing2D;
global using System.Drawing.Imaging;
global using System.Drawing.Printing;
global using System.Drawing.Text;
global using System.Dynamic;
global using System.Formats;
global using System.Formats.Asn1;
global using System.Globalization;
global using System.IO;
global using System.IO.Compression;
global using System.IO.Enumeration;
global using System.IO.IsolatedStorage;
global using System.IO.MemoryMappedFiles;
global using System.IO.Packaging;
global using System.IO.Pipes;
global using System.IO.Ports;
global using System.Linq;
global using System.Linq.Expressions;
global using System.Linq.Expressions.Interpreter;
global using System.Media;
global using System.Net;
global using System.Net.Cache;
global using System.Net.Http;
global using System.Net.Http.Headers;
global using System.Net.Http.Json;
global using System.Net.Http.Metrics;
global using System.Net.Mail;
global using System.Net.Mime;
global using System.Net.NetworkInformation;
global using System.Net.PeerToPeer;
global using System.Net.PeerToPeer.Collaboration;
global using System.Net.Security;
global using System.Net.Sockets;
global using System.Net.WebSockets;
global using System.Numerics;
global using System.Reflection;
global using System.Reflection.Emit;
global using System.Reflection.Metadata;
global using System.Reflection.Metadata.Ecma335;
global using System.Reflection.PortableExecutable;
global using System.Resources;
global using System.Runtime;
global using System.Runtime.CompilerServices;
global using System.Runtime.ConstrainedExecution;
global using System.Runtime.ExceptionServices;
global using System.Runtime.InteropServices;
global using System.Runtime.InteropServices.ComTypes;
global using System.Runtime.InteropServices.Marshalling;
global using System.Runtime.InteropServices.ObjectiveC;
global using System.Runtime.Intrinsics;
global using System.Runtime.Intrinsics.Arm;
global using System.Runtime.Intrinsics.Wasm;
global using System.Runtime.Intrinsics.X86;
global using System.Runtime.Loader;
global using System.Runtime.Remoting;
global using System.Runtime.Serialization;
global using System.Runtime.Serialization.Formatters;
global using System.Runtime.Serialization.Formatters.Binary;
global using System.Runtime.Serialization.Json;
global using System.Runtime.Versioning;
global using System.Security;
global using System.Security.AccessControl;
global using System.Security.Authentication;
global using System.Security.Authentication.ExtendedProtection;
global using System.Security.Claims;
global using System.Security.Cryptography;
global using System.Security.Cryptography.Pkcs;
global using System.Security.Cryptography.X509Certificates;
global using System.Security.Cryptography.Xml;
global using System.Security.Permissions;
global using System.Security.Policy;
global using System.Security.Principal;
global using System.ServiceModel;
global using System.ServiceModel.Syndication;
global using System.ServiceProcess;
global using System.Text;
global using System.Text.Encodings;
global using System.Text.Encodings.Web;
global using System.Text.Json;
global using System.Text.Json.Nodes;
global using System.Text.Json.Serialization;
global using System.Text.Json.Serialization.Metadata;
global using System.Text.RegularExpressions;
global using System.Text.Unicode;
global using System.Threading;
global using System.Threading.Channels;
global using System.Threading.Tasks;
global using System.Threading.Tasks.Dataflow;
global using System.Threading.Tasks.Sources;
global using System.Timers;
global using System.Transactions;
global using System.Web;
global using System.Windows;
global using System.Windows.Input;
global using System.Windows.Markup;
global using System.Xml;
global using System.Xml.Linq;
global using System.Xml.Resolvers;
global using System.Xml.Schema;
global using System.Xml.Serialization;
global using System.Xml.XPath;
global using System.Xml.Xsl;
global using System.Xml.Xsl.Runtime;
global using CommunityToolkit.Common;
global using CommunityToolkit.Common.Collections;
global using CommunityToolkit.Common.Deferred;
global using CommunityToolkit.Common.Extensions;
global using CommunityToolkit.Common.Helpers;
global using CommunityToolkit.Diagnostics;
global using CommunityToolkit.Helpers;
global using CommunityToolkit.HighPerformance;
global using CommunityToolkit.HighPerformance.Buffers;
global using CommunityToolkit.HighPerformance.Buffers.Views;
global using CommunityToolkit.HighPerformance.Enumerables;
global using CommunityToolkit.HighPerformance.Helpers;
global using CommunityToolkit.HighPerformance.Memory;
global using CommunityToolkit.HighPerformance.Memory.Views;
global using CommunityToolkit.HighPerformance.Streams;
global using Emik.Results;
global using Emik.Results.Extensions;
global using FastGenericNew;
global using JetBrains.Annotations;
global using TextCopy;
global using static Emik.Results.Please;
global using static Emik.Results.Result;
global using static FastGenericNew.FastNew;
global using static TextCopy.ClipboardService;
global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
global using Expression = System.Linq.Expressions.Expression;
global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;
global using GeneratedSource = (string HintName, string Source);
using static System.Linq.Expressions.Expression;
using static System.Enum;
using static System.Linq.Expressions.Expression;
using Enum = System.Enum;
using static System.Linq.Expressions.Expression;
using SecurityAction = System.Security.Permissions.SecurityAction;
using static System.Security.Permissions.SecurityAction;
using static System.Security.Permissions.SecurityPermissionFlag;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
// SPDX-License-Identifier: MPL-2.0

// ReSharper disable MissingIndent UsePositionalDeconstructionPattern
// ReSharper disable once CheckNamespace

#pragma warning disable CS1574, CS1580
/// <summary>Methods that deconstructs <see cref="Version"/> instances.</summary>

    /// <summary>Deconstructs this instance into the major and minor versions.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor
    )
    {
        if (version is { Major: var maj, Minor: var min })
        {
            major = maj;
            minor = min;
            return;
        }

        major = default;
        minor = default;
    }

    /// <summary>Deconstructs this instance into the major, minor, and build versions.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    /// <param name="build">The resulting build version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor,
        [NonNegativeValue] out int build
    )
    {
        if (version is { Major: var maj, Minor: var min, Build: var bui })
        {
            major = maj;
            minor = min;
            build = bui;
            return;
        }

        major = default;
        minor = default;
        build = default;
    }

    /// <summary>Deconstructs this instance into the major, minor, build, and revision versions.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    /// <param name="build">The resulting build version.</param>
    /// <param name="revision">The resulting revision version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor,
        [NonNegativeValue] out int build,
        [NonNegativeValue] out int revision
    )
    {
        if (version is { Major: var maj, Minor: var min, Build: var bui, Revision: var rev })
        {
            major = maj;
            minor = min;
            build = bui;
            revision = rev;
            return;
        }

        major = default;
        minor = default;
        build = default;
        revision = default;
    }

    /// <summary>
    /// Deconstructs this instance into the major, minor, build, major revision, and minor revision versions.
    /// </summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    /// <param name="build">The resulting build version.</param>
    /// <param name="majorRevision">The resulting major revision version.</param>
    /// <param name="minorRevision">The resulting minor revision version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor,
        [NonNegativeValue] out int build,
        [NonNegativeValue] out int majorRevision,
        [NonNegativeValue] out int minorRevision
    )
    {
        if (version is
        {
            Major: var maj, Minor: var min, Build: var bui, MajorRevision: var majRev, MinorRevision: var minRev,
        })
        {
            major = maj;
            minor = min;
            build = bui;
            majorRevision = majRev;
            minorRevision = minRev;
            return;
        }

        major = default;
        minor = default;
        build = default;
        majorRevision = default;
        minorRevision = default;
    }

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer

// ReSharper disable once RedundantUsingDirective.Global


// ReSharper disable once CheckNamespace


/// <summary>Methods to get elements of a tuple.</summary>

    /// <summary>Gets the first item of the tuple.</summary>
    /// <typeparam name="T1">The first type of the tuple.</typeparam>
    /// <typeparam name="T2">The second type of the tuple.</typeparam>
    /// <param name="tuple">The tuple to get the value from.</param>
    /// <returns>The field <see cref="ValueTuple{T1, T2}.Item1"/> from the parameter <paramref name="tuple"/>.</returns>
    public static T1 First<T1, T2>((T1, T2) tuple) => tuple.Item1;

    /// <summary>Gets the second item of the tuple.</summary>
    /// <typeparam name="T1">The first type of the tuple.</typeparam>
    /// <typeparam name="T2">The second type of the tuple.</typeparam>
    /// <param name="tuple">The tuple to get the value from.</param>
    /// <returns>The field <see cref="ValueTuple{T1, T2}.Item2"/> from the parameter <paramref name="tuple"/>.</returns>
    public static T2 Second<T1, T2>((T1, T2) tuple) => tuple.Item2;
#if !NET20 && !NET30 && !NET47 && !NETSTANDARD2_0 // Unique in the sense that they either don't have LINQ, or have tuples that don't implement ITuple.
    /// <summary>Gets the enumeration of the tuple.</summary>
    /// <param name="tuple">The tuple to enumerate.</param>
    /// <returns>The enumeration of the parameter <paramref name="tuple"/>.</returns>
    public static IEnumerable<object?> AsEnumerable(this ITuple tuple) => tuple.Length.For(i => tuple[i]);

    /// <summary>Gets the enumeration of the tuple.</summary>
    /// <typeparam name="T">The type of tuple.</typeparam>
    /// <param name="tuple">The tuple to enumerate.</param>
    /// <returns>The enumeration of the parameter <paramref name="tuple"/>.</returns>
    public static IEnumerable<object?> AsEnumerable<T>(this T tuple)
        where T : ITuple =>
        tuple.Length.For(i => tuple[i]);
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Extension methods for nullable types and booleans.</summary>

#if NET7_0_OR_GREATER
    /// <summary>Converts <see cref="bool"/> to <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of number to convert to.</typeparam>
    /// <param name="that">Whether or not to return the one value, or zero.</param>
    /// <returns>
    /// The value <see cref="INumberBase{T}.One"/> or <see cref="INumberBase{T}.Zero"/>,
    /// based on the value of <paramref name="that"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T As<T>(this bool that)
        where T : INumberBase<T> =>
        that ? T.One : T.Zero;
#endif
#if NETCOREAPP || ROSLYN
    /// <summary>Determines whether two sequences are equal.</summary>
    /// <typeparam name="TDerived">The type of element in the compared array.</typeparam>
    /// <typeparam name="TBase">The type of element contained by the collection.</typeparam>
    /// <param name="first">The first <see cref="ImmutableArray{TBase}"/> to compare.</param>
    /// <param name="second">The second <see cref="ImmutableArray{TDerived}"/> to compare.</param>
    /// <returns>
    /// The value <see langword="true"/> if both sequences have the same
    /// values, or are both default; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool GuardedSequenceEqual<TDerived, TBase>(
        this ImmutableArray<TBase> first,
        ImmutableArray<TDerived> second
    )
        where TDerived : TBase =>
        first.IsDefault || second.IsDefault ? first.IsDefault && second.IsDefault : first.SequenceEqual(second);

    /// <summary>Determines whether two sequences are equal according to an equality comparer.</summary>
    /// <typeparam name="TDerived">The type of element in the compared array.</typeparam>
    /// <typeparam name="TBase">The type of element contained by the collection.</typeparam>
    /// <param name="first">The first <see cref="ImmutableArray{TBase}"/> to compare.</param>
    /// <param name="second">The second <see cref="ImmutableArray{TDerived}"/> to compare.</param>
    /// <param name="comparer">The comparer to use to check for equality.</param>
    /// <returns>
    /// The value <see langword="true"/> if both sequences have the same
    /// values, or are both default; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool GuardedSequenceEqual<TDerived, TBase>(
        this ImmutableArray<TBase> first,
        ImmutableArray<TDerived> second,
        Func<TBase, TBase, bool>? comparer
    )
        where TDerived : TBase =>
        first.IsDefault || second.IsDefault ? first.IsDefault && second.IsDefault :
        comparer is null ? first.SequenceEqual(second) : first.SequenceEqual(second, comparer);

    /// <summary>Determines whether two sequences are equal according to an equality comparer.</summary>
    /// <typeparam name="TDerived">The type of element in the compared array.</typeparam>
    /// <typeparam name="TBase">The type of element contained by the collection.</typeparam>
    /// <param name="first">The first <see cref="ImmutableArray{TBase}"/> to compare.</param>
    /// <param name="second">The second <see cref="ImmutableArray{TDerived}"/> to compare.</param>
    /// <param name="comparer">The comparer to use to check for equality.</param>
    /// <returns>
    /// The value <see langword="true"/> if both sequences have the same
    /// values, or are both default; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool GuardedSequenceEqual<TDerived, TBase>(
        this ImmutableArray<TBase> first,
        ImmutableArray<TDerived> second,
        IEqualityComparer<TBase>? comparer
    )
        where TDerived : TBase =>
        first.IsDefault || second.IsDefault ? first.IsDefault && second.IsDefault :
        comparer is null ? first.SequenceEqual(second) : first.SequenceEqual(second, comparer);
#endif

    /// <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to check.</param>
    /// <param name="predicate">The predicate to determine the return value.</param>
    /// <returns>
    /// The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
    /// and returned <see langword="true"/> from the predicate; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool IsAnd<T>([NotNullWhen(true)] this T? value, [InstantHandle] Predicate<T> predicate) =>
        value is not null && predicate(value);

    /// <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to check.</param>
    /// <param name="predicate">The predicate to determine the return value.</param>
    /// <returns>
    /// The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
    /// and returned <see langword="true"/> from the predicate; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool IsAnd<T>([NotNullWhen(true)] this T? value, [InstantHandle] Predicate<T> predicate)
        where T : struct =>
        value is { } t && predicate(t);

    /// <summary>Conditionally invokes based on a condition.</summary>
    /// <param name="that">The value that must be <see langword="false"/>.</param>
    /// <param name="exThat">Filled by the compiler, the expression to assert.</param>
    /// <returns>The parameter <paramref name="that"/>.</returns>
    [AssertionMethod]
    public static bool IsFalse(
        [AssertionCondition(AssertionConditionType.IS_FALSE)] this bool that,
        [CallerArgumentExpression(nameof(that))] string? exThat = null
    ) =>
        that ? throw new UnreachableException(exThat) : false;

#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP
    /// <summary>Determines whether the value is null or not.</summary>
    /// <typeparam name="T">The type of value to check.</typeparam>
    /// <param name="value">The value to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="value"/>
    /// is <see langword="null"/>; otherwise, <see langword="false"/>.
    /// </returns>
    public static bool IsNull<T>([NotNullWhen(false)] this T? value) =>
        (!typeof(T).IsValueType || Nullable.GetUnderlyingType(typeof(T)) is not null) &&
        EqualityComparer<T?>.Default.Equals(value, default);
#endif

    /// <summary>Conditionally invokes based on a condition.</summary>
    /// <param name="that">The value that must be <see langword="true"/>.</param>
    /// <param name="exThat">Filled by the compiler, the expression to assert.</param>
    /// <returns>The parameter <paramref name="that"/>.</returns>
    [AssertionMethod]
    public static bool IsTrue(
        [AssertionCondition(AssertionConditionType.IS_TRUE)] this bool that,
        [CallerArgumentExpression(nameof(that))] string? exThat = null
    ) =>
        that ? true : throw new UnreachableException(exThat);

    /// <summary>Conditionally invokes based on a condition.</summary>
    /// <param name="value">The value to check.</param>
    /// <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
    /// <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    public static bool Then(
        this bool value,
        [InstantHandle] Action ifTrue,
        [InstantHandle] Action? ifFalse = null
    )
    {
        if (value)
            ifTrue();
        else
            ifFalse?.Invoke();

        return value;
    }

    /// <summary>Gives an optional value based on a condition.</summary>
    /// <remarks><para>The parameter is eagerly evaluated.</para></remarks>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to check.</param>
    /// <param name="onTrue">The value to return when <see langword="true"/>.</param>
    /// <returns>
    /// The value <paramref name="onTrue"/> if <paramref name="value"/>
    /// is <see langword="true"/>; otherwise, <see langword="default"/>.
    /// </returns>
    [Pure]
    public static T? Then<T>(this bool value, T onTrue) => value ? onTrue : default;

    /// <summary>Gives an optional value based on a condition.</summary>
    /// <remarks><para>The parameter is lazily evaluated.</para></remarks>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to check.</param>
    /// <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
    /// <returns>
    /// The value returned from <paramref name="ifTrue"/> if <paramref name="value"/>
    /// is <see langword="true"/>; otherwise, <see langword="default"/>.
    /// </returns>
    [MustUseReturnValue]
    public static T? Then<T>(this bool value, Func<T> ifTrue) => value ? ifTrue() : default;
#if !NET20 && !NET30
    /// <summary>Filters an <see cref="IEnumerable{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IEnumerable{T}"/> with strictly non-null values.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Filter<T>([NoEnumeration] this IEnumerable<T?>? iterable) =>
#pragma warning disable 8619
        iterable?.Where(x => x is not null) ?? [];
#pragma warning restore 8619

    /// <summary>Filters an <see cref="IEnumerable{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IEnumerable{T}"/> with strictly non-null values.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Filter<T>([NoEnumeration] this IEnumerable<T?>? iterable)
        where T : struct =>
#pragma warning disable 8629
        iterable?.Where(x => x.HasValue).Select(x => x.Value) ?? [];
#pragma warning restore 8629
#endif

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace

#pragma warning disable CS1574, CS1580
/// <summary>Methods that creates enumerations from individual items.</summary>

#if !NETSTANDARD || NETSTANDARD1_5_OR_GREATER
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(this Assembly? assembly)
    {
        try
        {
            return assembly?.GetTypes() ?? [];
        }
        catch (ReflectionTypeLoadException ex)
        {
            return ex.Types.Filter();
        }
    }
#endif

    /// <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="item">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, MustUseReturnValue]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        this T? item,
        [InstantHandle] Converter<T, IEnumerable<TResult>?> map
    ) =>
        item is not null && map(item) is { } iterable ? iterable : [];

    /// <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="item">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, MustUseReturnValue]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        this T? item,
        [InstantHandle] Converter<T, IEnumerable<TResult>?> map
    )
        where T : struct =>
        item.HasValue && map(item.Value) is { } iterable ? iterable : [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    ) =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    )
        where T : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    )
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    )
        where T : struct
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    ) =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    )
        where T : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    )
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];

    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    )
        where T : struct
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
#endif

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer

// ReSharper disable once RedundantUsingDirective.Global


// ReSharper disable once CheckNamespace


/// <summary>Methods to create methods.</summary>

    sealed class Compared<T>(Comparison<T?> comparer) : IComparer<T>
    {
        /// <inheritdoc />
        public int Compare(T? x, T? y) => comparer(x, y);
    }

    sealed class Compared<T, TResult>(Converter<T?, TResult> converter, IComparer<TResult> comparer) : IComparer<T>
    {
        /// <inheritdoc />
        public int Compare(T? x, T? y) => comparer.Compare(converter(x), converter(y));
    }

    sealed class Equated<T>(Func<T?, T?, bool> comparer, Func<T, int> hashCode) : IEqualityComparer<T>
    {
        /// <summary>Initializes a new instance of the <see cref="Equated{T}"/> class.</summary>
        /// <param name="comparer">The comparer to convert.</param>
        public Equated(IComparer<T> comparer)
            : this(FromIComparer(comparer), Default) { }

        /// <summary>Returns 0.</summary>
        /// <param name="_">The discard.</param>
        /// <returns>The value 0.</returns>
        public static int Default(T? _) => 0;

        /// <inheritdoc />
        public bool Equals(T? x, T? y) => comparer(x, y);

        /// <inheritdoc />
        public int GetHashCode(T obj) => hashCode(obj);

        /// <summary>Returns the equality function based on the <see cref="IComparer{T}"/>.</summary>
        /// <param name="comparer">The comparer to evaluate equality.</param>
        /// <returns>The equality function that wraps <paramref name="comparer"/>.</returns>
        // ReSharper disable NullableWarningSuppressionIsUsed
        static Func<T?, T?, bool> FromIComparer(IComparer<T> comparer) => (x, y) => comparer.Compare(x!, y!) is 0;
    }

    sealed class Equated<T, TResult>(Converter<T?, TResult> converter, IEqualityComparer<TResult> equalityComparer)
        : IEqualityComparer<T>
    {
        /// <inheritdoc />
        public bool Equals(T? x, T? y) => equalityComparer.Equals(converter(x), converter(y));

        /// <inheritdoc />
        // ReSharper disable once NullableWarningSuppressionIsUsed
        public int GetHashCode(T obj) => equalityComparer.GetHashCode(converter(obj)!);
    }

    /// <summary>The number of bits in a byte.</summary>
    public const int BitsInByte = 8;

    /// <summary>Invokes a method.</summary>
    /// <param name="del">The method to invoke.</param>
    public static void Invoke([InstantHandle] Action del) => del();

    /// <summary>Performs nothing.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Noop()
    {
        // .maxstack 8
        // #if DEBUG
        // IL_0000: nop
        // IL_0001: ret
        // #elif RELEASE
        // IL_0000: ret
        // #endif
    }

    /// <summary>Performs nothing.</summary>
    /// <typeparam name="T">The type of discard.</typeparam>
    /// <param name="_">The discard.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Noop<T>(T _)
    {
        // .maxstack 8
        // #if DEBUG
        // IL_0000: nop
        // IL_0001: ret
        // #elif RELEASE
        // IL_0000: ret
        // #endif
    }

    /// <summary>Performs nothing.</summary>
    /// <typeparam name="T1">The first type of discard.</typeparam>
    /// <typeparam name="T2">The second type of discard.</typeparam>
    /// <param name="_">The first discard.</param>
    /// <param name="__">The second discard.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Noop<T1, T2>(T1 _, T2 __)
    {
        // .maxstack 8
        // #if DEBUG
        // IL_0000: nop
        // IL_0001: ret
        // #elif RELEASE
        // IL_0000: ret
        // #endif
    }

    /// <summary>Create a delegate.</summary>
    /// <param name="del">The method group.</param>
    /// <returns>An invokable method.</returns>
    [Pure]
    public static Action Action(Action del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Action<T> Action1<T>(Action<T> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Action<T1, T2> Action2<T1, T2>(Action<T1, T2> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Action<T1, T2, T3> Action3<T1, T2, T3>(Action<T1, T2, T3> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Action<T1, T2, T3, T4> Action4<T1, T2, T3, T4>(Action<T1, T2, T3, T4> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Func<T> Func<T>(Func<T> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Func<T, TResult> Func1<T, TResult>(Func<T, TResult> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Func<T1, T2, TResult> Func2<T1, T2, TResult>(Func<T1, T2, TResult> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Func<T1, T2, T3, TResult> Func3<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> del) => del;

    /// <inheritdoc cref="MethodGroupings.Action"/>
    [Pure]
    public static Func<T1, T2, T3, T4, TResult> Func4<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> del) =>
        del;

    /// <summary>Negates a predicate.</summary>
    /// <typeparam name="T">The type of item for the predicate.</typeparam>
    /// <param name="predicate">The predicate to negate.</param>
    /// <returns>The argument <paramref name="predicate"/> wrapped in another that negates its result.</returns>
    [Pure]
    public static Func<T, bool> Not1<T>(Func<T, bool> predicate) => t => !predicate(t);

    /// <inheritdoc cref="MethodGroupings.Not{T}(Predicate{T})"/>
    [Pure]
    public static Func<T, int, bool> Not2<T>(Func<T, int, bool> predicate) => (t, i) => !predicate(t, i);

    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <param name="comparison">The <see cref="Comparison{T}"/> to use.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="comparison"/>.</returns>
    public static IComparer<T> Comparing<T>(Comparison<T?> comparison) => new Compared<T>(comparison);

    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
    /// <param name="converter">The converter to use.</param>
    /// <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="converter"/>.</returns>
    public static IComparer<T> Comparing<T, TResult>(
        Converter<T?, TResult> converter,
        IComparer<TResult>? comparer = null
    ) =>
        new Compared<T, TResult>(converter, comparer ?? Comparer<TResult>.Default);

    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <param name="comparison">The <see cref="Comparison{T}"/> to use.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="comparison"/>.</returns>
    public static IEqualityComparer<T> AsEquality<T>(this IComparer<T> comparison) => new Equated<T>(comparison);

    /// <summary>Creates the <see cref="IEqualityComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
    /// <param name="converter">The converter to use.</param>
    /// <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="converter"/>.</returns>
    public static IEqualityComparer<T> Equating<T, TResult>(
        Converter<T?, TResult> converter,
        IEqualityComparer<TResult>? comparer = null
    ) =>
        new Equated<T, TResult>(converter, comparer ?? EqualityComparer<TResult>.Default);

    /// <summary>Creates the <see cref="IEqualityComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <param name="comparer">The comparer to use.</param>
    /// <param name="hashCode">If specified, the hash code algorithm.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="comparer"/>.</returns>
    public static IEqualityComparer<T> Equating<T>(Func<T?, T?, bool> comparer, Func<T, int>? hashCode = null) =>
        new Equated<T>(comparer, hashCode ?? Equated<T>.Default);

    /// <inheritdoc cref="MethodGroupings.Not{T}(Predicate{T})"/>
    [Pure]
    public static Predicate<T> Not<T>(Predicate<T> predicate) => t => !predicate(t);

    /// <inheritdoc cref="Invoke"/>
    public static TResult Invoke<TResult>([InstantHandle] Func<TResult> del) => del();

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Provides methods for unfolding.</summary>

    /// <summary>Applies a selector and collects the returned items recursively until the value becomes null.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The initial value.</param>
    /// <param name="converter">The converter to apply.</param>
    /// <returns>
    /// The parameter <paramref name="value"/>, followed by each non-null
    /// returned value from the parameter <paramref name="converter"/>.
    /// </returns>
    [Pure]
    public static IEnumerable<T> FindPathToNull<T>(this T? value, Converter<T, T?> converter)
        where T : class
    {
        while (value is not null)
        {
            yield return value;

            value = converter(value);
        }
    }

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
#pragma warning disable RCS1163, RCS1175
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T value, Converter<T, T> converter)
#pragma warning restore RCS1163, RCS1175
        where T : struct =>
        throw Unreachable;

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T value, Converter<T, T?> converter)
        where T : struct
    {
        T? maybe = value;

        while (maybe is { } yes)
        {
            yield return yes;

            maybe = converter(yes);
        }
    }

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
#pragma warning disable RCS1163, RCS1175
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T? value, Converter<T, T> converter)
#pragma warning restore RCS1163, RCS1175
        where T : struct =>
        throw Unreachable;

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T? value, Converter<T, T?> converter)
        where T : struct =>
        value is { } t ? FindPathToEmptyNullable(t, converter) : [];

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static SmallList<T> FindSmallPathToNull<T>(this T? value, Converter<T, T?> converter)
        where T : class
    {
        SmallList<T> output = default;

        while (value is not null)
        {
            output.Add(value);
            value = converter(value);
        }

        return output;
    }

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
#pragma warning disable RCS1163, RCS1175
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T value, Converter<T, T> converter)
#pragma warning restore RCS1163, RCS1175
        where T : struct =>
        throw Unreachable;

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T value, Converter<T, T?> converter)
        where T : struct
    {
        SmallList<T> output = [];
        T? maybe = value;

        while (maybe is { } yes)
        {
            output.Add(yes);
            maybe = converter(yes);
        }

        return output;
    }

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
#pragma warning disable RCS1163, RCS1175
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T? value, Converter<T, T> converter)
#pragma warning restore RCS1163, RCS1175
        where T : struct =>
        throw Unreachable;

    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T? value, Converter<T, T?> converter)
        where T : struct =>
        value is { } t ? FindSmallPathToEmptyNullable(t, converter) : [];

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace EmptyNamespace

#if !NET20 && !NET30 && !NET471_OR_GREATER && !NETSTANDARD1_6_OR_GREATER && !NETCOREAPP
/// <summary>Adds support for Append and Prepend in lower frameworks.</summary>

    /// <summary>Appends a value to the end of the sequence.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <param name="source">A sequence of values.</param>
    /// <param name="element">The value to append to <paramref name="source"/>.</param>
    /// <returns>A new sequence that ends with <paramref name="element"/>.</returns>
    public static IEnumerable<TSource> Append<TSource>(this IEnumerable<TSource> source, TSource element) =>
        source.Concat(element.Yield());

    /// <summary>Prepends a value to the end of the sequence.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <param name="source">A sequence of values.</param>
    /// <param name="element">The value to prepend to <paramref name="source"/>.</param>
    /// <returns>A new sequence that starts with <paramref name="element"/>.</returns>
    public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element) =>
        element.Yield().Concat(source);
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace

#pragma warning disable 8604
/// <summary>Similar to <see cref="Each"/>, but with control flow, using <see cref="ControlFlow"/>.</summary>
// ReSharper disable LoopCanBePartlyConvertedToQuery

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor([NonNegativeValue] this int upper, [InstantHandle] Func<ControlFlow> func)
    {
        for (var i = 0; i < upper; i++)
            if (func() is ControlFlow.Break)
                break;

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor([NonNegativeValue] this int upper, [InstantHandle] Func<int, ControlFlow> func)
    {
        for (var i = 0; i < upper; i++)
            if (func(i) is ControlFlow.Break)
                break;

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Func<TExternal, ControlFlow> func
    )
    {
        for (var i = 0; i < upper; i++)
            if (func(external) is ControlFlow.Break)
                break;

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Func<int, TExternal, ControlFlow> func
    )
    {
        for (var i = 0; i < upper; i++)
            if (func(i, external) is ControlFlow.Break)
                break;

        return upper;
    }
#if !NET20 && !NET30
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<T, ControlFlow> func
    )
    {
        var list = iterable.ToCollectionLazily();

        foreach (var item in list)
            if (func(item) is ControlFlow.Break)
                break;

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Func<T, TExternal, ControlFlow> func
    )
    {
        var list = iterable.ToCollectionLazily();

        foreach (var item in list)
            if (func(item, external) is ControlFlow.Break)
                break;

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<T, int, ControlFlow> func
    )
    {
        var list = iterable.ToCollectionLazily();
        var i = 0;

        foreach (var item in list)
            if (func(item, checked(i++)) is ControlFlow.Break)
                break;

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Func<T, int, TExternal, ControlFlow> func
    )
    {
        var list = iterable.ToCollectionLazily();
        var i = 0;

        foreach (var item in list)
            if (func(item, checked(i++), external) is ControlFlow.Break)
                break;

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Func<TKey, TValue, ControlFlow> func
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value) is ControlFlow.Break)
                break;

        return dictionary;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Func<TKey, TValue, TExternal, ControlFlow> func
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value, external) is ControlFlow.Break)
                break;

        return dictionary;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Func<TKey, TValue, int, ControlFlow> func
    )
        where TKey : notnull
    {
        var i = 0;

        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value, checked(i++)) is ControlFlow.Break)
                break;

        return dictionary;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Func<TKey, TValue, int, TExternal, ControlFlow> func
    )
        where TKey : notnull
    {
        var i = 0;

        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value, checked(i++), external) is ControlFlow.Break)
                break;

        return dictionary;
    }
#endif
#if NET7_0_OR_GREATER
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T>([NonNegativeValue] this T upper, [InstantHandle] Func<ControlFlow> func)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func() is ControlFlow.Break)
                break;

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T>([NonNegativeValue] this T upper, [InstantHandle] Func<T, ControlFlow> func)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func(i) is ControlFlow.Break)
                break;

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Func<TExternal, ControlFlow> func
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func(external) is ControlFlow.Break)
                break;

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Func<T, TExternal, ControlFlow> func
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func(i, external) is ControlFlow.Break)
                break;

        return upper;
    }
#endif

/// <summary>Determines control flow for loops in <see cref="Each"/>.</summary>
#pragma warning disable MA0048
public enum ControlFlow : byte
#pragma warning restore MA0048
{
    /// <summary>The value indicating that the loop should continue.</summary>
    Continue,

    /// <summary>The value indicating that the loop should break.</summary>
    Break,
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace


/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T>([NoEnumeration] this IEnumerable<T> iterable, Action<T> action) =>
        new Enumerable<T, object?>(iterable, null, action);

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T, TExternal>(
        [NoEnumeration] this IEnumerable<T> iterable,
        TExternal external,
        Action<T, TExternal> action
    ) =>
        new Enumerable<T, TExternal>(iterable, external, action);

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T>([NoEnumeration] this IEnumerable<T> iterable, Action<T, int> action) =>
        new Enumerable<T, object?>(iterable, null, action);

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T, TExternal>(
        [NoEnumeration] this IEnumerable<T> iterable,
        TExternal external,
        Action<T, int, TExternal> action
    ) =>
        new Enumerable<T, TExternal>(iterable, external, action);

/// <summary>
/// Defines an <see cref="IEnumerable{T}"/> with a <see cref="Delegate"/> that is invoked on iteration.
/// </summary>
/// <typeparam name="T">The type of item in the <see cref="IEnumerable{T}"/>.</typeparam>
/// <typeparam name="TExternal">The context element to pass into the <see cref="Delegate"/>.</typeparam>
#pragma warning disable MA0048
public sealed partial class Enumerable<T, TExternal> : IEnumerable<T>
#pragma warning restore MA0048
{
    readonly Delegate _action;

    readonly IEnumerable<T> _enumerable;

    readonly TExternal _external;

    /// <inheritdoc />
    public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T> action)
        : this(enumerable, external, (Delegate)action) { }

    /// <inheritdoc />
    public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T, int> action)
        : this(enumerable, external, (Delegate)action) { }

    /// <inheritdoc />
    public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T, TExternal> action)
        : this(enumerable, external, (Delegate)action) { }

    /// <inheritdoc />
    public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T, int, TExternal> action)
        : this(enumerable, external, (Delegate)action) { }

    /// <summary>Initializes a new instance of the <see cref="Enumerable{T, TExternal}"/> class.</summary>
    /// <param name="enumerable">
    /// The <see cref="IEnumerable{T}"/> to create an <see cref="IEnumerator{T}"/> from.
    /// </param>
    /// <param name="external">The context element.</param>
    /// <param name="action">The <see cref="Delegate"/> to invoke on iteration.</param>
    Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Delegate action)
    {
        _enumerable = enumerable;
        _external = external;
        _action = action;
    }

    /// <inheritdoc />
    [CollectionAccess(CollectionAccessType.Read), Pure]
#pragma warning disable IDISP004
    public IEnumerator<T> GetEnumerator() => new Enumerator(_enumerable.GetEnumerator(), _external, _action);
#pragma warning restore IDISP004
    /// <inheritdoc />
    [CollectionAccess(CollectionAccessType.Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    sealed class Enumerator(
        [ProvidesContext] IEnumerator<T> enumerator,
        TExternal external,
        Delegate action
    ) : IEnumerator<T>
    {
        int _index;

        /// <inheritdoc />
        // ReSharper disable once AssignNullToNotNullAttribute
        public T Current => enumerator.Current;

        /// <inheritdoc />
        object? IEnumerator.Current => ((IEnumerator)enumerator).Current;

        /// <inheritdoc />
        public void Reset()
        {
            enumerator.Reset();
            _index = 0;
        }

        /// <inheritdoc />
#pragma warning disable IDISP007
        public void Dispose() => enumerator.Dispose();
#pragma warning restore IDISP007

        /// <inheritdoc />
        public bool MoveNext()
        {
            if (!enumerator.MoveNext())
                return false;

            var current = Current;

            switch (action)
            {
                case Action<T> act:
                    act(current);
                    break;
                case Action<T, int> act:
                    act(current, _index);
                    break;
                case Action<T, TExternal> act:
                    act(current, external);
                    break;
                case Action<T, int, TExternal> act:
                    act(current, _index, external);
                    break;
            }

            _index++;
            return true;
        }
    }
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace

#pragma warning disable 8603, 8604
/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For([NonNegativeValue] this int upper, [InstantHandle] Action action)
    {
        for (var i = 0; i < upper; i++)
            action();

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For([NonNegativeValue] this int upper, [InstantHandle] Action<int> action)
    {
        for (var i = 0; i < upper; i++)
            action(i);

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Action<TExternal> action
    )
    {
        for (var i = 0; i < upper; i++)
            action(external);

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Action<int, TExternal> action
    )
    {
        for (var i = 0; i < upper; i++)
            action(i, external);

        return upper;
    }
#if !NET20 && !NET30
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Action<T> action
    )
    {
        var list = iterable.ToCollectionLazily();

        foreach (var item in list)
            action(item);

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Action<T, TExternal> action
    )
    {
        var list = iterable.ToCollectionLazily();

        foreach (var item in list)
            action(item, external);

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Action<T, int> action
    )
    {
        var list = iterable.ToCollectionLazily();
        var i = 0;

        foreach (var item in list)
            action(item, checked(i++));

        return list;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Action<T, int, TExternal> action
    )
    {
        var list = iterable.ToCollectionLazily();
        var i = 0;

        foreach (var item in list)
            action(item, checked(i++), external);

        return list;
    }
#endif

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Action<TKey, TValue> action
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value);

        return dictionary;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Action<TKey, TValue, TExternal> action
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value, external);

        return dictionary;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Action<TKey, TValue, int> action
    )
        where TKey : notnull
    {
        var i = 0;

        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value, checked(i++));

        return dictionary;
    }

    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Action<TKey, TValue, int, TExternal> action
    )
        where TKey : notnull
    {
        var i = 0;

        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value, checked(i++), external);

        return dictionary;
    }
#if !NET20 && !NET30
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<int> For(this int num) =>
        num >= 0 ? Enumerable.Range(0, num) : Enumerable.Repeat(-num, -num).Select((x, i) => x - i - 1);

    /// <summary>Gets an enumeration of a number.</summary>
    /// <param name="num">The index to count up or down to.</param>
    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<int> GetEnumerator(this int num) => num.For().GetEnumerator();

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="int"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TExternal> For<TExternal>([NonNegativeValue] this int upper, TExternal external) =>
        Enumerable.Repeat(external, upper);

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<TResult>(
        [NonNegativeValue] this int upper,
        [InstantHandle] Func<TResult> func
    ) =>
        Enumerable.Repeat(func, upper).Select(x => x());

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<TResult>(
        [NonNegativeValue] this int upper,
        [InstantHandle] Converter<int, TResult> func
    ) =>
        Enumerable.Repeat(func, upper).Select((x, i) => x(i));
#endif
#if NET7_0_OR_GREATER
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> For<T>(this T upper)
        where T : IComparisonOperators<T?, T?, bool>,
        ISubtractionOperators<T, T, T>,
        IIncrementOperators<T>,
        IUnaryNegationOperators<T, T>
    {
        var isNegative = upper < default(T);
        var abs = isNegative ? -upper : upper;

        for (T? i = default; i < abs; i++)
            yield return isNegative ? upper - i : i;
    }

    /// <summary>Gets an enumeration of a number.</summary>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="num">The index to count up or down to.</param>
    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<T> GetEnumerator<T>(this T num)
        where T : IComparisonOperators<T?, T?, bool>,
        ISubtractionOperators<T, T, T>,
        IIncrementOperators<T>,
        IUnaryNegationOperators<T, T> =>
        num.For().GetEnumerator();

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="int"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TExternal> For<T, TExternal>([NonNegativeValue] this T upper, TExternal external)
        where T : IComparisonOperators<T?, T?, bool>, IIncrementOperators<T>, IUnaryNegationOperators<T, T>
    {
        var isNegative = upper < default(T);
        var abs = isNegative ? -upper : upper;

        for (T? i = default; i < abs; i++)
            yield return external;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<T, TResult>(
        [NonNegativeValue] this T upper,
        [InstantHandle] Func<TResult> func
    )
        where T : IComparisonOperators<T?, T?, bool>, IIncrementOperators<T>, IUnaryNegationOperators<T, T>
    {
        var isNegative = upper < default(T);
        var abs = isNegative ? -upper : upper;

        for (T? i = default; i < abs; i++)
            yield return func();
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<T, TResult>(
        [NonNegativeValue] this T upper,
        [InstantHandle] Converter<T, TResult> func
    )
        where T : IComparisonOperators<T?, T?, bool>,
        ISubtractionOperators<T, T, T>,
        IIncrementOperators<T>,
        IUnaryNegationOperators<T, T>
    {
        var isNegative = upper < default(T);
        var abs = isNegative ? -upper : upper;

        for (T? i = default; i < abs; i++)
            yield return func(isNegative ? upper - i : i);
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T>([NonNegativeValue] this T upper, [InstantHandle] Action action)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action();

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T>([NonNegativeValue] this T upper, [InstantHandle] Action<T> action)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action(i);

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Action<TExternal> action
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action(external);

        return upper;
    }

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Action<T, TExternal> action
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action(i, external);

        return upper;
    }

    /// <inheritdoc cref="Array.ConvertAll{TInput, TOutput}"/>
    public static TOutput[] ConvertAll<TInput, TOutput>(this TInput[] array, Converter<TInput, TOutput> converter) =>
        Array.ConvertAll(array, converter);
#endif

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace


/// <summary>Extension methods to create power sets.</summary>

    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<object>> PowerSet(this ICollection collection) =>
        collection.Cast<object>().PowerSetInner(collection.Count);

    /// <summary>Creates a power set from a collection.</summary>
    /// <remarks><para>
    /// The power set is defined as the set of all subsets, including the empty set and the set itself.
    /// </para></remarks>
    /// <typeparam name="T">The type of item in the set.</typeparam>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The argument <paramref name="collection"/> has 32 or more elements.
    /// </exception>
    /// <param name="collection">The set to create a power set.</param>
    /// <returns>The power set of the parameter <paramref name="collection"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this ICollection<T> collection) =>
        collection.PowerSetInner(collection.Count);

    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this IReadOnlyCollection<T> collection) =>
        collection.PowerSetInner(collection.Count);

    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this T[] collection) =>
        ((ICollection<T>)collection).PowerSet();

    // ReSharper disable ConditionIsAlwaysTrueOrFalse
    [LinqTunnel, Pure]
    static IEnumerable<IEnumerable<T>> PowerSetInner<T>(this IEnumerable<T> iterable, [ValueRange(0, 31)] int count) =>
        count < 32
            ? Enumerable.Range(0, 1 << count).Select(mask => iterable.Where((_, j) => (1 << j & mask) is not 0))
            : throw new ArgumentOutOfRangeException(nameof(count), count, $"Cannot exceed bits in {nameof(Int32)}.");
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable InvertIf
#pragma warning disable IDE0059

// ReSharper disable once CheckNamespace


/// <summary>Extension methods to force full enumerations.</summary>

    /// <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    public static void Enumerate([InstantHandle] this IEnumerable? iterable)
    {
        if (iterable is not null)
            foreach (var unused in iterable)
            {
                // Intentionally left empty for enumerables with side effects.
            }
    }

    /// <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    public static void Enumerate<T>([InstantHandle] this IEnumerable<T>? iterable)
    {
        if (iterable is not null)
            foreach (var unused in iterable)
            {
                // Intentionally left empty for enumerables with side effects.
            }
    }

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace

#pragma warning disable CS1574, CS1580
/// <summary>Extension methods that negate functions from <see cref="Enumerable"/>.</summary>

    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
    /// <remarks><para>
    /// Filters out unique elements within an <see cref="Enumerable{T}"/>.
    /// Each duplicate appears exactly once within the returned value.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
    /// <param name="source">The source to filter.</param>
    /// <param name="comparer">The comparer to assess distinctiveness.</param>
    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> DistinctDuplicates<T>(
        [NoEnumeration] this IEnumerable<T> source,
        IEqualityComparer<T>? comparer = null
    ) =>
        source.GroupDuplicates(comparer).Select(x => x.Key);

    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
    /// <remarks><para>
    /// Filters out unique elements within an <see cref="Enumerable{T}"/>.
    /// Each duplicate appears two or more times within the returned value.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
    /// <param name="source">The source to filter.</param>
    /// <param name="comparer">The comparer to assess distinctiveness.</param>
    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Duplicates<T>(
        [NoEnumeration] this IEnumerable<T> source,
        IEqualityComparer<T>? comparer = null
    ) =>
        source.GroupDuplicates(comparer).SelectMany(x => x);

    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
    /// <remarks><para>Filters out unique elements within an <see cref="Enumerable{T}"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
    /// <param name="source">The source to filter.</param>
    /// <param name="comparer">The comparer to assess distinctiveness.</param>
    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<IGrouping<T, T>> GroupDuplicates<T>(
        [NoEnumeration] this IEnumerable<T> source,
        IEqualityComparer<T>? comparer = null
    ) =>
        source.GroupBy(x => x, comparer).Where(x => x.Skip(1).Any());

    /// <summary>Negated <see cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains the elements from the input sequence starting at
    /// the first element in the linear series that does pass the test specified by the predicate.
    /// </returns>
    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> SkipUntil<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
        source.SkipWhile(Not1(predicate));

    /// <summary>Negated <see cref="Enumerable.SelectMany{T}(IEnumerable{T}, Func{T, IEnumerable{T}})"/>.</summary>
    /// <remarks><para>
    /// Splits the <see cref="IEnumerable{T}"/> into multiple <see cref="IEnumerable{T}"/>
    /// instances in at most the specified length.
    /// </para></remarks>
    /// <typeparam name="T">The type of the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <param name="source">The <see cref="IEnumerable{T}"/> to chop into slices.</param>
    /// <param name="count">The maximum length of any given returned <see cref="IEnumerable{T}"/> instances.</param>
    /// <returns>The wrapper of the parameter <paramref name="source"/> that returns slices of it.</returns>
    [Pure]
    public static IEnumerable<IEnumerable<T>> SplitEvery<T>(
        [InstantHandle] this IEnumerable<T> source,
        [ValueRange(1, int.MaxValue)] int count
    )
    {
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
        if (count <= 0)
            yield break;

        using var e = source.GetEnumerator();

        while (e.MoveNext())
            yield return e.SplitEvery(count);
    }

    /// <summary>Negated <see cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains the elements from the input
    /// sequence that occur before the element at which the test no longer fails.
    /// </returns>
    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> TakeUntil<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
        source.TakeWhile(Not1(predicate));

    /// <summary>Negated <see cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains elements from
    /// the input sequence that do not satisfy the condition.
    /// </returns>
    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> TakeUntil<T>(
        [NoEnumeration] this IEnumerable<T> source,
        Func<T, int, bool> predicate
    ) =>
        source.TakeWhile(Not2(predicate));

    /// <summary>Negated <see cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains elements from
    /// the input sequence that do not satisfy the condition.
    /// </returns>
    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Omit<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
        source.Where(Not1(predicate));

    /// <summary>Negated <see cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains elements from
    /// the input sequence that do not satisfy the condition.
    /// </returns>
    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Omit<T>(
        [NoEnumeration] this IEnumerable<T> source,
        Func<T, int, bool> predicate
    ) =>
        source.Where(Not2(predicate));

    static IEnumerable<T> SplitEvery<T>(this IEnumerator<T> e, [ValueRange(1, int.MaxValue)] int count)
    {
        do
        {
            yield return e.Current;

            count--;
        } while (count > 0 && e.MoveNext());
    }
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>

    /// <summary>Returns a fallback enumeration if the collection given is null or empty.</summary>
    /// <typeparam name="T">The type of item within the enumeration.</typeparam>
    /// <param name="iterable">The potentially empty collection.</param>
    /// <param name="fallback">The fallback value.</param>
    /// <returns>
    /// The parameter <paramref name="iterable"/> when non-empty, otherwise; <paramref name="fallback"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> DefaultIfEmpty<T>(this IEnumerable<T>? iterable, IEnumerable<T> fallback)
    {
        using var a = iterable?.GetEnumerator();

        if (a?.MoveNext() ?? false)
            do
                yield return a.Current;
            while (a.MoveNext());
        else
            foreach (var b in fallback)
                yield return b;
    }
#if !NETFRAMEWORK || NET35_OR_GREATER
    /// <summary>Upcasts or creates an <see cref="IList{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="IList{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static T[]? ToArrayLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as T[] ?? iterable.ToArray();
#endif

    /// <summary>Upcasts or creates an <see cref="ICollection{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="ICollection{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ICollection<T>? ToCollectionLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null
            ? null
            : iterable as ICollection<T> ??
            (iterable.TryGetNonEnumeratedCount(out var count)
                ? new Collection<T>(iterable, count)
#if NETFRAMEWORK && NET40_OR_GREATER
                : new List<T>(iterable));
#else
                : iterable.ToListLazily());
#endif

    /// <summary>Upcasts or creates an <see cref="IList{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="IList{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IList<T>? ToListLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
#if NETFRAMEWORK && NET40_OR_GREATER
        iterable is null ? null : iterable as IList<T> ?? new List<T>(iterable);
#else
        iterable is null ? null : iterable as IList<T> ?? iterable.ToList();
#endif
#if !NETFRAMEWORK || NET40_OR_GREATER
    /// <summary>Upcasts or creates an <see cref="ISet{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="IList{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ISet<T>? ToSetLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as ISet<T> ?? new HashSet<T>(iterable);

    /// <summary>Creates a <see cref="HashSet{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to encapsulate.</param>
    /// <param name="comparer">The comparer to use.</param>
    /// <returns>Itself as <see cref="ISet{T}"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static HashSet<T>? ToSet<T>(
        [InstantHandle] this IEnumerable<T>? iterable,
        IEqualityComparer<T>? comparer = null
    ) =>
        iterable is null ? null : new HashSet<T>(iterable, comparer);

    /// <summary>Upcasts or creates an <see cref="ISet{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <param name="comparer">The comparer to use if one needs to be generated.</param>
    /// <returns>Itself as <see cref="ISet{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ISet<T>? ToSetLazily<T>(
        [InstantHandle] this IEnumerable<T>? iterable,
        IEqualityComparer<T> comparer
    ) =>
        iterable is null ? null : iterable as ISet<T> ?? new HashSet<T>(iterable, comparer);
#endif

    /// <summary>Attempts to create a list from an <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item in the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <typeparam name="TList">The destination type.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to convert.</param>
    /// <param name="converter">The <see cref="IList{T}"/> to convert it to.</param>
    /// <returns>
    /// A <typeparamref name="TList"/> from <paramref name="converter"/>, as long as every element returned
    /// is not <paramref langword="null"/>, otherwise <paramref langword="default"/>.
    /// </returns>
    [MustUseReturnValue]
    public static TList? Collect<T, TList>(
        [InstantHandle] this IEnumerable<T?> iterable,
        [InstantHandle] Converter<IEnumerable<T>, TList> converter
    )
        where TList : IList<T> => // ReSharper disable once NullableWarningSuppressionIsUsed
#pragma warning disable CS8620 // Checked later, technically could cause problems, but most factory methods are fine.
        (TList?)converter(iterable);
#pragma warning restore CS8620

    /// <summary>Provides a wrapper to an <see cref="IEnumerable{T}"/> with a known count.</summary>
    /// <param name="enumerable">The enumerable to encapsulate.</param>
    /// <param name="count">The pre-computed count.</param>
    /// <typeparam name="T">The type of element in the <see cref="IEnumerable{T}"/>.</typeparam>
#pragma warning disable IDE0044
    sealed class Collection<T>([ProvidesContext] IEnumerable<T> enumerable, [NonNegativeValue] int count) : ICollection,
#pragma warning restore IDE0044
        ICollection<T>,
        IReadOnlyCollection<T>
    {
        /// <inheritdoc />
        [Pure]
        bool ICollection.IsSynchronized => true;

        /// <inheritdoc />
        [Pure]
        bool ICollection<T>.IsReadOnly => true;

        /// <inheritdoc cref="ICollection{T}.Count" />
        [NonNegativeValue, Pure]
        public int Count => count;

        /// <inheritdoc />
        [Pure]
        public object SyncRoot => enumerable;

        /// <inheritdoc />
        public void CopyTo(Array array, [NonNegativeValue] int index)
        {
            var i = 0;

            foreach (var next in enumerable)
            {
                array.SetValue(next, index);
                _ = checked(i++);
            }
        }

        /// <inheritdoc />
        public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
        {
            var i = 0;

            foreach (var next in enumerable)
            {
                array[arrayIndex] = next;
                _ = checked(i++);
            }
        }

        /// <inheritdoc />
#pragma warning disable RCS1163
        void ICollection<T>.Add(T? item) { }
#pragma warning restore RCS1163

        /// <inheritdoc />
        void ICollection<T>.Clear() { }

        /// <inheritdoc />
        [Pure]
        public bool Contains(T item)
        {
            // ReSharper disable once LoopCanBeConvertedToQuery
            foreach (var next in enumerable)
                if (EqualityComparer<T>.Default.Equals(next, item))
                    return true;

            return false;
        }

        /// <inheritdoc />
        [Pure]
#pragma warning disable RCS1163
        bool ICollection<T>.Remove(T? item) => false;
#pragma warning restore RCS1163

        /// <inheritdoc />
        [Pure]
        IEnumerator IEnumerable.GetEnumerator() => enumerable.GetEnumerator();

        /// <inheritdoc />
        [Pure]
        public IEnumerator<T> GetEnumerator() => enumerable.GetEnumerator();
    }

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable CheckNamespace ConditionIsAlwaysTrueOrFalse InvocationIsSkipped RedundantNameQualifier ReturnTypeCanBeEnumerable.Global UseIndexFromEndExpression


/// <summary>Extension methods to attempt to grab values from enumerables.</summary>

    /// <summary>Takes the last item lazily, or a fallback value.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
    [Pure]
    public static T EnumerateOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback)
    {
#if NETCOREAPP || ROSLYN
        if (iterable is ImmutableArray<T> { IsDefaultOrEmpty: true })
            return fallback;
#endif
        using var iterator = iterable.GetEnumerator();

        if (!iterator.MoveNext())
            return fallback;

        var last = iterator.Current;

        while (iterator.MoveNext())
            last = iterator.Current;

        return last;
    }

    /// <summary>Takes the first item, or a fallback value.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
    [MustUseReturnValue]
    public static T FirstOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback)
    {
        switch (iterable)
        {
            case string str:
                return str.Length is 0 ? fallback : Reinterpret<T>(str[0]);
#if NETCOREAPP || ROSLYN
            case ImmutableArray<T> array:
                return array.IsDefaultOrEmpty ? fallback : array[0];
#endif
            case IList<T> list:
                return list.Count is 0 ? fallback : list[0];
            case IReadOnlyList<T> list:
                return list.Count is 0 ? fallback : list[0];
            case var _ when iterable.TryGetNonEnumeratedCount(out var count):
                return count is 0 ? fallback : iterable.First();
            default:
            {
                using var iterator = iterable.GetEnumerator();
                return iterator.MoveNext() ? iterator.Current : fallback;
            }
        }
    }

    /// <summary>Takes the last item, or a fallback value.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
    [MustUseReturnValue]
    public static T LastOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback) =>
#pragma warning disable IDE0056
        iterable switch
        {
            string str => str.Length is 0 ? fallback : Reinterpret<T>(str[str.Length - 1]),
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> array => array.IsDefaultOrEmpty ? fallback : array[array.Length - 1],
#endif
            IReadOnlyList<T> list => list.Count is 0 ? fallback : list[list.Count - 1],
            IList<T> list => list.Count is 0 ? fallback : list[list.Count - 1],
            _ when iterable.TryGetNonEnumeratedCount(out var count) => count is 0 ? fallback : iterable.Last(),
            _ => iterable.EnumerateOr(fallback),
        };
#pragma warning restore IDE0056

    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="TKey">The key item in the collection.</typeparam>
    /// <typeparam name="TValue">The value item in the collection.</typeparam>
    /// <param name="dictionary">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="key">The key to use to get the value.</param>
    /// <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static TValue? Nth<TKey, TValue>([InstantHandle] this IDictionary<TKey, TValue> dictionary, TKey key)
        where TKey : notnull =>
        dictionary.TryGetValue(key, out var value) ? value : default;

#if !NET20 && !NET30
    /// <summary>Returns the item, or a fallback.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="self">The item to potentially return.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
    [Pure]
    public static T Or<T>(this T? self, T fallback)
        where T : class =>
        self ?? fallback;

    /// <summary>Returns the item, or a fallback.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="self">The item to potentially return.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
    [Pure]
    public static T Or<T>(this T? self, T fallback)
        where T : struct =>
        self ?? fallback;

    /// <summary>Returns the item, or a fallback.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="self">The item to potentially return.</param>
    /// <returns>The parameter <paramref name="self"/>, or a new instance.</returns>
    [Pure]
    public static T OrNew<T>(this T? self)
        where T : class, new() =>
        self ?? new();

    /// <summary>Returns the string, or an empty string.</summary>
    /// <param name="str">The string to potentially return.</param>
    /// <returns>The parameter <paramref name="str"/>, or <see cref="string.Empty"/>.</returns>
    [Pure]
    public static string OrEmpty(this string? str) => str ?? "";

    /// <summary>Returns the enumeration, or an empty enumeration.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The enumeration to potentially return.</param>
    /// <returns>The parameter <paramref name="iterable"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> OrEmpty<T>([NoEnumeration] this IEnumerable<T>? iterable) => iterable ?? [];

#if NETCOREAPP || ROSLYN
    /// <summary>Returns the array, or an empty array.</summary>
    /// <typeparam name="T">The type of array.</typeparam>
    /// <param name="array">The array to potentially return.</param>
    /// <returns>The parameter <paramref name="array"/>, or <see cref="ImmutableArray{T}.Empty"/>.</returns>
    [Pure]
    public static ImmutableArray<T> OrEmpty<T>(this ImmutableArray<T> array) => array.IsDefault ? [] : array;
#endif

    /// <summary>Gets a specific character from a string.</summary>
    /// <param name="str">The string to get the character from.</param>
    /// <param name="index">The index to use.</param>
    /// <returns>The character based on the parameters <paramref name="str"/> and <paramref name="index"/>.</returns>
    [Pure]
    public static char? Nth(this string str, [NonNegativeValue] int index) =>
        index >= 0 && index < str.Length ? str[index] : null;

    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static T? Nth<T>([InstantHandle] this IEnumerable<T> iterable, [NonNegativeValue] int index)
    {
        // Runtime check.
        if (index < 0)
            return default;

        return iterable switch
        {
            string str => index < str.Length ? Reinterpret<T>(str[index]) : default,
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> array => !array.IsDefault && index < array.Length ? array[index] : default,
#endif
            IReadOnlyList<T> list => index < list.Count ? list[index] : default,
            IList<T> list => index < list.Count ? list[index] : default,
            _ => iterable.Skip(index).FirstOrDefault(),
        };
    }

    /// <summary>Gets a specific character from a string.</summary>
    /// <param name="str">The string to get the character from.</param>
    /// <param name="index">The index to use.</param>
    /// <returns>The character based on the parameters <paramref name="str"/> and <paramref name="index"/>.</returns>
    [Pure]
    public static char? NthLast(this string str, [NonNegativeValue] int index) =>
        index >= 0 && index < str.Length ? str[str.Length - index - 1] : null;

    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static T? NthLast<T>([InstantHandle] this IEnumerable<T> iterable, [NonNegativeValue] int index)
    {
        // Runtime check.
        if (index < 0)
            return default;

        return iterable switch
        {
            string str => index < str.Length ? Reinterpret<T>(str[str.Length - index - 1]) : default,
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> array =>
                !array.IsDefault && index < array.Length ? array[array.Length - index - 1] : default,
#endif
            IReadOnlyList<T> list => index < list.Count ? list[list.Count - index - 1] : default,
            IList<T> list => index < list.Count ? list[list.Count - index - 1] : default,
            _ when iterable.TryGetNonEnumeratedCount(out var count) =>
                index < count ? iterable.Skip(count - index - 1).FirstOrDefault() : default,
            _ => iterable.Reverse().Skip(index).FirstOrDefault(),
        };
    }
#endif
#if NET5_0_OR_GREATER
    /// <summary>Tries to extract a span from the source.</summary>
    /// <typeparam name="T">The type of element in the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <param name="source">The source to extract the span from.</param>
    /// <param name="span">The resulting span.</param>
    /// <returns>Whether the span can be extracted from the parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)] // fast type checks that don't add a lot of overhead
    public static bool TryGetSpan<T>(
        [NoEnumeration, NotNullWhen(true)] this IEnumerable<T>? source,
        out ReadOnlySpan<T> span
    )
        where T : struct =>
        source switch
        {
            T[] provider => (span = provider) is var _,
            ImmutableArray<T> provider => (span = provider.AsSpan()) is var _,
            List<T> provider => (span = CollectionsMarshal.AsSpan(provider)) is var _,
            _ => !((span = default) is var _),
        };
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe T Reinterpret<T>(char c)
    {
        // ReSharper disable once InvocationIsSkipped RedundantNameQualifier
        System.Diagnostics.Debug.Assert(typeof(T) == typeof(char), "T must be char");
#pragma warning disable 8500
        return *(T*)&c;
#pragma warning restore 8500
    }

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable CheckNamespace RedundantNameQualifier




/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<int> For(this Index index) => (index.IsFromEnd ? -index.Value : index.Value).For();

    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
    /// <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<int> For(this Range range) =>
        (range.Start.IsFromEnd ? -range.Start.Value : range.Start.Value) is var start &&
        (range.End.IsFromEnd ? -range.End.Value : range.End.Value) is var end &&
        start == end ? [] :
        start < end ? Enumerable.Range(start, end - start) :
        Enumerable.Repeat(start, start - end).Select((x, i) => x - i);

    /// <summary>Separates the head from the tail of an <see cref="IEnumerable{T}"/>.</summary>
    /// <remarks><para>
    /// The tail is not guaranteed to be able to be enumerated over multiple times.
    /// As such, use a method like <see cref="Collected.ToCollectionLazily{T}"/> if multiple enumerations are needed.
    /// </para></remarks>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="enumerable">The enumerable to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="enumerable"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="enumerable"/>.</param>
    public static void Deconstruct<T>(this IEnumerable<T>? enumerable, out T? head, out IEnumerable<T> tail)
    {
        using var e = enumerable?.GetEnumerator();

        if (e is null)
        {
            head = default;
            tail = [];
            return;
        }

        head = e.MoveNext() ? e.Current : default;
        tail = e.AsEnumerable();
    }

    /// <summary>Gets a specific item from a collection.</summary>
    /// <param name="str">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="str"/>, or <see langword="default"/>.</returns>
    [Pure] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static char? Nth(this string str, Index index) =>
        index.IsFromEnd ? str.NthLast(index.Value - 1) : str.Nth(index.Value);

    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static T? Nth<T>([InstantHandle] this IEnumerable<T> iterable, Index index) =>
        index.IsFromEnd ? iterable.NthLast(index.Value - 1) : iterable.Nth(index.Value);

    /// <summary>Gets a specific item from a collection.</summary>
    /// <param name="str">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="str"/>, or <see langword="default"/>.</returns>
    [Pure] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static string? Nth(this string str, Range range) =>
        range.TryGetOffsetAndLength(str.Length, out var offset, out var length)
            ? str.Substring(offset, length)
            : default;

    /// <summary>Gets a range of items from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get a range of items from.</param>
    /// <param name="range">The ranges to get.</param>
    /// <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Nth<T>([InstantHandle] this IEnumerable<T> iterable, Range range)
    {
        [LinqTunnel, Pure]
        static IEnumerable<TT> Sub<TT>([InstantHandle] IEnumerable<TT> iterable, Range range) =>
            iterable.Skip(range.Start.Value).Take(range.End.Value - range.Start.Value);

        if (!range.Start.IsFromEnd && !range.End.IsFromEnd)
            return Sub(iterable, range);

        if (iterable.TryGetNonEnumeratedCount(out var count) && RangeStart(range, count) is var startRange)
            return Sub(iterable, startRange);

        var arr = iterable.ToListLazily();
        var arrRange = RangeStart(range, arr.Count);
        return Sub(arr, arrRange);
    }

    /// <summary>Gets an enumeration of an index.</summary>
    /// <param name="index">The index to count up or down to.</param>
    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<int> GetEnumerator(this Index index) => index.For().GetEnumerator();

    /// <summary>Gets an enumeration of a range.</summary>
    /// <param name="range">The range to iterate over.</param>
    /// <returns>An enumeration from the range's start to end.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<int> GetEnumerator(this Range range) => range.For().GetEnumerator();

    [Pure]
    static Index IndexStart(Index index, int length) => index.IsFromEnd ? length - index.Value - 1 : index;

    [Pure]
    static Range RangeStart(Range range, int length) =>
        new(IndexStart(range.Start, length), IndexStart(range.End, length));
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace

#pragma warning disable MA0048
/// <summary>Provides methods to convert <see cref="IEnumerator{T}"/> to <see cref="IEnumerable{T}"/>.</summary>

    /// <summary>Wraps the enumerator inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <param name="enumerator">The enumerator to encapsulate.</param>
    /// <returns>
    /// The <see cref="IEnumerator{T}"/> instance that returns the parameter <paramref name="enumerator"/>.
    /// </returns>
    [Pure]
    public static IEnumerator<object?> AsGeneric(this IEnumerator enumerator) => new Enumerator(enumerator);

    /// <summary>Wraps the enumerator inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <param name="enumerator">The enumerator to encapsulate.</param>
    /// <returns>The <see cref="IEnumerator{T}"/> instance that wraps <paramref name="enumerator"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<object?> AsEnumerable(this IEnumerator enumerator) =>
#pragma warning disable CA2000, IDISP004
        enumerator.AsGeneric().AsEnumerable();
#pragma warning restore CA2000, IDISP004

    /// <summary>Wraps the array inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <param name="array">The array to encapsulate.</param>
    /// <returns>The <see cref="IEnumerator{T}"/> instance that wraps <paramref name="array"/>.</returns>
    [LinqTunnel, Pure] // ReSharper disable once ObjectProducedWithMustDisposeAnnotatedMethodIsNotDisposed
    public static IEnumerable<object?> AsGenericEnumerable(this Array array) => array.GetEnumerator().AsEnumerable();

    /// <summary>Wraps the <see cref="IEnumerator{T}"/> inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item to enumerate.</typeparam>
    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to encapsulate.</param>
    /// <returns>The <see cref="IEnumerator{T}"/> instance that wraps <paramref name="enumerator"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> AsEnumerable<T>(this IEnumerator<T> enumerator) => new Enumerable<T>(enumerator);

    /// <summary>
    /// Wraps an <see cref="IEnumerator{T}"/> and exposes it from an <see cref="IEnumerable{T}"/> context.
    /// </summary>
    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to encapsulate.</param>
    /// <typeparam name="T">The type of item to enumerate.</typeparam>
    sealed partial class Enumerable<T>([ProvidesContext] IEnumerator<T> enumerator) : IEnumerable<T>
    {
        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.Read), Pure]
        public IEnumerator<T> GetEnumerator() => enumerator;

        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.Read), Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

#pragma warning disable SA1643
        /// <summary>Finalizes an instance of the <see cref="Enumerable{T}"/> class.</summary>
#pragma warning restore SA1643
#pragma warning disable MA0055, IDISP007, IDISP023
        ~Enumerable() => enumerator.Dispose();
#pragma warning restore MA0055, IDISP007, IDISP023
    }

    /// <summary>
    /// Wraps an <see cref="IEnumerator{T}"/> and exposes it from an <see cref="IEnumerable{T}"/> context.
    /// </summary>
    /// <param name="enumerator">The enumerator to encapsulate.</param>
    sealed partial class Enumerator([ProvidesContext] IEnumerator enumerator) : IEnumerator<object?>
    {
        /// <inheritdoc cref="IEnumerator{T}.Current" />
        [Pure]
        public object? Current => enumerator.Current;

        /// <inheritdoc />
        public void Reset() => enumerator.Reset();

        /// <inheritdoc />
        public void Dispose() { }

        /// <inheritdoc />
        public bool MoveNext() => enumerator.MoveNext();
    }

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace


/// <summary>Extension methods to create cartesian products.</summary>

    /// <summary>Creates a cartesian product from two collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T1">The type of item in the first set.</typeparam>
    /// <typeparam name="T2">The type of item in the second set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="second">The second set to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/> and <paramref name="second"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T1 First, T2 Second)> CartesianProduct<T1, T2>(
        this IEnumerable<T1> first,
        IEnumerable<T2> second
    ) =>
        first.SelectMany(_ => second, (x, y) => (x, y));

    /// <summary>Creates a cartesian product from three collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T1">The type of item in the first set.</typeparam>
    /// <typeparam name="T2">The type of item in the second set.</typeparam>
    /// <typeparam name="T3">The type of item in the third set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="second">The second set to create a cartesian product of.</param>
    /// <param name="third">The third set to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/>,
    /// <paramref name="second"/>, and <paramref name="third"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T1 First, T2 Second, T3 Third)> CartesianProduct<T1, T2, T3>(
        this IEnumerable<T1> first,
        IEnumerable<T2> second,
        IEnumerable<T3> third
    ) =>
        first
           .SelectMany(_ => second, (x, y) => (x, y))
           .SelectMany(_ => third, (xy, z) => (xy.x, xy.y, z));

    /// <summary>Creates a cartesian product from four collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T1">The type of item in the first set.</typeparam>
    /// <typeparam name="T2">The type of item in the second set.</typeparam>
    /// <typeparam name="T3">The type of item in the third set.</typeparam>
    /// <typeparam name="T4">The type of item in the fourth set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="second">The second set to create a cartesian product of.</param>
    /// <param name="third">The third set to create a cartesian product of.</param>
    /// <param name="fourth">The fourth set to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/>, <paramref name="second"/>,
    /// <paramref name="third"/>, and <paramref name="fourth"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T1 First, T2 Second, T3 Third, T4 Fourth)> CartesianProduct<T1, T2, T3, T4>(
        this IEnumerable<T1> first,
        IEnumerable<T2> second,
        IEnumerable<T3> third,
        IEnumerable<T4> fourth
    ) =>
        first
           .SelectMany(_ => second, (x, y) => (x, y))
           .SelectMany(_ => third, (xy, z) => (xy, z))
           .SelectMany(_ => fourth, (xyz, w) => (xyz.xy.x, xyz.xy.y, xyz.z, w));

    /// <summary>Creates a cartesian product from n-collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T">The type of item in the set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="rest">The rest of the sets to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/>, and all of <paramref name="rest"/>.
    /// </returns>
    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(
        this IEnumerable<T> first,
        params IEnumerable<T>[] rest
    ) =>
        Enumerable.Repeat(first, 1).Concat(rest).CartesianProduct();

    /// <summary>Creates a cartesian product from n-collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T">The type of item in the set.</typeparam>
    /// <param name="iterable">The sets to create a cartesian product of.</param>
    /// <returns>The cartesian product of all of the parameter <paramref name="iterable"/>.</returns>
    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> iterable) =>
        iterable.Aggregate(
            Enumerable.Repeat((IEnumerable<T>)[], 1),
            (sum, next) => sum.SelectMany(_ => next, (s, n) => s.Concat(Enumerable.Repeat(n, 1)))
        );
#endif

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace


/// <summary>Provides methods to flatten <see cref="IEnumerable{T}"/> instances.</summary>

    /// <summary>Flattens the nested collection.</summary>
    /// <typeparam name="T">The type of collection.</typeparam>
    /// <param name="enumerable">The collection to flatten.</param>
    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten<T>(this IEnumerable<IEnumerable<T>> enumerable) =>
        enumerable.SelectMany(Enumerable.AsEnumerable);

    /// <summary>Flattens the nested collection.</summary>
    /// <typeparam name="T">The type of collection.</typeparam>
    /// <param name="enumerable">The collection to flatten.</param>
    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten2<T>(this IEnumerable<IEnumerable<IEnumerable<T>>> enumerable) =>
        enumerable.SelectMany(Enumerable.AsEnumerable).SelectMany(Enumerable.AsEnumerable);

    /// <summary>Flattens the nested collection.</summary>
    /// <typeparam name="T">The type of collection.</typeparam>
    /// <param name="enumerable">The collection to flatten.</param>
    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten3<T>(this IEnumerable<IEnumerable<IEnumerable<IEnumerable<T>>>> enumerable) =>
        enumerable
           .SelectMany(Enumerable.AsEnumerable)
           .SelectMany(Enumerable.AsEnumerable)
           .SelectMany(Enumerable.AsEnumerable);

    /// <summary>
    /// Flattens the nested collection by taking all the first elements of the enumerations,
    /// then all the second elements of the enumerations, the third, and so on.
    /// When any enumeration runs out, it simply moves onto the next enumeration until all enumerations are finished.
    /// </summary>
    /// <typeparam name="T">The type of collection.</typeparam>
    /// <param name="enumerable">The collection to flatten.</param>
    /// <returns>
    /// The flattened collection by taking items in order of appearance of each individual enumerable,
    /// and only then by the outer enumerable.
    /// </returns>
    [Pure]
    public static IEnumerable<List<T>> Transpose<T>(this IEnumerable<IEnumerable<T>> enumerable)
    {
        // ReSharper disable once ObjectProducedWithMustDisposeAnnotatedMethodIsReturned
        var (truthy, falsy) = enumerable.Select(x => x.GetEnumerator()).SplitBy(x => x.MoveNext());

        falsy.For(x => x.Dispose());

        try
        {
            while (truthy is not [])
            {
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
                yield return truthy.ConvertAll(x => x.Current);
#else
                yield return new(truthy.Select(x => x.Current));
#endif
                (truthy, falsy) = truthy.SplitBy(x => x.MoveNext());
                falsy.For(x => x.Dispose());
            }
        }
        finally
        {
            truthy.For(x => x.Dispose());
        }
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace


/// <summary>Provides methods for creating combinations of items.</summary>

    /// <summary>Generates all combinations of the nested enumerable.</summary>
    /// <typeparam name="T">The type of nested enumerable.</typeparam>
    /// <param name="iterator">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="iterator"/>.</returns>
    [Pure]
#if NETFRAMEWORK && !NET45_OR_GREATER
    public static IEnumerable<IList<T>> Combinations<T>(
#else
    public static IEnumerable<IReadOnlyList<T>> Combinations<T>(
#endif
        [InstantHandle] this IEnumerable<IEnumerable<T>> iterator
    ) =>
#if NETFRAMEWORK && !NET45_OR_GREATER
        iterator.Select(x => x.ToListLazily()).ToListLazily().Combinations();
#else
        iterator.Select(x => x.ToReadOnly()).ToReadOnly().Combinations();
#endif

    /// <summary>Generates all combinations of the nested list.</summary>
    /// <typeparam name="T">The type of nested list.</typeparam>
    /// <param name="lists">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="lists"/>.</returns>
    [Pure]
#if NETFRAMEWORK && !NET45_OR_GREATER
    public static IEnumerable<IList<T>> Combinations<T>(this IList<IList<T>> lists)
#else
    public static IEnumerable<IReadOnlyList<T>> Combinations<T>(this IReadOnlyList<IReadOnlyList<T>> lists)
#endif
    {
        if (lists.Any(x => x is []))
            yield break;

        int count = lists.Count, index = 0, pos = 0;
        var indices = new int[count];
        var accumulator = new T[count];

        while (true)
        {
            while (pos < accumulator.Length)
            {
                indices[pos] = index;
                accumulator[pos] = lists[pos][index];
                index = 0;
                pos++;
            }

            var result = new T[count];
            Array.Copy(accumulator, result, count);
            yield return result;

            do
            {
                if (pos is 0)
                    yield break;

                index = indices[--pos] + 1;
            } while (index >= lists[pos].Count);
        }
    }

    /// <summary>Generates all combinations of the nested list.</summary>
    /// <typeparam name="T">The type of nested list.</typeparam>
    /// <param name="lists">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="lists"/>.</returns>
    [Pure]
    public static IEnumerable<SmallList<T>> Combinations<T>(this SmallList<SmallList<T>> lists)
    {
        // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
        foreach (var list in lists)
            if (list is [])
                return [];

        return lists.CombinationsIterator();
    }

    /// <summary>Generates all combinations of the nested enumerable.</summary>
    /// <typeparam name="T">The type of nested enumerable.</typeparam>
    /// <param name="iterator">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="iterator"/>.</returns>
    [Pure]
    public static IEnumerable<SmallList<T>> SmallListCombinations<T>(
        [InstantHandle] this IEnumerable<IEnumerable<T>> iterator
    ) =>
        iterator.Select(x => x.ToSmallList()).ToSmallList().Combinations();

    static IEnumerable<SmallList<T>> CombinationsIterator<T>(this SmallList<SmallList<T>> lists)
    {
        int count = lists.Count, index = 0, pos = 0;
        var indices = count.AsUninitSmallList<int>();
        var accumulator = count.AsUninitSmallList<T>();

        while (true)
        {
            while (pos < accumulator.Count)
            {
                indices[pos] = index;
                accumulator[pos] = lists[pos][index];
                index = 0;
                pos++;
            }

            yield return accumulator.Cloned;

            do
            {
                if (pos is 0)
                    yield break;

                index = indices[--pos] + 1;
            } while (index >= lists[pos].Count);
        }
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace


/// <summary>Extension methods for randomized getters.</summary>

    /// <summary>Shuffles a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to shuffle.</param>
    /// <param name="selector">The indices to swap with, when left unspecified, uses <see cref="Rand"/>.</param>
    /// <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static IList<T> Shuffle<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<int, int, int>? selector = null
    )
    {
        selector ??= Rand();

        var list = iterable.ToListLazily();

        for (var j = list.Count; j >= 1; j--)
        {
            var item = selector(0, j);

            if (item >= j - 1)
                continue;

            // Tuples might not necessarily be imported.
#pragma warning disable IDE0180 // ReSharper disable once SwapViaDeconstruction
            var t = list[item];
            list[item] = list[j - 1];
            list[j - 1] = t;
#pragma warning restore IDE0180
        }

        return list;
    }

    /// <inheritdoc cref="Shuffle{T}(IEnumerable{T}, Func{int, int, int})" />
    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static Span<T> Shuffle<T>(this Span<T> iterable, [InstantHandle] Func<int, int, int>? selector = null)
    {
        selector ??= Rand();

        for (var j = iterable.Length; j >= 1; j--)
        {
            var item = selector(0, j);

            if (item >= j - 1)
                continue;

            // Tuples might not necessarily be imported.
#pragma warning disable IDE0180 // ReSharper disable once SwapViaDeconstruction
            var t = iterable[item];
            iterable[item] = iterable[j - 1];
            iterable[j - 1] = t;
#pragma warning restore IDE0180
        }

        return iterable;
    }

    /// <summary>Shuffles a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to shuffle.</param>
    /// <param name="selector">The indices to swap with, when left unspecified, uses <see cref="Rand"/>.</param>
    /// <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static T PickRandom<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<int, int, int>? selector = null
    )
    {
        selector ??= Rand();

        return iterable switch
        {
            IList<T> list => list[selector(0, list.Count)],
            IReadOnlyList<T> list => list[selector(0, list.Count)],
            _ when iterable.ToList() is var list => list[selector(0, list.Count)],
            _ => throw Unreachable,
        };
    }

    /// <inheritdoc cref="PickRandom{T}(IEnumerable{T}, Func{int, int, int})" />
    [MustUseReturnValue]
    public static T PickRandom<T>([InstantHandle] this scoped Span<T> iterable, Func<int, int, int>? selector = null) =>
        PickRandom((ReadOnlySpan<T>)iterable, selector);

    /// <inheritdoc cref="PickRandom{T}(IEnumerable{T}, Func{int, int, int})" />
    [MustUseReturnValue]
    public static T PickRandom<T>(
        [InstantHandle] this scoped ReadOnlySpan<T> iterable,
        Func<int, int, int>? selector = null
    )
    {
        selector ??= Rand();
        return iterable[selector(0, iterable.Length)];
    }

    [Pure]
    static Func<int, int, int> Rand() =>
#if KTANE
        UnityEngine.Random.Range;
#elif NET6_0_OR_GREATER
        Random.Shared.Next;
#else
        // ReSharper disable once RedundantNameQualifier
        new Random().Next;
#endif
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable UnusedMember.Local
// ReSharper disable once CheckNamespace


#pragma warning disable CA1508
/// <summary>Extension methods for improving nullability awareness for enumerables.</summary>

    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="iterable">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IEnumerable<T?>? ItemCanBeEmptyNullable<T>(this IEnumerable<T>? iterable)
        where T : struct =>
        iterable?.Select(x => (T?)x);

#pragma warning disable CS8619
    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="iterable">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IEnumerable<T?>? ItemCanBeNull<T>(this IEnumerable<T>? iterable) => iterable;

    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="iterator">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="iterator"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterator))]
    public static IEnumerator<T?>? ItemCanBeNull<T>(this IEnumerator<T>? iterator) => iterator;

#if !NET20 && !NET30
    /// <summary>Returns the list if all items are non-null.</summary>
    /// <typeparam name="T">The type of list.</typeparam>
    /// <param name="list">The list to filter.</param>
    /// <returns>
    /// The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
    /// otherwise <see langword="null"/>.
    /// </returns>
    [Pure]
    public static IList<T>? ItemNotNull<T>(this IList<T?>? list) =>
        list?.All(x => x is not null) ?? false ? list : null;
#endif

    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="collection">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(collection))]
    public static IReadOnlyCollection<T?>? ItemCanBeNull<T>(this IReadOnlyCollection<T>? collection) => collection;

    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="list">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(list))]
    public static IReadOnlyList<T?>? ItemCanBeNull<T>(this IReadOnlyList<T>? list) => list;

    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="set">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(set))]
    public static IReadOnlySet<T?>? ItemCanBeNull<T>(this IReadOnlySet<T>? set) => set;
#pragma warning restore CS8619

// SPDX-License-Identifier: MPL-2.0
#if !NETSTANDARD1_0
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly

#pragma warning disable 8500, IDE0044, MA0102, SA1137


/// <summary>Provides methods for determining similarity between two sequences.</summary>

    const string E = "Value must be non-negative and less than the length.";

    const StringComparison DefaultCharComparer = StringComparison.Ordinal;

    /// <summary>Calculates the Jaro similarity between two strings.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro(this string? left, string? right) =>
        string.Equals(left, right, DefaultCharComparer) ? 1 : left.Jaro(right, EqualityComparer<char>.Default);

    /// <summary>Calculates the Jaro similarity between two strings.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro(this string? left, string? right, [InstantHandle] Func<char, char, bool>? comparer) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        Jaro(left, right, static x => x.Length, static (x, i) => x[i], comparer);

    /// <summary>Calculates the Jaro similarity between two strings.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro(this string? left, string? right, IEqualityComparer<char>? comparer) =>
        left.Jaro(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
    /// <remarks><para>Like <see cref="Jaro(string, string)"/>, but with a bias to common sub-slices.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik(this string? left, string? right) =>
        string.Equals(left, right, DefaultCharComparer) ? 1 : left.JaroEmik(right, EqualityComparer<char>.Default);

    /// <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, Func{char, char, bool})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik(this string? left, string? right, [InstantHandle] Func<char, char, bool>? comparer) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        JaroEmik(left, right, static x => x.Length, static (x, i) => x[i], comparer);

    /// <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, IEqualityComparer{char})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik(this string? left, string? right, IEqualityComparer<char>? comparer) =>
        left.JaroEmik(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
    /// <remarks><para>Like <see cref="Jaro(string, string)"/>, but with a bias to common prefixes.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler(this string? left, string? right) =>
        string.Equals(left, right, DefaultCharComparer) ? 1 : left.JaroWinkler(right, EqualityComparer<char>.Default);

    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, Func{char, char, bool})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler(
        this string? left,
        string? right,
        [InstantHandle] Func<char, char, bool>? comparer
    ) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        JaroWinkler(left, right, static x => x.Length, static (x, i) => x[i], comparer);

    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, IEqualityComparer{char})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler(
        this string? left,
        string? right,
        IEqualityComparer<char>? comparer
    ) =>
        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this IList<T>? left, IList<T>? right) => left.Jaro(right, EqualityComparer<T>.Default);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this IList<T>? left, IList<T>? right, [InstantHandle] Func<T, T, bool>? comparer) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        Jaro(left, right, static x => x.Count, static (x, i) => x[i], comparer);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
        left.Jaro(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(this IList<T>? left, IList<T>? right) =>
        left.Jaro(right, EqualityComparer<T>.Default);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, Func{T, T, bool})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this IList<T>? left,
        IList<T>? right,
        [InstantHandle] Func<T, T, bool>? comparer
    ) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        Jaro(left, right, static x => x.Count, static (x, i) => x[i], comparer);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, IEqualityComparer{T})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
        left.Jaro(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right) =>
        left.JaroWinkler(right, EqualityComparer<T>.Default);

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, Func{T, T, bool})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this IList<T>? left,
        IList<T>? right,
        [InstantHandle] Func<T, T, bool>? comparer
    ) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        JaroWinkler(left, right, static x => x.Count, static (x, i) => x[i], comparer);

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, IEqualityComparer{T})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.Jaro(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this scoped Span<T> left, scoped ReadOnlySpan<T> right, IEqualityComparer<T>? comparer)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            ((ReadOnlySpan<T>)left).Jaro(right, comparer);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static unsafe double Jaro<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        // ReSharper disable once WrongIndentSize
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var l = left.Pointer;
        var r = right.Pointer;
#else
        fixed (T* l = left)
        fixed (T* r = right)
#endif
            return Jaro(
                new Fat<T>(l, left.Length),
                new(r, right.Length),
                static x => x.Length,
                static (x, i) => x[i],
                comparer
            );
    }

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            ((ReadOnlySpan<T>)left).Jaro(right, comparer);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.JaroEmik(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            ((ReadOnlySpan<T>)left).JaroEmik(right, comparer);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static unsafe double JaroEmik<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        // ReSharper disable once WrongIndentSize
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var l = left.Pointer;
        var r = right.Pointer;
#else
        fixed (T* l = left)
        fixed (T* r = right)
#endif
            return JaroEmik(
                new Fat<T>(l, left.Length),
                new(r, right.Length),
                static x => x.Length,
                static (x, i) => x[i],
                comparer
            );
    }

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            ((ReadOnlySpan<T>)left).JaroEmik(right, comparer);

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.JaroWinkler(right, comparer is null ? null : comparer.Equals);

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            ((ReadOnlySpan<T>)left).JaroWinkler(right, comparer);

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static unsafe double JaroWinkler<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        // ReSharper disable once WrongIndentSize
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var l = left.Pointer;
        var r = right.Pointer;
#else
        fixed (T* l = left)
        fixed (T* r = right)
#endif
            return JaroWinkler(
                new Fat<T>(l, left.Length),
                new(r, right.Length),
                static x => x.Length,
                static (x, i) => x[i],
                comparer
            );
    }

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            ((ReadOnlySpan<T>)left).JaroWinkler(right, comparer);

    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="counter">The function that gets the count.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double Jaro<T, TItem>(
        T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        Jaro(left, right, counter(left), counter(right), indexer, comparer);

    /// <summary>Calculates the Jaro similarity between two instances.</summary>
    /// <typeparam name="T">The type of instance.</typeparam>
    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="leftLength">The left-hand side's length.</param>
    /// <param name="rightLength">The right-hand side's length.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double Jaro<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        JaroInner(left, right, leftLength, rightLength, indexer, comparer ?? EqualityComparer<TItem>.Default.Equals);

    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, Func{T, int}, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="counter">The function that gets the count.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroEmik<T, TItem>(
        T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        JaroEmik(left, right, counter(left), counter(right), indexer, comparer);

    /// <summary>Calculates the Jaro-Emik similarity between two instances.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, int, int, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of instance.</typeparam>
    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="leftLength">The left-hand side's length.</param>
    /// <param name="rightLength">The right-hand side's length.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroEmik<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    )
    {
        comparer ??= EqualityComparer<TItem>.Default.Equals;

        var jaro = JaroInner(left, right, leftLength, rightLength, indexer, comparer);

        if (leftLength is 0 || rightLength is 0)
            return jaro;

        var slice = Slice(left, right, leftLength, rightLength, indexer, comparer) * Grade(leftLength, rightLength);

        return Math.Max(jaro, slice);
    }

    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, Func{T, int}, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="counter">The function that gets the count.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroWinkler<T, TItem>(
        T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        JaroWinkler(left, right, counter(left), counter(right), indexer, comparer);

    /// <summary>Calculates the Jaro-Winkler similarity between two instances.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, int, int, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of instance.</typeparam>
    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="leftLength">The left-hand side's length.</param>
    /// <param name="rightLength">The right-hand side's length.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroWinkler<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    )
    {
        comparer ??= EqualityComparer<TItem>.Default.Equals;

        var jaroDistance = JaroInner(left, right, leftLength, rightLength, indexer, comparer);
        var prefixLength = NumberOfEquals(left, right, leftLength, rightLength, indexer, comparer);
        var distance = JaroWinklerDistance(jaroDistance, prefixLength);

        return Math.Min(distance, 1);
    }

    [MustUseReturnValue, ValueRange(0, 1)]
    static double JaroAllocated<T, TItem>(
        scoped Span<byte> visited,
        (T, T, int, int, Func<T, int, TItem>, Func<TItem, TItem, bool>) args
    )
    {
        var (left, right, leftLength, rightLength, indexer, comparer) = args;
        int rightPreviousIndex = 0, transpositionCount = 0;
        double matchCount = 0;
        visited.Clear();

        for (var i = 0; i < leftLength; i++)
            if (InBounds(leftLength, rightLength, i))
                rightPreviousIndex = Next(
                    visited,
                    left,
                    right,
                    leftLength,
                    rightLength,
                    i,
                    rightPreviousIndex,
                    comparer,
                    indexer,
                    ref matchCount,
                    ref transpositionCount
                );

        return matchCount is 0 ? 0 : JaroDistance(leftLength, rightLength, matchCount, transpositionCount);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, ValueRange(0, 1)]
    static double JaroInner<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    ) =>
        leftLength is 0 && rightLength is 0 ? 1 :
            leftLength is 0 || rightLength is 0 ? 0 :
                leftLength is 1 && rightLength is 1 ?
                    EqualsAt(left, right, 0, 0, comparer, indexer) ? 1 : 0 :
                    Allocate(rightLength, (left, right, leftLength, rightLength, indexer, comparer), Fun<T, TItem>());

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static SpanFunc<byte, (T, T, int, int, Func<T, int, TItem>, Func<TItem, TItem, bool>), double> Fun<T, TItem>() =>
        static (span, tuple) => JaroAllocated(span, tuple);

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
    static int Next<T, TItem>(
        scoped Span<byte> visited,
        T left,
        T right,
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightPreviousIndex,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [NonNegativeValue] ref double matchCount,
        [NonNegativeValue] ref int transpositionCount
    )
    {
        for (var rightIndex = 0; rightIndex < rightLength; rightIndex++)
        {
            if (!ShouldProceed(visited, left, right, leftLength, rightLength, leftIndex, rightIndex, comparer, indexer))
                continue;

            visited[rightIndex]++;
            matchCount++;

            if (rightIndex < rightPreviousIndex)
                transpositionCount++;

            return rightIndex;
        }

        return rightPreviousIndex;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    static bool ShouldProceed<T, TItem>(
        Span<byte> visited,
        T leftLength,
        T rightLength,
        [ValueRange(2, int.MaxValue)] int aLen,
        [ValueRange(2, int.MaxValue)] int bLen,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightIndex,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer
    ) =>
        InBounds(aLen, bLen, leftIndex, rightIndex) &&
        visited[rightIndex] is 0 &&
        EqualsAt(leftLength, rightLength, leftIndex, rightIndex, comparer, indexer);

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    static bool EqualsAt<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightIndex,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer
    ) =>
        comparer(indexer(left, leftIndex), indexer(right, rightIndex));

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, ValueRange(0, 1)]
    static double Slice<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    )
    {
        var score = 0;
        var isLeftSmaller = leftLength < rightLength;

        var small = isLeftSmaller ? left : right;
        var smallLength = isLeftSmaller ? leftLength : rightLength;

        var big = isLeftSmaller ? right : left;
        var bigLength = isLeftSmaller ? rightLength : leftLength;

        for (var i = 0; i < bigLength; i++)
        {
            var highestPossibleScore = Math.Min(bigLength - i - 1, smallLength);

            if (score >= highestPossibleScore)
                break;

            score = SliceInner(big, small, bigLength, smallLength, indexer, comparer, i, score);
        }

        return (double)score / smallLength;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
    static int SliceInner<T, TItem>(
        T big,
        T small,
        [NonNegativeValue] int bigLength,
        [NonNegativeValue] int smallLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [NonNegativeValue] int i,
        [NonNegativeValue] int score
    )
    {
        var lower = -1;

        for (var j = 0; j < smallLength && i + j < bigLength; j++)
            if (EqualsAt(big, small, i + j, j, comparer, indexer))
                score = Math.Max(score, j - lower);
            else
                lower = j;

        return score;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
    static int NumberOfEquals<T, TItem>(
        T left,
        T right,
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    )
    {
        var sharedLength = Math.Min(leftLength, rightLength);

        for (var sharedIndex = 0; sharedIndex < sharedLength; sharedIndex++)
            if (!EqualsAt(left, right, sharedIndex, sharedIndex, comparer, indexer))
                return sharedIndex;

        return sharedLength;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static bool InBounds(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex
    ) =>
        MinBound(leftLength, rightLength, leftIndex) <= MaxBound(leftLength, rightLength, leftIndex);

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static bool InBounds(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightIndex
    ) =>
        MinBound(leftLength, rightLength, leftIndex) <= rightIndex &&
        rightIndex <= MaxBound(leftLength, rightLength, leftIndex);

    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    static int MaxBound(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex
    ) =>
        Math.Min(SearchRange(leftLength, rightLength) + leftIndex, rightLength - 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    static int MinBound(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex
    ) =>
        SearchRange(leftLength, rightLength) < leftIndex
            ? Math.Max(0, leftIndex - SearchRange(leftLength, rightLength))
            : 0;

    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    static int SearchRange(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength
    ) =>
        Math.Max(leftLength, rightLength) / 2 - 1;

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(0, 1)]
    static double JaroDistance(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] double matchCount,
        [NonNegativeValue] int transpositionCount
    ) =>
        1 / 3.0 * (matchCount / leftLength + matchCount / rightLength + (matchCount - transpositionCount) / matchCount);

    [MustUseReturnValue, ValueRange(0, 1)]
    static double Grade([NonNegativeValue] int leftLength, [NonNegativeValue] int rightLength) =>
        1 - 1.0 / Math.Min(leftLength + 1, rightLength + 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(0, 1)]
    static double JaroWinklerDistance([ValueRange(0, 1)] double jaroDistance, [NonNegativeValue] int prefixLength) =>
        jaroDistance + 0.1 * prefixLength * (1.0 - jaroDistance);

    /// <summary>Represents a pointer with a length.</summary>
    [StructLayout(LayoutKind.Auto)]
#if !NO_READONLY_STRUCTS
    readonly
#endif
        unsafe partial struct Fat<T>(void* pointer, [NonNegativeValue] int length)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        /// <summary>Takes the element corresponding to the passed in index. A bounds check is performed.</summary>
        /// <param name="i">The index to take.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The parameter <paramref name="i"/> is outside the range.
        /// </exception>
        public T this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get => (uint)i < (uint)Length ? ((T*)pointer)[i] : throw new ArgumentOutOfRangeException(nameof(i), i, E);
        }

        /// <summary>Gets the length.</summary>
        public int Length => length;
    }
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Extension methods to count digits in numbers.</summary>

    /// <summary>Gets the amount of digits of the number.</summary>
    /// <param name="number">The number to count.</param>
    /// <returns>The amount of digits in the parameter <paramref name="number"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 3)]
    public static byte DigitCount(this byte number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            _ => 3,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 3)]
    public static byte DigitCount(this sbyte number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            _ => 3,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 5)]
    public static byte DigitCount(this ushort number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            < 1000 => 3,
            < 10000 => 4,
            _ => 5,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 5)]
    public static byte DigitCount(this short number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            < 1000 and > -1000 => 3,
            < 10000 and > -10000 => 4,
            _ => 5,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 10)]
    public static byte DigitCount(this uint number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            < 1000 => 3,
            < 10000 => 4,
            < 100000 => 5,
            < 1000000 => 6,
            < 10000000 => 7,
            < 100000000 => 8,
            < 1000000000 => 9,
            _ => 10,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 10)]
    public static byte DigitCount(this int number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            < 1000 and > -1000 => 3,
            < 10000 and > -10000 => 4,
            < 100000 and > -100000 => 5,
            < 1000000 and > -1000000 => 6,
            < 10000000 and > -10000000 => 7,
            < 100000000 and > -100000000 => 8,
            < 1000000000 and > -1000000000 => 9,
            _ => 10,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 20)]
    public static byte DigitCount(this ulong number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            < 1000 => 3,
            < 10000 => 4,
            < 100000 => 5,
            < 1000000 => 6,
            < 10000000 => 7,
            < 100000000 => 8,
            < 1000000000 => 9,
            < 10000000000 => 10,
            < 100000000000 => 11,
            < 1000000000000 => 12,
            < 10000000000000 => 13,
            < 100000000000000 => 14,
            < 1000000000000000 => 15,
            < 10000000000000000 => 16,
            < 100000000000000000 => 17,
            < 1000000000000000000 => 18,
            < 10000000000000000000 => 19,
            _ => 20,
        };

    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 19)]
    public static byte DigitCount(this long number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            < 1000 and > -1000 => 3,
            < 10000 and > -10000 => 4,
            < 100000 and > -100000 => 5,
            < 1000000 and > -1000000 => 6,
            < 10000000 and > -10000000 => 7,
            < 100000000 and > -100000000 => 8,
            < 1000000000 and > -1000000000 => 9,
            < 10000000000 and > -10000000000 => 10,
            < 100000000000 and > -100000000000 => 11,
            < 1000000000000 and > -1000000000000 => 12,
            < 10000000000000 and > -10000000000000 => 13,
            < 100000000000000 and > -100000000000000 => 14,
            < 1000000000000000 and > -1000000000000000 => 15,
            < 10000000000000000 and > -10000000000000000 => 16,
            < 100000000000000000 and > -100000000000000000 => 17,
            < 1000000000000000000 and > -1000000000000000000 => 18,
            _ => 19,
        };

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Extension methods to clamp numbers.</summary>

    /// <summary>Round the given integral value up to a power of 2.</summary>
    /// <param name="value">The value.</param>
    /// <returns>
    /// The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
    /// If <paramref name="value"/> is 0 or the result overflows, returns 0.
    /// </returns>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static uint RoundUpToPowerOf2(this uint value)
#if NET6_0_OR_GREATER
        =>
            BitOperations.RoundUpToPowerOf2(value);
#else
    {
        // Based on https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
        --value;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        return value + 1;
    }
#endif

    /// <summary>Round the given integral value up to a power of 2.</summary>
    /// <param name="value">The value.</param>
    /// <returns>
    /// The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
    /// If <paramref name="value"/> is 0 or the result overflows, returns 0.
    /// </returns>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ulong RoundUpToPowerOf2(this ulong value)
#if NET6_0_OR_GREATER
        =>
            BitOperations.RoundUpToPowerOf2(value);
#else
    {
        // Based on https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
        --value;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value |= value >> 32;
        return value + 1;
    }
#endif

    /// <summary>Round the given integral value up to a power of 2.</summary>
    /// <param name="value">The value.</param>
    /// <returns>
    /// The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
    /// If <paramref name="value"/> is 0 or the result overflows, returns 0.
    /// </returns>
    // ReSharper disable RedundantUnsafeContext
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe nuint RoundUpToPowerOf2(this nuint value) =>
#if NET6_0_OR_GREATER // ReSharper restore RedundantUnsafeContext
        BitOperations.RoundUpToPowerOf2(value);
#else
        sizeof(nuint) is 4 ? RoundUpToPowerOf2((uint)value) : (nuint)RoundUpToPowerOf2((ulong)value);
#endif
#if !NET7_0_OR_GREATER
    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
    /// <param name="number">The number to clip.</param>
    /// <param name="min">If specified, the smallest number to return.</param>
    /// <param name="max">If specified, the greatest number to return.</param>
    /// <returns>
    /// The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
    /// otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
    /// <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
    /// </returns>
    [Pure]
    public static int Clamp(this int number, int? min = null, int? max = null) =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;

    /// <inheritdoc cref="Clamp(int, int?, int?)"/>
    [Pure]
    public static float Clamp(this float number, float? min = null, float? max = null) =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;
#else
    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
    /// <typeparam name="T">The type of numeric value for comparisons.</typeparam>
    /// <param name="number">The number to clip.</param>
    /// <param name="min">If specified, the smallest number to return.</param>
    /// <param name="max">If specified, the greatest number to return.</param>
    /// <returns>
    /// The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
    /// otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
    /// <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
    /// </returns>
    [Pure]
    public static T Clamp<T>(this T number, T? min = null, T? max = null)
        where T : class, IComparisonOperators<T, T, bool> =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;

    /// <inheritdoc cref="Clamp{T}(T, T?, T?)"/>
    [Pure]
    public static T Clamp<T>(this T number, T? min = null, T? max = null)
        where T : struct, IComparisonOperators<T, T, bool> =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;
#endif

// SPDX-License-Identifier: MPL-2.0
#if !NETFRAMEWORK || NET35_OR_GREATER
// ReSharper disable CheckNamespace RedundantNameQualifier

#if !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP3_0_OR_GREATER

#endif

/// <summary>Provides methods to do math on enums without overhead from boxing.</summary>
[UsedImplicitly]

    // ReSharper disable once UnusedType.Local
    enum Unknowable;

    static readonly Dictionary<Type, IList> s_dictionary = [];

    /// <summary>Checks if the left-hand side implements the right-hand side.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="left"/> has the values
    /// of the parameter <paramref name="right"/>; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool Has<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() & right.AsInt()) == left.AsInt();
#else
        left.Op(right, static (x, y) => (x & y) == x);
#endif

    /// <summary>Performs a conversion operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The <see cref="int"/> cast of <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int AsInt<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (typeof(T) == typeof(Enum) ? value.GetType() : typeof(T)).GetEnumUnderlyingType() switch
        {
            var x when x == typeof(byte) => (byte)(object)value,
            var x when x == typeof(sbyte) => (sbyte)(object)value,
            var x when x == typeof(short) => (short)(object)value,
            var x when x == typeof(ushort) => (ushort)(object)value,
            var x when x == typeof(int) => (int)(object)value,
            var x when x == typeof(uint) => (int)(uint)(object)value,
            var x when x == typeof(long) => (int)(long)(object)value,
            var x when x == typeof(ulong) => (int)(ulong)(object)value,
            var x when x == typeof(nint) => (int)(nint)(object)value,
            var x when x == typeof(nuint) => (int)(nuint)(object)value,
            _ => throw Unreachable,
        };
#else
        typeof(T) == typeof(Enum)
            ? value.GetType().GetEnumUnderlyingType() switch
            {
                var x when x == typeof(byte) => (byte)(object)value,
                var x when x == typeof(sbyte) => (sbyte)(object)value,
                var x when x == typeof(short) => (short)(object)value,
                var x when x == typeof(ushort) => (ushort)(object)value,
                var x when x == typeof(int) => (int)(object)value,
                var x when x == typeof(uint) => (int)(uint)(object)value,
                var x when x == typeof(long) => (int)(long)(object)value,
                var x when x == typeof(ulong) => (int)(ulong)(object)value,
                var x when x == typeof(nint) => (int)(nint)(object)value,
                var x when x == typeof(nuint) => (int)(nuint)(object)value,
                _ => throw new NotSupportedException(),
            }
            : MathCaching<T>.From(value);
#endif

    /// <summary>Gets the values of an enum cached and strongly-typed.</summary>
    /// <typeparam name="T">The type of enum to get the values from.</typeparam>
    /// <returns>All values in the type parameter <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static IList<T> GetValues<T>()
        where T : Enum =>
        s_dictionary.TryGetValue(typeof(T), out var list)
            ? (IList<T>)list
            : (IList<T>)(s_dictionary[typeof(T)] = typeof(T) == typeof(Enum)
                ? []
                : (T[])Enum.GetValues(typeof(T)));

    /// <summary>Performs a conversion operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The <typeparamref name="T"/> cast of <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T As<T>(this int value)
        where T : Enum =>
        typeof(T) == typeof(Enum)
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
            ? (T)(Enum)(Unknowable)value
            : typeof(T).GetEnumUnderlyingType() switch
            {
                var x when x == typeof(byte) => (T)(object)(byte)value,
                var x when x == typeof(sbyte) => (T)(object)(sbyte)value,
                var x when x == typeof(short) => (T)(object)(short)value,
                var x when x == typeof(ushort) => (T)(object)(ushort)value,
                var x when x == typeof(int) => (T)(object)value,
                var x when x == typeof(uint) => (T)(object)(uint)value,
                var x when x == typeof(long) => (T)(object)(long)value,
                var x when x == typeof(ulong) => (T)(object)(ulong)value,
                var x when x == typeof(nint) => (T)(object)(nint)value,
                var x when x == typeof(nuint) => (T)(object)(nuint)value,
                _ => throw Unreachable,
            };
#else
            ? (T)(Enum)MathCaching<Unknowable>.To(value)
            : MathCaching<T>.To(value);
#endif

    /// <summary>Performs a negation operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Negate<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (-value.AsInt()).As<T>();
#else
        value.Op(static x => unchecked(-x));
#endif

    /// <summary>Performs an decrement operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately before it.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Predecessor<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (value.AsInt() - 1).As<T>();
#else
        value.Op(static x => unchecked(x - 1));
#endif

    /// <summary>Performs a increment operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately after it.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Successor<T>(this T value)
        where T : Enum =>
#if NETCOREAPP
        (value.AsInt() + 1).As<T>();
#else
        value.Op(static x => unchecked(x + 1));
#endif

    /// <summary>Performs an addition operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The sum of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Add<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() + right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => unchecked(x + y));
#endif

    /// <summary>Performs a subtraction operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The difference of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Subtract<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() - right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => unchecked(x - y));
#endif

    /// <summary>Performs a multiplication operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The product of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Multiply<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() * right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => unchecked(x * y));
#endif

    /// <summary>Performs a division operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The quotient of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Divide<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() / right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => x / y);
#endif

    /// <summary>Performs a modulo operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The remainder of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Modulo<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() % right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => x % y);
#endif

    /// <summary>Computes the product of a sequence of <typeparamref name="T"/> values.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="source">A sequence of <typeparamref name="T"/> values to calculate the product of.</param>
    /// <returns>The product of the values in the sequence.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Product<T>(this IEnumerable<T> source)
        where T : Enum =>
        source.Aggregate(Multiply);

    /// <summary>Computes the sum of a sequence of <typeparamref name="T"/> values.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="source">A sequence of <typeparamref name="T"/> values to calculate the sum of.</param>
    /// <returns>The sum of the values in the sequence.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Sum<T>(this IEnumerable<T> source)
        where T :
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        unmanaged,
#endif
        Enum
#if NET5_0_OR_GREATER
        =>
            source.TryGetSpan(out var span) ? span.Sum() : source.Aggregate(Add);
#else
        =>
            source.Aggregate(Add);
#endif
#if !NETCOREAPP
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T Op<T>(this T value, [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int> op)
        where T : Enum =>
        op(value.AsInt()).As<T>();

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T Op<T>(this T left, T right, [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int, int> op)
        where T : Enum =>
        op(left.AsInt(), right.AsInt()).As<T>();

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static TResult Op<T, TResult>(
        this T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int, TResult> op
    )
        where T : Enum =>
        op(left.AsInt(), right.AsInt());

    static class MathCaching<T>
        where T : Enum
    {
        public static Converter<T, int> From { [Pure] get; } = Make<Converter<T, int>>(false);

        public static Converter<int, T> To { [Pure] get; } = Make<Converter<int, T>>(true);

        [MustUseReturnValue]
        static TFunc Make<TFunc>(bool isReverse)
            where TFunc : Delegate
        {
            var parameter = Parameter(isReverse ? typeof(int) : typeof(T), nameof(T));
            var underlying = GetUnderlyingType(typeof(T));
            Expression cast = isReverse ? parameter : Convert(parameter, underlying);

            cast = underlying != typeof(int) ? Convert(parameter, isReverse ? underlying : typeof(int)) : cast;
            cast = isReverse ? Convert(cast, typeof(T)) : cast;

            return Lambda<TFunc>(cast, parameter).Compile();
        }
    }
#endif
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable CheckNamespace RedundantNameQualifier




/// <summary>Implements a <see cref="GetOffsetAndLength"/> overload that doesn't rely on tuples.</summary>

    /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
    /// <remarks><para>
    /// For performance reasons, we don't validate the input length parameter against negative values.
    /// It is expected Range will be used with collections which always have non negative length/count.
    /// We validate the range is inside the length scope though.
    /// </para></remarks>
    /// <param name="range">The <see cref="Range"/> that contains the range of elements.</param>
    /// <param name="length">
    /// The length of the collection that the range will be used with.
    /// <paramref name="length"/> has to be a positive value.
    /// </param>
    /// <param name="outOffset">The resulting offset.</param>
    /// <param name="outLength">The resulting length.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void GetOffsetAndLength(this Range range, int length, out int outOffset, out int outLength)
    {
        if (!TryGetOffsetAndLength(range, length, out outOffset, out outLength))
            throw new ArgumentOutOfRangeException(nameof(length));
    }

    /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
    /// <param name="range">The <see cref="Range"/> that contains the range of elements.</param>
    /// <param name="length">
    /// The length of the collection that the range will be used with.
    /// <paramref name="length"/> has to be a positive value.
    /// </param>
    /// <param name="outOffset">The resulting offset.</param>
    /// <param name="outLength">The resulting length.</param>
    /// <returns>Whether the values are set.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool TryGetOffsetAndLength(this Range range, int length, out int outOffset, out int outLength)
    {
        var startIndex = range.Start;
        var start = startIndex.IsFromEnd ? length - startIndex.Value : startIndex.Value;

        var endIndex = range.End;
        var end = endIndex.IsFromEnd ? length - endIndex.Value : endIndex.Value;

        outOffset = start;
        outLength = end - start;

        return unchecked((uint)end <= (uint)length && (uint)start <= (uint)end);
    }

// SPDX-License-Identifier: MPL-2.0
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace NullableWarningSuppressionIsUsed RedundantSuppressNullableWarningExpression
#pragma warning disable GlobalUsingsAnalyzer



#pragma warning restore GlobalUsingsAnalyzer
/// <summary>Methods that provide access to generic operators, for frameworks that do not support it.</summary>

    /// <summary>Increments the value.</summary>
    /// <typeparam name="T">The type of value to increment.</typeparam>
    /// <param name="t">The value to increment.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)] // ReSharper disable once CognitiveComplexity
    public static void Increment<T>(ref T t)
    {
        if (typeof(T) == typeof(byte))
            Unsafe.As<T, byte>(ref t)++;
        else if (typeof(T) == typeof(double))
            Unsafe.As<T, double>(ref t)++;
        else if (typeof(T) == typeof(float))
            Unsafe.As<T, float>(ref t)++;
        else if (typeof(T) == typeof(int))
            Unsafe.As<T, int>(ref t)++;
        else if (typeof(T) == typeof(nint))
            Unsafe.As<T, nint>(ref t)++;
        else if (typeof(T) == typeof(nuint))
            Unsafe.As<T, nuint>(ref t)++;
        else if (typeof(T) == typeof(sbyte))
            Unsafe.As<T, sbyte>(ref t)++;
        else if (typeof(T) == typeof(short))
            Unsafe.As<T, short>(ref t)++;
        else if (typeof(T) == typeof(uint))
            Unsafe.As<T, uint>(ref t)++;
        else if (typeof(T) == typeof(ulong))
            Unsafe.As<T, ulong>(ref t)++;
        else if (typeof(T) == typeof(ushort))
            Unsafe.As<T, ushort>(ref t)++;
        else if (DirectOperators<T>.IsSupported)
            t = DirectOperators<T>.Increment(t);
        else
            Fail<T>();
    }

    /// <summary>Determines whether the current type <typeparamref name="T"/> is supported.</summary>
    /// <typeparam name="T">The type to check.</typeparam>
    /// <returns>Whether the current type <typeparamref name="T"/> is supported.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsSupported<T>() => DirectOperators<T>.IsSupported;

    /// <summary>Performs an addition operation to return the sum.</summary>
    /// <typeparam name="T">The type of value to add.</typeparam>
    /// <param name="l">The left-hand side.</param>
    /// <param name="r">The right-hand side.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The sum of the parameters <paramref name="l"/> and <paramref name="r"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Adder<T>(T l, T r) =>
        0 switch
        {
            _ when typeof(T) == typeof(byte) => (T)(object)(byte)((byte)(object)l! + (byte)(object)r!),
            _ when typeof(T) == typeof(double) => (T)(object)((double)(object)l! + (double)(object)r!),
            _ when typeof(T) == typeof(float) => (T)(object)((float)(object)l! + (float)(object)r!),
            _ when typeof(T) == typeof(int) => (T)(object)((int)(object)l! + (int)(object)r!),
            _ when typeof(T) == typeof(nint) => (T)(object)((nint)(object)l! + (nint)(object)r!),
            _ when typeof(T) == typeof(nuint) => (T)(object)((nuint)(object)l! + (nuint)(object)r!),
            _ when typeof(T) == typeof(sbyte) => (T)(object)(sbyte)((sbyte)(object)l! + (sbyte)(object)r!),
            _ when typeof(T) == typeof(short) => (T)(object)(short)((short)(object)l! + (short)(object)r!),
            _ when typeof(T) == typeof(uint) => (T)(object)((uint)(object)l! + (uint)(object)r!),
            _ when typeof(T) == typeof(ulong) => (T)(object)((ulong)(object)l! + (ulong)(object)r!),
            _ when typeof(T) == typeof(ushort) => (T)(object)(ushort)((ushort)(object)l! + (ushort)(object)r!),
            _ when DirectOperators<T>.IsSupported => DirectOperators<T>.Adder(l, r),
            _ => Fail<T>(),
        };

    /// <summary>Performs a dividing operation to return the quotient.</summary>
    /// <typeparam name="T">The type of value to divide.</typeparam>
    /// <param name="l">The left-hand side.</param>
    /// <param name="r">The right-hand side.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The quotient of the parameters <paramref name="l"/> and <paramref name="r"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Divider<T>(T l, int r) =>
        0 switch
        {
            _ when typeof(T) == typeof(byte) => (T)(object)(byte)((byte)(object)l! / r),
            _ when typeof(T) == typeof(double) => (T)(object)((double)(object)l! / r),
            _ when typeof(T) == typeof(float) => (T)(object)((float)(object)l! / r),
            _ when typeof(T) == typeof(int) => (T)(object)((int)(object)l! / r),
            _ when typeof(T) == typeof(nint) => (T)(object)((nint)(object)l! / r),
            _ when typeof(T) == typeof(nuint) => (T)(object)((nuint)(object)l! / (nuint)r),
            _ when typeof(T) == typeof(sbyte) => (T)(object)(sbyte)((sbyte)(object)l! / r),
            _ when typeof(T) == typeof(short) => (T)(object)(short)((short)(object)l! / r),
            _ when typeof(T) == typeof(uint) => (T)(object)((uint)(object)l! / r),
            _ when typeof(T) == typeof(ulong) => (T)(object)((ulong)(object)l! / (ulong)r),
            _ when typeof(T) == typeof(ushort) => (T)(object)(ushort)((ushort)(object)l! / r),
            _ when DirectOperators<T>.IsSupported => DirectOperators<T>.Divider(l, r),
            _ => Fail<T>(),
        };

    /// <summary>Gets the minimum value.</summary>
    /// <typeparam name="T">The type of value to get the minimum value of.</typeparam>
    /// <returns>The minimum value of <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T MinValue<T>() => DirectOperators<T>.MinValue;

    /// <summary>Throws the exception used by <see cref="OperatorCaching"/> to propagate errors.</summary>
    /// <typeparam name="T">The type that failed.</typeparam>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>This method does not return.</returns>
    [DoesNotReturn, MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Fail<T>() =>
        throw new MissingMethodException(typeof(T).UnfoldedFullName(), "op_Addition/op_Division/op_Increment");

    /// <summary>Caches operators.</summary>
    /// <typeparam name="T">The containing member of operators.</typeparam>
    // ReSharper disable once ClassNeverInstantiated.Global
#pragma warning disable S1118
    public sealed partial class DirectOperators<T>
#pragma warning restore S1118
    {
        const BindingFlags Flags = BindingFlags.Public | BindingFlags.Static;

        static readonly Type[]
            s_binary = [typeof(T), typeof(T)],
            s_unary = [typeof(T)];

        static DirectOperators()
        {
            try
            {
                Increment = Make("op_Increment", Expression.Increment);
                Adder = Make<T>("op_Addition", Expression.AddChecked);
                Divider = Make<int>("op_Division", (x, y) => Expression.Divide(x, Expression.Convert(y, typeof(T))));
            }
            catch (InvalidOperationException)
            {
                IsSupported = false;
            }
        }
#pragma warning disable RCS1158
        /// <summary>
        /// Gets a value indicating whether the functions can be used.
        /// <see cref="MinValue"/> can be used regardless of its output.
        /// </summary>
        [CLSCompliant(false)]
        public static bool IsSupported
        {
            [MemberNotNullWhen(true, nameof(Adder), nameof(Divider), nameof(Increment)),
             MethodImpl(MethodImplOptions.AggressiveInlining),
             Pure]
            get;
        } = true;
#pragma warning restore RCS1158
        /// <summary>Gets the minimum value.</summary>
        // ReSharper disable once NullableWarningSuppressionIsUsed
        public static T MinValue { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            (typeof(T).IsEnum ? typeof(T).GetEnumUnderlyingType() : typeof(T)) switch
            {
                var x when x == typeof(byte) => (T)(object)byte.MinValue,
                var x when x == typeof(double) => (T)(object)double.MinValue,
                var x when x == typeof(float) => (T)(object)float.MinValue,
                var x when x == typeof(int) => (T)(object)int.MinValue,
#if NET5_0_OR_GREATER
                var x when x == typeof(nint) => (T)(object)nint.MinValue,
                var x when x == typeof(nuint) => (T)(object)nuint.MinValue,
#endif
                var x when x == typeof(sbyte) => (T)(object)sbyte.MinValue,
                var x when x == typeof(short) => (T)(object)short.MinValue,
                var x when x == typeof(uint) => (T)(object)uint.MinValue,
                var x when x == typeof(ulong) => (T)(object)ulong.MinValue,
                var x when x == typeof(ushort) => (T)(object)ushort.MinValue,
                _ => typeof(T).GetField(nameof(MinValue), Flags)?.GetValue(null) is T t ? t : default!,
            };

        /// <summary>Gets the function for dividing.</summary>
        public static Converter<T?, T>? Increment { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }

        /// <summary>Gets the function for adding.</summary>
        public static Func<T?, T?, T>? Adder { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }

        /// <summary>Gets the function for dividing.</summary>
        public static Func<T?, int, T>? Divider { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }

        [Pure]
        static Converter<T?, T> Make(string name, [InstantHandle] Func<Expression, UnaryExpression> go) =>
            typeof(T).GetMethod(name, Flags, null, s_unary, null) is not { } method &&
            Expression.Parameter(typeof(T), "unit") is var unit
                ? Expression.Lambda<Converter<T?, T>>(go(unit), unit).Compile()
                : (Converter<T?, T>)Delegate.CreateDelegate(typeof(Converter<T?, T>), method);

        [Pure]
        static Func<T?, TRight?, T> Make<TRight>(
            string name,
            [InstantHandle] Func<Expression, Expression, BinaryExpression> go
        ) =>
            (typeof(T).GetMethod(name, Flags, null, s_binary, null) is not { } method ||
                (Func<T?, T?, T>)Delegate.CreateDelegate(typeof(Func<T?, T?, T>), method) is not { } func) &&
            Expression.Parameter(typeof(T), "left") is var left &&
            Expression.Parameter(typeof(TRight), "right") is var right
                ? Expression.Lambda<Func<T?, TRight?, T>>(go(left, right), left, right).Compile()
                : (x, y) => func(x, (T?)(object?)y);
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable AsyncifyInvocation, CA1810, CA2008, MA0051, S3949, S4462, VSTHRD002, VSTHRD105
// ReSharper disable CognitiveComplexity CommentTypo IdentifierTypo SuggestBaseTypeForParameter
// ReSharper disable once CheckNamespace EmptyNamespace

#if !NETFRAMEWORK || NET40_OR_GREATER
/// <summary>Efficient prime operations by GordonBGood: https://stackoverflow.com/a/9700790/18052726.</summary>
public sealed class Primes : IEnumerable<ulong>
{
    /// <summary>
    /// Very efficient auto-resizing thread-safe read-only indexer class to hold the base primes array.
    /// </summary>
    sealed class BasePrimeArray
    {
        readonly object _lock = new();

        byte[] _saved = [];

        uint _lwi, _lpd;

        [Pure]
        public uint this[uint i]
        {
            get
            {
                if (i < _saved.Length)
                    return _saved[i];

                lock (_lock)
                {
                    var length = _saved.Length;

                    while (i >= length)
                    {
                        var buffer = (ushort[])s_masterCopy.Clone();

                        if (length is 0)
                            for (uint bi = 0, wi = 0, w = 0, mask = 0x8000, v = 0;
                                w < buffer.Length;
                                bi += s_patterns[wi++], wi = wi >= s_length ? 0 : wi)
                            {
                                if (mask >= 0x8000)
                                {
                                    mask = 1;
                                    v = buffer[w++];
                                }
                                else
                                    mask <<= 1;

                                if ((v & mask) is not 0)
                                    continue;

                                var p = Fstbp + bi + bi;
                                var k = p * p - Fstbp >> 1;
                                if (k >= s_pageRange) break;

                                var pd = p / s_circumference;
                                var kd = k / s_circumference;
                                var kn = s_lookup[k - kd * s_circumference];

                                for (uint wrd = kd * s_candidates + (uint)(kn >> 4), ndx = wi * s_length + kn;
                                    wrd < buffer.Length;)
                                {
                                    var st = s_wheelStates[ndx];
                                    buffer[wrd] |= st._mask;
                                    wrd += st._multiply * pd + st._extra;
                                    ndx = st._next;
                                }
                            }
                        else
                        {
                            _lwi += s_pageRange;
                            CullBuffer(_lwi, buffer);
                        }

                        var c = Count(s_pageRange, buffer);
                        var newArray = new byte[length + c];
                        _saved.CopyTo(newArray, 0);

                        for (uint p = Fstbp + (_lwi << 1), wi = 0, w = 0, mask = 0x8000, current = 0;
                            length < newArray.Length;
                            p += (uint)(s_patterns[wi++] << 1), wi = wi >= s_length ? 0 : wi)
                        {
                            if (mask >= 0x8000)
                            {
                                mask = 1;
                                current = buffer[w++];
                            }
                            else
                                mask <<= 1;

                            if ((current & mask) is not 0)
                                continue;

                            var pd = p / s_circumference;
                            newArray[length++] = (byte)((pd - _lpd << 6) + wi);
                            _lpd = pd;
                        }

                        _saved = newArray;
                    }
                }

                return _saved[i];
            }
        }
    }

    /// <summary>This class implements the enumeration (<see cref="IEnumerator{T}"/>).</summary>
    /// <remarks><para>
    /// It works by farming out tasks culling pages, which it then processes in order by enumerating
    /// the found primes as recognized by the remaining non-composite bits in the cull page buffers.
    /// </para></remarks>
    sealed class Enumerator : IEnumerator<ulong>
    {
        readonly Processor[] _processors = new Processor[s_procs];

        int _big = -s_primes.Length - 1;

        uint _wheelUpperBound = s_length - 1;

        ulong _index = (ulong)-s_patterns[s_length - 1];

        ushort _current, _mask;

        ushort[] _buffer;

        public Enumerator()
        {
            for (var s = 0u; s < s_procs; s++)
                _processors[s] = new()
                {
                    _buffer = new ushort[s_bufferSize],
                };

            for (var s = 1u; s < s_procs; s++)
                _processors[s]._task = CullBufferAsync((s - 1u) * s_bufferRange, _processors[s]._buffer);

            _buffer = _processors[0]._buffer;
        }

        [Pure]
        public ulong Current { get; private set; }

        [Pure]
        object IEnumerator.Current => Current;

        public bool MoveNext()
        {
            if (_big < 0)
            {
                if (_big is -1) // No yield, so automatically comes around again.
                    _big += _buffer.Length;
                else
                {
                    Current = s_primes[s_primes.Length + ++_big];
                    return true;
                }
            }

            do
            {
                _index += s_patterns[_wheelUpperBound++];

                if (_wheelUpperBound >= s_length)
                    _wheelUpperBound = 0;

                if ((_mask <<= 1) is not 0)
                    continue;

                if (++_big >= s_bufferSize)
                {
                    _big = 0;

                    for (var prc = 0; prc < s_procs - 1; prc++)
                        _processors[prc] = _processors[prc + 1];

                    _processors[s_procs - 1u]._buffer = _buffer;
                    _processors[s_procs - 1u]._task = CullBufferAsync(_index + (s_procs - 1u) * s_bufferRange, _buffer);
                    _processors[0]._task.Wait();
                    _buffer = _processors[0]._buffer;
                }

                _current = _buffer[_big];
                _mask = 1;
            } while ((_current & _mask) is not 0);

            Current = Fstbp + _index + _index;
            return true;
        }

        void IEnumerator.Reset() { }

        void IDisposable.Dispose() { }
    }

    /// <summary>Used for multi-threading buffer array processing.</summary>
    [StructLayout(LayoutKind.Auto)]
    struct Processor
    {
        internal ushort[] _buffer;

        internal Task _task;
    }

    [StructLayout(LayoutKind.Auto)]
    struct WheelState
    {
        internal byte _extra, _multiply;

        internal ushort _mask, _next;
    }

    /// <summary>
    /// The <see cref="L1CachePow"/> can not be less than 14 and is
    /// usually the two raised to the power of the L1 or L2 cache.
    /// </summary>
    const int L1CachePow = 14, L1CacheSz = 1 << L1CachePow;

    /// <summary>For buffer <see cref="ushort"/> <see cref="Array"/>.</summary>
    const int Mxpgsz = L1CacheSz / 2;

    /// <summary>This times <see cref="s_bigWheel"/> times two should not be bigger than the L2 cache in bytes.</summary>
    const uint ChunkSize = 17, Fstcp = 11, Fstbp = 19;

    /// <summary>Big wheel primes, following prime.</summary>
    static readonly byte[] s_primes = [2, 3, 5, 7, 11, 13, 17];

    /// <summary>A Counting Look Up Table for very fast counting of primes.</summary>
    static readonly byte[] s_counting;

    /// <summary>Look up wheel position from index and vice versa.</summary>
    static readonly byte[] s_lookup;

    /// <summary>Wheel Index Look Up Table.</summary>
    static readonly byte[] s_wheelIndices;

    /// <summary>
    /// The 2,3,57 factorial wheel increment pattern, (sum) 48 elements long, starting at prime 19 position.
    /// </summary>
    static readonly byte[] s_patterns =
    [
        2, 3, 1, 3, 2, 1, 2, 3, 3, 1, 3, 2, 1, 3, 2, 3, 4, 2, 1, 2, 1, 2, 4, 3,
        2, 3, 1, 2, 3, 1, 3, 3, 2, 1, 2, 3, 1, 3, 2, 1, 2, 1, 5, 1, 5, 1, 2, 1,
    ];

    /// <summary>The position of the wheel.</summary>
    static readonly byte[] s_positions;

    /// <summary>To look up wheel rounded up index position values, allow for overflow in size.</summary>
    static readonly byte[] s_roundUp;

    /// <summary>One can get single threaded performance by setting <see cref="s_procs"/> = 1.</summary>
    static readonly uint s_procs = (uint)Environment.ProcessorCount + 1;

    /// <summary>Small wheel circumference for odd numbers.</summary>
    static readonly uint s_circumference = s_patterns.Aggregate(0u, (acc, n) => acc + n);

    /// <summary>The length of <see cref="s_patterns"/>.</summary>
    static readonly uint s_length = (uint)s_patterns.Length;

    /// <summary>Number of wheel candidates.</summary>
    static readonly uint s_candidates = s_length >> 4;

    /// <summary>
    /// The big wheel circumference expressed in number of 16 bit words as in a minimum bit buffer size.
    /// </summary>
    static readonly uint s_bigWheel =
        s_primes.Aggregate(1u, (acc, p) => acc * p) / 2 / s_circumference * s_length / 16;

    /// <summary>Page size and range as developed.</summary>
    static readonly uint s_pageSize = Mxpgsz / s_bigWheel * s_bigWheel;

    /// <summary>Buffer size (multiple chunks) as produced.</summary>
    static readonly uint s_pageRange = s_pageSize * 16 / s_length * s_circumference;

    /// <summary>Number of uints even number of caches in chunk.</summary>
    static readonly uint s_bufferSize = ChunkSize * s_pageSize, s_bufferRange = ChunkSize * s_pageRange;

    /// <summary>A Master Copy page used to hold the lower base primes preculled version of the page.</summary>
    static readonly ushort[] s_masterCopy;

    /// <summary>The base primes array.</summary>
    static readonly BasePrimeArray s_basePrimes = new();

    /// <summary>Wheel State Look Up Table.</summary>
    static readonly WheelState[] s_wheelStates;

    /// <summary>Initializes static members of the <see cref="Primes"/> class.</summary>
    /// <remarks><para>The static constructor is used to initialize the static readonly arrays.</para></remarks>
    static Primes()
    {
        // To look up wheel position index from wheel index.
        s_positions = new byte[s_patterns.Length + 1];

        for (byte i = 0, acc = 0; i < s_patterns.Length; i++)
        {
            acc += s_patterns[i];
            s_positions[i + 1] = acc;
        }

        s_lookup = new byte[s_circumference + 1];

        for (byte i = 1; i < s_positions.Length; i++)
            for (var j = (byte)(s_positions[i - 1] + 1); j <= s_positions[i]; j++)
                s_lookup[j] = i;

        s_roundUp = new byte[s_circumference * 2];

        for (byte i = 1; i < s_roundUp.Length; i++)
            if (i > s_circumference)
                s_roundUp[i] = (byte)(s_circumference + s_positions[s_lookup[i - s_circumference]]);
            else
                s_roundUp[i] = s_positions[s_lookup[i]];

        s_counting = new byte[1 << 16];

        for (var i = 0; i < s_counting.Length; i++)
            s_counting[i] = (byte)((uint)(ushort)(i ^ -1)).RoundUpToPowerOf2();

        s_wheelIndices = new byte[s_length];

        for (var i = 0; i < s_wheelIndices.Length; i++)
        {
            var t = (uint)(s_positions[i] * 2) + Fstbp;

            if (t >= s_circumference)
                t -= s_circumference;

            if (t >= s_circumference)
                t -= s_circumference;

            s_wheelIndices[i] = (byte)t;
        }

        s_wheelStates = new WheelState[s_length * s_length];

        for (var x = 0u; x < s_length; x++)
        {
            var p = Fstbp + 2u * s_positions[x];
            var pr = p % s_circumference;

            for (uint y = 0, position = (p * p - Fstbp) / 2; y < s_length; y++)
            {
                var m = s_patterns[(x + y) % s_length];
                position %= s_circumference;
                var posn = s_lookup[position];
                position += m * pr;
                var nposd = position / s_circumference;
                var nposn = s_lookup[position - nposd * s_circumference];

                s_wheelStates[x * s_length + posn] = new()
                {
                    _mask = (ushort)(1 << (posn & 0xF)),
                    _multiply = (byte)(m * s_candidates),
                    _extra = (byte)(s_candidates * nposd + (nposn >> 4) - (posn >> 4)),
                    _next = (ushort)(s_length * x + nposn),
                };
            }
        }

        s_masterCopy = new ushort[s_pageSize];

        var start = 0;

        for (; start < s_primes.Length; start++)
            if (s_primes[start] >= Fstcp)
                break;

        for (; start < s_primes.Length; start++)
        {
            var p = (uint)s_primes[start];
            var k = p * p - Fstbp >> 1;
            var pd = p / s_circumference;
            var kd = k / s_circumference;
            var kn = s_lookup[k - kd * s_circumference];

            for (uint w = kd * s_candidates + (uint)(kn >> 4),
                ndx = s_lookup[(2 * s_circumference + p - Fstbp) / 2] * s_length + kn;
                w < s_masterCopy.Length;)
            {
                var st = s_wheelStates[ndx];
                s_masterCopy[w] |= st._mask;
                w += st._multiply * pd + st._extra;
                ndx = st._next;
            }
        }
    }

    /// <summary>Gets the shared instance.</summary>
    public static Primes Shared { get; } = [];

    /// <summary>Gets the count of primes up the number, inclusively.</summary>
    /// <param name="topNumber">The <see cref="ulong"/> top number to check for prime.</param>
    /// <returns>The long number of primes found.</returns>
    [Pure]
    public static long CountTo(ulong topNumber)
    {
        if (topNumber < Fstbp)
            return PrimesLength(topNumber);

        var cnt = (long)s_primes.Length;
        IterateTo(topNumber, (_, lim, b) => Interlocked.Add(ref cnt, Count(lim, b)));
        return cnt;
    }

    [Pure]
    static long PrimesLength(ulong topNumber)
    {
        for (var i = 0; i < s_primes.Length; i++)
            if (s_primes[i] > topNumber)
                return i;

        return s_primes.Length;
    }

    /// <summary>Gets the prime number based on the index.</summary>
    /// <param name="index">The <see cref="long"/> zero-based index for the prime.</param>
    /// <returns>The <see cref="ulong"/> prime found at the given <paramref name="index"/>.</returns>
    [Pure]
    public static ulong ElementAt(long index)
    {
        if (index < s_primes.Length)
            return s_primes[(int)index];

        long cnt = s_primes.Length;
        var ndx = 0UL;
        var cycl = 0u;
        var bit = 0u;

        bool Find(ulong lwi, ushort[] buffer)
        {
            var c = Count(s_bufferRange, buffer);

            if ((cnt += c) < index)
                return false;

            ndx = lwi;
            cnt -= c;

            do
            {
                var w = cycl++ * s_candidates;
                c = s_counting[buffer[w++]] + s_counting[buffer[w++]] + s_counting[buffer[w]];
                cnt += c;
            } while (cnt < index);

            cnt -= c;
            var y = --cycl * s_candidates;
            var v = ((ulong)buffer[y + 2] << 32) + ((ulong)buffer[y + 1] << 16) + buffer[y];

            do
                if ((v & 1UL << (int)bit++) is 0)
                    ++cnt;
            while (cnt <= index);

            --bit;
            return true;
        }

        IterateUntil(Find);

        return Fstbp + (ndx + cycl * s_circumference + s_positions[bit] << 1);
    }

    /// <summary>Gets the sum of the primes up to the number, inclusively.</summary>
    /// <param name="topNumber">The <see cref="uint"/> number to reach.</param>
    /// <returns>The <see cref="ulong"/> sum of all primes up to <paramref name="topNumber"/>.</returns>
    [Pure]
    public static ulong SumTo(uint topNumber)
    {
        static long SumBuffer(ulong lowi, uint bitlim, ushort[] buf)
        {
            var acc = 0L;

            for (uint i = 0, wi = 0, msk = 0x8000, w = 0, v = 0;
                i < bitlim;
                i += s_patterns[wi++], wi = wi >= s_length ? 0 : wi)
            {
                if (msk >= 0x8000)
                {
                    msk = 1;
                    v = buf[w++];
                }
                else
                    msk <<= 1;

                if ((v & msk) is 0)
                    acc += (long)(Fstbp + (lowi + i << 1));
            }

            return acc;
        }

        if (topNumber < Fstbp)
        {
            var s = 0u;

            for (var i = PrimesLength(topNumber); i < s_primes.Length; i++)
                s += s_primes[i];

            return s;
        }

        var su = 0u; // ReSharper disable once LoopCanBeConvertedToQuery

        foreach (var next in s_primes)
            su += next;

        var sum = (long)su;
        IterateTo(topNumber, (pos, lim, b) => Interlocked.Add(ref sum, SumBuffer(pos, lim, b)));
        return (ulong)sum;
    }

    /// <summary>Gets the enumerator for the primes.</summary>
    /// <returns>The enumerator of the primes.</returns>
    [Pure]
    public IEnumerator<ulong> GetEnumerator() => new Enumerator();

    /// <summary>Gets the enumerator for the primes.</summary>
    /// <returns>The enumerator of the primes.</returns>
    [Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>Fast buffer segment culling method using a Wheel State Look Up Table.</summary>
    /// <param name="lwi">The limit.</param>
    /// <param name="b">The buffer.</param>
    static void CullBuffer(ulong lwi, ushort[] b)
    {
        var nlwi = lwi;

        // Copy pre-culled lower base primes.
        for (var i = 0u; i < b.Length; nlwi += s_pageRange, i += s_pageSize)
            s_masterCopy.CopyTo(b, i);

        for (uint i = 0, pd = 0;; i++)
        {
            pd += s_basePrimes[i] >> 6;
            var wi = s_basePrimes[i] & 0x3Fu;
            var wp = (uint)s_positions[wi];
            var p = pd * s_circumference + s_wheelIndices[wi];
            var k = p * (ulong)p - Fstbp >> 1;

            if (k >= nlwi)
                break;

            if (k < lwi)
            {
                k = (lwi - k) % (s_circumference * p);

                if (k is not 0)
                {
                    var nwp = wp + (uint)((k + p - 1) / p);
                    k = (s_roundUp[nwp] - wp) * p - k;
                }
            }
            else
                k -= lwi;

            var kd = k / s_circumference;
            var kn = s_lookup[k - kd * s_circumference];

            for (uint word = (uint)kd * s_candidates + (uint)(kn >> 4), ndx = wi * s_length + kn; word < b.Length;)
            {
                var st = s_wheelStates[ndx];
                b[word] |= st._mask;
                word += st._multiply * pd + st._extra;
                ndx = st._next;
            }
        }
    }

    /// <summary>
    /// Iterates the action over each page up to the page including the <paramref name="topNumber"/>,
    /// making an adjustment to the top limit for the last page.
    /// </summary>
    /// <remarks><para>This method works for non-dependent actions that can be executed in any order.</para></remarks>
    /// <param name="topNumber">The number to reach.</param>
    /// <param name="action">The action to invoke.</param>
    static void IterateTo(ulong topNumber, Action<ulong, uint, ushort[]> action)
    {
        var processors = new Processor[s_procs];

        for (var s = 0u; s < s_procs; s++)
            processors[s] = new()
            {
                _buffer = new ushort[s_bufferSize],
                _task = Task.Factory.StartNew(Noop),
            };

        var topIndex = topNumber - Fstbp >> 1;

        for (ulong index = 0; index <= topIndex;)
        {
            processors[0]._task.Wait();
            var buffer = processors[0]._buffer;

            for (var s = 0u; s < s_procs - 1; s++)
                processors[s] = processors[s + 1];

            var lowi = index;
            var nxtndx = index + s_bufferRange;
            var lim = topIndex < nxtndx ? (uint)(topIndex - index + 1) : s_bufferRange;

            processors[s_procs - 1] = new()
            {
                _buffer = buffer,
                _task = CullBufferAsync(index, buffer, b => action(lowi, lim, b)),
            };

            index = nxtndx;
        }

        for (var s = 0u; s < s_procs; s++)
            processors[s]._task.Wait();
    }

    /// <summary>
    /// Iterates the <paramref name="predicate"/> over each page up to the page where the predicate paramenter returns
    /// <see langword="true"/>, this method works for dependent operations that need to be executed in increasing order.
    /// </summary>
    /// <remarks><para>It is somewhat slower as the predicate function is executed outside the task.</para></remarks>
    /// <param name="predicate">The predicate to iterate over.</param>
    static void IterateUntil([InstantHandle] Func<ulong, ushort[], bool> predicate)
    {
        var processors = new Processor[s_procs];

        for (var s = 0u; s < s_procs; s++)
        {
            var buffer = new ushort[s_bufferSize];

            processors[s] = new()
            {
                _buffer = buffer,
                _task = CullBufferAsync(s * s_bufferRange, buffer),
            };
        }

        for (var ndx = 0ul;; ndx += s_bufferRange)
        {
            processors[0]._task.Wait();
            var buffer = processors[0]._buffer;

            if (predicate(ndx, buffer))
                break;

            for (var s = 0u; s < s_procs - 1; s++)
                processors[s] = processors[s + 1];

            processors[s_procs - 1] = new()
            {
                _buffer = buffer,
                _task = CullBufferAsync(ndx + s_procs * s_bufferRange, buffer),
            };
        }
    }

    /// <summary>Very fast counting method using the CLUT look up table.</summary>
    /// <param name="bitlim">The bit limiter.</param>
    /// <param name="buf">The buffer.</param>
    /// <returns>The count.</returns>
    [MustUseReturnValue]
    static int Count(uint bitlim, ushort[] buf)
    {
        if (bitlim < s_bufferRange)
        {
            var adder = (bitlim - 1) / s_circumference;
            var bit = s_lookup[bitlim - adder * s_circumference] - 1;
            adder *= s_candidates;

            for (var i = 0; i < 3; i++)
                buf[adder++] |= (ushort)(unchecked((ulong)-2) << bit >> (i << 4));
        }

        var accumulator = 0;

        for (uint i = 0, w = 0; i < bitlim; i += s_circumference)
            accumulator += s_counting[buf[w++]] + s_counting[buf[w++]] + s_counting[buf[w++]];

        return accumulator;
    }

    /// <summary>Forms a task of the cull buffer operaion.</summary>
    /// <param name="lwi">The limit.</param>
    /// <param name="b">The buffer.</param>
    /// <param name="f">The callback.</param>
    /// <returns>The awaitable <see cref="Task"/>.</returns>
    [MustUseReturnValue]
    static Task CullBufferAsync(ulong lwi, ushort[] b, Action<ushort[]>? f = null)
    {
        void WrapperUnspecified() => CullBuffer(lwi, b);

        void WrapperSpecified()
        {
            CullBuffer(lwi, b);
            f(b);
        }

        return Task.Factory.StartNew(f is null ? WrapperUnspecified : WrapperSpecified);
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Provides extension methods for <see cref="char"/>.</summary>

    /// <inheritdoc cref="char.IsControl(char)"/>
    [Pure]
    public static bool IsControl(this char c) => char.IsControl(c);

    /// <inheritdoc cref="char.IsDigit(char)"/>
    [Pure]
    public static bool IsDigit(this char c) => char.IsDigit(c);

    /// <inheritdoc cref="char.IsHighSurrogate(char)"/>
    [Pure]
    public static bool IsHighSurrogate(this char c) => char.IsHighSurrogate(c);

    /// <inheritdoc cref="char.IsLetter(char)"/>
    [Pure]
    public static bool IsLetter(this char c) => char.IsLetter(c);

    /// <inheritdoc cref="char.IsLetterOrDigit(char)"/>
    [Pure]
    public static bool IsLetterOrDigit(this char c) => char.IsLetterOrDigit(c);

    /// <inheritdoc cref="char.IsLower(char)"/>
    [Pure]
    public static bool IsLower(this char c) => char.IsLower(c);

    /// <inheritdoc cref="char.IsLowSurrogate(char)"/>
    [Pure]
    public static bool IsLowSurrogate(this char c) => char.IsLowSurrogate(c);

    /// <inheritdoc cref="string.IsNullOrEmpty(string)"/>
    [Pure]
    public static bool IsNullOrEmpty([NotNullWhen(false)] this string? value) => string.IsNullOrEmpty(value);

#if NET35
    /// <summary>
    /// Indicates whether a specified string is <see langword="null"/>,
    /// empty, or consists only of white-space characters.
    /// </summary>
    /// <param name="value">The string to test.</param>
    /// <returns>
    /// <see langword="true"/> if the <paramref name="value"/> parameter is <see langword="null"/>,
    /// or <see cref="string.Empty"/>, or if <paramref name="value"/> consists exclusively of white-space characters.
    /// </returns>
    [Pure]
    public static bool IsNullOrWhitespace([NotNullWhen(false)] this string? value) =>
        value?.All(char.IsWhiteSpace) != false;
#elif !NET20 && !NET30
    /// <inheritdoc cref="string.IsNullOrWhiteSpace(string)"/>
    [Pure]
    public static bool IsNullOrWhitespace([NotNullWhen(false)] this string? value) => string.IsNullOrWhiteSpace(value);
#endif

    /// <inheritdoc cref="char.IsNumber(char)"/>
    [Pure]
    public static bool IsNumber(this char c) => char.IsNumber(c);

    /// <inheritdoc cref="char.IsPunctuation(char)"/>
    [Pure]
    public static bool IsPunctuation(this char c) => char.IsPunctuation(c);

    /// <inheritdoc cref="char.IsSeparator(char)"/>
    [Pure]
    public static bool IsSeparator(this char c) => char.IsSeparator(c);

    /// <inheritdoc cref="char.IsSurrogate(char)"/>
    [Pure]
    public static bool IsSurrogate(this char c) => char.IsSurrogate(c);

    /// <inheritdoc cref="char.IsSymbol(char)"/>
    [Pure]
    public static bool IsSymbol(this char c) => char.IsSymbol(c);

    /// <inheritdoc cref="char.IsUpper(char)"/>
    public static bool IsUpper(this char c) => char.IsUpper(c);

    /// <inheritdoc cref="char.IsWhiteSpace(char)"/>
    [Pure]
    public static bool IsWhitespace(this char c) => char.IsWhiteSpace(c);

    /// <summary>Converts the character to the byte-equivalent, 0-9.</summary>
    /// <param name="c">The character to convert.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="c"/> isn't between '0' and '9', inclusively on both ends.
    /// </exception>
    /// <returns>The number 0-9 representing the character.</returns>
    [Pure]
    public static byte AsDigit(this char c) =>
        c is >= '0' and <= '9'
            ? (byte)(c - '0')
            : throw new ArgumentOutOfRangeException(nameof(c), c, "Character must be 0-9.");

    /// <summary>Attempts to convert the character to the byte-equivalent, 0-9.</summary>
    /// <param name="c">The character to convert.</param>
    /// <returns>The number 0-9 representing the character, or <see langword="null"/>.</returns>
    [Pure]
    public static byte? TryAsDigit(this char c) => c is >= '0' and <= '9' ? (byte)(c - '0') : null;

    /// <inheritdoc cref="char.ToLower(char)"/>
    [Pure]
    public static char ToLower(this char c) => char.ToLowerInvariant(c);

    /// <inheritdoc cref="char.ToUpper(char)"/>
    [Pure]
    public static char ToUpper(this char c) => char.ToUpperInvariant(c);

    /// <inheritdoc cref="char.GetNumericValue(char)"/>
    [Pure]
    public static double GetNumericValue(this char c) => char.GetNumericValue(c);

    /// <inheritdoc cref="string.Trim(char[])"/>
    [Pure]
    public static string Trim(this string s, string trim)
    {
        int start = 0, end = 1;

        for (; start < s.Length; start++)
            if (start >= trim.Length || s[start] != trim[start])
                break;

        for (; end <= s.Length; end++)
            if (end > trim.Length || s[^end] != trim[^end])
                return s[..^(end - 1)];

        return s[start..^end];
    }

    /// <inheritdoc cref="string.TrimEnd(char[])"/>
    [Pure]
    public static string TrimEnd(this string s, string trim)
    {
        for (var i = 1; i <= s.Length; i++)
            if (i > trim.Length || s[^i] != trim[^i])
                return s[..^(i - 1)];

        return "";
    }

    /// <inheritdoc cref="string.TrimStart(char[])"/>
    [Pure]
    public static string TrimStart(this string s, string trim)
    {
        for (var i = 0; i < s.Length; i++)
            if (i >= trim.Length || s[i] != trim[i])
                return s[i..];

        return "";
    }

#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <inheritdoc cref="char.GetUnicodeCategory(char)"/>
    [Pure]
    public static UnicodeCategory GetUnicodeCategory(this char c) => char.GetUnicodeCategory(c);
#endif

// SPDX-License-Identifier: MPL-2.0
#if NET40_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable CheckNamespace RedundantNameQualifier





/// <summary>Provides methods to do math on enums without overhead from boxing.</summary>
[UsedImplicitly]

    const string ParameterName = "value";
#pragma warning disable CA2208, MA0015
    static readonly ConstantExpression s_parameterName = Constant(ParameterName, typeof(string));
#pragma warning restore CA2208, MA0015

    static readonly ConstructorInfo s_newArgument = typeof(ArgumentException).GetConstructor(
            BindingFlags.Instance | BindingFlags.Public,
            null,
            [typeof(string), typeof(string)],
            null
        ) ??
        throw Unreachable;

    static readonly ConstructorInfo s_newInvalidEnumArgument = typeof(InvalidEnumArgumentException).GetConstructor(
            BindingFlags.Instance | BindingFlags.Public,
            null,
            [typeof(string), typeof(int), typeof(Type)],
            null
        ) ??
        throw Unreachable;

    /// <summary>Converts the value to a constant <see cref="string"/>.</summary>
    /// <remarks><para>
    /// Combinations via <see cref="FlagsAttribute"/> are ignored. Only explicit fields count.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <exception cref="InvalidEnumArgumentException">The value doesn't represent an exact value.</exception>
    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
    [Pure]
    public static string AsString<T>(this T value)
        where T : Enum =>
        typeof(T) == typeof(Enum) ? value.ToString() : StringCaching<T>.From(value);

    /// <summary>Converts the <see cref="string"/> to a constant value.</summary>
    /// <remarks><para>
    /// Combinations via <see cref="FlagsAttribute"/> are ignored. Only explicit fields count.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <exception cref="ArgumentException">The value doesn't represent an exact value.</exception>
    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
    [Pure]
    public static T As<T>(this string value)
        where T : Enum =>
        typeof(T) == typeof(Enum) ? (T)Enum.Parse(typeof(T), value) : StringCaching<T>.To(value);

    static class StringCaching<T>
        where T : Enum
    {
        public static Converter<T, string> From { get; } = Make<Converter<T, string>>(false);

        public static Converter<string, T> To { get; } = Make<Converter<string, T>>(true);

        static TFunc Make<TFunc>(bool isToT)
            where TFunc : Delegate
        {
            var parameter = Parameter(isToT ? typeof(string) : typeof(T), ParameterName);
            var cases = Cases(isToT);
            var thrower = Thrower(parameter, isToT);
            var ret = Switch(parameter, thrower, cases);

            return Lambda<TFunc>(ret, parameter).Compile();
        }

        static SwitchCase[] Cases(bool isToT) =>
            [..typeof(T).GetFields(BindingFlags.Static | BindingFlags.Public).Select(x => Case(x, isToT))];

        static SwitchCase Case(FieldInfo x, bool isToT)
        {
            var str = Constant(x.Name, typeof(string));
            var t = Constant(x.GetValue(null), typeof(T));
            var from = isToT ? str : t;
            var to = isToT ? t : str;

            return SwitchCase(to, from);
        }

        static UnaryExpression Thrower(Expression parameter, bool isToT) =>
            Throw(isToT ? Format(parameter) : InvalidEnumArgument(parameter), isToT ? typeof(T) : typeof(string));

        static NewExpression Format(Expression parameter) => New(s_newArgument, parameter, s_parameterName);

        static NewExpression InvalidEnumArgument(Expression parameter) =>
            New(
                s_newInvalidEnumArgument,
                s_parameterName,
                Convert(parameter, typeof(int)),
                Constant(typeof(T), typeof(Type))
            );
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable ConditionalAccessQualifierIsNonNullableAccordingToAPIContract CheckNamespace RedundantNameQualifier RedundantUsingDirective UseSymbolAlias
#pragma warning disable 1696, SA1137, SA1216
#if WAWA
namespace Wawa.Modules;
#else

#endif


#if !(NET20 || NET30)

#endif


/// <summary>Provides stringification methods.</summary>
// ReSharper disable once BadPreprocessorIndent
#if WAWA
public
#endif

    const int MaxIteration = 32, MaxRecursion = 3;
#if !WAWA
    const RegexOptions Options = RegexOptions.Multiline | RegexOptions.Compiled;
#endif // ReSharper disable UnusedMember.Local
#pragma warning disable CA1823, IDE0051
    const string
        BitFlagSeparator = " | ",
        Else = "th",
        EqualityContract = nameof(EqualityContract),
        False = "false",
        FirstOrd = "st",
        Invalid = $"!<{nameof(InvalidOperationException)}>",
        KeyValueSeparator = ": ",
        Null = "null",
        SecondOrd = "nd",
        Separator = ", ",
        ThirdOrd = "rd",
        True = "true",
        Unsupported = $"!<{nameof(NotSupportedException)}>",
        UnsupportedPlatform = $"!<{nameof(PlatformNotSupportedException)}>";
#pragma warning restore CA1823, IDE0051
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    static readonly Dictionary<Type, bool>
#if !WAWA
        s_fullyUnmanaged = [],
#endif
        s_hasMethods = [];

    static readonly Dictionary<Type, Delegate> s_stringifiers = [];
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    static readonly Dictionary<Type, string> s_unfoldedNames = new()
    {
        [typeof(bool)] = "bool",
        [typeof(byte)] = "byte",
        [typeof(char)] = "char",
        [typeof(decimal)] = "decimal",
        [typeof(double)] = "double",
        [typeof(float)] = "float",
        [typeof(int)] = "int",
        [typeof(long)] = "long",
        [typeof(nint)] = "nint",
        [typeof(nuint)] = "nuint",
        [typeof(object)] = "object",
        [typeof(sbyte)] = "sbyte",
        [typeof(short)] = "short",
        [typeof(string)] = "string",
        [typeof(uint)] = "uint",
        [typeof(ulong)] = "ulong",
        [typeof(ushort)] = "ushort",
        [typeof(void)] = "void",
    };
#endif
    static readonly ConstantExpression
        s_exEmpty = Constant(""),
#if !NETFRAMEWORK || NET40_OR_GREATER
        s_exInvalid = Constant(Invalid),
        s_exUnsupported = Constant(Unsupported),
        s_exUnsupportedPlatform = Constant(UnsupportedPlatform),
#endif
        s_exSeparator = Constant(Separator),
        s_exTrue = Constant(true);

    static readonly MethodInfo
        s_combine = ((Func<string, string, string>)string.Concat).Method,
        s_stringify = ((Func<bool, int, bool, string>)Stringify).Method.GetGenericMethodDefinition();
#endif
    static readonly MethodInfo s_toString = ((Func<string?>)s_hasMethods.ToString).Method;
#if !WAWA
#pragma warning disable MA0110, SYSLIB1045
    static readonly Regex
        s_parentheses = new(@"\((?>(?:\((?<A>)|\)(?<-A>)|[^()]+){2,})\)", Options),
        s_brackets = new(@"\[(?>(?:\[(?<A>)|\](?<-A>)|[^\[\]]+){2,})\]", Options),
        s_curlies = new("{(?>(?:{(?<A>)|}(?<-A>)|[^{}]+){2,})}", Options),
        s_angles = new("<(?>(?:<(?<A>)|>(?<-A>)|[^<>]+){2,})>", Options),
        s_quotes = new(@"""(?>(?:{(?<A>)|}(?<-A>)|[^""]+){2,})""", Options);
#pragma warning restore MA0110, SYSLIB1045
#endif

    /// <summary>Gets the field count of the version.</summary>
    /// <param name="version">The <see cref="Version"/> to use.</param>
    /// <returns>The field count of the parameter <paramref name="version"/>.</returns>
    [Pure]
    public static int FieldCount(
#if !WAWA
        this
#endif // ReSharper disable once BadPreprocessorIndent
            Version? version
    ) =>
        version switch
        {
            (_, <= 0, <= 0, <= 0) => 1,
            (_, _, <= 0, <= 0) => 2,
            (_, _, _, <= 0) => 3,
            _ => 4,
        };
#if !WAWA
    /// <summary>Creates the collapsed form of the string.</summary>
    /// <param name="s">The string to collapse.</param>
    /// <returns>The collapsed string.</returns>
    public static string Collapse(this string s)
    {
        s = s_parentheses.Replace(s, "(…)");
        s = s_brackets.Replace(s, "[…]");
        s = s_curlies.Replace(s, "{…}");
        s = s_angles.Replace(s, "<…>");
        return s_quotes.Replace(s, "\"…\"");
    }

    /// <summary>Converts a number to an ordinal.</summary>
    /// <param name="i">The number to convert.</param>
    /// <param name="one">The string for the value 1 or -1.</param>
    /// <param name="many">The string to concatenate. Use prefixed dashes to trim <paramref name="one"/>.</param>
    /// <returns>The conjugation of all the parameters.</returns>
    [Pure]
    public static string Conjugate(this int i, string one, string many = "s") =>
        i is not 1 and not -1 && Math.Min(many.TakeWhile(x => x is '-').Count(), one.Length) is var trim
            ? $"{i} {one[..^trim]}{many[trim..]}"
            : $"{i} {one}";

    /// <summary>Creates the prettified form of the string.</summary>
    /// <param name="s">The string to prettify.</param>
    /// <returns>The prettified string.</returns>
    public static string Prettify(this string s) => Prettify(s, separator: ",;");

    /// <summary>Creates the prettified form of the string.</summary>
    /// <param name="s">The string to prettify.</param>
    /// <param name="start">The characters considered to be starting blocks.</param>
    /// <param name="end">The characters considered to be ending blocks.</param>
    /// <param name="separator">The characters considered to be separators.</param>
    /// <param name="indent">The amount of spaces for indentation.</param>
    /// <returns>The prettified string.</returns>
    public static string Prettify(
        this string s, // ReSharper disable once MethodOverloadWithOptionalParameter
        string start = "([{<",
        string end = ")]}>",
        string separator = ",;",
        string indent = "    "
    )
#pragma warning disable CA1508
    {
        // Inspired by https://gist.github.com/kodo-pp/89cefb17a8772cd9fd7b875d94fd29c7.
        var seen = false;
        var nest = 0;
        StringBuilder sb = new();

        for (var i = 0; i < s.Length; i++)
            (seen, nest, sb) = s[i] switch
            {
                not ' ' when seen && sb.Indent(indent, nest) is var _ && (seen = false) => throw Unreachable,
                _ when start.Contains(s[i]) && (s.Nth(i + 1) is not { } next || !end.Contains(next)) =>
                    (seen, ++nest, sb.Append(s[i]).Indent(indent, nest)),
                _ when end.Contains(s[i]) && (s.Nth(i - 1) is not { } prev || !start.Contains(prev)) =>
                    (seen, --nest, sb.Indent(indent, nest).Append(s[i])),
                _ when separator.Contains(s[i]) => (true, nest, sb.Append(s[i])),
                ' ' when seen && nest > 0 ||
                    s.Nth(i - 1) is { } prev && start.Contains(prev) ||
                    s.Nth(i + 1) is { } next && end.Contains(next) => (seen, nest, sb),
                _ => (seen, nest, sb.Append(s[i])),
            };

        return $"{sb}";
    }
#pragma warning restore CA1508
#endif
#if NET40_OR_GREATER || NETSTANDARD || NETCOREAPP
    /// <summary>Concatenates an enumeration of <see cref="char"/> into a <see cref="string"/>.</summary>
    /// <remarks><para>
    /// This method is more efficient than using <see cref="Conjoin{T}(IEnumerable{T}, string)"/>
    /// for <see cref="char"/> enumerations.
    /// </para></remarks>
    /// <param name="chars">The enumeration of characters.</param>
    /// <returns>A <see cref="string"/> built from concatenating <paramref name="chars"/>.</returns>
    [Pure]
    public static string Concat([InstantHandle] this IEnumerable<char> chars) => string.Concat(chars);
#endif

    /// <summary>Joins a set of values into one long <see cref="string"/>.</summary>
    /// <remarks><para>
    /// This method is more efficient than using
    /// <see cref="Conjoin{T}(IEnumerable{T}, string)"/> for <see cref="char"/> separators.
    /// </para></remarks>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>One long <see cref="string"/>.</returns>
    // ReSharper disable BadPreprocessorIndent
    [Pure]
    public static string Conjoin<T>(
        [InstantHandle]
#if !WAWA
        this
#endif
            IEnumerable<T> values,
        char separator
    ) =>
        $"{new StringBuilder().AppendMany(values, separator)}";

    /// <summary>Joins a set of values into one long <see cref="string"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>One long <see cref="string"/>.</returns>
    [Pure]
    public static string Conjoin<T>(
        [InstantHandle]
#if !WAWA
        this
#endif
            IEnumerable<T> values,
        string separator = Separator
    ) =>
        $"{new StringBuilder().AppendMany(values, separator)}";

    /// <summary>Gets the short display form of the version.</summary>
    /// <param name="version">The <see cref="Version"/> to convert.</param>
    /// <returns>The full name of the parameter <paramref name="version"/>.</returns>
    [Pure]
    public static string ToShortString(
#if !WAWA
        this
#endif
            Version? version
    )
    {
        if (version is not var (major, minor, build, revision) ||
            major <= 0 && minor <= 0 && build <= 0 && revision <= 0)
            return "v0";

        var length = Length(major, revision, minor, build);

        Span<char> span = stackalloc char[length];
        Format(span, version);
        return span.ToString();
    }
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
#if !WAWA
    /// <summary>Gets the full type name, with its generics extended.</summary>
    /// <param name="type">The <see cref="Type"/> to get the full name of.</param>
    /// <returns>The full name of the parameter <paramref name="type"/>.</returns>
    [Pure]
    public static string UnfoldedFullName(this Type? type) =>
        type is { Namespace: var name and not "" and not null } ? $"{name}.{UnfoldedName(type)}" : UnfoldedName(type);
#endif

    /// <summary>Gets the type name, with its generics extended.</summary>
    /// <param name="type">The <see cref="Type"/> to get the name of.</param>
    /// <returns>The name of the parameter <paramref name="type"/>.</returns>
    [Pure]
    public static string UnfoldedName(
#if !WAWA
        this
#endif
            Type? type
    ) =>
        type is null ? Null :
        s_unfoldedNames.TryGetValue(type, out var val) ? val :
        s_unfoldedNames[type] = $"{type.UnfoldedName(new())}";
#endif

    /// <summary>Converts a number to an ordinal.</summary>
    /// <param name="i">The number to convert.</param>
    /// <param name="indexByZero">Determines whether to index from zero or one.</param>
    /// <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
    [Pure]
    public static string Nth(
#if !WAWA
        this
#endif
            int i,
        bool indexByZero = false
    ) =>
        indexByZero ? (i + 1).ToOrdinal() : i.ToOrdinal();

    /// <inheritdoc cref="string.Split(string[], StringSplitOptions)"/>
    // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static string[] Chop(
#if !WAWA
        this
#endif
            string source,
        string separator
    ) => // ReSharper disable once RedundantCast
        source.Split((char[])[..separator], StringSplitOptions.RemoveEmptyEntries);

    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(
#if !WAWA
        this
#endif
            T? source
    ) =>
        Stringify(source, MaxRecursion);

    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <param name="depth">Determines how deep the recursive function should go.</param>
    /// <param name="useQuotes">
    /// Determines whether <see cref="string"/> and <see cref="char"/> have a " and ' surrounding them.
    /// </param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(
#if !WAWA
        this
#endif
#pragma warning disable SA1114 RCS1163
            T? source,
        int depth,
        bool useQuotes = false
#pragma warning restore SA1114 RCS1163
    ) =>
        source switch
        {
            null => Null,
            true => True,
            false => False,
            nint x => $"{x}",
            nuint x => $"{x}",
            char x => useQuotes ? Escape(x) : $"{x}",
            string x => useQuotes ? $@"""{x}""" : x,
            Enum x when x.AsInt() is var i && x.GetType().IsDefined(typeof(FlagsAttribute), false) is var b =>
                $"{x.GetType().Name}({(b ? $"0x{i:x}" : i)}) = {(b
                    ? Conjoin(i.AsBits().Select(x.GetType().Into), BitFlagSeparator)
                    : x)}",
            Type x => UnfoldedName(x),
            Version x => ToShortString(x),
#if KTANE
            Object x => x.name,
#endif
            IConvertible x => x.ToString(CultureInfo.InvariantCulture),
            ICustomFormatter x => x.Format("", x, CultureInfo.InvariantCulture),
            _ when depth <= 0 =>
#if NET20 || NET30 || !(!NETSTANDARD || NETSTANDARD2_0_OR_GREATER)
                source.ToString(),
#else
                source.StringifyObject(depth - 1),
#endif
#if NET40_OR_GREATER || NETSTANDARD || NETCOREAPP
            IEnumerable<char> x => useQuotes ? $@"""{x.Concat()}""" : x.Concat(),
#else
            IEnumerable<char> x => useQuotes ? $@"""{Conjoin(x, "")}""" : Conjoin(x, ""),
#endif
            IDictionary { Count: 0 } => "{ }",
            IDictionary x => $"{{ {x.DictionaryStringifier(depth - 1, useQuotes)} }}",
            ICollection { Count: var count } x => Count(x, depth - 1, useQuotes, count),
            IEnumerable x => $"[{EnumeratorStringifier(x.GetEnumerator(), depth - 1, useQuotes)}]",
#if NET471_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER
#pragma warning disable IDISP004
            ITuple x => $"({EnumeratorStringifier(x.AsEnumerable().GetEnumerator(), depth - 1, useQuotes)})",
#pragma warning restore IDISP004
#endif
#if !NETFRAMEWORK || NET40_OR_GREATER
            IStructuralComparable x when new FakeComparer(depth - 1) is var c && x.CompareTo(x, c) is var _ => $"{c}",
            IStructuralEquatable x when new FakeComparer(depth - 1) is var c && x.GetHashCode(c) is var _ => $"{c}",
#endif
#if ROSLYN
            ISymbol x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
#endif
#if NET20 || NET30 || !(!NETSTANDARD || NETSTANDARD2_0_OR_GREATER)
            _ => source.ToString(),
#else
            _ => source.StringifyObject(depth - 1),
#endif
        };

    /// <summary>Forces the use of reflective stringification.</summary>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <param name="depth">The amount of nesting.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
#if !WAWA
    public
#endif
        static string UseStringifier<T>(this T source, int depth = MaxRecursion)
    {
        // Method can be called if 'forceReflection' is true.
        if (!typeof(T).IsValueType && source is null)
            return Null;

        if (!s_stringifiers.ContainsKey(typeof(T)))
            s_stringifiers[typeof(T)] = GenerateStringifier<T>();

        var name = source?.GetType() is { } type && type != typeof(T)
            ? $"{UnfoldedName(type)} as {UnfoldedName(typeof(T))}"
            : UnfoldedName(typeof(T));

        return ((Func<T, int, string>)s_stringifiers[typeof(T)])(source, depth) is not "" and var str
            ? $"{name} {{ {str} }}"
            : name;
    }

    /// <summary>Appends an enumeration onto the <see cref="StringBuilder"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="builder">The <see cref="StringBuilder"/> to mutate and <see langword="return"/>.</param>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
#if !WAWA
    public
#endif
        static StringBuilder AppendMany<T>(
            this StringBuilder builder,
            [InstantHandle] IEnumerable<T> values,
            char separator
        )
    {
        using var enumerator = values.GetEnumerator();

        if (enumerator.MoveNext())
            builder.Append(enumerator.Current);
        else
            return builder;

        while (enumerator.MoveNext())
            builder.Append(separator).Append(enumerator.Current);

        return builder;
    }

    /// <summary>Appends an enumeration onto the <see cref="StringBuilder"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="builder">The <see cref="StringBuilder"/> to mutate and <see langword="return"/>.</param>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
#if !WAWA
    public
#endif
        static StringBuilder AppendMany<T>(
            this StringBuilder builder,
            [InstantHandle] IEnumerable<T> values,
            string separator = Separator
        )
    {
        if (separator is "")
            switch (values)
            {
                case char[] x: return builder.Append(x);
                case string x: return builder.Append(x);
            }

        using var enumerator = values.GetEnumerator();

        if (enumerator.MoveNext())
            builder.Append(enumerator.Current);
        else
            return builder;

        while (enumerator.MoveNext())
            builder.Append(separator).Append(enumerator.Current);

        return builder;
    }

#if !WAWA
    /// <summary>Gets the type name, with its generics extended.</summary>
    /// <param name="type">The <see cref="Type"/> to get the name of.</param>
    /// <returns>The name of the parameter <paramref name="type"/>.</returns>
    [Pure]
    public static bool IsUnmanaged([NotNullWhen(true)] this Type? type) =>
        type is not null &&
        (s_fullyUnmanaged.TryGetValue(type, out var answer) ? answer :
            !type.IsValueType ? s_fullyUnmanaged[type] = false :
            type.IsEnum || type.IsPointer || type.IsPrimitive ? s_fullyUnmanaged[type] = true :
            s_fullyUnmanaged[type] = type.IsGenericTypeDefinition
                ? type
                   .GetCustomAttributes()
                   .Any(x => x?.GetType().FullName is "System.Runtime.CompilerServices.IsUnmanagedAttribute")
                : Array.TrueForAll(
                    type.GetFields(
                        BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic
                    ),
                    x => IsUnmanaged(x.FieldType)
                ));
#endif
    static void AppendKeyValuePair(this StringBuilder builder, string key, string value) =>
        builder.Append(key).Append(KeyValueSeparator).Append(value);
#pragma warning disable IDE0057
    static void Push(char c, scoped ref Span<char> span)
    {
        span[0] = c; // ReSharper disable once ReplaceSliceWithRangeIndexer
        span = span.Slice(1);
    }

    // ReSharper disable InvocationIsSkipped RedundantAssignment
    static void Push([NonNegativeValue] int next, scoped ref Span<char> span)
    {
        var it = next.TryFormat(span, out var slice);
        System.Diagnostics.Debug.Assert(it, "TryFormat"); // ReSharper disable once ReplaceSliceWithRangeIndexer
        span = span.Slice(slice);
    }
#pragma warning restore IDE0057
    // ReSharper disable RedundantAssignment
    static void Push([NonNegativeValue] int next, char c, scoped ref Span<char> span)
    {
        Push(next, ref span);
        Push(c, ref span);
    }

    static void Format(scoped Span<char> span, Version version)
    {
        Push('v', ref span);

        switch (version)
        {
            case (var major, var minor, var build, > 0 and var revision):
                Push(major, '.', ref span);
                Push(minor, '.', ref span);
                Push(build, '.', ref span);
                Push(revision, ref span);
                break;
            case (var major, var minor, > 0 and var build):
                Push(major, '.', ref span);
                Push(minor, '.', ref span);
                Push(build, ref span);
                break;
            case (var major, > 0 and var minor):
                Push(major, '.', ref span);
                Push(minor, ref span);
                break;
            default:
                Push(version.Major, ref span);
                break;
        }

        System.Diagnostics.Debug.Assert(span.IsEmpty, nameof(Span<char>.IsEmpty));
    }

#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER // ReSharper restore RedundantAssignment
    // ReSharper disable once ConditionalAccessQualifierIsNonNullableAccordingToAPIContract
    [MustUseReturnValue]
    static bool CanUse(PropertyInfo p) =>
        p is { CanRead: true, PropertyType.Name: not "SyntaxTree" } &&
        p.GetIndexParameters().Length is 0 &&
        Array.TrueForAll(p.GetCustomAttributes(true), x => x?.GetType() != typeof(ObsoleteAttribute));
#endif
    [Pure]
    static bool IsEqualityContract(PropertyInfo x) =>
        x is { CanRead: true, CanWrite: false, Name: EqualityContract } &&
        x.PropertyType == typeof(Type) &&
        x.GetIndexParameters().Length is 0;

    [Pure]
    static bool IsRecord<T>() =>
        Array.Exists(
            typeof(T).GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic),
            IsEqualityContract
        );

    [Pure]
    static int Length(int major, int revision, int minor, int build) =>
        (major.DigitCount() + 1 is var length && revision > 0 ?
            minor.DigitCount() + build.DigitCount() + revision.DigitCount() + 3 :
            build > 0 ? minor.DigitCount() + build.DigitCount() + 2 :
                minor > 0 ? minor.DigitCount() + 1 : 0) +
        length;

    [Inline, Pure]
    static int Mod(this int i) => Math.Abs(i) / 10 % 10 is 1 ? 0 : Math.Abs(i) % 10;

    [MustUseReturnValue]
    static string Count(IEnumerable e, int depth, bool useQuotes, int count) =>
        count is 0
            ? "[Count: 0]"
            : $"[Count: {count}; {EnumeratorStringifier(e.GetEnumerator(), depth, useQuotes, count)}]";

    [Pure]
    static string Escape(char c) =>
        c switch
        {
            '\'' => "'\\''",
            '\"' => "'\\\"'",
            '\\' => @"'\\'",
            '\0' => "'\\0'",
            '\a' => "'\\a'",
            '\b' => "'\\b'",
            '\f' => "'\\f'",
            '\n' => "'\\n'",
            '\r' => "'\\r'",
            '\t' => "'\\t'",
            '\v' => "'\\v'",
            _ => $"{c}",
        };

    [Pure]
    static string Etcetera(this int? i) => i is null ? "…" : $"…{i} more";

    [Pure]
    static string ToOrdinal(this int i) =>
        $"{i}{Mod(i) switch
        {
            1 => FirstOrd,
            2 => SecondOrd,
            3 => ThirdOrd,
            _ => Else,
        }}";

    [Pure]
    static object Into(this Type type, int i) =>
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
        Enum.ToObject(type, i);
#else
        Enum.Parse(type, $"{i}");
#endif

    [MustUseReturnValue]
    static StringBuilder EnumeratorStringifier(
        [HandlesResourceDisposal] this IEnumerator iterator,
        [NonNegativeValue] int depth,
        bool useQuotes,
        [NonNegativeValue] int? count = null
    )
    {
        try
        {
            StringBuilder builder = new();

            if (iterator.MoveNext())
                builder.Append(Stringify(iterator.Current, depth, useQuotes));

            var i = 0;

            while (iterator.MoveNext())
            {
                if (checked(++i) >= MaxIteration)
                {
                    builder.Append(Separator).Append(Etcetera(count - i));
                    break;
                }

                builder.Append(Separator).Append(Stringify(iterator.Current, depth, useQuotes));
            }

            return builder;
        }
        finally
        {
#pragma warning disable IDISP007
            (iterator as IDisposable)?.Dispose();
#pragma warning restore IDISP007
        }
    }
#if !WAWA
    [MustUseReturnValue]
    static StringBuilder Indent(this StringBuilder sb, string indent, int nest)
    {
        sb.AppendLine();

        for (var i = 0; i < nest && nest >= 0; i++)
            sb.Append(indent);

        return sb;
    }
#endif
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    [MustUseReturnValue]
    static string StringifyObject<T>(this T source, int depth)
    {
        if (source is null)
            return Null;

        if (!s_hasMethods.ContainsKey(typeof(T)))
            s_hasMethods[typeof(T)] =
                source.GetType().GetMethod(nameof(ToString), Type.EmptyTypes)?.DeclaringType != typeof(object) &&
                !IsRecord<T>();

        // ReSharper disable once ConstantNullCoalescingCondition NullCoalescingConditionIsAlwaysNotNullAccordingToAPIContract
        if (depth < 0)
            return s_hasMethods[typeof(T)] ? source.ToString() ?? Null : UnfoldedName(source.GetType());
#pragma warning disable 8600, 8603 // Will never be null, we have access to this function.
        if (source.GetType() is var t && t != typeof(T))
            return (string)s_stringify.MakeGenericMethod(t).Invoke(null, [source, depth, false]);
#pragma warning restore 8600, 8603

        // ReSharper disable once ConstantNullCoalescingCondition ConditionIsAlwaysTrueOrFalseAccordingToNullableAPIContract
        return UseStringifier(source, depth);
    }

    [MustUseReturnValue]
    static Func<T, int, string> GenerateStringifier<T>()
    {
        static MethodCallExpression Combine(Expression prev, Expression curr)
        {
            var call = Call(s_combine, prev, s_exSeparator);
            return Call(s_combine, call, curr);
        }

        const BindingFlags Flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy;

        ParameterExpression
            exInstance = Parameter(typeof(T), nameof(T)),
            exDepth = Parameter(typeof(int), nameof(Int32));

        var deepProperties = typeof(T).IsInterface ? typeof(T).GetInterfaces().SelectMany(x => x.GetProperties()) : [];
        var deepFields = typeof(T).IsInterface ? typeof(T).GetInterfaces().SelectMany(x => x.GetFields()) : [];

        // ReSharper disable ArrangeStaticMemberQualifier ConditionalAccessQualifierIsNonNullableAccordingToAPIContract
        var properties = typeof(T)
           .GetProperties(Flags)
           .Concat(deepProperties)
           .Where(CanUse)
           .OrderBy(x => x.Name, StringComparer.Ordinal)
#if NETFRAMEWORK && !NET40_OR_GREATER
           .Select(p => GetMethodCaller<T, PropertyInfo>(p, exInstance, exDepth, static x => x.PropertyType));
#else
           .Select(p => GetMethodCaller(p, exInstance, exDepth, static x => x.PropertyType));
#endif
        var fields = typeof(T)
           .GetFields(Flags)
           .Concat(deepFields)
           .OrderBy(x => x.Name, StringComparer.Ordinal)
#if NETFRAMEWORK && !NET40_OR_GREATER
           .Select(f => GetMethodCaller<T, FieldInfo>(f, exInstance, exDepth, static x => x.FieldType));
#else
           .Select(f => GetMethodCaller(f, exInstance, exDepth, static x => x.FieldType));
#endif

        var all = fields
           .Concat(properties)
#if WAWA
           .ToList();
#else
           .ToCollectionLazily();
#endif
        var exResult = all.Count is 0 ? s_exEmpty : all.Aggregate(Combine);
        return Lambda<Func<T, int, string>>(exResult, exInstance, exDepth).Compile();
    }

    // ReSharper disable SuggestBaseTypeForParameter
    [MustUseReturnValue]
#pragma warning disable CA1859
#if NETFRAMEWORK && !NET40_OR_GREATER
    static Expression GetMethodCaller<T, TMember>(
#else
    static Expression GetMethodCaller<TMember>(
#endif
        TMember info,
        ParameterExpression exInstance,
        ParameterExpression exDepth,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<TMember, Type> selector
    )
#pragma warning restore CA1859
        where TMember : MemberInfo
    {
        var type = selector(info);
        var exConstant = Constant($"{info.Name}{KeyValueSeparator}");

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
        if (type.IsByRef || type.IsByRefLike)
#else
        if (type.IsByRef)
#endif
            return Call(s_combine, exConstant, Call(exInstance, s_toString));

        var method = s_stringify.MakeGenericMethod(type);

        // ReSharper disable once NullableWarningSuppressionIsUsed
        Expression
            exMember = MakeMemberAccess(exInstance, info),
            exCall = Call(method, exMember, exDepth, s_exTrue);
#if NETFRAMEWORK && !NET40_OR_GREATER // Doesn't support CatchBlock. Workaround works but causes more heap allocations.
        var call = Lambda<Func<T, int, string>>(exCall, exInstance, exDepth).Compile();
        Expression<Func<T, int, string>> wrapped = (t, i) => TryStringify(t, i, call);

        exCall = Invoke(wrapped, exInstance, exDepth);
#else
        CatchBlock
            invalid = Catch(typeof(InvalidOperationException), s_exInvalid),
            unsupported = Catch(typeof(NotSupportedException), s_exUnsupported),
            unsupportedPlatform = Catch(typeof(PlatformNotSupportedException), s_exUnsupportedPlatform);

        exCall = TryCatch(exCall, unsupportedPlatform, unsupported, invalid);
#endif
        return Call(s_combine, exConstant, exCall);
    }
#endif
#if NETFRAMEWORK && !NET40_OR_GREATER
    static string TryStringify<T>(T instance, int depth, [InstantHandle] Func<T, int, string> stringify)
    {
        try
        {
            return stringify(instance, depth);
        }
        catch (PlatformNotSupportedException)
        {
            return UnsupportedPlatform;
        }
        catch (NotSupportedException)
        {
            return Unsupported;
        }
        catch (InvalidOperationException)
        {
            return Invalid;
        }
    }
#endif
    [Pure]
    static StringBuilder DictionaryStringifier(this IDictionary dictionary, int depth, bool useQuotes)
    {
        var iterator = dictionary.GetEnumerator();
        StringBuilder builder = new();

        if (iterator.MoveNext())
            builder.AppendKeyValuePair(
                Stringify(iterator.Key, depth, useQuotes),
                Stringify(iterator.Value, depth, useQuotes)
            );

        var i = 0;

        while (iterator.MoveNext())
        {
            if (checked(++i) >= MaxIteration)
            {
                builder.Append(Separator).Append(Etcetera(dictionary.Count - i));
                break;
            }

            builder
               .Append(Separator)
               .AppendKeyValuePair(
                    Stringify(iterator.Key, depth, useQuotes),
                    Stringify(iterator.Value, depth, useQuotes)
                );
        }

        return builder;
    }

#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    static StringBuilder UnfoldedName(this Type? type, StringBuilder builder)
    {
        StringBuilder Append(Type x)
        {
            builder.Append(',').Append(' ');
            return x.UnfoldedName(builder);
        }

        if (type is null)
            return builder;

        if (s_unfoldedNames.TryGetValue(type, out var val))
            return builder.Append(val);

        if (type.GetElementType() is { } underlying)
            return UnfoldedElementName(type, builder, underlying);

        var name = type.Name;

        if (!type.IsGenericType)
            return builder.Append(name);

        var len = name.IndexOf('`') is var i && i is -1 ? name.Length : i;
        var types = type.GetGenericArguments();

        types.FirstOrDefault()?.UnfoldedName(builder.Append(name, 0, len).Append('<'));
        types.Skip(1).Select(Append).Enumerate();

        return builder.Append('>');
    }

    static StringBuilder UnfoldedElementName(Type type, StringBuilder builder, Type underlying)
    {
        if (type.IsByRef)
            builder.Append('r').Append('e').Append('f').Append(' ');

        var underlyingName = UnfoldedName(underlying);
        builder.Append(underlyingName);

        if (type.IsArray)
            builder.Append('[').Append(']');

        if (type.IsPointer)
            builder.Append('*');

        return builder;
    }
#endif
#if !NETFRAMEWORK || NET40_OR_GREATER
    sealed class FakeComparer(int depth) : IComparer, IEqualityComparer
    {
        StringBuilder? _builder;

        /// <inheritdoc />
        public override string ToString() =>
            _builder?.Remove(_builder.Length - Separator.Length, Separator.Length).Append(')').ToString() ?? "()";

        /// <inheritdoc />
        bool IEqualityComparer.Equals(object? x, object? y) => Append(x, true);

        /// <inheritdoc />
        int IComparer.Compare(object? x, object? y) => Append(x, 0);

        /// <inheritdoc />
        int IEqualityComparer.GetHashCode(object? obj) => Append(obj, 0);

        T Append<T>(object? obj, T ret)
        {
#pragma warning disable RCS1196
            (_builder ??= new("(")).Append(Stringify(obj, depth)).Append(Separator);
#pragma warning restore RCS1196
            return ret;
        }
    }
#endif
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Contains a myriad of strings that list all whitespace characters.</summary>

    /// <summary>All unicode characters where <c>White_Space=yes</c>, and are line breaks.</summary>
    public const string Breaking = "\n\v\f\r\u0085\u2028\u2029";

    /// <summary>All unicode characters where <c>White_Space=yes</c>, and are not a line break.</summary>
    public const string NonBreaking =
        "\u0009\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000";

    /// <summary>All unicode characters where <c>White_Space=no</c>, but appears to be whitespace.</summary>
    public const string Related = "\u180E\u200B\u200C\u200D\u2060\uFEFF";

    /// <summary>All unicode characters where <c>White_Space=yes</c>.</summary>
    public const string Unicode = $"{Breaking}{NonBreaking}";

    /// <summary>All unicode characters that appear to be whitespace.</summary>
    public const string Combined = $"{Unicode}{Related}";
#if NET8_0_OR_GREATER
#pragma warning disable IDISP004
    /// <inheritdoc cref="Breaking"/>
    public static ReadOnlyMemory<SearchValues<char>> BreakingSearchMemory
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new OnceMemoryManager<SearchValues<char>>(SearchValues.Create(Breaking)).Memory;

    /// <inheritdoc cref="NonBreaking"/>
    public static ReadOnlyMemory<SearchValues<char>> NonBreakingSearchMemory
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } = new OnceMemoryManager<SearchValues<char>>(SearchValues.Create(NonBreaking)).Memory;

    /// <inheritdoc cref="Related"/>
    public static ReadOnlyMemory<SearchValues<char>> RelatedSearchMemory
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new OnceMemoryManager<SearchValues<char>>(SearchValues.Create(Related)).Memory;

    /// <inheritdoc cref="Unicode"/>
    public static ReadOnlyMemory<SearchValues<char>> UnicodeSearchMemory
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new OnceMemoryManager<SearchValues<char>>(SearchValues.Create(Unicode)).Memory;

    /// <inheritdoc cref="Combined"/>
    public static ReadOnlyMemory<SearchValues<char>> CombinedSearchMemory
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new OnceMemoryManager<SearchValues<char>>(SearchValues.Create(Combined)).Memory;
#pragma warning restore IDISP004
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable CheckNamespace RedundantNameQualifier




/// <summary>Provides extension methods for <see cref="char"/>.</summary>

    /// <summary>Removes the single character based on the index from the langword="string"/>.</summary>
    /// <param name="str">The builder to take the character from.</param>
    /// <param name="index">The index to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <returns>The parameter <paramref name="str"/>.</returns>
    public static string Pop(this string str, int index, out char popped)
    {
        if (index >= 0 && index < str.Length)
        {
            popped = str[index];
            return str.Remove(index, 1);
        }

        popped = default;
        return str;
    }

    /// <inheritdoc cref="Pop(StringBuilder, int, out char)"/>
    public static string Pop(this string str, Index index, out char popped) =>
        str.Pop(index.GetOffset(str.Length), out popped);

    /// <summary>Removes the substring based on the range from the langword="string"/>.</summary>
    /// <param name="str">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="str"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="str"/>.</returns>
    public static string Pop(this string str, Range range, out string popped)
    {
        range.GetOffsetAndLength(str.Length, out var startIndex, out var length);
        popped = str[range];
        return str.Remove(startIndex, length);
    }

    /// <summary>Removes the substring based on the range from the <see langword="string"/>.</summary>
    /// <param name="str">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="str"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="str"/>.</returns>
    public static string Remove(this string str, Range range)
    {
        range.GetOffsetAndLength(str.Length, out var startIndex, out var length);
        return str.Remove(startIndex, length);
    }

    /// <summary>Removes the single character based on the index from the <see cref="StringBuilder"/>.</summary>
    /// <param name="builder">The builder to take the character from.</param>
    /// <param name="index">The index to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
    public static StringBuilder Pop(this StringBuilder builder, int index, out char popped)
    {
        if (index >= 0 && index < builder.Length)
        {
            popped = builder[index];
            return builder.Remove(index, 1);
        }

        popped = default;
        return builder;
    }

    /// <inheritdoc cref="Pop(StringBuilder, int, out char)"/>
    public static StringBuilder Pop(this StringBuilder builder, Index index, out char popped) =>
        builder.Pop(index.GetOffset(builder.Length), out popped);

    /// <summary>Removes the substring based on the range from the <see cref="StringBuilder"/>.</summary>
    /// <param name="builder">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="builder"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
    public static StringBuilder Pop(this StringBuilder builder, Range range, out string popped)
    {
        range.GetOffsetAndLength(builder.Length, out var startIndex, out var length);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        popped = string.Create(
            length,
            (builder, startIndex),
            static (span, tuple) =>
            {
                var (builder, startIndex) = tuple;

                for (var i = 0; i < span.Length; i++)
                    span[i] = builder[i + startIndex];
            }
        );
#else
        StringBuilder poppedBuilder = new(length);

        for (var i = 0; i < length; i++)
            poppedBuilder[i] = builder[startIndex + i];

        popped = $"{poppedBuilder}";
#endif
        return builder.Remove(startIndex, length);
    }

    /// <summary>Removes the substring based on the range from the <see cref="StringBuilder"/>.</summary>
    /// <param name="builder">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="builder"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
    public static StringBuilder Remove(this StringBuilder builder, Range range)
    {
        range.GetOffsetAndLength(builder.Length, out var startIndex, out var length);
        return builder.Remove(startIndex, length);
    }

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent ConvertToStaticClass
// ReSharper disable once CheckNamespace


/// <summary>Defines methods for callbacks with spans. Methods here do not clear the allocated buffer.</summary>
/// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>

    /// <summary>Provides reinterpret span methods.</summary>
    /// <typeparam name="TTo">The type to convert to.</typeparam>
    public static class To<TTo>
    {
#pragma warning disable 8500, RCS1158
        /// <summary>
        /// Encapsulates the functionality to determine if a conversion is supported between two types.
        /// </summary>
        /// <typeparam name="TFrom">The type to convert from.</typeparam>
        public static class Is<TFrom>
        {
            /// <summary>
            /// Gets a value indicating whether the conversion between types
            /// <typeparamref name="TFrom"/> and <see cref="TTo"/> is defined.
            /// </summary>
            public static unsafe bool Supported { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
                typeof(TTo) == typeof(TFrom) ||
                sizeof(TFrom) >= sizeof(TTo) &&
                IsReinterpretable(typeof(TFrom), typeof(TTo));

            /// <summary>
            /// Gets the error that occurs when converting between types would cause undefined behavior.
            /// </summary>
            public static NotSupportedException Error
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                get => new($"Cannot convert from {typeof(TFrom).Name} to {typeof(TTo).Name}.");
            }

            [Pure]
            static bool IsReinterpretable(Type first, Type second) =>
                first.FindPathToNull(Next).CartesianProduct(second.FindPathToNull(Next)).Any(x => x.First == x.Second);

            [Pure]
            static Type? Next(Type x) => x.IsValueType && x.GetFields() is [{ FieldType: var y }] ? y : null;
        }

        /// <summary>
        /// Converts a <see cref="ReadOnlySpan{T}"/> of type <typeparamref name="TFrom"/>
        /// to a <see cref="ReadOnlySpan{T}"/> of type <see cref="TTo"/>.
        /// </summary>
        /// <typeparam name="TFrom">The type to convert from.</typeparam>
        /// <param name="source">The <see cref="ReadOnlySpan{T}"/> to convert from.</param>
        /// <exception cref="NotSupportedException">
        /// Thrown when <see cref="Is{TFrom}.Supported"/> is <see langword="false"/>.
        /// </exception>
        /// <returns>
        /// The reinterpretation of the parameter <paramref name="source"/> from its original
        /// type <typeparamref name="TFrom"/> to the destination type <see cref="TTo"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static unsafe ReadOnlySpan<TTo> From<TFrom>(ReadOnlySpan<TFrom> source) =>
            typeof(TTo) == typeof(TFrom) || Is<TFrom>.Supported ? *(ReadOnlySpan<TTo>*)&source : throw Is<TFrom>.Error;

        /// <summary>
        /// Converts a <see cref="Span{T}"/> of type <typeparamref name="TFrom"/>
        /// to a <see cref="Span{T}"/> of type <see cref="TTo"/>.
        /// </summary>
        /// <typeparam name="TFrom">The type to convert from.</typeparam>
        /// <param name="source">The <see cref="Span{T}"/> to convert from.</param>
        /// <exception cref="NotSupportedException">Thrown when conversion between the types TFrom and TTo is not supported.</exception>
        /// <returns>
        /// The reinterpretation of the parameter <paramref name="source"/> from its original
        /// type <typeparamref name="TFrom"/> to the destination type <see cref="TTo"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static unsafe Span<TTo> From<TFrom>(Span<TFrom> source) =>
            typeof(TTo) == typeof(TFrom) || Is<TFrom>.Supported ? *(Span<TTo>*)&source : throw Is<TFrom>.Error;
#pragma warning restore 8500, RCS1158
    }

    /// <summary>A callback for a span.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <param name="span">The allocated span.</param>
    public delegate void SpanAction<TSpan>(scoped Span<TSpan> span);

    /// <summary>A callback for a span with a reference parameter.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <param name="param">The parameter.</param>
    public delegate void SpanAction<TSpan, in TParam>(scoped Span<TSpan> span, TParam param);

    /// <summary>A callback for a span with a reference parameter that is also a span, but immutable.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <param name="param">The span parameter.</param>
    public delegate void SpanActionReadOnlySpan<TSpan, TParam>(scoped Span<TSpan> span, ReadOnlySpan<TParam> param);

    /// <summary>A callback for a span with a reference parameter that is also a span.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TParam">The inner type of the span parameter.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <param name="param">The span parameter.</param>
    public delegate void SpanActionSpan<TSpan, TParam>(scoped Span<TSpan> span, Span<TParam> param);

    /// <summary>A callback for a span with a return value.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <returns>The returned value of this delegate.</returns>
    public delegate TResult SpanFunc<TSpan, out TResult>(scoped Span<TSpan> span);

    /// <summary>A callback for a span with a reference parameter with a return value.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <param name="param">The parameter.</param>
    /// <returns>The returned value of this delegate.</returns>
    public delegate TResult SpanFunc<TSpan, in TParam, out TResult>(scoped Span<TSpan> span, TParam param);

    /// <summary>A callback for a span with a reference parameter that is also a span, with a return value.</summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <param name="param">The span parameter.</param>
    /// <returns>The returned value of this delegate.</returns>
    public delegate TResult SpanFuncReadOnlySpan<TSpan, TParam, out TResult>(
        scoped Span<TSpan> span,
        ReadOnlySpan<TParam> param
    );

    /// <summary>
    /// A callback for a span with a reference parameter that is also a span, but immutable, with a return value.
    /// </summary>
    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
    /// <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="span">The allocated span.</param>
    /// <param name="param">The span parameter.</param>
    /// <returns>The returned value of this delegate.</returns>
    public delegate TResult SpanFuncSpan<TSpan, TParam, out TResult>(scoped Span<TSpan> span, Span<TParam> param);

    /// <summary>The maximum size for the number of bytes a stack allocation will occur in this class.</summary>
    /// <remarks><para>
    /// Stack allocating arrays is an incredibly powerful tool that gets rid of a lot of the overhead that comes from
    /// instantiating arrays normally. Notably, that all classes (such as <see cref="Array"/> or <see cref="List{T}"/>)
    /// are heap allocated, and moreover are garbage collected. This can put a strain in methods that are called often.
    /// </para><para>
    /// However, there isn't as much stack memory available as there is heap, which can cause a DoS (Denial of Service)
    /// vulnerability if you aren't careful. The methods in <c>Span</c> will automatically switch to unmanaged heap
    /// allocation if the type argument and length create an array that exceeds 1kiB (1024 bytes).
    /// </para></remarks>
    public const int StackallocSize = 1 << 10;
#if !NETSTANDARD1_0
    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="del">The callback to invoke.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Allocate(
        [NonNegativeValue] int length,
        [InstantHandle, RequireStaticDelegate] SpanAction<byte> del
    ) =>
        Allocate<byte>(length, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="del">The callback to invoke.</param>
    public static unsafe void Allocate<TSpan>(
        int length,
        [InstantHandle, RequireStaticDelegate] SpanAction<TSpan> del
    )
        where TSpan : unmanaged
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
        {
            del(stackalloc TSpan[value]);
            return;
        }

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            del(new((void*)ptr, value));
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TParam">The type of the parameter.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Allocate<TParam>(
        int length,
        TParam param,
        [InstantHandle, RequireStaticDelegate] SpanAction<byte, TParam> del
    ) =>
        Allocate<byte, TParam>(length, param, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    public static unsafe void Allocate<TSpan, TParam>(
        int length,
        TParam param,
        [InstantHandle, RequireStaticDelegate] SpanAction<TSpan, TParam> del
    )
        where TSpan : unmanaged
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
        {
            del(stackalloc TSpan[value], param);
            return;
        }

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            del(new((void*)ptr, value), param);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Allocate<TParam>(
        int length,
        scoped ReadOnlySpan<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanActionReadOnlySpan<byte, TParam> del
    )
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
        =>
            Allocate<byte, TParam>(length, param, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    public static unsafe void Allocate<TSpan, TParam>(
        int length,
        scoped ReadOnlySpan<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanActionReadOnlySpan<TSpan, TParam> del
    )
        where TSpan : unmanaged
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
        {
            del(stackalloc TSpan[value], param);
            return;
        }

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            del(new((void*)ptr, value), param);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Allocate<TParam>(
        int length,
        scoped Span<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanActionSpan<byte, TParam> del
    )
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
        =>
            Allocate<byte, TParam>(length, param, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    public static unsafe void Allocate<TSpan, TParam>(
        int length,
        scoped Span<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanActionSpan<TSpan, TParam> del
    )
        where TSpan : unmanaged
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
        {
            del(stackalloc TSpan[value], param);
            return;
        }

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            del(new((void*)ptr, value), param);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }
#endif

    /// <summary>Gets the reference that whose address is within the null range.</summary>
    /// <remarks><para>
    /// This is a highly unsafe function. The runtime reserves the first 2kiB for null-behaving values, which means a
    /// valid reference will never be within this range. This allows reference types to be a disjoint union of a valid
    /// reference, and an 11-bit number. Be careful with the values returned by this function: <see langword="null"/>
    /// comparisons can <see langword="return"/> <see langword="false"/>, but will behave as such.
    /// </para></remarks>
    /// <typeparam name="T">The type of the nullable reference type.</typeparam>
    /// <param name="reference">
    /// The resulting reference that contains the address of the parameter <paramref name="address"/>.
    /// </param>
    /// <param name="address">The number to set.</param>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void UnsafelySetNullishTo<T>(out T? reference, byte address)
        where T : class
    {
#pragma warning disable 8500
        fixed (T* ptr = &reference)
#pragma warning restore 8500
            *(nuint*)ptr = address;
    }

    /// <summary>Determines if a given length and type should be stack-allocated.</summary>
    /// <remarks><para>
    /// See <see cref="StackallocSize"/> for details about stack- and heap-allocation.
    /// </para></remarks>
    /// <typeparam name="T">The type of array.</typeparam>
    /// <param name="length">The amount of items.</param>
    /// <returns>
    /// The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsStack<T>([NonNegativeValue] int length) => InBytes<T>(length) <= StackallocSize;

    /// <summary>Gets the byte length needed to allocate the current length, used in <see cref="IsStack{T}"/>.</summary>
    /// <typeparam name="T">The type of array.</typeparam>
    /// <param name="length">The amount of items.</param>
    /// <returns>
    /// The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure] // ReSharper disable once RedundantUnsafeContext
    public static unsafe int InBytes<T>([NonNegativeValue] int length) =>
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
        length * Unsafe.SizeOf<T>();
#else
#pragma warning disable 8500
        length * sizeof(T);
#pragma warning restore 8500
#endif // ReSharper disable RedundantUnsafeContext

    /// <summary>Returns the memory address of a given reference object.</summary>
    /// <remarks><para>The value is not pinned; do not read values from this location.</para></remarks>
    /// <param name="reference">The reference <see cref="object"/> for which to get the address.</param>
    /// <returns>The memory address of the reference object.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable 8500
    public static unsafe nuint ToAddress(this object? reference) => *(nuint*)&reference;
#pragma warning restore 8500
#pragma warning disable 9091 // InlineAttribute makes this okay.
#pragma warning disable RCS1242 // Normally causes defensive copies; Parameter is unused though.
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <summary>Allocates an inlined span of the specified size.</summary>
    /// <remarks><para>
    /// The returned <see cref="Span{T}"/> will point to uninitialized memory.
    /// Be sure to call <see cref="Span{T}.Fill"/> or otherwise written to first before enumeration or reading.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <param name="_">The discard, which is used to let the compiler track lifetimes.</param>
    /// <returns>The <see cref="Span{T}"/> of the specified size.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL // ReSharper disable once NullableWarningSuppressionIsUsed
    public static Span<T> Inline1<T>(in T _ = default!)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            Ref(ref AsRef(_));
#else
    public static unsafe Span<T> Inline1<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out T x);
        return Ref(ref x);
    }
#endif
#endif
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline2<T>(in Two<T> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<T>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline2<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<T> x);
        return PooledSmallList<T>.Validate<Two<T>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline4<T>(in Two<Two<T>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<T>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline4<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<T>> x);
        return PooledSmallList<T>.Validate<Two<Two<T>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline8<T>(in Two<Two<Two<T>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<T>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline8<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<T>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<T>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline16<T>(in Two<Two<Two<Two<T>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<Two<T>>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline16<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<T>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<T>>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline32<T>(in Two<Two<Two<Two<Two<T>>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<T>>>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline32<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<Two<T>>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<T>>>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline64<T>(in Two<Two<Two<Two<Two<Two<T>>>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<T>>>>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline64<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<Two<Two<T>>>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<T>>>>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline128<T>(in Two<Two<Two<Two<Two<Two<Two<T>>>>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline128<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<Two<Two<Two<T>>>>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline256<T>(in Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline256<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline512<T>(in Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>>.AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline512<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>>.AsSpan(ref x);
    }
#endif

    /// <inheritdoc cref="Inline1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static Span<T> Inline1024<T>(in Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>> _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            PooledSmallList<T>
               .Validate<Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>>>
               .AsSpan(ref AsRef(_));
#else
    public static unsafe Span<T> Inline1024<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>> x);
        return PooledSmallList<T>.Validate<Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>>>.AsSpan(ref x);
    }
#endif
#endif
#pragma warning restore RCS1242
    /// <summary>Creates a new <see cref="Span{T}"/> of length 1 around the specified reference.</summary>
    /// <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> Ref<T>(ref T reference) =>
#if NET7_0_OR_GREATER
        new(ref reference);
#else
        MemoryMarshal.CreateSpan(ref reference, 1);
#endif

    /// <summary>Creates a new reinterpreted <see cref="Span{T}"/> over the specified reference.</summary>
    /// <typeparam name="TFrom">The source type.</typeparam>
    /// <typeparam name="TTo">The destination type.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    public static unsafe Span<TTo> Ref<TFrom, TTo>(ref TFrom reference)
        where TFrom : struct
        where TTo : struct =>
        MemoryMarshal.Cast<TFrom, TTo>(Ref(ref reference));
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <summary>Creates a new <see cref="ReadOnlySpan{T}"/> of length 1 around the specified reference.</summary>
    /// <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> In<T>(in T reference) =>
#if NET8_0_OR_GREATER || CSHARPREPL
        new(ref AsRef(reference));
#elif NET7_0_OR_GREATER
        new(AsRef(reference));
#else
        MemoryMarshal.CreateReadOnlySpan(ref AsRef(reference), 1);
#endif

    /// <summary>Creates a new reinterpreted <see cref="ReadOnlySpan{T}"/> over the specified reference.</summary>
    /// <typeparam name="TFrom">The source type.</typeparam>
    /// <typeparam name="TTo">The destination type.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    public static unsafe ReadOnlySpan<TTo> In<TFrom, TTo>(in TFrom reference)
        where TFrom : struct
        where TTo : struct =>
        MemoryMarshal.Cast<TFrom, TTo>(In(reference));
#endif
#if !NETSTANDARD1_0
    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public static TResult Allocate<TResult>(
        int length,
        [InstantHandle, RequireStaticDelegate] SpanFunc<byte, TResult> del
    ) =>
        Allocate<byte, TResult>(length, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MustUseReturnValue]
    public static unsafe TResult Allocate<TSpan, TResult>(
        int length,
        [InstantHandle, RequireStaticDelegate] SpanFunc<TSpan, TResult> del
    )
        where TSpan : unmanaged
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
            return del(stackalloc TSpan[value]);

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            return del(new((void*)ptr, value));
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TParam">The type of the parameter.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public static TResult Allocate<TParam, TResult>(
        int length,
        TParam param,
        [InstantHandle, RequireStaticDelegate] SpanFunc<byte, TParam, TResult> del
    ) =>
        Allocate<byte, TParam, TResult>(length, param, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MustUseReturnValue]
    public static unsafe TResult Allocate<TSpan, TParam, TResult>(
        int length,
        TParam param,
        [InstantHandle, RequireStaticDelegate] SpanFunc<TSpan, TParam, TResult> del
    )
        where TSpan : unmanaged
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
            return del(stackalloc TSpan[value], param);

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            return del(new((void*)ptr, value), param);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public static TResult Allocate<TParam, TResult>(
        int length,
        scoped ReadOnlySpan<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanFuncReadOnlySpan<byte, TParam, TResult> del
    )
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
        =>
            Allocate<byte, TParam, TResult>(length, param, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MustUseReturnValue]
    public static unsafe TResult Allocate<TSpan, TParam, TResult>(
        int length,
        scoped ReadOnlySpan<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanFuncReadOnlySpan<TSpan, TParam, TResult> del
    )
        where TSpan : unmanaged
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
            return del(stackalloc TSpan[value], param);

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            return del(new((void*)ptr, value), param);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public static TResult Allocate<TParam, TResult>(
        int length,
        scoped Span<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanFuncSpan<byte, TParam, TResult> del
    )
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
        =>
            Allocate<byte, TParam, TResult>(length, param, del);

    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
    /// <remarks><para>See <see cref="StackallocSize"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
    /// <typeparam name="TResult">The return type.</typeparam>
    /// <param name="length">The length of the buffer.</param>
    /// <param name="param">The parameter to pass in.</param>
    /// <param name="del">The callback to invoke.</param>
    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
    [MustUseReturnValue]
    public static unsafe TResult Allocate<TSpan, TParam, TResult>(
        int length,
        scoped Span<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanFuncSpan<TSpan, TParam, TResult> del
    )
        where TSpan : unmanaged
#if UNMANAGED_SPAN
        where TParam : unmanaged
#endif
    {
        var value = Math.Max(length, 0);

        if (IsStack<TSpan>(length))
            return del(stackalloc TSpan[value], param);

        var ptr = Marshal.AllocHGlobal(value);

        try
        {
            return del(new((void*)ptr, value), param);
        }
        finally
        {
            Marshal.FreeHGlobal(ptr);
        }
    }
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <summary>Reinterprets the given read-only reference as a mutable reference.</summary>
    /// <typeparam name="T">The underlying type of the reference.</typeparam>
    /// <param name="source">The read-only reference to reinterpret.</param>
    /// <returns>A mutable reference to a value of type <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable 8500
    public static unsafe ref T AsRef<T>(in T source)
    {
        fixed (T* ptr = &source)
            return ref Unsafe.AsRef<T>(ptr);
    }
#pragma warning restore 8500
#endif
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace EmptyNamespace


/// <summary>Efficient LINQ-like methods for <see cref="ReadOnlySpan{T}"/> and siblings.</summary>
// ReSharper disable NullableWarningSuppressionIsUsed
#pragma warning disable MA0048

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> Where<T>(
        this IMemoryOwner<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    ) =>
        source.Memory[..^Filter(source.Memory.Span, predicate)];

    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> Where<T>(
        this Memory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    ) =>
        source[..^Filter(source.Span, predicate)];
#endif

    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Where<T>(
        this Span<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            source[..^Filter(source, predicate)];

    // Surprisingly, direct indexing is more efficient than .CopyTo despite latter guaranteeing SIMD.
    // Benchmarked with various sizes and on function "static x => BitOperations.PopCount(x) % 2 is 0".
    // This function was chosen as the baseline due to it being cheap to compute, evenly distributed,
    // and ensuring all patterns of [[false, false], [false, true], [true, false], [true, true]] would appear.
    // ReSharper disable CommentTypo
    // https://sharplab.io/#v2:D4AQTAjAsAULIQGwAICWA7ALsg6gCwFMAnAgSXXWIB4AVAPgApZkXkBlABwEN1a7kAzgHsArkQDGBADTNWABRIATVOK6YCfZByUq1BWAEpYAb1ksAZkKLIGANy7XUyALzIADAG40yKoNESCADoAGQJ0AHNMPC9UAGpYoxhWZFMk5NZUcxttAmVVdQZhMUkAbVQAXQNE9JrkcSEsDBECD1gzdPtrAUwHbFdUVrg0msUhdtq0LIZ4pzpXIoCQsMi8aonakAB2QR6iTEGJgHc8VAAbAhsAQhy8vUL/UoqqwfHWTuRlAQ5TrkkAWzCfW8AFodr0DrUFo9AoFyoEAMJCDgATxoQnuxQIJW6vRhlQhNShF3mDyxMIAep9vr8CACsOUCeknMDXFSfv9AYyAL5tYbILZ+TFLCJRQZcoA
    // https://cdn.discordapp.com/attachments/445375602648940544/1129045669148098610/image.png
    // ReSharper restore CommentTypo

    [NonNegativeValue, MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int Filter<T>(Span<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> predicate)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        var end = 0;

        for (var i = 0; i < source.Length; i++)
        {
            if (IsPass(ref source, predicate, i, end))
                continue;

            var start = i;

            if (!FindNextPass(source, predicate, ref i))
                return end + i - start;

            end += i - start;
            source[i - end] = source[i];
        }

        return end;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IsPass<T>(ref Span<T> source, Predicate<T> predicate, int i, int end)
    {
        if (!predicate(source[i]))
            return false;

        if (end > 0)
            source[i - end] = source[i];

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool FindNextPass<T>(in ReadOnlySpan<T> source, Predicate<T> predicate, ref int i)
    {
        do
            if (++i >= source.Length)
                return false;
        while (!predicate(source[i]));

        return true;
    }

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable CheckNamespace ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator LoopCanBeConvertedToQuery MergeIntoPattern NullableWarningSuppressionIsUsed RedundantUsingDirective SuggestBaseTypeForParameter

#pragma warning disable 1574, 8500, MA0051


/// <summary>Provides the method to convert spans.</summary>

#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Raw{T}(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe byte[] Raw<T>(scoped PooledSmallList<T> value) =>
        [.. MemoryMarshal.CreateReadOnlySpan(ref Unsafe.AsRef<byte>(&value), sizeof(PooledSmallList<T>))];
#endif

    /// <inheritdoc cref="Raw{T}(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe byte[] Raw<T>(scoped Span<T> value) =>
        [.. MemoryMarshal.CreateReadOnlySpan(ref *(byte*)&value, sizeof(Span<T>))];

    /// <inheritdoc cref="Raw{T}(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe byte[] Raw<TBody, TSeparator, TStrategy>(scoped SplitSpan<TBody, TSeparator, TStrategy> value)
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>?
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            [.. MemoryMarshal.CreateReadOnlySpan(ref *(byte*)&value, sizeof(SplitSpan<TBody, TSeparator, TStrategy>))];

    /// <inheritdoc cref="Raw{T}(T)" />
#pragma warning restore 1574
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe byte[] Raw<T>(scoped ReadOnlySpan<T> value) =>
       [.. MemoryMarshal.CreateReadOnlySpan(ref *(byte*)&value, sizeof(ReadOnlySpan<T>))];
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <summary>Reads the raw memory of the object.</summary>
    /// <typeparam name="T">The type of value to read.</typeparam>
    /// <param name="value">The value to read.</param>
    /// <returns>The raw memory of the parameter <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static byte[] Raw<T>(T value) =>
        [.. MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<T, byte>(ref value), Unsafe.SizeOf<T>())];
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace

#pragma warning disable IDE0056, SA1137
/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
// ReSharper disable BadPreprocessorIndent ConditionIsAlwaysTrueOrFalse UseIndexFromEndExpression

    /// <summary>Separates the head from the tail of a <see cref="Span{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="span"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="span"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deconstruct<T>(this Span<T> span, out T? head, out Span<T> tail)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (span.IsEmpty)
        {
            head = default;
            tail = default;
            return;
        }

        head = span[0];
        tail = span[1..];
    }

    /// <summary>Separates the head from the tail of a <see cref="ReadOnlySpan{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="span"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="span"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deconstruct<T>(this ReadOnlySpan<T> span, out T? head, out ReadOnlySpan<T> tail)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (span.IsEmpty)
        {
            head = default;
            tail = default;
            return;
        }

        head = span[0];
        tail = span[1..];
    }
#if !NET7_0_OR_GREATER
    /// <inheritdoc cref="IndexOfAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>?
#else
        where T : IEquatable<T>?
#endif
        =>
            ((ReadOnlySpan<T>)span).IndexOfAny(values);

    /// <summary>
    /// Searches for the first index of any of the specified values similar
    /// to calling IndexOf several times with the logical OR operator.
    /// </summary>
    /// <typeparam name="T">The type of the span and values.</typeparam>
    /// <param name="span">The span to search.</param>
    /// <param name="values">The set of values to search for.</param>
    /// <returns>The first index of the occurrence of any of the values in the span. If not found, returns -1.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>?
#else
        where T : IEquatable<T>?
#endif
    {
#pragma warning disable 8500
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var searchSpace = (T*)span.Pointer;
        var value = (T*)values.Pointer;
#else
        fixed (T* searchSpace = span)
        fixed (T* value = values)
#endif
#pragma warning restore 8500
            return SpanHelpers.IndexOfAny(searchSpace, span.Length, value, values.Length);
    }
#endif

    /// <summary>Gets the specific slice from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> Nth<T>(this ReadOnlySpan<T> span, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            range.TryGetOffsetAndLength(span.Length, out var offset, out var length)
                ? span.Slice(offset, length)
                : default;

    /// <summary>Gets the specific slice from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> Nth<T>(this Span<T> span, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            range.TryGetOffsetAndLength(span.Length, out var offset, out var length)
                ? span.Slice(offset, length)
                : default;

    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped ReadOnlySpan<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index >= 0 && index < span.Length ? span[index] : default;

    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped ReadOnlySpan<T> span, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (index.IsFromEnd ? span.Length - index.Value : index.Value) is >= 0 and var offset && offset < span.Length
                ? span[offset]
                : default;

    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this scoped ReadOnlySpan<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index > 0 && index <= span.Length ? span[span.Length - index] : default;

    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped Span<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index >= 0 && index < span.Length ? span[index] : default;

    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped Span<T> span, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (index.IsFromEnd ? span.Length - index.Value : index.Value) is >= 0 and var offset && offset < span.Length
                ? span[offset]
                : default;

    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this scoped Span<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index > 0 && index <= span.Length ? span[span.Length - index] : default;

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace EmptyNamespace


/// <summary>Efficient LINQ-like methods for <see cref="ReadOnlySpan{T}"/> and siblings.</summary>
// ReSharper disable NullableWarningSuppressionIsUsed
#pragma warning disable MA0048

    /// <summary>Determines whether the type is a numeric primitive.</summary>
    /// <typeparam name="T">The type to test.</typeparam>
    /// <returns>Whether the type parameter <typeparamref name="T"/> is a primitive representing a number.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsNumericPrimitive<T>() =>
        typeof(T) == typeof(byte) ||
        typeof(T) == typeof(double) ||
        typeof(T) == typeof(float) ||
        typeof(T) == typeof(int) ||
        typeof(T) == typeof(long) ||
        typeof(T) == typeof(nint) ||
        typeof(T) == typeof(nuint) ||
        typeof(T) == typeof(sbyte) ||
        typeof(T) == typeof(short) ||
        typeof(T) == typeof(uint) ||
        typeof(T) == typeof(ulong) ||
        typeof(T) == typeof(ushort);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.All{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool All<T>(this IMemoryOwner<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> func) =>
        All((ReadOnlySpan<T>)source.Memory.Span, func);

    /// <inheritdoc cref="Enumerable.All{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool All<T>(this Memory<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> func) =>
        All((ReadOnlySpan<T>)source.Span, func);
#endif

    /// <inheritdoc cref="Enumerable.All{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool All<T>(this scoped Span<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> func)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            All((ReadOnlySpan<T>)source, func);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.All{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool All<T>(
        this ReadOnlyMemory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> func
    ) =>
        All(source.Span, func);
#endif

    /// <inheritdoc cref="Enumerable.All{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool All<T>(
        this scoped ReadOnlySpan<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> func
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        foreach (var next in source)
            if (!func(next))
                return false;

        return true;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Any{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Any<T>(this IMemoryOwner<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> func) =>
        Any((ReadOnlySpan<T>)source.Memory.Span, func);

    /// <inheritdoc cref="Enumerable.Any{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Any<T>(this Memory<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> func) =>
        Any((ReadOnlySpan<T>)source.Span, func);
#endif

    /// <inheritdoc cref="Enumerable.Any{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Any<T>(this scoped Span<T> source, [InstantHandle, RequireStaticDelegate] Predicate<T> func)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            Any((ReadOnlySpan<T>)source, func);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Any{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Any<T>(
        this ReadOnlyMemory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> func
    ) =>
        Any(source.Span, func);
#endif

    /// <inheritdoc cref="Enumerable.Any{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Any<T>(
        this scoped ReadOnlySpan<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> func
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        foreach (var next in source)
            if (func(next))
                return true;

        return false;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Select{T, TResult}(IEnumerable{T}, Func{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IMemoryOwner<T> Select<T>(
        this IMemoryOwner<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, T> selector
    )
    {
        Select(source.Memory.Span, selector);
        return source;
    }

    /// <inheritdoc cref="Enumerable.Select{T, TResult}(IEnumerable{T}, Func{T, int, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IMemoryOwner<T> Select<T>(
        this IMemoryOwner<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, int, T> selector
    )
    {
        Select(source.Memory.Span, selector);
        return source;
    }

    /// <inheritdoc cref="Enumerable.Select{T, TResult}(IEnumerable{T}, Func{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> Select<T>(this Memory<T> source, [InstantHandle, RequireStaticDelegate] Func<T, T> selector)
    {
        Select(source.Span, selector);
        return source;
    }

    /// <inheritdoc cref="Enumerable.Select{T, TResult}(IEnumerable{T}, Func{T, int, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> Select<T>(
        this Memory<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, int, T> selector
    )
    {
        Select(source.Span, selector);
        return source;
    }
#endif

    /// <inheritdoc cref="Enumerable.Select{T, TResult}(IEnumerable{T}, Func{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Select<T>(this Span<T> source, [InstantHandle, RequireStaticDelegate] Func<T, T> selector)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        for (var i = 0; i < source.Length; i++)
            source[i] = selector(source[i]);

        return source;
    }

    /// <inheritdoc cref="Enumerable.Select{T, TResult}(IEnumerable{T}, Func{T, int, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Select<T>(
        this Span<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, int, T> selector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        for (var i = 0; i < source.Length; i++)
            source[i] = selector(source[i], i);

        return source;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
#if NET6_0_OR_GREATER
    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(
        this Memory<T> span,
        ReadOnlyMemory<T> other,
        IEqualityComparer<T>? comparer = null
    ) =>
        span.Span.SequenceEqual(other.Span, comparer);

    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(
        this ReadOnlyMemory<T> span,
        ReadOnlyMemory<T> other,
        IEqualityComparer<T>? comparer = null
    ) =>
        span.Span.SequenceEqual(other.Span, comparer);
#else
    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(this Memory<T> span, ReadOnlyMemory<T> other)
        where T : IEquatable<T>? =>
        span.Span.SequenceEqual(other.Span);

    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(this ReadOnlyMemory<T> span, ReadOnlyMemory<T> other)
        where T : IEquatable<T>? =>
        span.Span.SequenceEqual(other.Span);
#endif

    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> SkipWhile<T>(
        this IMemoryOwner<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    ) =>
        SkipWhile(source.Memory, predicate);

    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> SkipWhile<T>(
        this Memory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
    {
        var span = source.Span;

        for (var i = 0; i < source.Length; i++)
            if (!predicate(span[i]))
                return source[i..];

        return source;
    }
#endif

    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> SkipWhile<T>(
        this Span<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        for (var i = 0; i < source.Length; i++)
            if (!predicate(source[i]))
                return source[i..];

        return source;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlyMemory<T> SkipWhile<T>(
        this ReadOnlyMemory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
    {
        var span = source.Span;

        for (var i = 0; i < source.Length; i++)
            if (!predicate(span[i]))
                return source[i..];

        return source;
    }
#endif

    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> SkipWhile<T>(
        this ReadOnlySpan<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        for (var i = 0; i < source.Length; i++)
            if (!predicate(source[i]))
                return source[i..];

        return source;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> TakeWhile<T>(
        this IMemoryOwner<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    ) =>
        TakeWhile(source.Memory, predicate);

    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> TakeWhile<T>(
        this Memory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
    {
        var span = source.Span;

        for (var i = 0; i < source.Length; i++)
            if (predicate(span[i]))
                return source[..i];

        return source;
    }
#endif

    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> TakeWhile<T>(
        this Span<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        for (var i = 0; i < source.Length; i++)
            if (predicate(source[i]))
                return source[..i];

        return source;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlyMemory<T> TakeWhile<T>(
        this ReadOnlyMemory<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
    {
        var span = source.Span;

        for (var i = 0; i < source.Length; i++)
            if (predicate(span[i]))
                return source[..i];

        return source;
    }
#endif

    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, bool})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> TakeWhile<T>(
        this ReadOnlySpan<T> source,
        [InstantHandle, RequireStaticDelegate] Predicate<T> predicate
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        for (var i = 0; i < source.Length; i++)
            if (predicate(source[i]))
                return source[..i];

        return source;
    }

// SPDX-License-Identifier: MPL-2.0
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
// ReSharper disable once CheckNamespace EmptyNamespace RedundantUsingDirective




/// <inheritdoc cref="SpanQueries"/>
// ReSharper disable NullableWarningSuppressionIsUsed RedundantSuppressNullableWarningExpression
#pragma warning disable MA0048

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Range{T}(Span{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this IMemoryOwner<T> source) => Range(source.Memory.Span);

    /// <inheritdoc cref="Range{T}(Span{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this Memory<T> source) => Range(source.Span);
#endif

    /// <summary>Creates the range.</summary>
    /// <typeparam name="T">The type of number.</typeparam>
    /// <param name="source">The <see cref="Span{T}"/> to mutate.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this Span<T> source)
    {
        switch (source.Length)
        {
            case 0: return source;
            case 1:
                MemoryMarshal.GetReference(source) = default!;
                return source;
            case var length:
                if (!IsNumericPrimitive<T>() && !IsSupported<T>())
                    Fail<T>();

                InAscendingOrder<T>.UpTo(length).CopyTo(source);
                return source;
        }
    }

    static class InAscendingOrder<T>
    {
        // Vector512<T> is the largest vector type.
        const int InitialCapacity = 512;

        static T[] s_values = new T[InitialCapacity / Unsafe.SizeOf<T>()];

        static InAscendingOrder() => Populate(s_values);

        /// <summary>Gets the read-only span containing the set of values up to the specified parameter.</summary>
        /// <param name="length">The amount of items required.</param>
        /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
        /// <returns>
        /// The <see cref="ReadOnlySpan{T}"/> containing a range from 0 to <paramref name="length"/> - 1.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<T> UpTo(int length)
        {
            ReadOnlySpan<T> original = s_values;

            if (length <= original.Length)
                return original[..length];

            var replacement = new T[((uint)length).RoundUpToPowerOf2()];
            Span<T> span = replacement;
            original.CopyTo(span);
            Populate(span[(original.Length - 1)..]);
            s_values = replacement;
            return span[..length];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void Populate(scoped Span<T> span)
        {
            for (var i = 1; i < span.Length; i++)
            {
                span[i] = span[i - 1];
                Increment(ref span[i]);
            }
        }
    }
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator InvertIf RedundantExtendsListEntry RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER

#pragma warning disable 8618, 9193, CA1823, IDE0250, MA0071, MA0102, RCS1158, SA1137





/// <summary>Methods to split spans into multiple spans.</summary>
#pragma warning disable MA0048

    /// <summary>
    /// Defines the values for <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/> without a compile-time strategy.
    /// </summary>
    /// <typeparam name="TBody">The type of element from the span.</typeparam>
    /// <typeparam name="TSeparator">The type of separator.</typeparam>
    public interface ISplitMemory<TBody, TSeparator> : IEnumerable<ReadOnlyMemory<TBody>>
    {
        /// <summary>Gets the body.</summary>
        public ReadOnlyMemory<TBody> Body { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }

        /// <summary>Gets the separator.</summary>
        public ReadOnlyMemory<TSeparator> Separator { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
    }

    /// <inheritdoc cref="SplitSpanFactory.SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAny> SplitAny<T>(this ReadOnlyMemory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        new(span, separator);

    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAny> SplitAny<T>(this Memory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        ((ReadOnlyMemory<T>)span).SplitAny(separator);

    /// <inheritdoc cref="SplitSpanFactory.SplitAll{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAll> SplitAll<T>(this ReadOnlyMemory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        new(span, separator);

    /// <inheritdoc cref="SplitAll{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAll> SplitAll<T>(this Memory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        ((ReadOnlyMemory<T>)span).SplitAll(separator);
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this ReadOnlyMemory<T> span,
        in OnceMemoryManager<SearchValues<T>> separator
    )
        where T : IEquatable<T> =>
        new(span, separator.Memory);

    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this Memory<T> span,
        OnceMemoryManager<SearchValues<T>> separator
    )
        where T : IEquatable<T> =>
        ((ReadOnlyMemory<T>)span).SplitOn(separator);
#endif
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchOne> SplitOn<T>(this ReadOnlyMemory<T> span, in OnceMemoryManager<T> separator)
        where T : IEquatable<T> =>
        new(span, separator.Memory);

    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchOne> SplitOn<T>(this Memory<T> span, in OnceMemoryManager<T> separator)
        where T : IEquatable<T> =>
        ((ReadOnlyMemory<T>)span).SplitOn(separator);
#endif

    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAny> SplitAny(this string span, string separator) =>
        span.AsMemory().SplitAny(separator.AsMemory());

    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAny> SplitAny(this string span, ReadOnlyMemory<char> separator) =>
        span.AsMemory().SplitAny(separator);

    /// <inheritdoc cref="SplitAll{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAll> SplitAll(this string span, string separator) =>
        span.AsMemory().SplitAll(separator.AsMemory());

    /// <inheritdoc cref="SplitAll{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAll> SplitAll(this string span, ReadOnlyMemory<char> separator) =>
        span.AsMemory().SplitAll(separator);

    /// <inheritdoc cref="SplitLines(ReadOnlyMemory{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this string span) =>
        span.AsMemory().SplitLines();

    /// <inheritdoc cref="SplitSpanFactory.SplitSpanLines"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this ReadOnlyMemory<char> span) =>
#if NET8_0_OR_GREATER
        new(span, BreakingSearchMemory);
#else
        new(span, Breaking.AsMemory());
#endif

    /// <inheritdoc cref="SplitLines(ReadOnlyMemory{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this Memory<char> span) =>
        ((ReadOnlyMemory<char>)span).SplitLines();

    // /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    // [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    // public static SplitMemory<char, char, One> SplitOn(this string span, in char separator) =>
    //     span.AsMemory().SplitOn(separator);

    /// <inheritdoc cref="SplitWhitespace(ReadOnlyMemory{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this string span) =>
        span.AsMemory().SplitWhitespace();

    /// <inheritdoc cref="SplitSpanFactory.SplitSpanWhitespace"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this ReadOnlyMemory<char> span) =>
#if NET8_0_OR_GREATER
        new(span, UnicodeSearchMemory);
#else
        new(span, Unicode.AsMemory());
#endif

    /// <inheritdoc cref="SplitWhitespace(ReadOnlyMemory{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this Memory<char> span) =>
        ((ReadOnlyMemory<char>)span).SplitWhitespace();

#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitAny{T}(ReadOnlyMemory{T}, ReadOnlyMemory{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, SearchValues<char>, MatchAny> SplitOn(
        this string span,
        in OnceMemoryManager<SearchValues<char>> separator
    ) =>
        span.AsMemory().SplitOn(separator);
#endif

/// <summary>Represents a split entry.</summary>
/// <typeparam name="TBody">The type of element from the span.</typeparam>
/// <typeparam name="TSeparator">The type of separator.</typeparam>
/// <typeparam name="TStrategy">The strategy for splitting elements.</typeparam>
[StructLayout(LayoutKind.Auto)]
[method: MethodImpl(MethodImplOptions.AggressiveInlining)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct SplitMemory<TBody, TSeparator, TStrategy>(
        ReadOnlyMemory<TBody> body,
        ReadOnlyMemory<TSeparator> separator
    ) : IEquatable<object>,
    IEquatable<ISplitMemory<TBody, TSeparator>>,
    IEquatable<SplitMemory<TBody, TSeparator, TStrategy>>,
    ISplitMemory<TBody, TSeparator>
    where TBody : IEquatable<TBody>?
#if !NET7_0_OR_GREATER
    where TSeparator : IEquatable<TSeparator>?
#endif
{
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Accumulator{TAccumulator}"/>
    public delegate TAccumulator RefAccumulator<TAccumulator>(
        TAccumulator accumulator,
        scoped in ReadOnlyMemory<TBody> next
    );

    readonly ReadOnlyMemory<TBody> _body = body;

    readonly ReadOnlyMemory<TSeparator> _separator = separator;

    /// <summary>
    /// Initializes a new instance of the <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/> struct.
    /// </summary>
    /// <param name="body">The line to split.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SplitMemory(ReadOnlyMemory<TBody> body)
        : this(body, default) { }

    /// <inheritdoc />
    public readonly ReadOnlyMemory<TBody> Body
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.First"/>
    public readonly ReadOnlyMemory<TBody> First
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Last"/>
    public readonly ReadOnlyMemory<TBody> Last
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetReversedEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }

    /// <inheritdoc />
    public readonly ReadOnlyMemory<TSeparator> Separator
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Single"/>
    public readonly ReadOnlyMemory<TBody> Single
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() && e.Current is var ret && !e.MoveNext() ? ret : default;
    }

    /// <summary>Gets itself as <see cref="SplitSpan{TBody, TSeparator, TStrategy}"/>.</summary>
    public readonly SplitSpan<TBody, TSeparator, TStrategy> SplitSpan
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => new(_body.Span, _separator.Span);
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.this[int]"/>
    public readonly ReadOnlyMemory<TBody> this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
            if (index < 0)
                throw new ArgumentOutOfRangeException(nameof(index), index, "must be positive");

            var e = GetEnumerator();

            for (var i = 0; i <= index; i++)
                if (!e.MoveNext())
                    return default;

            return e.Current;
        }
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.this[Index]"/>
    public readonly ReadOnlyMemory<TBody> this[Index index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            if (index.Value is var value && !index.IsFromEnd)
            {
                var forwards = GetEnumerator();

                for (var i = 0; i <= value; i++)
                    if (!forwards.MoveNext())
                        return default;

                return forwards.Current;
            }

            var backwards = GetReversedEnumerator();

            for (var i = 0; i <= value; i++)
                if (!backwards.MoveNext())
                    return default;

            return backwards.Current;
        }
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.op_Equality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(
        SplitMemory<TBody, TSeparator, TStrategy> left,
        SplitMemory<TBody, TSeparator, TStrategy> right
    ) =>
        left.Equals(right);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.op_Inequality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(
        SplitMemory<TBody, TSeparator, TStrategy> left,
        SplitMemory<TBody, TSeparator, TStrategy> right
    ) =>
        !left.Equals(right);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Deconstruct"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out ReadOnlyMemory<TBody> head, out SplitMemory<TBody, TSeparator, TStrategy> tail)
    {
        if (GetEnumerator() is var e && !e.MoveNext())
        {
            head = default;
            tail = default;
            return;
        }

        head = e.Current;
        tail = new(e.Body, _separator);
    }

    /// <inheritdoc cref="object.Equals(object)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override bool Equals(object? obj) =>
        obj is SplitMemory<TBody, TSeparator, TStrategy> other && Equals(other);

    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals(ISplitMemory<TBody, TSeparator>? other) =>
        other?.GetType() == typeof(SplitMemory<TBody, TSeparator, TStrategy>) &&
        _body.Span.SequenceEqual(other.Body.Span) &&
        _separator.Span.SequenceEqual(To<TSeparator>.From(other.Separator.Span));

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ConcatEqual{TOtherSeparator, TOtherStrategy}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool ConcatEqual<TOtherSeparator, TOtherStrategy>(
        SplitMemory<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        =>
            ConcatEqual(in other);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ConcatEqual{TOtherSeparator, TOtherStrategy}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool ConcatEqual<TOtherSeparator, TOtherStrategy>(
        scoped in SplitMemory<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        =>
            SplitSpan.ConcatEqual(other.SplitSpan);

    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals(SplitMemory<TBody, TSeparator, TStrategy> other) =>
        _body.Span.SequenceEqual(other._body.Span) &&
        _separator.Span.SequenceEqual(To<TSeparator>.From(other._separator.Span));

    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals<TOtherStrategy>(scoped in SplitMemory<TBody, TSeparator, TOtherStrategy> other) =>
        typeof(TStrategy) == typeof(TOtherStrategy) &&
        _body.Span.SequenceEqual(other._body.Span) &&
        _separator.Span.SequenceEqual(To<TSeparator>.From(other._separator.Span));

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.SequenceEqual{TOtherSeparator, TOtherStrategy}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool SequenceEqual<TOtherSeparator, TOtherStrategy>(
        SplitMemory<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        =>
            ConcatEqual(in other);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.SequenceEqual{TOtherSeparator, TOtherStrategy}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool SequenceEqual<TOtherSeparator, TOtherStrategy>(
        scoped in SplitMemory<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        =>
            SplitSpan.SequenceEqual(other.SplitSpan);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Count"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int Count()
    {
        var e = GetEnumerator();
        var count = 0;

        while (e.MoveNext())
            count++;

        return count;
    }

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override int GetHashCode() =>
        unchecked(typeof(SplitMemory<TBody, TSeparator, TStrategy>).GetHashCode() * 7);

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() => SplitSpan.ToString();

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(ReadOnlyMemory<TBody> divider) => ToString(divider.Span);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(scoped in ReadOnlyMemory<TBody> divider) => ToString(divider.Span);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(ReadOnlySpan<TBody> divider) => SplitSpan.ToString(divider);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(scoped in ReadOnlySpan<TBody> divider) => SplitSpan.ToString(divider);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToStringArray"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string[] ToStringArray() => SplitSpan.ToStringArray();

    /// <summary>Copies the values to a new <see cref="ReadOnlyMemory{T}"/> <see cref="Array"/>.</summary>
    /// <returns>
    /// The <see cref="ReadOnlyMemory{T}"/> <see cref="Array"/> containing the copied values of this instance.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReadOnlyMemory<TBody>[] ToArrayMemories()
    {
        using var ret = New4<ReadOnlyMemory<TBody>>();

        foreach (var next in this)
            ret.Append(next);

        return ret.View.ToArray();
    }

    /// <summary>Copies the values to a new <see cref="ReadOnlyMemory{T}"/> <see cref="Array"/>.</summary>
    /// <param name="divider">The separator between each element.</param>
    /// <returns>
    /// The <see cref="ReadOnlyMemory{T}"/> <see cref="Array"/> containing the copied values of this instance.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReadOnlyMemory<TBody>[] ToArrayMemories(ReadOnlyMemory<TBody> divider) =>
        ToArrayMemories(in divider);

    /// <inheritdoc cref="ToArrayMemories(ReadOnlyMemory{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReadOnlyMemory<TBody>[] ToArrayMemories(scoped in ReadOnlyMemory<TBody> divider)
    {
        using var ret = New4<ReadOnlyMemory<TBody>>();
        var e = GetEnumerator();

        if (e.MoveNext())
            ret.Append(e.Current);
        else
            return [];

        while (e.MoveNext())
            ret.Append(divider).Append(e.Current);

        return ret.View.ToArray();
    }

    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetEnumerator() => new(this);

    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReversedEnumerator GetReversedEnumerator() => new(this);

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    IEnumerator<ReadOnlyMemory<TBody>> IEnumerable<ReadOnlyMemory<TBody>>.GetEnumerator() => GetEnumerator();

    /// <inheritdoc cref="SplitSpan{TBody,TSeparator,TStrategy}.Aggregate{TAccumulator}(TAccumulator, SplitSpan{TBody, TSeparator, TStrategy}.RefAccumulator{TAccumulator})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] RefAccumulator<TAccumulator> func
    )
    {
        var accumulator = seed;

        foreach (var next in this)
            accumulator = func(accumulator, next);

        return accumulator;
    }

    /// <inheritdoc cref="SplitSpan{TBody,TSeparator,TStrategy}.Aggregate{TAccumulator}(TAccumulator, SplitSpan{TBody, TSeparator, TStrategy}.Accumulator{TAccumulator})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulator, ReadOnlyMemory<TBody>, TAccumulator> func
    )
    {
        var accumulator = seed;

        foreach (var next in this)
            accumulator = func(accumulator, next);

        return accumulator;
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray()"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray() => SplitSpan.ToArray();

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(ReadOnlyMemory<TBody> divider) => ToArray(divider.Span);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(scoped in ReadOnlyMemory<TBody> divider) => ToArray(divider.Span);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(ReadOnlySpan<TBody> divider) => SplitSpan.ToArray(divider);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(scoped in ReadOnlySpan<TBody> divider) => SplitSpan.ToArray(divider);

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArrays"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[][] ToArrays() => SplitSpan.ToArrays();

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static ReadOnlyMemory<T> Convert<T>(in ReadOnlyMemory<T> memory, scoped in ReadOnlySpan<T> span) =>
        Unsafe.IsNullRef(ref MemoryMarshal.GetReference(span))
            ? default
            : memory.Slice(
                (int)Unsafe.ByteOffset(
                    ref MemoryMarshal.GetReference(memory.Span),
                    ref MemoryMarshal.GetReference(span)
                ) /
                Unsafe.SizeOf<T>(),
                span.Length
            );

    /// <summary>
    /// Represents the enumeration object that views <see cref="SplitMemory{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public partial struct Enumerator(ReadOnlyMemory<TBody> body, ReadOnlyMemory<TSeparator> separator)
        : IEnumerator<ReadOnlyMemory<TBody>>
    {
        readonly ReadOnlyMemory<TSeparator> _separator = separator;

        readonly ReadOnlyMemory<TBody> _original = body;

        ReadOnlyMemory<TBody> _body = body, _current;

        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(ReadOnlyMemory<TBody> body)
            : this(body, default) { }

        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(SplitMemory<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }

        /// <inheritdoc cref="SplitMemory{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlyMemory<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
        }

        /// <inheritdoc />
        readonly object IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }

        /// <inheritdoc />
        public readonly ReadOnlyMemory<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }

        /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator.Move"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Move(
            scoped in ReadOnlyMemory<TSeparator> sep,
            scoped ref ReadOnlyMemory<TBody> body,
            out ReadOnlyMemory<TBody> current
        )
        {
            var b = body.Span;
            var ret = SplitSpan<TBody, TSeparator, TStrategy>.Enumerator.Move(sep.Span, ref b, out var c);
            current = Convert(body, c);
            body = Convert(body, b);
            return ret;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => Move(_separator, ref _body, out _current);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly void IDisposable.Dispose() { }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IEnumerator.Reset() => _body = _original;
    }

    /// <summary>
    /// Represents the enumeration object that views <see cref="SplitMemory{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public partial struct ReversedEnumerator(ReadOnlyMemory<TBody> body, ReadOnlyMemory<TSeparator> separator)
        : IEnumerator<ReadOnlyMemory<TBody>>
    {
        readonly ReadOnlyMemory<TBody> _original = body;

        readonly ReadOnlyMemory<TSeparator> _separator = separator;

        ReadOnlyMemory<TBody> _body = body, _current;

        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(ReadOnlyMemory<TBody> body)
            : this(body, default) { }

        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(SplitMemory<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }

        /// <inheritdoc cref="SplitMemory{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlyMemory<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
        }

        /// <inheritdoc />
        readonly object IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }

        /// <inheritdoc cref="IEnumerator{T}.Current"/>
        public readonly ReadOnlyMemory<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }

        /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator.Move"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MoveNext(
            scoped in ReadOnlyMemory<TSeparator> sep,
            scoped ref ReadOnlyMemory<TBody> body,
            out ReadOnlyMemory<TBody> current
        )
        {
            var b = body.Span;
            var ret = SplitSpan<TBody, TSeparator, TStrategy>.ReversedEnumerator.MoveNext(sep.Span, ref b, out var c);
            current = Convert(body, c);
            body = Convert(body, b);
            return ret;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => MoveNext(_separator, ref _body, out _current);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly void IDisposable.Dispose() { }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IEnumerator.Reset() => _body = _original;
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Efficient LINQ-like methods for <see cref="ReadOnlySpan{T}"/> and siblings.</summary>
// ReSharper disable NullableWarningSuppressionIsUsed
#pragma warning disable MA0048

#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IMemoryOwner<T> BreakableFor<T>(
        this IMemoryOwner<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, ControlFlow> func
    )
    {
        BreakableFor((ReadOnlySpan<T>)iterable.Memory.Span, func);
        return iterable;
    }

    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> BreakableFor<T>(
        this Memory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, ControlFlow> func
    )
    {
        BreakableFor((ReadOnlySpan<T>)iterable.Span, func);
        return iterable;
    }
#endif

    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> BreakableFor<T>(
        this Span<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, ControlFlow> func
    )
    {
        BreakableFor((ReadOnlySpan<T>)iterable, func);
        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlyMemory<T> BreakableFor<T>(
        this ReadOnlyMemory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, ControlFlow> func
    )
    {
        BreakableFor(iterable.Span, func);
        return iterable;
    }
#endif

    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> BreakableFor<T>(
        this ReadOnlySpan<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, ControlFlow> func
    )
    {
        foreach (var x in iterable)
            if (func(x) is ControlFlow.Break)
                break;

        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, int, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IMemoryOwner<T> BreakableFor<T>(
        this IMemoryOwner<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, int, ControlFlow> func
    )
    {
        BreakableFor((ReadOnlySpan<T>)iterable.Memory.Span, func);
        return iterable;
    }

    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, int, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> BreakableFor<T>(
        this Memory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, int, ControlFlow> func
    )
    {
        BreakableFor((ReadOnlySpan<T>)iterable.Span, func);
        return iterable;
    }
#endif

    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, int, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> BreakableFor<T>(
        this Span<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, int, ControlFlow> func
    )
    {
        BreakableFor((ReadOnlySpan<T>)iterable, func);
        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, int, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlyMemory<T> BreakableFor<T>(
        this ReadOnlyMemory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, int, ControlFlow> func
    )
    {
        BreakableFor(iterable.Span, func);
        return iterable;
    }
#endif

    /// <inheritdoc cref="EachWithControlFlow.BreakableFor{T}(IEnumerable{T}, Func{T, int, ControlFlow})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> BreakableFor<T>(
        this ReadOnlySpan<T> iterable,
        [InstantHandle, RequireStaticDelegate] Func<T, int, ControlFlow> func
    )
    {
        for (var i = 0; i < iterable.Length; i++)
            if (func(iterable[i], i) is ControlFlow.Break)
                break;

        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IMemoryOwner<T> For<T>(
        this IMemoryOwner<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T> action
    )
    {
        For((ReadOnlySpan<T>)iterable.Memory.Span, action);
        return iterable;
    }

    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> For<T>(this Memory<T> iterable, [InstantHandle, RequireStaticDelegate] Action<T> action)
    {
        For((ReadOnlySpan<T>)iterable.Span, action);
        return iterable;
    }
#endif

    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> For<T>(this Span<T> iterable, [InstantHandle, RequireStaticDelegate] Action<T> action)
    {
        For((ReadOnlySpan<T>)iterable, action);
        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlyMemory<T> For<T>(
        this ReadOnlyMemory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T> action
    )
    {
        For(iterable.Span, action);
        return iterable;
    }
#endif

    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> For<T>(
        this ReadOnlySpan<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T> action
    )
    {
        foreach (var x in iterable)
            action(x);

        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T, int})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IMemoryOwner<T> For<T>(
        this IMemoryOwner<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T, int> action
    )
    {
        For((ReadOnlySpan<T>)iterable.Memory.Span, action);
        return iterable;
    }

    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T, int})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Memory<T> For<T>(
        this Memory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T, int> action
    )
    {
        For((ReadOnlySpan<T>)iterable.Span, action);
        return iterable;
    }
#endif

    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T, int})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> For<T>(this Span<T> iterable, [InstantHandle, RequireStaticDelegate] Action<T, int> action)
    {
        For((ReadOnlySpan<T>)iterable, action);
        return iterable;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T, int})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlyMemory<T> For<T>(
        this ReadOnlyMemory<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T, int> action
    )
    {
        For(iterable.Span, action);
        return iterable;
    }
#endif

    /// <inheritdoc cref="Each.For{T}(IEnumerable{T}, Action{T, int})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> For<T>(
        this ReadOnlySpan<T> iterable,
        [InstantHandle, RequireStaticDelegate] Action<T, int> action
    )
    {
        for (var i = 0; i < iterable.Length; i++)
            action(iterable[i], i);

        return iterable;
    }

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace EmptyNamespace

#pragma warning disable 1574, 1580, 1581, 1584, S1199 // ReSharper disable once RedundantUsingDirective


/// <inheritdoc cref="SpanSimdQueries"/>
// ReSharper disable NullableWarningSuppressionIsUsed RedundantSuppressNullableWarningExpression
#pragma warning disable MA0048

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this IMemoryOwner<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable.Memory.Span);

    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this Memory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable.Span);
#endif

    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this scoped Span<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this ReadOnlyMemory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable.Span);
#endif

    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this scoped ReadOnlySpan<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this IMemoryOwner<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable.Memory.Span);

    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this Memory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable.Span);
#endif

    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this scoped Span<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this ReadOnlyMemory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable.Span);
#endif

    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this scoped ReadOnlySpan<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this IMemoryOwner<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable.Memory.Span, keySelector);

    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this Memory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable.Span, keySelector);
#endif

    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this scoped Span<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable, keySelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this ReadOnlyMemory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable.Span, keySelector);
#endif

    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this scoped ReadOnlySpan<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable, keySelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this IMemoryOwner<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable.Memory.Span, keySelector);

    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this Memory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable.Span, keySelector);
#endif

    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this scoped Span<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable, keySelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this ReadOnlyMemory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable.Span, keySelector);
#endif

    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this scoped ReadOnlySpan<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable, keySelector);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool Compare<T, TS>(T l, T r) =>
        0 switch
        {
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(byte) => (byte)(object)l! > (byte)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(byte) => (byte)(object)l! < (byte)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(double) => (double)(object)l! > (double)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(double) => (double)(object)l! < (double)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(float) => (float)(object)l! > (float)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(float) => (float)(object)l! < (float)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(int) => (int)(object)l! > (int)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(int) => (int)(object)l! < (int)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(nint) => (nint)(object)l! > (nint)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(nint) => (nint)(object)l! < (nint)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(nuint) => (nuint)(object)l! > (nuint)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(nuint) => (nuint)(object)l! < (nuint)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(sbyte) => (sbyte)(object)l! > (sbyte)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(sbyte) => (sbyte)(object)l! < (sbyte)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(short) => (short)(object)l! > (short)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(short) => (short)(object)l! < (short)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(uint) => (uint)(object)l! > (uint)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(uint) => (uint)(object)l! < (uint)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(ulong) => (ulong)(object)l! > (ulong)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(ulong) => (ulong)(object)l! < (ulong)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(ushort) => (ushort)(object)l! > (ushort)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(ushort) => (ushort)(object)l! < (ushort)(object)r!,
            _ when typeof(TS) == typeof(SMax) => Comparer<T>.Default.Compare(l, r) > 0,
            _ when typeof(TS) == typeof(SMin) => Comparer<T>.Default.Compare(l, r) < 0,
            _ => throw Unreachable,
        };
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static Vector<T> LoadUnsafe<T>(in T source)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
#if CSHARPREPL
            Vector.LoadUnsafe(ref AsRef(source));
#elif NET8_0_OR_GREATER
            Vector.LoadUnsafe(source);
#else
            Unsafe.ReadUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref Unsafe.AsRef(source)));
#endif
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable MA0051 // ReSharper disable once CognitiveComplexity
    static T MinMax<T, TS>(this ReadOnlySpan<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
#pragma warning restore MA0051
    {
        // ReSharper disable once TooWideLocalVariableScope
        T value;

        if (span.IsEmpty)
            return default!;
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
        if (!IsNumericPrimitive<T>() ||
#if NET7_0_OR_GREATER
            !Vector<T>.IsSupported ||
#endif
            !Vector.IsHardwareAccelerated ||
            span.Length < Vector<T>.Count
        )
#endif
        {
            value = span[0];

            for (var i = 1; i < span.Length; i++)
                if (Compare<T, TS>(span[i], value))
                    value = span[i];

            return value;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
        ref var current = ref MemoryMarshal.GetReference(span);
        ref var lastVectorStart = ref Unsafe.Add(ref current, span.Length - Vector<T>.Count);
        var best = LoadUnsafe(current);
        current = ref Unsafe.Add(ref current, Vector<T>.Count)!;

        for (;
            Unsafe.IsAddressLessThan(ref current, ref lastVectorStart);
            current = ref Unsafe.Add(ref current, Vector<T>.Count)!)
            best = 0 switch
            {
                _ when typeof(TS) == typeof(SMax) => Vector.Max(best, LoadUnsafe(current)),
                _ when typeof(TS) == typeof(SMin) => Vector.Min(best, LoadUnsafe(current)),
                _ => throw Unreachable,
            };

        best = 0 switch
        {
            _ when typeof(TS) == typeof(SMax) => Vector.Max(best, LoadUnsafe(lastVectorStart)),
            _ when typeof(TS) == typeof(SMin) => Vector.Min(best, LoadUnsafe(lastVectorStart)),
            _ => throw Unreachable,
        };

        value = best[0];

        for (var i = 1; i < Vector<T>.Count; i++)
            if (0 switch
            {
                _ when typeof(TS) == typeof(SMax) => Compare<T, TS>(best[i], value),
                _ when typeof(TS) == typeof(SMin) => Compare<T, TS>(best[i], value),
                _ => throw Unreachable,
            })
                value = best[i];

        return value;
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    static T MinMax<T, TResult, TS>(
        this scoped ReadOnlySpan<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (enumerable.IsEmpty)
            return default!;
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var bestValue = enumerable[0];
        var bestKey = converter(bestValue);

        for (var i = 1; i < enumerable.Length; i++)
            if (converter(enumerable[i]) is var next &&
                0 switch
                {
                    _ when typeof(TS) == typeof(SMax) => Compare<TResult, TS>(next, bestKey),
                    _ when typeof(TS) == typeof(SMin) => Compare<TResult, TS>(next, bestKey),
                    _ => throw Unreachable,
                })
            {
                bestKey = next;
                bestValue = enumerable[i];
            }
#else
        ref var bestValue = ref MemoryMarshal.GetReference(enumerable);
        ref var current = ref Unsafe.Add(ref bestValue, 1);
        ref var last = ref Unsafe.Add(ref bestValue, enumerable.Length);
        var bestKey = converter(bestValue);

        for (; Unsafe.IsAddressLessThan(ref current, ref last); current = ref Unsafe.Add(ref current, 1)!)
            if (converter(current) is var next &&
                0 switch
                {
                    _ when typeof(TS) == typeof(SMax) => Compare<TResult, TS>(next, bestKey),
                    _ when typeof(TS) == typeof(SMin) => Compare<TResult, TS>(next, bestKey),
                    _ => throw Unreachable,
                })
            {
                bestKey = next;
                bestValue = ref current;
            }
#endif
        return bestValue;
    }

    struct SMin;

    struct SMax;

// SPDX-License-Identifier: MPL-2.0
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
// ReSharper disable once CheckNamespace EmptyNamespace


// ReSharper disable once RedundantUsingDirective



/// <inheritdoc cref="SpanSimdQueries"/>
// ReSharper disable InvocationIsSkipped NullableWarningSuppressionIsUsed RedundantSuppressNullableWarningExpression
#pragma warning disable MA0048

    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this scoped Span<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Average((ReadOnlySpan<T>)span);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this ReadOnlyMemory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Average(span.Span);
#endif

    /// <summary>Gets the average.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <param name="span">The span to get the average of.</param>
    /// <returns>The average of <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this scoped ReadOnlySpan<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Divider(span.Sum(), span.Length);

    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this scoped Span<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Sum((ReadOnlySpan<T>)span);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this ReadOnlyMemory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Sum(span.Span);
#endif

    /// <summary>Gets the sum.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <param name="span">The span to get the sum of.</param>
    /// <returns>The sum of <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this scoped ReadOnlySpan<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
    {
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP_3_0_OR_GREATER || NET5_0_OR_GREATER
        if (IsNumericPrimitive<T>() &&
#if NET7_0_OR_GREATER
            Vector<T>.IsSupported &&
#endif
            Vector.IsHardwareAccelerated &&
            Vector<T>.Count > 2 &&
            span.Length >= Vector<T>.Count * 4)
            return SumVectorized(span);
#endif
        if (typeof(T).IsEnum)
            return span.UnderlyingSum();

        T sum = default!;

        foreach (var value in span)
            checked
            {
                sum = Adder(sum, value);
            }

        return sum;
    }

    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this scoped Span<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Average((ReadOnlySpan<T>)span, converter);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this ReadOnlyMemory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Average(span.Span, converter);
#endif

    /// <summary>Gets the average.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <typeparam name="TResult">The type of return.</typeparam>
    /// <param name="span">The span to get the average of.</param>
    /// <param name="converter">The mapping of each element.</param>
    /// <returns>The average of each mapping of <paramref name="span"/> by <paramref name="converter"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this scoped ReadOnlySpan<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Divider(span.Sum(converter), span.Length);

    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this scoped Span<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Sum((ReadOnlySpan<T>)span, converter);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this ReadOnlyMemory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Sum(span.Span, converter);
#endif

    /// <summary>Gets the sum.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <typeparam name="TResult">The type of return.</typeparam>
    /// <param name="span">The span to get the sum of.</param>
    /// <param name="converter">The mapping of each element.</param>
    /// <returns>The sum of each mapping of <paramref name="span"/> by <paramref name="converter"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this scoped ReadOnlySpan<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
    {
        TResult sum = default!;

        foreach (var x in span)
            sum = Adder(sum, converter(x));

        return sum;
    }

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this IMemoryOwner<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Average((ReadOnlySpan<T>)span.Memory.Span);

    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this Memory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Average((ReadOnlySpan<T>)span.Span);
#endif

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this IMemoryOwner<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Sum((ReadOnlySpan<T>)span.Memory.Span);

    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this Memory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Sum((ReadOnlySpan<T>)span.Span);
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this IMemoryOwner<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Average((ReadOnlySpan<T>)span.Memory.Span, converter);

    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this Memory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Average((ReadOnlySpan<T>)span.Span, converter);
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this IMemoryOwner<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Sum((ReadOnlySpan<T>)span.Memory.Span, converter);

    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this Memory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Sum((ReadOnlySpan<T>)span.Span, converter);
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP_3_0_OR_GREATER || NET5_0_OR_GREATER
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
    static Vector<T> LoadUnsafe<T>(ref T source, nuint elementOffset)
#if NET8_0_OR_GREATER
        =>
            Vector.LoadUnsafe(ref source, elementOffset);
#else
        where T : struct
    {
        source = ref Unsafe.Add(ref source, (nint)elementOffset);
        return Unsafe.ReadUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref source));
    }
#endif
#endif
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static ReadOnlySpan<TTo> Underlying<TFrom, TTo>(this in ReadOnlySpan<TFrom> span)
    {
        // ReSharper disable RedundantNameQualifier UseSymbolAlias
        System.Diagnostics.Debug.Assert(typeof(TFrom).IsEnum, "typeof(TFrom).IsEnum");
        System.Diagnostics.Debug.Assert(typeof(TTo).IsPrimitive, "typeof(TTo).IsPrimitive");

        System.Diagnostics.Debug.Assert(
            Unsafe.SizeOf<TFrom>() == Unsafe.SizeOf<TTo>(),
            "Unsafe.SizeOf<TFrom>() == Unsafe.SizeOf<TTo>()"
        ); // ReSharper restore RedundantNameQualifier

        return MemoryMarshal.CreateReadOnlySpan(
            ref Unsafe.As<TFrom, TTo>(ref MemoryMarshal.GetReference(span)),
            span.Length
        );
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T UnderlyingSum<T>(this in ReadOnlySpan<T> span) =>
        typeof(T).GetEnumUnderlyingType() switch
        {
            var x when x == typeof(sbyte) => (T)(object)span.Underlying<T, sbyte>().Sum(),
            var x when x == typeof(byte) => (T)(object)span.Underlying<T, byte>().Sum(),
            var x when x == typeof(short) => (T)(object)span.Underlying<T, short>().Sum(),
            var x when x == typeof(ushort) => (T)(object)span.Underlying<T, ushort>().Sum(),
            var x when x == typeof(int) => (T)(object)span.Underlying<T, int>().Sum(),
            var x when x == typeof(uint) => (T)(object)span.Underlying<T, uint>().Sum(),
            var x when x == typeof(long) => (T)(object)span.Underlying<T, long>().Sum(),
            var x when x == typeof(ulong) => (T)(object)span.Underlying<T, ulong>().Sum(),
            var x when x == typeof(nint) => (T)(object)span.Underlying<T, nint>().Sum(),
            var x when x == typeof(nuint) => (T)(object)span.Underlying<T, nuint>().Sum(),
            _ => throw Unreachable,
        };
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP_3_0_OR_GREATER || NET5_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable MA0051
    static T SumVectorized<T>(scoped ReadOnlySpan<T> span)
#pragma warning restore MA0051
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
    {
        ref var ptr = ref MemoryMarshal.GetReference(span);
        var length = (nuint)span.Length;
        var accumulator = Vector<T>.Zero;

        Vector<T> overflowTestVector = new(MinValue<T>());

        nuint index = 0;
        var limit = length - (nuint)Vector<T>.Count * 4;

        do
        {
            var data = LoadUnsafe(ref ptr, index);
            var accumulator2 = accumulator + data;
            var overflowTracking = (accumulator2 ^ accumulator) & (accumulator2 ^ data);

            data = LoadUnsafe(ref ptr, index + (nuint)Vector<T>.Count);
            accumulator = accumulator2 + data;
            overflowTracking |= (accumulator ^ accumulator2) & (accumulator ^ data);

            data = LoadUnsafe(ref ptr, index + (nuint)Vector<T>.Count * 2);
            accumulator2 = accumulator + data;
            overflowTracking |= (accumulator2 ^ accumulator) & (accumulator2 ^ data);

            data = LoadUnsafe(ref ptr, index + (nuint)Vector<T>.Count * 3);
            accumulator = accumulator2 + data;
            overflowTracking |= (accumulator ^ accumulator2) & (accumulator ^ data);

            if ((overflowTracking & overflowTestVector) != Vector<T>.Zero)
                throw new OverflowException();

            index += (nuint)Vector<T>.Count * 4;
        } while (index < limit);

        limit = length - (nuint)Vector<T>.Count;

        if (index < limit)
        {
            var overflowTracking = Vector<T>.Zero;

            do
            {
                var data = LoadUnsafe(ref ptr, index);
                var accumulator2 = accumulator + data;
                overflowTracking |= (accumulator2 ^ accumulator) & (accumulator2 ^ data);
                accumulator = accumulator2;

                index += (nuint)Vector<T>.Count;
            } while (index < limit);

            if ((overflowTracking & overflowTestVector) != Vector<T>.Zero)
                throw new OverflowException();
        }

        T result = default!;

        for (var i = 0; i < Vector<T>.Count; i++)
            checked
            {
                result = Adder(result, accumulator[i]);
            }

        while (index < length)
        {
            checked
            {
                result = Adder(result, Unsafe.Add(ref ptr, index));
            }

            index++;
        }

        return result;
    }
#endif
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace RedundantNameQualifier RedundantExtendsListEntry RedundantUsingDirective StructCanBeMadeReadOnly





#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
/// <summary>
/// Provides implementations to turn nested <see cref="Two{T}"/> instances into a continuous <see cref="Span{T}"/>.
/// </summary>

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<T> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<T>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<T>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<T>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<Two<T>>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<Two<Two<T>>>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<Two<Two<Two<T>>>>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="PooledSmallList{T}.From{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> AsSpan<T>(this in Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>> two) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        PooledSmallList<T>.AsSpan(ref AsRef(two));

    /// <inheritdoc cref="Two{T}.op_Implicit(ValueTuple{T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Two<T> AsTwo<T>(this (T First, T Second) tuple) => tuple;
#endif

/// <summary>
/// Represents two inlined elements, equivalent to <see cref="ValueTuple{T1, T2}"/>,
/// but the memory layout is guaranteed to be sequential, and both elements are of the same type.
/// </summary>
/// <remarks><para>
/// The name of this type may or may not derive from a specific algebralien from a show...
/// </para></remarks>
/// <typeparam name="T">The type of item to store.</typeparam>
/// <param name="left">The first item.</param>
/// <param name="right">The second item.</param>
[StructLayout(LayoutKind.Sequential)]
#pragma warning disable MA0102
#if !NO_READONLY_STRUCTS
readonly
#endif
public partial struct Two<T>(T left, T right) :
#if NET7_0_OR_GREATER
    IComparisonOperators<Two<T>, Two<T>, bool>,
    IEqualityOperators<Two<T>, Two<T>, bool>,
#endif
#if NET471_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    ITuple,
#endif
    IComparable<Two<T>>,
    IEquatable<Two<T>>
{
    /// <summary>The stored items.</summary>
    public readonly T First = left, Second = right;

    /// <summary>Applies the indexer and returns the instance according to the value.</summary>
    /// <param name="back">Whether or not to return <see cref="Second"/>.</param>
    [Pure]
    public T this[bool back] => back ? Second : First;

    /// <inheritdoc cref="Two{T}.op_Implicit(Two{T})"/>
    public (T First, T Second) Tuple => this;

#if NET471_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <inheritdoc />
    [Pure, ValueRange(2)]
    int ITuple.Length => 2;

    /// <inheritdoc />
    [Pure]
    object? ITuple.this[int index] =>
        index switch
        {
            0 => First,
            1 => Second,
            _ => throw new ArgumentOutOfRangeException(nameof(index), index, null),
        };
#endif

    /// <summary>Deconstructs this instance into the two inlined elements.</summary>
    /// <param name="first">The first item.</param>
    /// <param name="second">The second item.</param>
    public void Deconstruct(out T first, out T second)
    {
        first = First;
        second = Second;
    }

    /// <summary>Determines whether both instances contain the same two values.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both instances have the same two values.</returns>
    [Pure]
    public static bool operator ==(Two<T> left, Two<T> right) => left.Equals(right);

    /// <summary>Determines whether both instances contain different values.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both instances have different values.</returns>
    [Pure]
    public static bool operator !=(Two<T> left, Two<T> right) => !(left == right);

    /// <summary>Determines whether the left instance is less than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left instance is less than the right.</returns>
    [Pure]
    public static bool operator <(Two<T> left, Two<T> right) => left.CompareTo(right) < 0;

    /// <summary>Determines whether the left instance is equal to or less than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left instance is equal to or less than the right.</returns>
    [Pure]
    public static bool operator <=(Two<T> left, Two<T> right) => left.CompareTo(right) <= 0;

    /// <summary>Determines whether the left instance is greater than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left instance is greater than the right.</returns>
    [Pure]
    public static bool operator >(Two<T> left, Two<T> right) => left.CompareTo(right) > 0;

    /// <summary>Determines whether the left instance is equal to or greater than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left instance is equal to or greater than the right.</returns>
    [Pure]
    public static bool operator >=(Two<T> left, Two<T> right) => left.CompareTo(right) >= 0;

    /// <summary>Implicitly converts the <see cref="Two{T}"/> into the <see cref="ValueTuple{T1, T2}"/>.</summary>
    /// <param name="two">The <see cref="Two{T}"/> to convert.</param>
    /// <returns>The equivalent tuple layout of the parameter <paramref name="two"/>.</returns>
    [Pure]
    public static implicit operator (T First, T Second)(Two<T> two) => (two.First, two.Second);

    /// <summary>Implicitly converts the <see cref="ValueTuple{T1, T2}"/> into the <see cref="Two{T}"/>.</summary>
    /// <param name="tuple">The <see cref="ValueTuple{T1, T2}"/> to convert.</param>
    /// <returns>The equivalent sequential layout of the parameter <paramref name="tuple"/>.</returns>
    [Pure]
    public static implicit operator Two<T>((T First, T Second) tuple) => (tuple.First, tuple.Second);

    /// <inheritdoc cref="object.Equals(object)"/>
    [Pure]
    public override bool Equals(object? obj) => obj is Two<T> two && Equals(two);

    /// <inheritdoc />
    [Pure]
    public bool Equals(Two<T> other) =>
        EqualityComparer<T>.Default.Equals(First, other.First) &&
        EqualityComparer<T>.Default.Equals(Second, other.Second);

    /// <inheritdoc />
    [Pure]
    public int CompareTo(Two<T> other) =>
        Comparer<T>.Default.Compare(First, other.First) is var first and not 0 ? first :
        Comparer<T>.Default.Compare(Second, other.Second) is var second and not 0 ? second : 0;

    /// <inheritdoc />
    [Pure]
    public override int GetHashCode()
    {
        unchecked
        {
            var hashCode = 0;

            if (First is not null)
                hashCode = EqualityComparer<T>.Default.GetHashCode(First);

            if (Second is not null)
                hashCode ^= EqualityComparer<T>.Default.GetHashCode(Second);

            return hashCode;
        }
    }
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace EmptyNamespace


/// <summary>Efficient LINQ-like methods for <see cref="ReadOnlySpan{T}"/> and siblings.</summary>
// ReSharper disable NullableWarningSuppressionIsUsed
#pragma warning disable MA0048

#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Aggregate{T}(IEnumerable{T}, Func{T, T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T? Aggregate<T>(
        this IMemoryOwner<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, T, T> func
    ) =>
        Aggregate((ReadOnlySpan<T>)source.Memory.Span, func);

    /// <inheritdoc cref="Enumerable.Aggregate{T}(IEnumerable{T}, Func{T, T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T? Aggregate<T>(this Memory<T> source, [InstantHandle, RequireStaticDelegate] Func<T, T, T> func) =>
        Aggregate((ReadOnlySpan<T>)source.Span, func);
#endif

    /// <inheritdoc cref="Enumerable.Aggregate{T}(IEnumerable{T}, Func{T, T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T? Aggregate<T>(
        this scoped Span<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, T, T> func
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            Aggregate((ReadOnlySpan<T>)source, func);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Aggregate{T}(IEnumerable{T}, Func{T, T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T? Aggregate<T>(
        this ReadOnlyMemory<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, T, T> func
    ) =>
        Aggregate(source.Span, func);
#endif

    /// <inheritdoc cref="Enumerable.Aggregate{T}(IEnumerable{T}, Func{T, T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T? Aggregate<T>(
        this scoped ReadOnlySpan<T> source,
        [InstantHandle, RequireStaticDelegate] Func<T, T, T> func
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        var e = source.GetEnumerator();

        if (!e.MoveNext())
            return default;

        var accumulator = e.Current;

        while (e.MoveNext())
            accumulator = func(accumulator, e.Current);

        return accumulator;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TAccumulate Aggregate<T, TAccumulate>(
        this IMemoryOwner<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func
    ) =>
        Aggregate((ReadOnlySpan<T>)source.Memory.Span, seed, func);

    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TAccumulate Aggregate<T, TAccumulate>(
        this Memory<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func
    ) =>
        Aggregate((ReadOnlySpan<T>)source.Span, seed, func);
#endif

    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TAccumulate Aggregate<T, TAccumulate>(
        this scoped Span<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            Aggregate((ReadOnlySpan<T>)source, seed, func);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TAccumulate Aggregate<T, TAccumulate>(
        this ReadOnlyMemory<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func
    ) =>
        Aggregate(source.Span, seed, func);
#endif

    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TAccumulate Aggregate<T, TAccumulate>(
        this scoped ReadOnlySpan<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        foreach (var next in source)
            seed = func(seed, next);

        return seed;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate, TResult}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate}, Func{TAccumulate, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Aggregate<T, TAccumulate, TResult>(
        this IMemoryOwner<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, TResult> resultSelector
    ) =>
        Aggregate((ReadOnlySpan<T>)source.Memory.Span, seed, func, resultSelector);

    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate, TResult}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate}, Func{TAccumulate, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Aggregate<T, TAccumulate, TResult>(
        this Memory<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, TResult> resultSelector
    ) =>
        Aggregate((ReadOnlySpan<T>)source.Span, seed, func, resultSelector);
#endif

    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate, TResult}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate}, Func{TAccumulate, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Aggregate<T, TAccumulate, TResult>(
        this scoped Span<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, TResult> resultSelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            Aggregate((ReadOnlySpan<T>)source, seed, func, resultSelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate, TResult}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate}, Func{TAccumulate, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Aggregate<T, TAccumulate, TResult>(
        this ReadOnlyMemory<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, TResult> resultSelector
    ) =>
        Aggregate(source.Span, seed, func, resultSelector);
#endif

    /// <inheritdoc cref="Enumerable.Aggregate{T, TAccumulate, TResult}(IEnumerable{T}, TAccumulate, Func{TAccumulate, T, TAccumulate}, Func{TAccumulate, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Aggregate<T, TAccumulate, TResult>(
        this scoped ReadOnlySpan<T> source,
        TAccumulate seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, T, TAccumulate> func,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulate, TResult> resultSelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        foreach (var next in source)
            seed = func(seed, next);

        return resultSelector(seed);
    }

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible InvertIf InvocationIsSkipped RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias


#pragma warning disable 8618, 9193, CA1823, IDE0250, MA0071, MA0102, RCS1158, SA1137




/// <summary>Methods to split spans into multiple spans.</summary>
#pragma warning disable MA0048

    /// <summary>The type that indicates to match all elements.</summary>
    public struct MatchAll;

    /// <summary>The type that indicates to match any element.</summary>
    public struct MatchAny;

    /// <summary>The type that indicates to match exactly one element.</summary>
    public struct MatchOne;

    /// <summary>Splits a span by the specified separator.</summary>
    /// <typeparam name="T">The type of element from the span.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="separator">The separator.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAny> SplitAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            new(span, separator);

    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAny> SplitAny<T>(this Span<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            ((ReadOnlySpan<T>)span).SplitAny(separator);

    /// <summary>Splits a span by the specified separator.</summary>
    /// <typeparam name="T">The type of element from the span.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="separator">The separator.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAll> SplitAll<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            new(span, separator);

    /// <inheritdoc cref="SplitAll{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAll> SplitAll<T>(this Span<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            ((ReadOnlySpan<T>)span).SplitAll(separator);
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this ReadOnlySpan<T> span,
        in SearchValues<T> separator
    )
        where T : IEquatable<T> =>
        new(span, In(separator));

    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this Span<T> span,
        in SearchValues<T> separator
    )
        where T : IEquatable<T> =>
        ((ReadOnlySpan<T>)span).SplitOn(separator);
#endif
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchOne> SplitOn<T>(this ReadOnlySpan<T> span, in T separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>?
#endif
        =>
            new(span, In(separator));

    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchOne> SplitOn<T>(this Span<T> span, in T separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>?
#endif
        =>
            ((ReadOnlySpan<T>)span).SplitOn(separator);
#endif
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAny> SplitSpanAny(this string span, string separator) =>
        span.AsSpan().SplitAny(separator.AsSpan());

    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAny> SplitAny(this string span, ReadOnlySpan<char> separator) =>
        span.AsSpan().SplitAny(separator);

    /// <inheritdoc cref="SplitAll{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAll> SplitSpanAll(this string span, string separator) =>
        span.AsSpan().SplitAll(separator.AsSpan());

    /// <inheritdoc cref="SplitAll{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAll> SplitAll(this string span, ReadOnlySpan<char> separator) =>
        span.AsSpan().SplitAll(separator);

    /// <inheritdoc cref="SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitSpanLines(this string span) =>
        span.AsSpan().SplitLines();

    /// <summary>Splits a span by line breaks.</summary>
    /// <remarks><para>Line breaks are considered any character in <see cref="Breaking"/>.</para></remarks>
    /// <param name="span">The span to split.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this ReadOnlySpan<char> span) =>
#if NET8_0_OR_GREATER
        new(span, BreakingSearchMemory.Span);
#else
        new(span, Breaking.AsSpan());
#endif

    /// <inheritdoc cref="SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this Span<char> span) =>
        ((ReadOnlySpan<char>)span).SplitLines();

    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchOne> SplitOn(this string span, in char separator) =>
        span.AsSpan().SplitOn(separator);

    /// <inheritdoc cref="SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitSpanWhitespace(this string span) =>
        span.AsSpan().SplitWhitespace();

    /// <summary>Splits a span by whitespace.</summary>
    /// <remarks><para>Whitespace is considered any character in <see cref="Unicode"/>.</para></remarks>
    /// <param name="span">The span to split.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this ReadOnlySpan<char> span) =>
#if NET8_0_OR_GREATER
        new(span, UnicodeSearchMemory.Span);
#else
        new(span, Unicode.AsSpan());
#endif

    /// <inheritdoc cref="SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this Span<char> span) =>
        ((ReadOnlySpan<char>)span).SplitWhitespace();
#endif
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, SearchValues<char>, MatchAny> SplitSpanOn(
        this string span,
        in SearchValues<char> separator
    ) =>
        span.AsSpan().SplitOn(separator);
#endif

/// <summary>Represents a split entry.</summary>
/// <typeparam name="TBody">The type of element from the span.</typeparam>
/// <typeparam name="TSeparator">The type of separator.</typeparam>
/// <typeparam name="TStrategy">The strategy for splitting elements.</typeparam>
/// <param name="body">The line to split.</param>
/// <param name="separator">The separator.</param>
[StructLayout(LayoutKind.Auto)]
[method: MethodImpl(MethodImplOptions.AggressiveInlining)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
#if !NO_REF_STRUCTS
    ref
#endif
    partial struct SplitSpan<TBody, TSeparator, TStrategy>(ReadOnlySpan<TBody> body, ReadOnlySpan<TSeparator> separator)
#if UNMANAGED_SPAN
    where TBody : unmanaged, IEquatable<TBody>?
#else
    where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
    where TSeparator : IEquatable<TSeparator>?
#endif
{
    /// <summary>Represents the accumulator function for the enumeration of this type.</summary>
    /// <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
    /// <param name="accumulator">The accumulator.</param>
    /// <param name="next">The next slice from the enumeration.</param>
    /// <returns>The final accumulator value.</returns>
    public delegate TAccumulator Accumulator<TAccumulator>(TAccumulator accumulator, scoped ReadOnlySpan<TBody> next);

    /// <inheritdoc cref="Accumulator{TAccumulator}"/>
    public delegate TAccumulator RefAccumulator<TAccumulator>(
        TAccumulator accumulator,
        scoped in ReadOnlySpan<TBody> next
    );

    readonly ReadOnlySpan<TBody> _body = body;

    readonly ReadOnlySpan<TSeparator> _separator = separator;

    /// <summary>Initializes a new instance of the <see cref="SplitSpan{T, TSeparator, TStrategy}"/> struct.</summary>
    /// <param name="body">The line to split.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SplitSpan(ReadOnlySpan<TBody> body)
        : this(body, default) { }

    /// <summary>Gets the error thrown by this type.</summary>
    public static NotSupportedException Error
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => new($"Unrecognized type: {typeof(TStrategy).Name}");
    }

    /// <summary>Gets the line to split.</summary>
    public readonly ReadOnlySpan<TBody> Body
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
    }

    /// <summary>Gets the first element.</summary>
    public readonly ReadOnlySpan<TBody> First
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }

    /// <summary>Gets the last element.</summary>
    public readonly ReadOnlySpan<TBody> Last
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetReversedEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }

    /// <summary>Gets the separator.</summary>
    public readonly ReadOnlySpan<TSeparator> Separator
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
    }

    /// <summary>Gets the single element.</summary>
    public readonly ReadOnlySpan<TBody> Single
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() && e.Current is var ret && !e.MoveNext() ? ret : default;
    }

    /// <summary>Gets the specified index.</summary>
    /// <param name="index">The index to get.</param>
    /// <exception cref="ArgumentOutOfRangeException">The parameter <paramref name="index"/> is negative.</exception>
    public readonly ReadOnlySpan<TBody> this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
            if (index < 0)
                throw new ArgumentOutOfRangeException(nameof(index), index, "must be positive");

            var e = GetEnumerator();

            for (var i = 0; i <= index; i++)
                if (!e.MoveNext())
                    return default;

            return e.Current;
        }
    }

    /// <summary>Gets the specified index.</summary>
    /// <param name="index">The index to get.</param>
    public readonly ReadOnlySpan<TBody> this[Index index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            if (index.Value is var value && !index.IsFromEnd)
            {
                var forwards = GetEnumerator();

                for (var i = 0; i <= value; i++)
                    if (!forwards.MoveNext())
                        return default;

                return forwards.Current;
            }

            var backwards = GetReversedEnumerator();

            for (var i = 0; i <= value; i++)
                if (!backwards.MoveNext())
                    return default;

            return backwards.Current;
        }
    }

    /// <summary>Determines whether both splits are equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both splits are equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(
        scoped in SplitSpan<TBody, TSeparator, TStrategy> left,
        scoped in SplitSpan<TBody, TSeparator, TStrategy> right
    ) =>
        left.Equals(right);

    /// <summary>Determines whether both splits are not equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both splits are not equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(
        scoped in SplitSpan<TBody, TSeparator, TStrategy> left,
        scoped in SplitSpan<TBody, TSeparator, TStrategy> right
    ) =>
        !left.Equals(right);

    /// <summary>Separates the head from the tail of this <see cref="SplitSpan{T, TSeparator, TStrategy}"/>.</summary>
    /// <param name="head">The first element of this enumeration.</param>
    /// <param name="tail">The rest of this enumeration.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out ReadOnlySpan<TBody> head, out SplitSpan<TBody, TSeparator, TStrategy> tail)
    {
        if (GetEnumerator() is var e && !e.MoveNext())
        {
            head = default;
            tail = default;
            return;
        }

        head = e.Current;
        tail = new(e.Body, _separator);
    }

    /// <summary>Determines whether both splits are eventually equal when concatenating all slices.</summary>
    /// <typeparam name="TOtherSeparator">The type of separator for the other side.</typeparam>
    /// <typeparam name="TOtherStrategy">The strategy for splitting for the other side.</typeparam>
    /// <param name="other">The other side.</param>
    /// <returns>
    /// The value <paramref langword="true"/> if both sequences are equal, otherwise; <paramref langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool ConcatEqual<TOtherSeparator, TOtherStrategy>(
        scoped in SplitSpan<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
    {
        if (GetEnumerator() is var e && other.GetEnumerator() is var otherE && !e.MoveNext())
            return !otherE.MoveNext();

        if (!otherE.MoveNext())
            return false;

        ReadOnlySpan<TBody>
            reader = e.Current,
            otherReader = otherE.Current;

        while (true)
            if (e.EqualityMoveNext(ref otherE, ref reader, ref otherReader, out var ret))
                return ret;
    }

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override bool Equals(object? obj) => false;

    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals<TOtherStrategy>(scoped in SplitSpan<TBody, TSeparator, TOtherStrategy> other) =>
        typeof(TStrategy) == typeof(TOtherStrategy) &&
        _body.SequenceEqual(other._body) &&
        _separator.SequenceEqual(To<TSeparator>.From(other._separator));

    /// <summary>Determines whether both splits are equal.</summary>
    /// <typeparam name="TOtherSeparator">The type of separator for the right-hand side.</typeparam>
    /// <typeparam name="TOtherStrategy">The strategy for splitting elements for the right-hand side.</typeparam>
    /// <param name="other">The side to compare to.</param>
    /// <returns>
    /// The value <paramref langword="true"/> if both sequences are equal, otherwise; <paramref langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool SequenceEqual<TOtherSeparator, TOtherStrategy>(
        scoped in SplitSpan<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
    {
        var e = GetEnumerator();
        var eOther = other.GetEnumerator();

        while (e.MoveNext())
            if (!(eOther.MoveNext() && e.Current.SequenceEqual(eOther.Current)))
                return false;

        return !eOther.MoveNext();
    }

    /// <summary>Computes the length.</summary>
    /// <returns>The length.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int Count()
    {
        var e = GetEnumerator();
        var count = 0;

        while (e.MoveNext())
            count++;

        return count;
    }

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override int GetHashCode() => unchecked(typeof(TBody).GetHashCode() * 31);

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() =>
        typeof(TBody) == typeof(char)
            ? Aggregate(new(), StringBuilderAccumulator()).ToString()
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            : ToArrays().Stringify(3, true);
#else
            : throw new NotSupportedException();
#endif

    /// <summary>
    /// Converts the elements of the collection to a <see cref="string"/> representation,
    /// using the specified divider between elements.
    /// </summary>
    /// <param name="divider">The divider to insert between elements.</param>
    /// <returns>A <see cref="string"/> representation of the collection.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(ReadOnlySpan<TBody> divider) => ToString(in divider);

    /// <inheritdoc cref="ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(scoped in ReadOnlySpan<TBody> divider)
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = New4<TBody>();

        var e = GetEnumerator();

        if (e.MoveNext())
            ret.Append(e.Current);
        else
            return "";

        while (e.MoveNext())
            ret.Append(divider).Append(e.Current);

        return ret.View.ToString();
#else
        List<TBody> ret = [];

        var e = GetEnumerator();

        if (!e.MoveNext())
            return "";

        foreach (var next in e.Current)
            ret.Add(next);

        while (e.MoveNext())
        {
            foreach (var next in divider)
                ret.Add(next);

            foreach (var next in e.Current)
                ret.Add(next);
        }

        return ret.Conjoin(typeof(TBody) == typeof(char) ? "" : ", ");
#endif
    }

    /// <summary>Copies the values to a new <see cref="string"/> <see cref="Array"/>.</summary>
    /// <returns>The <see cref="string"/> <see cref="Array"/> containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string[] ToStringArray()
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = New4<string>();

        foreach (var next in this)
            ret.Append(typeof(TBody) == typeof(char) ? next.ToString() : next.ToArray().Conjoin());

        return ret.View.ToArray();
#else
        List<string> ret = [];

        foreach (var next in this)
            ret.Add(typeof(TBody) == typeof(char) ? next.ToString() : next.ToArray().Conjoin());

        return [.. ret];
#endif
    }

    /// <summary>Gets the accumulated result of a set of callbacks where each element is passed in.</summary>
    /// <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
    /// <param name="seed">The accumulator.</param>
    /// <param name="func">An accumulator function to be invoked on each element.</param>
    /// <returns>The accumulated result of <paramref name="seed"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] Accumulator<TAccumulator> func
    )
    {
        var accumulator = seed;

        foreach (var next in this)
            accumulator = func(accumulator, next);

        return accumulator;
    }

    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Aggregate{TAccumulator}(TAccumulator, Accumulator{TAccumulator})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] RefAccumulator<TAccumulator> func
    )
    {
        var accumulator = seed;

        foreach (var next in this)
            accumulator = func(accumulator, next);

        return accumulator;
    }

    /// <summary>Copies the values to a new flattened array.</summary>
    /// <returns>The array containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray()
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = New4<TBody>();

        foreach (var next in this)
            ret.Append(next);

        return ret.View.ToArray();
#else
        List<TBody> ret = [];

        foreach (var next in this)
            foreach (var element in next)
                ret.Add(element);

        return [.. ret];
#endif
    }

    /// <summary>Copies the values to a new flattened array.</summary>
    /// <param name="divider">The separator between each element.</param>
    /// <returns>The array containing the copied values of this instance.</returns>
    public readonly TBody[] ToArray(ReadOnlySpan<TBody> divider) => ToArray(in divider);

    /// <inheritdoc cref="ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(scoped in ReadOnlySpan<TBody> divider)
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = New4<TBody>();

        var e = GetEnumerator();

        if (e.MoveNext())
            ret.Append(e.Current);
        else
            return [];

        while (e.MoveNext())
            ret.Append(divider).Append(e.Current);

        return ret.View.ToArray();
#else
        List<TBody> ret = [];

        var e = GetEnumerator();

        if (!e.MoveNext())
            return [];

        foreach (var next in e.Current)
            ret.Add(next);

        while (e.MoveNext())
        {
            foreach (var next in divider)
                ret.Add(next);

            foreach (var next in e.Current)
                ret.Add(next);
        }

        return [.. ret];
#endif
    }

    /// <summary>Copies the values to a new nested array.</summary>
    /// <returns>The nested array containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[][] ToArrays()
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = New4<TBody[]>();

        foreach (var next in this)
            ret.Append(next.ToArray());

        return ret.View.ToArray();
#else
        List<TBody[]> ret = [];

        foreach (var next in this)
            ret.Add(next.ToArray());

        return [.. ret];
#endif
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] // ReSharper disable once RedundantUnsafeContext
    static unsafe RefAccumulator<StringBuilder> StringBuilderAccumulator() =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        static (StringBuilder builder, in ReadOnlySpan<TBody> span) => builder.Append(
            MemoryMarshal.CreateReadOnlySpan(
                ref Unsafe.As<TBody, char>(ref MemoryMarshal.GetReference(span)),
                span.Length
            )
        );
#else
        static (StringBuilder builder, in ReadOnlySpan<TBody> span) =>
        {
#if NETFRAMEWORK && !NET46_OR_GREATER || NETSTANDARD && !NETSTANDARD1_3_OR_GREATER
            for (var i = 0; i < span.Length; i++)
                builder.Append(((char*)span.Pointer)[i]);

            return builder;
#else
#pragma warning disable 8500
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
            var ptr = span.Pointer;
#else
            fixed (TBody* ptr = span)
#endif
#pragma warning restore 8500
                return builder.Append((char*)ptr, span.Length);
#endif
        };
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static ReadOnlySpan<TBody> UnsafelyAdvance(ReadOnlySpan<TBody> body, int start) =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        MemoryMarshal.CreateReadOnlySpan(
            ref Unsafe.Add(ref MemoryMarshal.GetReference(body), start),
            body.Length - start
        );
#else
        body[start..];
#endif

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static ReadOnlySpan<TBody> UnsafelyTake(ReadOnlySpan<TBody> body, int end) =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        MemoryMarshal.CreateReadOnlySpan(ref MemoryMarshal.GetReference(body), end);
#else
        body[..end];
#endif
}

// SPDX-License-Identifier: MPL-2.0
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
// ReSharper disable once CheckNamespace EmptyNamespace




/// <summary>Encapsulates a single value to be exposed as a <see cref="Memory{T}"/> of size 1.</summary>
/// <typeparam name="T">The type of value.</typeparam>
/// <param name="value">The value to encapsulate.</param>
public sealed partial class OnceMemoryManager<T>(T value) : MemoryManager<T>
{
    GCHandle _handle;

    // ReSharper disable once ReplaceWithPrimaryConstructorParameter
    T _value = value;

    /// <summary>Gets the value.</summary>
    public T Value
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
    }

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable IDISP010, IDISP023
    protected override void Dispose(bool disposing) => Unpin();
#pragma warning restore IDISP010, IDISP023
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Unpin()
    {
        if (_handle.IsAllocated)
            _handle.Free();
    }

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public override unsafe MemoryHandle Pin(int elementIndex = 0) =>
        typeof(T).IsValueType
            ? default
            : new(
                (void*)(_handle.IsAllocated ? _handle : _handle = GCHandle.Alloc(_value, GCHandleType.Pinned))
               .AddrOfPinnedObject()
            );

    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public override Span<T> GetSpan() => Ref(ref _value);
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible InvertIf InvocationIsSkipped RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias


#pragma warning disable 8618, 9193, CA1823, IDE0250, MA0071, MA0102, RCS1158, SA1137



/// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}"/>
readonly ref partial struct SplitSpan<TBody, TSeparator, TStrategy>
{
    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetEnumerator() => new(this);

    /// <summary>
    /// Represents the enumeration object that views <see cref="SplitSpan{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public
#if !NO_REF_STRUCTS
        ref
#endif
        partial struct Enumerator(ReadOnlySpan<TBody> body, ReadOnlySpan<TSeparator> separator)
    {
        readonly ReadOnlySpan<TSeparator> _separator = separator;

        ReadOnlySpan<TBody> _body = body, _current;

        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(ReadOnlySpan<TBody> body)
            : this(body, default) { }

        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(SplitSpan<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }

        /// <inheritdoc cref="SplitSpan{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlySpan<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
        }

        /// <inheritdoc cref="IEnumerator.Current"/>
        public readonly ReadOnlySpan<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }

        /// <summary>Performs one step of an enumeration over the provided spans.</summary>
        /// <param name="sep">The separator span.</param>
        /// <param name="body">The span that contains the current state of the enumeration.</param>
        /// <param name="current">The current span.</param>
        /// <returns>
        /// <see langword="true"/> if a step was able to be performed successfully;
        /// <see langword="false"/> if the end of the collection is reached.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Move(
            scoped in ReadOnlySpan<TSeparator> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        ) =>
            0 switch
            {
                _ when body.IsEmpty && (current = default) is var _ => false,
                _ when sep.IsEmpty => (current = body) is var _ && (body = default) is var _,
                _ when typeof(TStrategy) == typeof(MatchAll) =>
                    MoveNextAll(To<TBody>.From(sep), ref body, out current),
#if NET8_0_OR_GREATER
                _ when typeof(TStrategy) == typeof(MatchAny) && typeof(TSeparator) == typeof(SearchValues<TBody>) =>
                    MoveNextAny(To<SearchValues<TBody>>.From(sep), ref body, out current),
#endif
                _ when typeof(TStrategy) == typeof(MatchAny) =>
                    MoveNextAny(To<TBody>.From(sep), ref body, out current),
                _ when typeof(TStrategy) == typeof(MatchOne) =>
                    MoveNextOne(To<TBody>.From(sep), ref body, out current),
                _ => throw Error,
            };

        /// <inheritdoc cref="IEnumerator.MoveNext"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => Move(_separator, ref _body, out _current);

        /// <summary>
        /// Checks if two sequences of type <see name="TBody"/> are equal while iterating through the next element.
        /// </summary>
        /// <typeparam name="TOtherSeparator">The type of separator used in the other sequence.</typeparam>
        /// <typeparam name="TOtherStrategy">The strategy used for splitting the other sequence.</typeparam>
        /// <param name="other">The enumerator for the other sequence.</param>
        /// <param name="reader">The <see cref="ReadOnlySpan{T}"/> representing this sequence.</param>
        /// <param name="otherReader">The <see cref="ReadOnlySpan{T}"/> representing the other sequence.</param>
        /// <param name="ret">
        /// Output parameter indicating if the sequences are equal.
        /// Note that this value is undefined if <see langword="false"/> is returned.
        /// </param>
        /// <returns>
        /// The value <see langword="true"/> if enumeration should be stopped; otherwise, <see langword="false"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool EqualityMoveNext<TOtherSeparator, TOtherStrategy>(
            ref SplitSpan<TBody, TOtherSeparator, TOtherStrategy>.Enumerator other,
            ref ReadOnlySpan<TBody> reader,
            ref ReadOnlySpan<TBody> otherReader,
            out bool ret
        )
#if !NET7_0_OR_GREATER
            where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        {
            Unsafe.SkipInit(out ret);

            if (reader.Length is var length && otherReader.Length is var otherLength && length == otherLength)
                return SameLength(ref other, ref reader, ref otherReader, ref ret);

            if (length < otherLength)
            {
                if (!reader.SequenceEqual(otherReader[..length]) || !MoveNext())
                {
                    ret = false;
                    return true;
                }

                reader = Current;
                otherReader = otherReader[length..];
                return false;
            }

            if (!UnsafelyTake(reader, otherLength).SequenceEqual(otherReader) || !other.MoveNext())
            {
                ret = false;
                return true;
            }

            reader = UnsafelyTake(reader, otherLength);
            otherReader = other.Current;
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAll(
            scoped in ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAll), "TStrategy is MatchAll");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
        Retry:

            switch (body.IndexOf(sep))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case 0:
                    if (body.Length != sep.Length)
                    {
                        body = UnsafelyAdvance(body, sep.Length);
                        goto Retry;
                    }

                    current = default;
                    return false;
                case var i:
                    current = UnsafelyTake(body, i);
                    body = UnsafelyAdvance(body, i + sep.Length);
                    return true;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable MA0051
        static bool MoveNextAny(
            scoped in ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
#pragma warning restore MA0051
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
#if NET7_0_OR_GREATER
            switch (body.IndexOfAnyExcept(sep))
            {
                case -1:
                    current = default;
                    return false;
                case 0: break;
                case var i:
                    body = UnsafelyAdvance(body, i);
                    break;
            }

            if (body.IndexOfAny(sep) is not -1 and var length)
            {
                current = UnsafelyTake(body, length);
                body = UnsafelyAdvance(body, length + 1);
                return true;
            }

            current = body;
            body = default;
#else
        Retry:

            var min = int.MaxValue;

            foreach (var next in sep)
                switch (body.IndexOf(next))
                {
                    case -1: continue;
                    case 0:
                        if (body.Length is not 1)
                        {
                            body = UnsafelyAdvance(body, 1);
                            goto Retry;
                        }

                        current = default;
                        return false;
                    case var i when i < min:
                        min = i;
                        continue;
                }

            if (min is not int.MaxValue)
            {
                current = UnsafelyTake(body, min);
#pragma warning disable S3949
                body = UnsafelyAdvance(body, min + 1);
#pragma warning restore S3949
                return true;
            }

            current = body;
            body = default;
#endif
            return true;
        }

#if NET8_0_OR_GREATER
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAny(
            scoped in ReadOnlySpan<SearchValues<TBody>> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            ref var single = ref MemoryMarshal.GetReference(sep);

            switch (body.IndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case 0: break;
                case var offset:
                    body = UnsafelyAdvance(body, offset);
                    break;
            }

            if (body.IndexOfAny(single) is not -1 and var length)
            {
                current = UnsafelyTake(body, length);
                body = UnsafelyAdvance(body, length + 1);
                return true;
            }

            current = body;
            body = default;
            return true;
        }
#endif
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextOne(
            scoped in ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchOne), "TStrategy is MatchOne");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
            ref var single = ref MemoryMarshal.GetReference(sep);
#else
            var single = sep[0];
#endif
#if !NET7_0_OR_GREATER
        Retry:
#endif
#if NET7_0_OR_GREATER
            switch (body.IndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case 0: break;
                case var offset:
                    body = UnsafelyAdvance(body, offset);
                    break;
            }

            if (body.IndexOf(single) is not -1 and var length)
            {
                current = UnsafelyTake(body, length);
                body = UnsafelyAdvance(body, length + 1);
                return true;
            }

            current = body;
            body = default;
            return true;
#else
            switch (body.IndexOf(single))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case 0:
                    if (body.Length is not 1)
                    {
                        body = UnsafelyAdvance(body, 1);
                        goto Retry;
                    }

                    current = default;
                    return false;
                case var i:
                    current = UnsafelyTake(body, i);
                    body = UnsafelyAdvance(body, i + 1);
                    return true;
            }
#endif
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        bool SameLength<TOtherSeparator, TOtherStrategy>(
            ref SplitSpan<TBody, TOtherSeparator, TOtherStrategy>.Enumerator other,
            ref ReadOnlySpan<TBody> reader,
            ref ReadOnlySpan<TBody> otherReader,
            ref bool ret
        )
#if !NET7_0_OR_GREATER
            where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        {
            if (!reader.SequenceEqual(otherReader))
            {
                ret = false;
                return true;
            }

            if (!MoveNext())
            {
                ret = !other.MoveNext();
                return true;
            }

            if (!other.MoveNext())
            {
                ret = false;
                return true;
            }

            reader = Current;
            otherReader = other.Current;
            return false;
        }
    }
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible InvertIf InvocationIsSkipped RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias


#pragma warning disable 8618, 9193, CA1823, IDE0250, MA0071, MA0102, RCS1158, SA1137



/// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}"/>
readonly ref partial struct SplitSpan<TBody, TSeparator, TStrategy>
{
    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReversedEnumerator GetReversedEnumerator() => new(this);

    /// <summary>
    /// Represents the enumeration object that views <see cref="SplitSpan{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public
#if !NO_REF_STRUCTS
        ref
#endif
        partial struct ReversedEnumerator(ReadOnlySpan<TBody> body, ReadOnlySpan<TSeparator> separator)
    {
        readonly ReadOnlySpan<TSeparator> _separator = separator;

        ReadOnlySpan<TBody> _body = body, _current;

        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(ReadOnlySpan<TBody> body)
            : this(body, default) { }

        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(SplitSpan<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }

        /// <inheritdoc cref="SplitSpan{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlySpan<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
        }

        /// <inheritdoc cref="IEnumerator.Current"/>
        public readonly ReadOnlySpan<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }

        /// <summary>Performs one step of an enumeration over the provided spans.</summary>
        /// <param name="sep">The separator span.</param>
        /// <param name="body">The span that contains the current state of the enumeration.</param>
        /// <param name="current">The current span.</param>
        /// <returns>
        /// <see langword="true"/> if a step was able to be performed successfully;
        /// <see langword="false"/> if the end of the collection is reached.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MoveNext(
            scoped in ReadOnlySpan<TSeparator> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        ) =>
            0 switch
            {
                _ when body.IsEmpty && (current = default) is var _ => false,
                _ when sep.IsEmpty => (current = body) is var _ && (body = default) is var _,
                _ when typeof(TStrategy) == typeof(MatchAll) =>
                    MoveNextAll(To<TBody>.From(sep), ref body, out current),
#if NET8_0_OR_GREATER
                _ when typeof(TStrategy) == typeof(MatchAny) && typeof(TSeparator) == typeof(SearchValues<TBody>) =>
                    MoveNextAny(To<SearchValues<TBody>>.From(sep), ref body, out current),
#endif
                _ when typeof(TStrategy) == typeof(MatchAny) =>
                    MoveNextAny(To<TBody>.From(sep), ref body, out current),
                _ when typeof(TStrategy) == typeof(MatchOne) =>
                    MoveNextOne(To<TBody>.From(sep), ref body, out current),
                _ => throw Error,
            };

        /// <inheritdoc cref="IEnumerator.MoveNext"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => MoveNext(_separator, ref _body, out _current);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAll(
            scoped in ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAll), "TStrategy is MatchAll");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
        Retry:

            switch (body.LastIndexOf(sep))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case var i when i == body.Length - sep.Length:
                    if (body.Length != sep.Length)
                    {
                        body = UnsafelyTake(body, i);
                        goto Retry;
                    }

                    current = default;
                    return false;
                case var i:
                    current = UnsafelyAdvance(body, i + sep.Length);
                    body = UnsafelyTake(body, i);
                    return true;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable MA0051
        static bool MoveNextAny(
            scoped in ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
#pragma warning restore MA0051
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
#if NET7_0_OR_GREATER
            switch (body.LastIndexOfAnyExcept(sep))
            {
                case -1:
                    current = default;
                    return false;
                case var i when i == body.Length - 1: break;
                case var i:
                    body = UnsafelyTake(body, i + 1);
                    break;
            }

            if (body.LastIndexOfAny(sep) is not -1 and var length)
            {
                current = UnsafelyAdvance(body, length + 1);
                body = UnsafelyTake(body, length);
                return true;
            }

            current = body;
            body = default;
#else
        Retry:

            var max = -1;

            foreach (var next in sep)
                switch (body.LastIndexOf(next))
                {
                    case -1: continue;
                    case var i when i == body.Length - 1:
                        if (body.Length is not 1)
                        {
                            body = UnsafelyTake(body, body.Length - 1);
                            goto Retry;
                        }

                        current = default;
                        return false;
                    case var i when i > max:
                        max = i;
                        continue;
                }

            if (max is not -1)
            {
                current = UnsafelyAdvance(body, max + 1);
                body = UnsafelyTake(body, max);
                return true;
            }

            current = body;
            body = default;
#endif
            return true;
        }

#if NET8_0_OR_GREATER
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAny(
            scoped in ReadOnlySpan<SearchValues<TBody>> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            ref var single = ref MemoryMarshal.GetReference(sep);

            switch (body.LastIndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case var i when i == body.Length - 1: break;
                case var i:
                    body = UnsafelyTake(body, i + 1);
                    break;
            }

            if (body.LastIndexOfAny(single) is not -1 and var length)
            {
                current = UnsafelyAdvance(body, length + 1);
                body = UnsafelyTake(body, length);
                return true;
            }

            current = body;
            body = default;
            return true;
        }
#endif
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextOne(
            scoped in ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchOne), "TStrategy is MatchOne");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
            ref var single = ref MemoryMarshal.GetReference(sep);
#else
            var single = sep[0];
#endif
#if !NET7_0_OR_GREATER
        Retry:
#endif
#if NET7_0_OR_GREATER
            switch (body.LastIndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case var i when i == body.Length - 1: break;
                case var offset:
                    body = UnsafelyTake(body, offset + 1);
                    break;
            }

            if (body.IndexOf(single) is not -1 and var length)
            {
                current = UnsafelyAdvance(body, length + 1);
                body = UnsafelyTake(body, length);
                return true;
            }

            current = body;
            body = default;
            return true;
#else
            switch (body.LastIndexOf(single))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case var i when i == body.Length - 1:
                    if (body.Length is not 1)
                    {
                        body = UnsafelyTake(body, 1);
                        goto Retry;
                    }

                    current = default;
                    return false;
                case var i:
                    current = UnsafelyAdvance(body, i);
                    body = UnsafelyTake(body, i - 1);
                    return true;
            }
#endif
        }
    }
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable once CheckNamespace


/// <summary>Provides methods for heap-allocation analysis.</summary>

    /// <summary>
    /// A <see langword="string"/> to use in an <see cref="ObsoleteAttribute"/> to indicate that the API isn't meant
    /// for production, but not for deprecated reasons.
    /// </summary>
    const string NotForProduction = "NOT deprecated. While this can be used in Release builds to run this on " +
        "optimized code; This API exists for debugging builds and should be excluded from final production builds.";

    /// <summary>Swallows all exceptions from a callback; Use with caution.</summary>
    /// <param name="action">The dangerous callback.</param>
    /// <returns>An exception, if caught.</returns>
    [Inline, Obsolete(NotForProduction)]
    public static Exception? Swallow([InstantHandle] this Action action)
    {
        try
        {
            action();
            return null;
        }
#pragma warning disable CA1031
        catch (Exception ex)
#pragma warning restore CA1031
        {
            return ex;
        }
    }

    /// <summary>Swallows all exceptions from a callback; Use with caution.</summary>
    /// <typeparam name="T">The type of return.</typeparam>
    /// <param name="func">The dangerous callback.</param>
    /// <returns>The value returned from <paramref name="func"/>, or the exception caught.</returns>
    [Inline, Obsolete(NotForProduction)]
    public static (T?, Exception?) Swallow<T>([InstantHandle] this Func<T> func)
    {
        try
        {
            return (func(), null);
        }
#pragma warning disable CA1031
        catch (Exception ex)
#pragma warning restore CA1031
        {
            return (default, ex);
        }
    }

    /// <summary>Gets the amount of bytes a callback uses.</summary>
    /// <remarks><para>
    /// This method temporarily tunes the <see cref="GC"/> to <see cref="GCLatencyMode.LowLatency"/>
    /// for accurate results. As such, the parameter <paramref name="heap"/> should not cause
    /// substantial allocation such that collecting mid-way is required.
    /// </para></remarks>
    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
    /// <returns>The number of bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.</returns>
    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
    public static long CountAllocation([InstantHandle, RequireStaticDelegate] Action heap, bool willWarmup = true)
    {
        if (willWarmup)
            heap.Swallow();
#if !(NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER)
        var mode = GCSettings.LatencyMode;
#endif
        try
        {
#if NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            GC.TryStartNoGCRegion(ushort.MaxValue, ushort.MaxValue);
#else
            GCSettings.LatencyMode = GCLatencyMode.LowLatency;
#endif
#if NETCOREAPP3_0_OR_GREATER
            var before = GC.GetTotalAllocatedBytes(true);
#else
            var before = GC.GetTotalMemory(true);
#endif
            heap.Swallow();
#if NETCOREAPP3_0_OR_GREATER
            var after = GC.GetTotalAllocatedBytes(true);
#else
            var after = GC.GetTotalMemory(false); // Prevents last-second garbage collection.
#endif

            return after - before;
        }
        finally
        {
#if NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            if (GCSettings.LatencyMode is GCLatencyMode.NoGCRegion)
                GC.EndNoGCRegion();
#else
            GCSettings.LatencyMode = mode;
#endif
        }
    }

    /// <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
    /// <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
    /// <returns>
    /// An <see cref="Array"/> where each entry is a separate test of the number of
    /// bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.
    /// </returns>
    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
    public static long[] CountAllocations(
        [InstantHandle, RequireStaticDelegate] Action heap,
        [NonNegativeValue] int times = byte.MaxValue,
        bool willWarmup = true
    )
    {
        if (willWarmup)
            heap.Swallow();

        var all = new long[times];

        for (var i = 0; i < times; i++)
            all[i] += CountAllocation(heap, false);

        return all;
    }

    /// <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
    /// <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
    /// <returns>
    /// An <see cref="Array"/> where each entry is a separate test of the number of
    /// bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.
    /// </returns>
    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
    public static bool HasAllocations(
        [InstantHandle, RequireStaticDelegate] Action heap,
        [NonNegativeValue] int times = byte.MaxValue,
        bool willWarmup = true
    )
    {
        if (willWarmup)
            heap.Swallow();

        for (var i = 0; i < times; i++)
            if (CountAllocation(heap, false) is not 0)
                return true;

        return false;
    }

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable CS8632, MA0048, SA1629, SYSLIB0003, GlobalUsingsAnalyzer
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
#endif

// ReSharper disable once CheckNamespace

#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
#endif

/// <summary>Provides methods for exiting the program.</summary>

    /// <remarks><para>This method represents the exit code 0, indicating success.</para></remarks>
    /// <inheritdoc cref="With"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static Exception Success(string? message = null) => throw With(0, message);

    /// <remarks><para>This method represents the exit code 1, indicating failure.</para></remarks>
    /// <inheritdoc cref="With"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static Exception Failure(string? message = null) => throw With(1, message);

    /// <remarks><para>This method represents the exit code 2, indicating invalid parameters.</para></remarks>
    /// <inheritdoc cref="With"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static Exception Usage(string? message = null) => throw With(2, message);

    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <inheritdoc cref="Success"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static T Success<T>(string? message = null) => throw With(0, message);

    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <inheritdoc cref="Failure"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static T Failure<T>(string? message = null) => throw With(1, message);

    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <inheritdoc cref="Usage"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static T Usage<T>(string? message = null) => throw With(2, message);

    /// <summary>Terminates this process and returns the exit code to the operating system.</summary>
    /// <param name="message">The message to print into the standard output/error, if specified.</param>
    /// <exception cref="SecurityException">
    /// The caller does not have sufficient security permission to perform this function.
    /// </exception>
    /// <returns>This method does not return. Specified to allow <see langword="throw"/> expressions.</returns>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
#pragma warning disable CS1573
    static Exception With(byte exitCode, string? message)
#pragma warning restore CS1573
    {
        if (message is not null)
            (exitCode is 0 ? Console.Out : Console.Error).WriteLine(message);

        Environment.Exit(exitCode);
        throw Unreachable;
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer



// ReSharper disable once CheckNamespace RedundantUsingDirective.Global


/// <summary>Provides a reference for an <c>UnreachableException</c>.</summary>
#pragma warning disable MA0048

    /// <summary>Gets the <see cref="Exception"/> that a collection cannot be empty.</summary>
    public static InvalidOperationException CannotBeEmpty { get; } = new("Buffer is empty.");

    /// <summary>Gets the <see cref="Exception"/> that represents unfinished logic.</summary>
    public static NotImplementedException Todo { get; } = new();

    /// <summary>Gets the <see cref="Exception"/> that represents an unreachable state.</summary>
    public static UnreachableException Unreachable { get; } = new();

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable CS8632, RCS1196

// ReSharper disable once CheckNamespace


/// <summary>Provides methods to use callbacks within a statement.</summary>
#pragma warning disable MA0048

    const string DebugFile = "/tmp/morsels.log";
#if DEBUG
    static Peeks() => File.Create(DebugFile).Dispose();
#endif

    /// <summary>An event that is invoked every time <see cref="Write"/> is called.</summary>
    // ReSharper disable RedundantCast
    // ReSharper disable once EventNeverSubscribedTo.Global
    public static event Action<string> OnWrite =
#if NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2
        Shout;
#else
        (Action<string>)Shout +
#if KTANE
        (Action<string>)UnityEngine.Debug.Log +
#endif
        (Action<string>)Console.WriteLine;
#endif
#if NETFRAMEWORK || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <summary>Gets all of the types currently loaded.</summary>
    [Pure]
    public static IEnumerable<Type> AllTypes =>
        AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.TryGetTypes());
#endif
#pragma warning disable CS1574
    /// <summary>
    /// Invokes <see cref="System.Diagnostics.Debug.WriteLine(string)"/>, and <see cref="Trace.WriteLine(string)"/>.
    /// </summary>
    /// <remarks><para>
    /// This method exists to be able to hook both conditional methods in <see cref="OnWrite"/>,
    /// and to allow the consumer to be able to remove this method to the same <see cref="OnWrite"/>.
    /// </para></remarks>
    /// <param name="message">The value to send a message.</param>
#pragma warning restore CS1574
    public static void Shout(string message)
    {
        // ReSharper disable once InvocationIsSkipped
        System.Diagnostics.Debug.WriteLine(message);
#if !(NETSTANDARD && !NETSTANDARD2_0_OR_GREATER)
        Trace.WriteLine(message);
#endif
        if (File.Exists(DebugFile))
            File.AppendAllText(DebugFile, $"[{DateTime.Now.ToLongTimeString()}]: {message}\n");
    }

    /// <summary>Quick and dirty debugging function, invokes <see cref="OnWrite"/>.</summary>
    /// <param name="message">The value to send a message.</param>
    /// <exception cref="InvalidOperationException">
    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
    /// every callback has been manually removed as it is always valid by default.
    /// </exception>
    public static void Write(this string message) => (OnWrite ?? throw new InvalidOperationException(message))(message);
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <summary>Quick and dirty debugging function, invokes <see cref="OnWrite"/>.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to stringify.</param>
    /// <exception cref="InvalidOperationException">
    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
    /// every callback has been manually removed as it is always valid by default.
    /// </exception>
    // ReSharper disable once InvokeAsExtensionMethod
    public static void Write<T>(T value) => Write(Stringifier.Stringify(value));

    /// <summary>Quick and dirty debugging function.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to stringify and return.</param>
    /// <param name="shouldPrettify">Determines whether to prettify the resulting <see cref="string"/>.</param>
    /// <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
    /// <param name="map">The map callback.</param>
    /// <param name="filter">The filter callback.</param>
    /// <param name="logger">The logging callback.</param>
    /// <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
    /// <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
    /// <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
    /// <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
    /// <exception cref="InvalidOperationException">
    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
    /// every callback has been manually removed as it is always valid by default.
    /// </exception>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    [return: NotNullIfNotNull(nameof(value))]
    public static T Debug<T>(
        this T value,
        bool shouldPrettify = true,
        bool shouldLogExpression = true,
        [InstantHandle] Converter<T, object?>? map = null,
        [InstantHandle] Predicate<T>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
    {
        const string
            Indent = "\n        ",
            Of = $"{Indent}of ";

#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
#pragma warning disable 8500
        static unsafe StringBuilder Accumulator(StringBuilder accumulator, scoped in ReadOnlySpan<char> next)
        {
            var trimmed = next.Trim();

            fixed (char* ptr = &trimmed[0])
                accumulator.Append(ptr, trimmed.Length).Append(' ');

            return accumulator;
        }
#pragma warning restore 8500
#endif

        if (!(filter ?? (_ => true))(value))
            return value;

        logger ??= Write;

        // ReSharper disable ExplicitCallerInfoArgument InvokeAsExtensionMethod RedundantNameQualifier
        var stringified = (map ?? (x => x))(value) switch
        {
            var x when typeof(T) == typeof(string) && !(shouldLogExpression = false) => x,
            string x => x,
            var x when shouldPrettify => Stringifier.Stringify(x).Prettify(),
            var x => Stringifier.Stringify(x),
        };

        var location = shouldLogExpression
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
            ? expression?.Collapse().SplitSpanLines().Aggregate(new StringBuilder(Of), Accumulator)
#else
            ? expression
              ?.Collapse()
               .Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
               .Select(x => x.Trim())
               .Prepend(Of)
               .Conjoin("")
#endif
            : default;

        var log = $"{stringified}{location}{Indent}at {member} in {Path.GetFileName(path)}:line {line}";
        logger(log);
        return value;
    }

    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    [return: NotNullIfNotNull(nameof(value))]
    public static T Debug<T, TAs>(
        this T value,
        bool shouldPrettify = true,
        bool shouldLogExpression = true,
        [InstantHandle] Converter<T, TAs?>? map = null,
        [InstantHandle] Predicate<T>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
    {
        if (!(filter ?? (_ => true))(value))
            return value;

        var stringified = (map ?? (x => x is TAs t ? t : default))(value) switch
        {
            var x when typeof(T) == typeof(string) && !(shouldLogExpression = false) => x as object,
            string x => x,
            var x when shouldPrettify => Stringifier.Stringify(x).Prettify(),
            var x => Stringifier.Stringify(x),
        };

        Debug(
            stringified,
            false,
            shouldLogExpression,
            logger: logger,
            expression: expression,
            path: path,
            line: line,
            member: member
        );

        return value;
    }

    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static Span<T> Debug<T>(
        this in Span<T> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<T[], object?>? map = null,
        [InstantHandle] Predicate<T[]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        // ReSharper disable ExplicitCallerInfoArgument
        _ = value
           .ToArray()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);

        // ReSharper restore ExplicitCallerInfoArgument
        return value;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static PooledSmallList<T> Debug<T>(
        this in PooledSmallList<T> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<T[], object?>? map = null,
        [InstantHandle] Predicate<T[]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        // ReSharper disable ExplicitCallerInfoArgument
        _ = value
           .View
           .ToArray()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);

        // ReSharper restore ExplicitCallerInfoArgument
        return value;
    }
#endif

    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Debug<TBody, TSeparator, TStrategy>(
        this in SplitSpan<TBody, TSeparator, TStrategy> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [InstantHandle] Predicate<TBody[][]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        // ReSharper disable ExplicitCallerInfoArgument
        _ = value
           .ToArrays()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);

        // ReSharper restore ExplicitCallerInfoArgument
        return value;
    }

    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static ReadOnlySpan<T> Debug<T>(
        this ReadOnlySpan<T> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<T[], object?>? map = null,
        [InstantHandle] Predicate<T[]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        // ReSharper disable ExplicitCallerInfoArgument
        _ = value
           .ToArray()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);

        // ReSharper restore ExplicitCallerInfoArgument
        return value;
    }
#endif

    /// <summary>Executes an <see cref="Action{T}"/>, and returns the argument.</summary>
    /// <typeparam name="T">The type of value and action parameter.</typeparam>
    /// <param name="value">The value to pass into the callback.</param>
    /// <param name="action">The callback to perform.</param>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    public static T Peek<T>(this T value, [InstantHandle] Action<T> action)
    {
        action(value);
        return value;
    }
#if !NETFRAMEWORK
    /// <summary>Executes a <see langword="delegate"/> pointer, and returns the argument.</summary>
    /// <typeparam name="T">The type of value and delegate pointer parameter.</typeparam>
    /// <param name="value">The value to pass into the callback.</param>
    /// <param name="call">The callback to perform.</param>
    /// <exception cref="ArgumentNullException">
    /// The value <paramref name="call"/> points to <see langword="null"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    public static unsafe T Peek<T>(this T value, [InstantHandle] delegate*<T, void> call)
    {
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
        if (call is not null)
            call(value);

        return value;
    }
#endif

    /// <summary>Executes the function, and returns the result.</summary>
    /// <typeparam name="T">The type of value and input parameter.</typeparam>
    /// <typeparam name="TResult">The type of output and return value.</typeparam>
    /// <param name="value">The value to pass into the callback.</param>
    /// <param name="converter">The callback to perform.</param>
    /// <returns>The return value of <paramref name="converter"/> after passing in <paramref name="value"/>.</returns>
    public static TResult Then<T, TResult>(this T value, [InstantHandle] Converter<T, TResult> converter) =>
        converter(value);

// SPDX-License-Identifier: MPL-2.0
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
// ReSharper disable once CheckNamespace


// ReSharper disable once RedundantExtendsListEntry RedundantUsingDirective



/// <summary>An extremely bad logger.</summary>
// ReSharper disable once RedundantExtendsListEntry
public sealed partial class BadLogger : IDisposable
{
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Clear"/>
#endif
    static readonly byte[] s_clear = [0x1b, 0x5b, 0x48, 0x1b, 0x5b, 0x32, 0x4a, 0x1b, 0x5b, 0x33, 0x4a];
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <summary>Gets the buffer that clears the console when printed. Only on certain Linux terminals though.</summary>
    /// <remarks><para>
    /// Buffer is based on the following command:
    /// </para><code>
    /// ~$ clear | xxd
    /// 00000000: 1b5b 481b 5b32 4a1b 5b33 4a.[H.[2J.[3J
    /// </code></remarks>
    [Pure]
    public static ReadOnlySpan<byte> Clear => s_clear;
#endif

    /// <summary>Gets the default interval when one is left unspecified.</summary>
    [Pure]
    public static TimeSpan DefaultInterval { get; } = TimeSpan.FromMilliseconds(100);

    readonly Stopwatch _stopwatch = new();

    readonly FileStream _stream;

    readonly TimeSpan _interval;

    TimeSpan _last;

    /// <summary>Initializes a new instance of the <see cref="BadLogger"/> class.</summary>
    /// <param name="path">The path to the file to write.</param>
    /// <param name="interval">The rate of flushing the stream.</param>
    public BadLogger(string path = "/tmp/morsels.log", TimeSpan? interval = null)
    {
        _interval = interval ?? DefaultInterval;
        (_stream = File.OpenWrite(path)).SetLength(0);
        _stream.Write(s_clear, 0, s_clear.Length);
        OnWrite += Log;
        "..".Debug();
        _stopwatch.Start();
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _stopwatch.Stop();
        "(◕_◕)🎉".Debug();
        _stopwatch.ElapsedMilliseconds.ToString("0ms").Debug();
        OnWrite -= Log;
        _stream.Dispose();
    }

    /// <summary>Logs the message.</summary>
    /// <param name="entry">The entry to log.</param>
    public void Log(string entry)
    {
        var log = $"[{DateTime.Now:HH:mm:ss.fff}]: {entry}\n";
#if NETCOREAPP3_0_OR_GREATER
        const int MaxBytesInUtf16 = 3;
        Allocate(log.Length * MaxBytesInUtf16, (this, log), Write());
#else
        var bytes = Encoding.UTF8.GetBytes(log);
        _stream.Write(bytes, 0, bytes.Length);
#endif
        TryFlush();
    }

    /// <summary>Attempts to flush if enough time has elapsed.</summary>
    /// <returns>Whether it flushed.</returns>
    public bool TryFlush()
    {
        if (_stopwatch.Elapsed is var elapsed && elapsed - _last <= _interval)
            return false;

        _last = elapsed;
        _stream.Flush();
        return true;
    }

    /// <summary>Produces the side effect specified by the passed in <see cref="Action"/>.</summary>
    /// <param name="action">The <see cref="Action"/>.</param>
    /// <returns>Itself.</returns>
    public BadLogger Try([InstantHandle] Action action)
    {
        try
        {
            action();
            return this;
        }
        catch (Exception ex)
        {
            $"{ex}".Debug();
            throw;
        }
    }

    /// <summary>Produces the side effect specified by the passed in <see cref="Action{T}"/>.</summary>
    /// <param name="action">The <see cref="Action{T}"/>.</param>
    /// <typeparam name="T">The type of <paramref name="context"/>.</typeparam>
    /// <param name="context">The context value.</param>
    /// <returns>Itself.</returns>
    public BadLogger Try<T>([InstantHandle] Action<T> action, T context)
    {
        try
        {
            action(context);
            return this;
        }
        catch (Exception ex)
        {
            $"{ex}".Debug();
            throw;
        }
    }

    /// <summary>Produces the side effect specified by the passed in <see cref="Action{T1, T2}"/>.</summary>
    /// <param name="action">The <see cref="Action{T1, T2}"/>.</param>
    /// <typeparam name="T1">The type of <paramref name="firstContext"/>.</typeparam>
    /// <typeparam name="T2">The type of <paramref name="secondContext"/>.</typeparam>
    /// <param name="firstContext">The first context value.</param>
    /// <param name="secondContext">The second context value.</param>
    /// <returns>Itself.</returns>
    public BadLogger Try<T1, T2>([InstantHandle] Action<T1, T2> action, T1 firstContext, T2 secondContext)
    {
        try
        {
            action(firstContext, secondContext);
            return this;
        }
        catch (Exception ex)
        {
            $"{ex}".Debug();
            throw;
        }
    }
#if NETCOREAPP3_0_OR_GREATER
    static SpanAction<byte, (BadLogger, string)> Write() =>
        static (span, tuple) =>
        {
            var (that, log) = tuple;
            Utf8.FromUtf16(log, span, out _, out var wrote);
            that._stream.Write(span[..wrote]);
        };
#endif
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
#pragma warning disable GlobalUsingsAnalyzer


// ReSharper disable once CheckNamespace

#pragma warning restore GlobalUsingsAnalyzer
/// <summary>Generates the attribute needed to use this analyzer.</summary>
/// <param name="hintName">The file name of the source.</param>
/// <param name="contents">The contents of the source.</param>
public abstract class FixedGenerator(
    [StringSyntax(StringSyntaxAttribute.Uri), UriString] string hintName,
    [StringSyntax("C#")] string contents
) : IIncrementalGenerator
{
    /// <summary>The header for generated files.</summary>
    [StringSyntax("C#")]
    public const string Header =
        """
        // <auto-generated/>
        // ReSharper disable RedundantNameQualifier
        // ReSharper disable once CheckNamespace
        #nullable enable

        """;

    /// <summary>The extension of each generated file.</summary>
    const string Extension = ".g.cs";

    /// <summary>Gets the attribute that indicates source generation from this library.</summary>
    [Pure, StringSyntax("C#")]
    public static string Annotation { get; } =
#if DEBUG
        $"[global::System.CodeDom.Compiler.GeneratedCode(\"{
            typeof(FixedGenerator).Assembly.ManifestModule.FullyQualifiedName}\", \"{
                typeof(FixedGenerator).Assembly.ManifestModule.ModuleVersionId}\")]";
#else
        $"[global::System.CodeDom.Compiler.GeneratedCode(\"{
            typeof(FixedGenerator).Assembly.GetName().Name}\", \"{
                typeof(FixedGenerator).Assembly.GetName().Version}\")]";
#endif

    /// <summary>Gets the name of the generated attribute.</summary>
    [Pure]
    public string Name => hintName;

    /// <summary>Gets the name of the attribute generated specified by <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The kind of <see cref="FixedGenerator"/> to get the <see cref="Name"/> from.</typeparam>
    /// <returns>The <see cref="Name"/> of the <see cref="FixedGenerator"/> <typeparamref name="T"/>.</returns>
    [Pure]
    public static string Of<T>()
        where T : FixedGenerator, new() =>
        new T().Name;

    /// <inheritdoc />
    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(x => x.AddSource($"{hintName}{Extension}", $"{Header}{contents}\n"));
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
#pragma warning disable GlobalUsingsAnalyzer, SA1216
// ReSharper disable once RedundantUsingDirective.Global


#pragma warning restore GlobalUsingsAnalyzer
// ReSharper disable once CheckNamespace




/// <summary>Contains syntactic operations and registrations.</summary>

    /// <summary>Adds the deconstruction of the tuples onto the <see cref="SourceProductionContext"/>.</summary>
    /// <param name="context">The context to use for source generation.</param>
    /// <param name="generated">The tuple containing the hint name and source.</param>
    public static void AddSource(SourceProductionContext context, GeneratedSource generated) =>
        context.AddSource(generated.HintName, generated.Source);

    /// <summary>Returns whether the provided <see cref="SyntaxNode"/> is of type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of <see cref="SyntaxNode"/> to test the instance for.</typeparam>
    /// <param name="node">The passed in node to test.</param>
    /// <param name="_">The discarded token, existing purely for convenience.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="node"/> is
    /// an instance of <typeparamref name="T"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool AnnotatedAndIs<T>([NotNullWhen(true)] SyntaxNode? node, CancellationToken _ = default)
        where T : MemberDeclarationSyntax =>
        node is T { AttributeLists.Count: >= 1 };

    /// <summary>Determines whether the symbol can be passed in as a generic.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// can be placed as a generic parameter, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool CanBeGeneric([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is
            not null and
            not IDynamicTypeSymbol and
            not IPointerTypeSymbol and
            not { IsRefLikeType: true } and
            not { SpecialType: System_Void };

    /// <summary>Determines whether the symbol is declared with the attribute of the specific name.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <param name="name">The name to get.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// has the attribute <paramref name="name"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool HasAttribute([NotNullWhen(true)] this ISymbol? symbol, string? name)
    {
        [Pure]
        static ReadOnlySpan<char> WithoutAttributeSuffix(string name) =>
            name.AsSpan() is var span && span is [.. var x, 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e'] ? x : span;

        if (symbol is null)
            return false;

        if (name is null)
            return symbol.GetAttributes() is not [];

        var against = WithoutAttributeSuffix(name);

        foreach (var attribute in symbol.GetAttributes())
            if (attribute.AttributeClass?.Name is { } match && WithoutAttributeSuffix(match).SequenceEqual(against))
                return true;

        return false;
    }

    /// <summary>Returns whether the provided <see cref="SyntaxNode"/> is of type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of <see cref="SyntaxNode"/> to test the instance for.</typeparam>
    /// <param name="node">The passed in node to test.</param>
    /// <param name="_">The discarded token, existing purely for convenience.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="node"/> is
    /// an instance of <typeparamref name="T"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool Is<T>([NotNullWhen(true)] SyntaxNode? node, CancellationToken _ = default)
        where T : SyntaxNode =>
        node is T;

    /// <summary>Determines whether the symbol is accessible from an external assembly.</summary>
    /// <param name="accessibility">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="accessibility"/> is accessible externally.
    /// </returns>
    [Pure]
    public static bool IsAccessible(this Accessibility accessibility) =>
        accessibility is Accessibility.Protected or Accessibility.ProtectedOrInternal or Accessibility.Public;

    /// <summary>Determines whether the symbol is accessible from an external assembly.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/> is accessible externally.
    /// </returns>
    [Pure]
    public static bool IsAccessible([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol?.DeclaredAccessibility.IsAccessible() is true;

    /// <summary>
    /// Determines whether the symbol and all subsequent parent types
    /// are declared with the <see langword="partial"/> keyword.
    /// </summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/> and all its subsequent
    /// parent types are <see langword="partial"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsCompletelyPartial([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol?.FindPathToNull(x => x.ContainingType).All(IsPartial) is true;

    /// <summary>Returns whether the provided <see cref="SyntaxNode"/> is the first declaration.</summary>
    /// <param name="node">The passed in node to test.</param>
    /// <param name="symbol">The symbol to retrieve the declaring syntax references from.</param>
    /// <param name="token">The cancellation token.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="node"/> is the first
    /// to declare the parameter <paramref name="symbol"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsFirst(
        this SyntaxNode? node,
        [NotNullWhen(true)] ISymbol? symbol,
        CancellationToken token = default
    ) =>
        symbol is { DeclaringSyntaxReferences: var x } && (x is not [var first, ..] || first.GetSyntax(token) == node);

    /// <summary>Determines whether the symbol is an <see langword="interface"/>.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is an <see langword="interface"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsInterface([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is { BaseType: null, SpecialType: not System_Object };

    /// <summary>Returns whether the provided <see cref="ISymbol"/> is an interface implementation.</summary>
    /// <param name="symbol">The passed in symbol to test.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is an explicit interface implementation, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsInterfaceDeclaration([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol?.Name.Contains('.') ?? false;

    /// <summary>Determines whether the symbol is declared with the <see cref="ObsoleteAttribute"/> attribute.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is obsolete, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsObsolete([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol.HasAttribute(nameof(ObsoleteAttribute));

    /// <summary>Determines whether the symbol is declared with the <see langword="partial"/> keyword.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is <see langword="partial"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsPartial([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol
          ?.DeclaringSyntaxReferences
           .Select(x => x.GetSyntax())
           .OfType<TypeDeclarationSyntax>()
           .Any(x => x.Modifiers.Any(x => x.ValueText is "partial")) is true;

    /// <summary>Determines whether the symbol is an <see langword="unmanaged"/> primitive type.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/> is
    /// an <see langword="unmanaged"/> primitive, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsUnmanagedPrimitive([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is // ReSharper disable once MissingIndent
        {
            SpecialType: System_Char or
            System_SByte or
            System_Byte or
            System_Int16 or
            System_UInt16 or
            System_Int32 or
            System_UInt32 or
            System_Int64 or
            System_UInt64 or
            System_Decimal or
            System_Single or
            System_Double or
            System_IntPtr or
            System_UIntPtr,
        };

    /// <summary>Determines whether the symbol has a default implementation.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>The value <see langword="true"/> if the symbol has a default implementation.</returns>
    [Pure]
    public static bool HasDefaultImplementation([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol is IMethodSymbol { IsAbstract: false, IsVirtual: true };

    /// <summary>Determines whether the symbol has a parameterless constructor.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// has a parameterless constructor, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool HasParameterlessConstructor([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is INamedTypeSymbol { InstanceConstructors: var x } && x.Any(x => x.Parameters is []);

    /// <summary>Gets the hint name of the <see cref="INamedTypeSymbol"/>.</summary>
    /// <param name="symbol">The symbol to use.</param>
    /// <param name="prefix">If specified, the prefix to contain within the hint name.</param>
    /// <returns>The hint name of the parameter <paramref name="symbol"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(symbol))]
    public static string? HintName(this INamedTypeSymbol? symbol, string? prefix = nameof(Emik))
    {
        if (symbol is null)
            return null;

        StringBuilder sb = new(symbol.Name);
        ISymbol? containing = symbol;

        if (symbol.TypeParameters.Length is not 0 and var length)
            sb.Append('`').Append(length);

        while ((containing = containing.ContainingWithoutGlobal()) is not null)
        {
            sb.Insert(0, '.').Insert(0, containing.Name);

            if (containing is INamedTypeSymbol { TypeParameters.Length: not 0 and var i })
                sb.Append('`').Append(i);
        }

        if (prefix is not null)
            sb.Insert(0, '.').Insert(0, prefix);

        return sb.Append(".g.cs").ToString();
    }

    /// <summary>Gets the keyword associated with the declaration of the <see cref="ITypeSymbol"/>.</summary>
    /// <param name="symbol">The symbol to get its keyword.</param>
    /// <returns>The keyword used to declare the parameter <paramref name="symbol"/>.</returns>
    [Pure]
    public static string Keyword(this ITypeSymbol symbol) =>
        symbol switch
        {
            { IsValueType: true, IsRecord: true } => "record struct",
            { IsRecord: true } => "record",
            { IsValueType: true } => "struct",
            { IsReferenceType: true } => "class",
            _ => "",
        };

    /// <summary>Gets the keyword associated with the declaration of the <see cref="RefKind"/>.</summary>
    /// <param name="kind">The symbol to get its keyword.</param>
    /// <returns>The keyword used to declare the parameter <paramref name="kind"/>.</returns>
    [Pure]
    public static string KeywordInParameter(this RefKind kind) =>
        kind switch
        {
            RefKind.In => "in ",
            RefKind.Out => "out ",
            RefKind.Ref => "ref ",
            _ => "",
        };

    /// <summary>Gets the keyword associated with the declaration of the <see cref="RefKind"/>.</summary>
    /// <param name="kind">The symbol to get its keyword.</param>
    /// <returns>The keyword used to declare the parameter <paramref name="kind"/>.</returns>
    [Pure]
    public static string KeywordInReturn(this RefKind kind) =>
        kind switch
        {
            RefKind.Ref => "ref ",
            RefKind.RefReadOnly => "ref readonly ",
            _ => "",
        };

    /// <inheritdoc cref="MemberPath.TryGetMemberName(ExpressionSyntax, out string)"/>
    [Pure]
    public static string? MemberName(this ExpressionSyntax syntax)
    {
        syntax.TryGetMemberName(out var result);
        return result;
    }

    /// <inheritdoc cref="AttributeArgumentSyntaxExt.TryGetStringValue(AttributeArgumentSyntax, SemanticModel, CancellationToken, out string)"/>
    [Pure]
    public static string? StringValue(this SyntaxNodeAnalysisContext context, AttributeArgumentSyntax syntax)
    {
        syntax.TryGetStringValue(context.SemanticModel, context.CancellationToken, out var result);
        return result;
    }

    /// <inheritdoc cref="AnalysisContext.RegisterSyntaxNodeAction{TLanguageKindEnum}(Action{SyntaxNodeAnalysisContext}, TLanguageKindEnum[])"/>
    public static AnalysisContext RegisterSyntaxNodeAction<TSyntaxNode>(
        this AnalysisContext context,
        Action<SyntaxNodeAnalysisContext, TSyntaxNode> action,
        params SyntaxKind[] syntaxKinds
    )
        where TSyntaxNode : SyntaxNode =>
        context.RegisterSyntaxNodeAction(action, ImmutableArray.Create(syntaxKinds));

    /// <inheritdoc cref="AnalysisContext.RegisterSyntaxNodeAction{TLanguageKindEnum}(Action{SyntaxNodeAnalysisContext}, ImmutableArray{TLanguageKindEnum})"/>
    public static AnalysisContext RegisterSyntaxNodeAction<TSyntaxNode>(
        this AnalysisContext context,
        Action<SyntaxNodeAnalysisContext, TSyntaxNode> action,
        ImmutableArray<SyntaxKind> syntaxKinds
    )
        where TSyntaxNode : SyntaxNode
    {
        context.RegisterSyntaxNodeAction(Filter(action), syntaxKinds);
        return context;
    }

    /// <summary>Adds information to a diagnostic.</summary>
    /// <typeparam name="T">The type of <paramref name="message"/>.</typeparam>
    /// <param name="diagnostic">The diagnostic to append.</param>
    /// <param name="message">The string to append.</param>
    /// <returns>The diagnostic with added information.</returns>
    [MustUseReturnValue]
    public static Diagnostic And<T>(this Diagnostic diagnostic, T message) =>
        Diagnostic.Create(
            new(
                diagnostic.Descriptor.Id,
                diagnostic.Descriptor.Title,
                $"{diagnostic.Descriptor.MessageFormat} {message.Stringify()}",
                diagnostic.Descriptor.Category,
                diagnostic.Descriptor.DefaultSeverity,
                diagnostic.Descriptor.IsEnabledByDefault,
                $"{diagnostic.Descriptor.Description} {message.Stringify()}",
                diagnostic.Descriptor.HelpLinkUri,
                diagnostic.Descriptor.CustomTags.ToArrayLazily()
            ),
            diagnostic.Location,
            diagnostic.Severity,
            diagnostic.AdditionalLocations,
            diagnostic.Properties
        );

    /// <summary>Gets all the members, including its base type members.</summary>
    /// <param name="symbol">The symbol to get all of the members of.</param>
    /// <returns>
    /// All of the symbols of the parameter <paramref name="symbol"/>, including the members that come from its
    /// interfaces and base types, and any subsequent interfaces and base types from those.
    /// </returns>
    [Pure]
    public static IEnumerable<ISymbol> GetAllMembers(this INamedTypeSymbol symbol) =>
        symbol
           .BaseType
           .FindPathToNull(x => x.BaseType)
           .SelectMany(GetAllMembers)
           .Concat(symbol.GetMembers());

    /// <summary>Gets the symbol from a lookup.</summary>
    /// <param name="context">The context to use.</param>
    /// <param name="syntax">The syntax to lookup.</param>
    /// <returns>The symbols that likely define it.</returns>
    [Pure]
    public static IEnumerable<ISymbol> Symbols(this in SyntaxNodeAnalysisContext context, ExpressionSyntax syntax) =>
        (syntax.MemberName() ?? $"{syntax}") is var name && syntax is PredefinedTypeSyntax
            ? context.Compilation.GetSymbolsWithName(
                x => x.Contains(name),
                cancellationToken: context.CancellationToken
            )
            : context.SemanticModel.LookupSymbols(syntax.SpanStart, name: name);

    /// <summary>Gets the containing <see cref="INamespaceOrTypeSymbol"/>.</summary>
    /// <param name="syntax">The syntax to lookup.</param>
    /// <returns>The containing type or namespace of the parameter <paramref name="syntax"/>.</returns>
    [Pure]
    public static INamespaceOrTypeSymbol ContainingSymbol(this ISymbol syntax) =>
        syntax.ContainingType ?? (INamespaceOrTypeSymbol)syntax.ContainingNamespace;

    /// <summary>Gets the containing symbol so long as it isn't the global namespace.</summary>
    /// <param name="symbol">The symbol to use.</param>
    /// <returns>The containing symbol, or <see langword="null"/> if it is the global namespace.</returns>
    [Pure]
    public static ISymbol? ContainingWithoutGlobal(this ISymbol? symbol) =>
        symbol?.ContainingSymbol is var x && x is INamespaceSymbol { IsGlobalNamespace: true } ? null : x;

    /// <inheritdoc cref="GetAllMembers(INamespaceSymbol)" />
    [Pure]
    public static IEnumerable<INamespaceOrTypeSymbol> GetAllMembers(this Compilation symbol) =>
        symbol.GlobalNamespace.GetAllMembers();

    /// <inheritdoc cref="GetAllMembers(INamespaceSymbol)" />
    [Pure]
    public static IEnumerable<INamespaceOrTypeSymbol> GetAllMembers(this IAssemblySymbol symbol) =>
        symbol.GlobalNamespace.GetAllMembers();

    /// <summary>Gets all of the types declared by this symbol.</summary>
    /// <param name="symbol">The symbol to get all of the type symbols of.</param>
    /// <returns>
    /// The <see cref="IEnumerable{T}"/> of all types defined in the parameter <paramref name="symbol"/>.
    /// </returns>
    [Pure]
    public static IEnumerable<INamespaceOrTypeSymbol> GetAllMembers(this INamespaceSymbol symbol) =>
        symbol.GetMembers().SelectMany(GetAllNamespaceOrTypeSymbolMembers).Prepend(symbol);

    /// <summary>Gets the underlying type symbol of another symbol.</summary>
    /// <param name="symbol">The symbol to get the underlying type from.</param>
    /// <returns>The underlying type symbol from <paramref name="symbol"/>, if applicable.</returns>
    [Pure]
    public static ITypeSymbol? ToUnderlying(this ISymbol? symbol) =>
        symbol switch
        {
            IEventSymbol x => x.Type,
            IFieldSymbol x => x.Type,
            ILocalSymbol x => x.Type,
            IDiscardSymbol x => x.Type,
            IPropertySymbol x => x.Type,
            IParameterSymbol x => x.Type,
            IMethodSymbol x => x.ReturnType,
            IArrayTypeSymbol x => x.ElementType,
            IPointerTypeSymbol x => x.PointedAtType,
            IFunctionPointerTypeSymbol x => x.Signature.ReturnType,
            _ => null,
        };

    /// <summary>Gets the underlying symbol if the provided parameter is the nullable type.</summary>
    /// <param name="symbol">The symbol to get the underlying type from.</param>
    /// <returns>The underlying type of <paramref name="symbol"/>, if it exists.</returns>
    [Pure]
    public static ITypeSymbol? UnderlyingNullable(this ISymbol? symbol) =>
        symbol is INamedTypeSymbol
        {
            ContainingNamespace: { ContainingNamespace.IsGlobalNamespace: true, Name: nameof(System) },
            Name: nameof(Nullable),
            IsValueType: true,
            TypeArguments:
            [
                { } underlying and not { Name: nameof(Nullable) },
            ],
        }
            ? underlying
            : null;

    /// <summary>Gets the specified symbol.</summary>
    /// <typeparam name="T">The type of symbol to get.</typeparam>
    /// <param name="context">The context.</param>
    /// <param name="token">The cancellation token.</param>
    /// <returns>The context node as <typeparamref name="T"/>.</returns>
    public static T? Get<T>(this in GeneratorSyntaxContext context, CancellationToken token = default)
        where T : ISymbol =>
        context.SemanticModel.GetDeclaredSymbol(context.Node, token) is T symbol ? symbol : default;

    [Pure]
    static Action<SyntaxNodeAnalysisContext> Filter<TSyntaxNode>(Action<SyntaxNodeAnalysisContext, TSyntaxNode> action)
        where TSyntaxNode : SyntaxNode =>
        context =>
        {
            if (!context.IsExcludedFromAnalysis() && context.Node is TSyntaxNode node)
                action(context, node);
        };

    [Pure]
    static IEnumerable<INamespaceOrTypeSymbol> GetAllNamespaceOrTypeSymbolMembers(INamespaceOrTypeSymbol x) =>
        ((x as INamespaceSymbol)?.GetAllMembers() ?? Enumerable.Empty<INamespaceOrTypeSymbol>()).Prepend(x);
#endif

// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
// ReSharper disable once CheckNamespace


/// <summary>Contains syntactic operations and registrations.</summary>

    /// <summary>Gets the fully qualified name for a given symbol.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance.</param>
    /// <returns>The fully qualified name for <paramref name="symbol"/>.</returns>
    public static string GetFullyQualifiedName(this ISymbol symbol) =>
        symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

    /// <summary>Gets the fully qualified name for a given symbol, including nullability annotations.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance.</param>
    /// <returns>The fully qualified name for <paramref name="symbol"/>.</returns>
    public static string GetFullyQualifiedNameWithNullabilityAnnotations(this ISymbol symbol) =>
        symbol.ToDisplayString(
            SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(
                SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
            )
        );

    /// <summary>Checks whether or not a given type symbol has a specified full name.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="name">The full name to check.</param>
    /// <returns>Whether <paramref name="symbol"/> has a full name equals to <paramref name="name"/>.</returns>
    public static bool HasFullyQualifiedName(this ISymbol symbol, string name) =>
        symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == name;

    /// <summary>
    /// Checks whether or not a given symbol has an attribute with the specified fully qualified metadata name.
    /// </summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="name">The attribute name to look for.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified name.</returns>
    public static bool HasAttributeWithFullyQualifiedMetadataName(this ISymbol symbol, string name)
    {
        foreach (var attribute in symbol.GetAttributes())
            if (attribute.AttributeClass is { } named && named.HasFullyQualifiedMetadataName(name))
                return true;

        return false;
    }

    /// <summary>Checks whether or not a given symbol has an attribute with the specified type.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="typeSymbol">The <see cref="ITypeSymbol"/> instance for the attribute type to look for.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified type.</returns>
    public static bool HasAttributeWithType(this ISymbol symbol, ITypeSymbol typeSymbol) =>
        TryGetAttributeWithType(symbol, typeSymbol, out _);

    /// <summary>Tries to get an attribute with the specified type.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="typeSymbol">The <see cref="ITypeSymbol"/> instance for the attribute type to look for.</param>
    /// <param name="attributeData">The resulting attribute, if it was found.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified type.</returns>
    [Pure]
    public static bool TryGetAttributeWithType(
        this ISymbol symbol,
        ITypeSymbol typeSymbol,
        [NotNullWhen(true)] out AttributeData? attributeData
    )
    {
        // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
        foreach (var attribute in symbol.GetAttributes())
            if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, typeSymbol))
            {
                attributeData = attribute;
                return true;
            }

        attributeData = null;
        return false;
    }

    /// <summary>Checks whether or not a given type symbol has a specified fully qualified metadata name.</summary>
    /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance to check.</param>
    /// <param name="name">The full name to check.</param>
    /// <returns>Whether <paramref name="symbol"/> has a full name equals to <paramref name="name"/>.</returns>
    public static bool HasFullyQualifiedMetadataName(this ITypeSymbol symbol, string name)
    {
        var builder = ImmutableArrayBuilder<char>.Rent();

        try
        {
            symbol.AppendFullyQualifiedMetadataName(builder);
            return builder.WrittenSpan.SequenceEqual(name.AsSpan());
        }
        finally
        {
            builder.Dispose();
        }
    }

    /// <summary>Gets the fully qualified metadata name for a given <see cref="ITypeSymbol"/> instance.</summary>
    /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance.</param>
    /// <returns>The fully qualified metadata name for <paramref name="symbol"/>.</returns>
    [Pure]
    public static string GetFullyQualifiedMetadataName(this ITypeSymbol symbol)
    {
        var builder = ImmutableArrayBuilder<char>.Rent();

        try
        {
            symbol.AppendFullyQualifiedMetadataName(builder);
            return builder.ToString();
        }
        finally
        {
            builder.Dispose();
        }
    }

    /// <summary>Tries to get an attribute with the specified fully qualified metadata name.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="name">The attribute name to look for.</param>
    /// <param name="attributeData">The resulting attribute, if it was found.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified name.</returns>
    [Pure]
    public static bool TryGetAttributeWithFullyQualifiedMetadataName(
        this ISymbol symbol,
        string name,
        [NotNullWhen(true)] out AttributeData? attributeData
    )
    {
        foreach (var attribute in symbol.GetAttributes())
            if (attribute.AttributeClass is { } named && named.HasFullyQualifiedMetadataName(name))
            {
                attributeData = attribute;
                return true;
            }

        attributeData = null;
        return false;
    }

    /// <summary>Calculates the effective accessibility for a given symbol.</summary>
    /// <param name="symbol">The <see cref="ISymbol"/> instance to check.</param>
    /// <returns>The effective accessibility for <paramref name="symbol"/>.</returns>
    [Pure]
    public static Accessibility GetEffectiveAccessibility(this ISymbol symbol)
    {
        // Start by assuming it's visible
        var visibility = Accessibility.Public;

        // Handle special cases
        // ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
        switch (symbol.Kind)
        {
            case SymbolKind.Alias: return Accessibility.Private; // ReSharper disable once TailRecursiveCall
            case SymbolKind.Parameter: return GetEffectiveAccessibility(symbol.ContainingSymbol);
            case SymbolKind.TypeParameter: return Accessibility.Private;
        }

        // Traverse the symbol hierarchy to determine the effective accessibility
        while (symbol is not null && symbol.Kind != SymbolKind.Namespace)
        {
            switch (symbol.DeclaredAccessibility)
            {
                case Accessibility.NotApplicable or Accessibility.Private: return Accessibility.Private;
                case Accessibility.Internal or Accessibility.ProtectedAndInternal:
                    visibility = Accessibility.Internal;
                    break;
            }

            symbol = symbol.ContainingSymbol;
        }

        return visibility;
    }

    /// <summary>Checks whether or not a given symbol can be accessed from a specified assembly.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="assembly">The assembly to check the accessibility of <paramref name="symbol"/> for.</param>
    /// <returns>Whether <paramref name="assembly"/> can access <paramref name="symbol"/>.</returns>
    [Pure]
    public static bool CanBeAccessedFrom(this ISymbol symbol, IAssemblySymbol assembly) =>
        symbol.GetEffectiveAccessibility() is var accessibility &&
        accessibility == Accessibility.Public ||
        accessibility == Accessibility.Internal && symbol.ContainingAssembly.GivesAccessTo(assembly);

    /// <summary>Negated <see cref="SyntaxValueProvider.ForAttributeWithMetadataName"/>.</summary>
    /// <inheritdoc cref="SyntaxValueProvider.ForAttributeWithMetadataName"/>
    [Pure]
    public static IncrementalValuesProvider<T> AgainstAttributeWithMetadataName<T>(
        this SyntaxValueProvider syntaxValueProvider,
        string fullyQualifiedMetadataName,
        [InstantHandle] Func<SyntaxNode, CancellationToken, bool> predicate,
        [InstantHandle] Func<SyntaxNode, ISymbol, SemanticModel, CancellationToken, T> transform
    )
    {
        (bool HasValue, T Value) Extract(GeneratorSyntaxContext context, CancellationToken token) =>
            context.SemanticModel.GetDeclaredSymbol(context.Node, token) is { } symbol &&
            !symbol.TryGetAttributeWithFullyQualifiedMetadataName(fullyQualifiedMetadataName, out _)
                ? (true, transform(context.Node, symbol, context.SemanticModel, token))
                : default;

        return syntaxValueProvider
           .CreateSyntaxProvider(predicate, Extract)
           .Where(static x => x.HasValue)
           .Select(static (item, _) => item.Value);
    }

    /// <summary>Filters an <see cref="IncrementalValuesProvider{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="provider">The <see cref="IncrementalValuesProvider{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IncrementalValuesProvider{T}"/> with strictly non-null values.</returns>
    [Pure]
    public static IncrementalValuesProvider<T> Filter<T>(this IncrementalValuesProvider<T?> provider) =>
#pragma warning disable 8619
        provider.Where(x => x is not null);
#pragma warning restore 8619

    /// <summary>Filters an <see cref="IncrementalValuesProvider{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="provider">The <see cref="IncrementalValuesProvider{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IncrementalValuesProvider{T}"/> with strictly non-null values.</returns>
    [Pure]
    public static IncrementalValuesProvider<T> Filter<T>(this IncrementalValuesProvider<T?> provider)
        where T : struct =>
#pragma warning disable 8629
        provider.Where(x => x.HasValue).Select((x, _) => x.Value);
#pragma warning restore 8629

    /// <summary>Filters an <see cref="IncrementalValuesProvider{T}"/> to the specified destination type.</summary>
    /// <typeparam name="TFrom">The initial type.</typeparam>
    /// <typeparam name="TTo">The target type.</typeparam>
    /// <param name="provider">The <see cref="IncrementalValuesProvider{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IncrementalValuesProvider{T}"/> with <typeparamref name="TTo"/> values.</returns>
    [Pure]
    public static IncrementalValuesProvider<TTo> OfType<TFrom, TTo>(this IncrementalValuesProvider<TFrom?> provider)
        where TTo : TFrom => // ReSharper disable once NullableWarningSuppressionIsUsed
        provider.Where(static x => x is TTo).Select(static (x, _) => (TTo)x!);

    /// <summary>Appends the fully qualified metadata name for a given symbol to a target builder.</summary>
    /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance.</param>
    /// <param name="builder">The target <see cref="ImmutableArrayBuilder{T}"/> instance.</param>
    static void AppendFullyQualifiedMetadataName(this ISymbol symbol, in ImmutableArrayBuilder<char> builder)
    {
        static void BuildFrom(ISymbol? symbol, in ImmutableArrayBuilder<char> builder)
        {
            switch (symbol)
            {
                // Namespaces that are nested also append a leading '.'
                case INamespaceSymbol { ContainingNamespace.IsGlobalNamespace: false }:
                    BuildFrom(symbol.ContainingNamespace, builder);
                    builder.Add('.');
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;

                // Other namespaces (ie. the one right before global) skip the leading '.'
                case INamespaceSymbol { IsGlobalNamespace: false }:
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;

                // Types with no namespace just have their metadata name directly written
                case ITypeSymbol { ContainingSymbol: INamespaceSymbol { IsGlobalNamespace: true } }:
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;

                // Types with a containing non-global namespace also append a leading '.'
                case ITypeSymbol { ContainingSymbol: INamespaceSymbol namespaceSymbol }:
                    BuildFrom(namespaceSymbol, builder);
                    builder.Add('.');
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;

                // Nested types append a leading '+'
                case ITypeSymbol { ContainingSymbol: ITypeSymbol typeSymbol }:
                    BuildFrom(typeSymbol, builder);
                    builder.Add('+');
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;
            }
        }

        BuildFrom(symbol, builder);
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
// ReSharper disable NullableWarningSuppressionIsUsed
// ReSharper disable once CheckNamespace


/// <summary>A helper type to build sequences of values with pooled buffers.</summary>
/// <typeparam name="T">The type of items to create sequences for.</typeparam>
[StructLayout(LayoutKind.Auto)]
public ref partial struct ImmutableArrayBuilder<T>
{
    /// <summary>The rented <see cref="Writer"/> instance to use.</summary>
    Writer? _writer;

    /// <summary>
    /// Initializes a new instance of the <see cref="ImmutableArrayBuilder{T}"/> struct with the specified parameters.
    /// </summary>
    /// <param name="writer">The target data writer to use.</param>
    ImmutableArrayBuilder(Writer writer) => _writer = writer;

    /// <inheritdoc cref="ImmutableArray{T}.Builder.Count"/>
    public readonly int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] get => _writer!.Count;
    }

    /// <summary>Gets the data written to the underlying buffer so far, as a <see cref="ReadOnlySpan{T}"/>.</summary>
    [UnscopedRef]
    public readonly ReadOnlySpan<T> WrittenSpan
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] get => _writer!.WrittenSpan;
    }

    /// <summary>Creates a <see cref="ImmutableArrayBuilder{T}"/> value with a pooled underlying data writer.</summary>
    /// <returns>A <see cref="ImmutableArrayBuilder{T}"/> instance to write data to.</returns>
    public static ImmutableArrayBuilder<T> Rent() => new(new());

    /// <inheritdoc cref="ImmutableArray{T}.Builder.Add(T)"/>
    public readonly void Add(T item) => _writer!.Add(item);

    /// <summary>Adds the specified items to the end of the array.</summary>
    /// <param name="items">The items to add at the end of the array.</param>
    public readonly void AddRange(scoped ReadOnlySpan<T> items) => _writer!.AddRange(items);

    /// <inheritdoc cref="ImmutableArray{T}.Builder.ToImmutable"/>
    public readonly ImmutableArray<T> ToImmutable() => ImmutableCollectionsMarshal.AsImmutableArray(ToArray());

    /// <inheritdoc cref="ImmutableArray{T}.Builder.ToArray"/>
    public readonly T[] ToArray() => WrittenSpan.ToArray();

    /// <summary>Gets an <see cref="IEnumerable{T}"/> instance for the current builder.</summary>
    /// <remarks><para>The builder should not be mutated while an enumerator is in use.</para></remarks>
    /// <returns>An <see cref="IEnumerable{T}"/> instance for the current builder.</returns>
    public readonly IEnumerable<T> AsEnumerable() => _writer!;

    /// <inheritdoc/>
    public readonly override string ToString() => WrittenSpan.ToString();

    /// <inheritdoc cref="IDisposable.Dispose"/>
    public void Dispose()
    {
        var writer = _writer;
        _writer = null;
        writer?.Dispose();
    }

    /// <summary>A class handling the actual buffer writing.</summary>
    sealed class Writer : ICollection<T>, IDisposable
    {
        /// <summary>The starting offset within <see cref="_array"/>.</summary>
        int _index;

        /// <summary>The underlying <typeparamref name="T"/> array.</summary>
        T?[]? _array = ArrayPool<T?>.Shared.Rent(typeof(T) == typeof(char) ? 1024 : 8);

        /// <inheritdoc/>
        bool ICollection<T>.IsReadOnly => true;

        /// <inheritdoc cref="ImmutableArrayBuilder{T}.Count"/>
        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => _index;
        }

        /// <inheritdoc cref="ImmutableArrayBuilder{T}.WrittenSpan"/>
        public ReadOnlySpan<T> WrittenSpan
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new(_array!, 0, _index);
        }

        /// <inheritdoc cref="ImmutableArrayBuilder{T}.Add"/>
        public void Add(T item)
        {
            EnsureCapacity(1);
            _array![_index++] = item;
        }

        /// <inheritdoc cref="ImmutableArrayBuilder{T}.AddRange"/>
        public void AddRange(ReadOnlySpan<T> items)
        {
            EnsureCapacity(items.Length);
            items.CopyTo(_array.AsSpan(_index)!);
            _index += items.Length;
        }

        /// <inheritdoc/>
        public void Dispose()
        {
            var array = _array;
            _array = null;

            if (array is not null)
                ArrayPool<T?>.Shared.Return(array, typeof(T) != typeof(char));
        }

        /// <inheritdoc/>
        void ICollection<T>.Clear() => throw new NotSupportedException();

        /// <inheritdoc/>
        void ICollection<T>.CopyTo(T[] array, int arrayIndex) => Array.Copy(_array!, 0, array, arrayIndex, _index);

        /// <summary>
        /// Ensures that <see cref="_array"/> has enough free space to contain a given number of new items.
        /// </summary>
        /// <param name="requestedSize">The minimum number of items to ensure space for in <see cref="_array"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void EnsureCapacity(int requestedSize)
        {
            if (requestedSize > _array!.Length - _index)
                ResizeBuffer(requestedSize);
        }

        /// <summary>Resizes <see cref="_array"/> to ensure it can fit the specified number of new items.</summary>
        /// <param name="sizeHint">The minimum number of items to ensure space for in <see cref="_array"/>.</param>
        [MethodImpl(MethodImplOptions.NoInlining)]
        void ResizeBuffer(int sizeHint)
        {
            var minimumSize = _index + sizeHint;
            var oldArray = _array!;
            var newArray = ArrayPool<T?>.Shared.Rent(minimumSize);

            Array.Copy(oldArray, newArray, _index);
            _array = newArray;
            ArrayPool<T?>.Shared.Return(oldArray, typeof(T) != typeof(char));
        }

        /// <inheritdoc/>
        bool ICollection<T>.Contains(T item) => throw new NotSupportedException();

        /// <inheritdoc/>
        bool ICollection<T>.Remove(T item) => throw new NotSupportedException();

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<T>)this).GetEnumerator();

        /// <inheritdoc/>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            var array = _array!;
            var length = _index;

            for (var i = 0; i < length; i++)
                yield return array[i]!;
        }
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if XNA
// ReSharper disable BitwiseOperatorOnEnumWithoutFlags InconsistentNaming NullableWarningSuppressionIsUsed
// ReSharper disable once CheckNamespace


/// <summary>Provides thread-safe access to keyboard input.</summary>

#pragma warning disable CA1810
    static ConcurrentKeyboard()
#pragma warning restore CA1810
    {
        Trace.Assert(Unsafe.SizeOf<Keys>() is sizeof(int), $"sizeof({nameof(Keys)}) is 4");
        Trace.Assert(Unsafe.SizeOf<KeyMods>() is sizeof(ushort), $"sizeof({nameof(KeyMods)}) is 2");
        Trace.Assert(Unsafe.SizeOf<KeyboardState>() >= sizeof(uint) * 8 + sizeof(byte), "Memory layout is known.");

        Trace.Assert(TryGetType(out var type), $"{nameof(type)} is not null");
        Trace.Assert(TryGetField(type, out var delegateField), $"{nameof(delegateField)} is not null");
        Trace.Assert(TryGetValue(delegateField, out Delegate? del), $"{nameof(del)} is not null");
        s_modState = CompileModState(del);

        Trace.Assert(TryGetField(out var keyField), $"{nameof(keyField)} is not null");
        Trace.Assert(TryGetValue(keyField, out List<Keys>? keys), $"{nameof(keys)} is not null");
        s_keys = keys;

        Trace.Assert(TryFindInvalidState(out var invalid), $"{nameof(ToState)} breaks on {invalid}");
    }

    static readonly Func<KeyMods> s_modState;

    static readonly List<Keys> s_keys;

    /// <summary>Thread-safe version of <see cref="Keyboard.GetState()"/>.</summary>
    /// <returns>The current <see cref="KeyboardState"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyboardState GetState() => s_keys.AsSpan().ToState(GetModState());

    /// <summary>
    /// Converts the <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> into the summed <see cref="KeyboardState"/>.
    /// </summary>
    /// <remarks><para>
    /// This operation treats the provided <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> as a set for computation,
    /// meaning that repeated <see cref="Keys"/> of the same value have the same effect as if it appeared once.
    /// </para></remarks>
    /// <param name="keys">The <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> to process.</param>
    /// <param name="mods">The <see cref="KeyMods"/> for modifiers.</param>
    /// <returns>
    /// The <see cref="KeyboardState"/> that comes from both parameters
    /// <paramref name="keys"/> and <paramref name="mods"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyboardState ToState(this in ReadOnlySpan<Keys> keys, KeyMods mods = KeyMods.None)
    {
        KeyboardState output = default;
        var reader = MemoryMarshal.Cast<Keys, int>(keys);
        ref var writer = ref Unsafe.As<KeyboardState, uint>(ref output);
        ref var bits = ref Unsafe.As<KeyMods, ushort>(ref mods);
        ref var start = ref MemoryMarshal.GetReference(reader);
        ref var end = ref Unsafe.Add(ref start, reader.Length);

        while (Unsafe.IsAddressLessThan(ref start, ref end))
            Unsafe.Add(ref writer, start >> 5 & 7) |= 1u << (start & 31);

        Unsafe.As<uint, byte>(ref Unsafe.Add(ref writer, 8)) = (byte)((bits & 4096) >> 11 | (bits & 8192) >> 13);

        return output;
    }

    /// <summary>
    /// Converts the <see cref="Span{T}"/> of <see cref="Keys"/> into the summed <see cref="KeyboardState"/>.
    /// </summary>
    /// <remarks><para>
    /// This operation treats the provided <see cref="Span{T}"/> of <see cref="Keys"/> as a set for computation,
    /// meaning that repeated <see cref="Keys"/> of the same value have the same effect as if it appeared once.
    /// </para></remarks>
    /// <param name="keys">The <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> to process.</param>
    /// <param name="mods">The <see cref="KeyMods"/> for modifiers.</param>
    /// <returns>
    /// The <see cref="KeyboardState"/> that comes from both parameters
    /// <paramref name="keys"/> and <paramref name="mods"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyboardState ToState(this Span<Keys> keys, KeyMods mods = KeyMods.None) =>
        ((ReadOnlySpan<Keys>)keys).ToState(mods);

    /// <summary>Gets the current set of key modifiers that are active.</summary>
    /// <returns>The <see cref="KeyMods"/> representing the current modifiers active.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyMods GetModState() => s_modState();

    [Pure]
    static bool TryFindInvalidState([NotNullWhen(false)] out Enum? invalid)
    {
        static bool IsModifierCausingInvalidState(KeyMods mod) =>
            ((ReadOnlySpan<Keys>)[]).ToState(mod) is { CapsLock: var capsLock, NumLock: var numLock } state &&
            capsLock != mod is KeyMods.CapsLock ||
            numLock != mod is KeyMods.NumLock ||
            state.GetPressedKeyCount() is not 0;

        static bool IsKeyCausingInvalidState(Keys key) =>
            Span.In(key).ToState() is not { CapsLock: false, NumLock: false } state ||
            state.IsKeyUp(key) ||
            state.GetPressedKeyCount() is not 1;

        var keyModTests = EnumMath.GetValues<KeyMods>().Where(IsModifierCausingInvalidState).Cast<Enum>();
        var keyTests = EnumMath.GetValues<Keys>().Where(IsKeyCausingInvalidState).Cast<Enum>();
        invalid = keyModTests.Concat(keyTests).Filter().FirstOrDefault();
        return invalid is null;
    }

    [MustUseReturnValue]
    static bool TryGetField([NotNullWhen(true)] out FieldInfo? field) =>
        (field = typeof(Keyboard).GetField("_keys", BindingFlags.NonPublic | BindingFlags.Static)) is not null;

    [MustUseReturnValue]
    static bool TryGetField(in Type type, [NotNullWhen(true)] out FieldInfo? field) =>
        (field = type.GetField(nameof(GetModState), BindingFlags.Public | BindingFlags.Static)) is not null;

    [MustUseReturnValue]
    static bool TryGetType([NotNullWhen(true)] out Type? type) =>
#pragma warning disable REFL037
        (type = typeof(Keyboard).Assembly.GetType("Sdl+Keyboard")) is not null;
#pragma warning restore REFL037
    [MustUseReturnValue]
    static bool TryGetValue(in FieldInfo delegateField, [NotNullWhen(true)] out Delegate? del) =>
        (del = delegateField.GetValue(null) as Delegate) is not null;

    [MustUseReturnValue]
    static bool TryGetValue(in FieldInfo field, [NotNullWhen(true)] out List<Keys>? keys) =>
        (keys = field.GetValue(null) as List<Keys>) is not null;

    [Pure]
    static Func<KeyMods> CompileModState(in Delegate del)
    {
        var constant = Expression.Constant(del);
        var invoke = Expression.Invoke(constant);
        var mods = Expression.Convert(invoke, typeof(KeyMods));
        return Expression.Lambda<Func<KeyMods>>(mods).Compile();
    }
#endif

// SPDX-License-Identifier: MPL-2.0
#if XNA
// ReSharper disable once CheckNamespace


/// <summary>Contains the set of all key modifiers.</summary>
[Flags]
public enum KeyMods : ushort
{
    None,
    LeftShift,
    RightShift,
    Shift = RightShift | LeftShift,
    LeftCtrl = 1 << 6,
    RightCtrl = 1 << 7,
    Ctrl = RightCtrl | LeftCtrl,
    LeftAlt = 1 << 8,
    RightAlt = 1 << 9,
    Alt = RightAlt | LeftAlt,
    LeftGui = 1 << 10,
    RightGui = 1 << 11,
    Gui = RightGui | LeftGui,
    NumLock = 1 << 12,
    CapsLock = 1 << 13,
    AltGr = 1 << 14,
    Reserved = 1 << 15,
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace



#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for read-only lists.</summary>
#pragma warning disable MA0048

    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to a read-only list.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a read-only list.</param>
    /// <returns>A read-only list of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IReadOnlyList<T>? ToReadOnly<T>(this IEnumerable<T>? iterable) =>
        iterable is null
            ? null
            : iterable as IReadOnlyList<T> ?? new ReadOnlyList<T>(iterable as IList<T> ?? [.. iterable]);
#endif

/// <summary>Encapsulates an <see cref="IList{T}"/> and make all mutating methods a no-op.</summary>
/// <typeparam name="T">The type of element in the list.</typeparam>
/// <param name="list">The list to encapsulate.</param>
[NoStructuralTyping]
public sealed partial class ReadOnlyList<T>([ProvidesContext] IList<T> list) : IList<T>, IReadOnlyList<T>
{
    /// <inheritdoc />
    [Pure]
    public bool IsReadOnly => true;

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(Read), Pure]
    public int Count => list.Count;

    /// <inheritdoc cref="IList{T}.this" />
    [Pure]
    public T this[int index]
    {
        [CollectionAccess(Read)] get => list[index];
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)] set { }
    }

    /// <inheritdoc />
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => list.CopyTo(array, arrayIndex);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ICollection<T>.Add(T? item) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ICollection<T>.Clear() { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IList<T>.Insert(int index, T? item) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IList<T>.RemoveAt(int index) { }

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => list.Contains(item);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ICollection<T>.Remove(T? item) => false;

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => list.IndexOf(item);

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public IEnumerator<T> GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
    public override string? ToString() => list.ToString();
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace RedundantExtendsListEntry StructCanBeMadeReadOnly


#pragma warning disable IDE0250, IDE0251, MA0102, SA1137


/// <summary>Extension methods that act as factories for <see cref="Yes{T}"/>.</summary>
#pragma warning disable MA0048

    /// <summary>Gets the fallback for when an enumeration returns <see langword="null"/>.</summary>
    public static object Fallback { get; } = new();

    /// <summary>Creates a <see cref="Yes{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Yes{T}"/> instance that can be yielded forever.</returns>
    [Pure]
    public static Yes<T> Forever<T>(this T source) => source;

/// <summary>A factory for creating iterator types that yield the same item forever.</summary>
/// <typeparam name="T">The type of the item to yield.</typeparam>
/// <param name="value">The item to use.</param>
[StructLayout(LayoutKind.Auto)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Yes<T>([ProvidesContext] T value) : IEnumerable<T>, IEnumerator<T>
{
    /// <inheritdoc />
    [CollectionAccess(Read), ProvidesContext, Pure]
    public T Current => value;

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    object IEnumerator.Current => value ?? Fallback;

    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Yes{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(Read), Pure]
    public static implicit operator Yes<T>([ProvidesContext] T value) => new(value);

    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(Read), Pure]
    public static implicit operator T(Yes<T> value) => value.Current;

    /// <summary>Returns itself.</summary>
    /// <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="Yes{T}"/>.</para></remarks>
    /// <returns>Itself.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public Yes<T> GetEnumerator() => this;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IDisposable.Dispose() { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IEnumerator.Reset() { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool IEnumerator.MoveNext() => true;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
}

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly RedundantExtendsListEntry
#pragma warning disable CA1710, CA1815, IDE0250, IDE0251, MA0048, MA0102, SA1137



/// <summary>Extension methods that act as factories for <see cref="Once{T}"/>.</summary>

    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> Yield<T>(this T source, bool condition = true) => condition ? source : [];

    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> Yield<T>(this T source, Func<bool> condition) => condition() ? source : [];

    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> Yield<T>(this T source, Predicate<T> condition) => condition(source) ? source : [];

    /// <summary>Creates a <see cref="Once{T}"/> from an item if it isn't null.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> YieldValued<T>(this T? source)
        where T : class =>
        source is null ? [] : source;

    /// <summary>Creates a <see cref="Once{T}"/> from an item if it isn't null.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> YieldValued<T>(this T? source)
        where T : struct =>
        source.HasValue ? source.Value : [];

/// <summary>A factory for creating iterator types that yields an item once.</summary>
/// <typeparam name="T">The type of the item to yield.</typeparam>
/// <param name="value">The item to use.</param>
[StructLayout(LayoutKind.Auto)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Once<T>([ProvidesContext] T value) : IList<T>, IReadOnlyList<T>, IReadOnlySet<T>, ISet<T>
{
    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ICollection<T>.IsReadOnly => true;

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    int IReadOnlyCollection<T>.Count => HasValue ? 1 : 0;

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    int ICollection<T>.Count => HasValue ? 1 : 0;

    /// <summary>Gets a value indicating whether this is a default value.</summary>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure] // ReSharper disable once ReplaceAutoPropertyWithComputedProperty
    public bool HasValue { get; } = true;

    /// <summary>Gets the item to use.</summary>
    [CollectionAccess(Read), ProvidesContext, Pure]
    public T Current => value;

    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    T IList<T>.this[int _]
    {
        [CollectionAccess(Read)] get => value;
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)] set { }
    }

    /// <inheritdoc cref="IList{T}.this[int]"/>
    [CollectionAccess(Read), Pure]
    T IReadOnlyList<T>.this[int _] => value;

    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Once{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public static implicit operator Once<T>([ProvidesContext] Enumerator value) => value.Current;

    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Once{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public static implicit operator Once<T>([ProvidesContext] T value) => new(value);

    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public static implicit operator Enumerator([ProvidesContext] Once<T> value) => value.Current;

    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(Read), Pure]
    public static implicit operator T(Once<T> value) => value.Current;

    /// <inheritdoc />
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => array[arrayIndex] = value;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ICollection<T>.Add(T? item) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ICollection<T>.Clear() { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IList<T>.Insert(int index, T? item) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IList<T>.RemoveAt(int index) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.ExceptWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.IntersectWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.SymmetricExceptWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.UnionWith(IEnumerable<T>? other) { }

    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => EqualityComparer<T>.Default.Equals(value, item);

    /// <inheritdoc cref="ISet{T}.IsProperSubsetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsProperSubsetOf([InstantHandle] IEnumerable<T> other) =>
        HasValue
            ? other.Any()
            : other.ToCollectionLazily() is { Count: > 1 } c && Overlaps(c);

    /// <inheritdoc cref="ISet{T}.IsProperSupersetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsProperSupersetOf([InstantHandle] IEnumerable<T> other) => HasValue && !other.Any();

    /// <inheritdoc cref="ISet{T}.IsSubsetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsSubsetOf([InstantHandle] IEnumerable<T> other) => !HasValue || Overlaps(other);

    /// <inheritdoc cref="ISet{T}.IsSupersetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsSupersetOf([InstantHandle] IEnumerable<T> other) =>
        !HasValue || other.ToCollectionLazily() is { Count: <= 1 } c && Overlaps(c);

    /// <inheritdoc cref="ISet{T}.Overlaps" />
    [CollectionAccess(Read), Pure]
    public bool Overlaps([InstantHandle] IEnumerable<T> other) => other.Contains(value);

    /// <inheritdoc cref="ISet{T}.SetEquals" />
    [CollectionAccess(Read), Pure]
    public bool SetEquals([InstantHandle] IEnumerable<T> other) => HasValue ? !other.Any() : other.SequenceEqual(this);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ICollection<T>.Remove(T? item) => false;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ISet<T>.Add(T? item) => false;

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => Contains(item) ? 0 : -1;

    /// <summary>
    /// Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
    /// </summary>
    /// <returns>Itself.</returns>
    [CollectionAccess(Read), Pure]
    public Enumerator GetEnumerator() => HasValue ? new(value) : default;

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>An enumerator over <see cref="Once{T}"/>.</summary>
    /// <param name="value">The item to use.</param>
    [StructLayout(LayoutKind.Auto)]
    public partial struct Enumerator(T value) : IEnumerator<T>
    {
        static readonly object s_fallback = new();

        // ReSharper disable once ConvertToConstant.Local
        readonly bool _hasValue = true;

        bool _canMove = true;

        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public readonly T Current => value;

        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        readonly object IEnumerator.Current => value ?? s_fallback;

        /// <summary>Implicitly calls the constructor.</summary>
        /// <param name="value">The value to pass into the constructor.</param>
        /// <returns>A new instance of <see cref="Yes{T}"/> with <paramref name="value"/> passed in.</returns>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
        public static implicit operator Enumerator(T value) => new(value);

        /// <summary>Implicitly calls <see cref="Current"/>.</summary>
        /// <param name="value">The value to call <see cref="Current"/>.</param>
        /// <returns>The value that was passed in to this instance.</returns>
        [CollectionAccess(Read), Pure]
        public static implicit operator T(Enumerator value) => value.Current;

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        readonly void IDisposable.Dispose() { }

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public bool MoveNext() => _canMove && !(_canMove = false);

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public void Reset() => _canMove = _hasValue;
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly RedundantExtendsListEntry RedundantReadonlyModifier
#pragma warning disable CA1710, CA1815, IDE0250, IDE0250, IDE0251, MA0048, MA0102, RCS1085, SA1137



/// <summary>Extension methods that act as factories for <see cref="Bits{T}"/>.</summary>

    /// <summary>Creates the <see cref="Bits{T}"/> from the item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Bits{T}"/> instance with the parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Bits<T> AsBits<T>(this T source)
        where T : unmanaged =>
        source;

    /// <summary>Computes the Bitwise-AND of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseAnd<T>(this IEnumerable<T> source)
        where T : unmanaged
    {
        T t = default;

        foreach (var next in source)
            Bits<T>.And(next, ref t);

        return t;
    }

    /// <summary>Computes the Bitwise-AND-NOT of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseAndNot<T>(this IEnumerable<T> source)
        where T : unmanaged
    {
        T t = default;

        foreach (var next in source)
            Bits<T>.AndNot(next, ref t);

        return t;
    }
#if !(NETFRAMEWORK && !NET45_OR_GREATER || NETSTANDARD1_0)
    /// <summary>Returns the reference that contains the most bits.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the most bits of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseMax<T>(this IEnumerable<T> source)
        where T : unmanaged =>
        source.Aggregate(default(T), (acc, next) => Bits<T>.Max(acc, next));

    /// <summary>Returns the reference that contains the least bits.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the least bits of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseMin<T>(this IEnumerable<T> source)
        where T : unmanaged =>
        source.Aggregate(default(T), (acc, next) => Bits<T>.Min(acc, next));
#endif

    /// <summary>Computes the Bitwise-OR of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseOr<T>(this IEnumerable<T> source)
        where T : unmanaged
    {
        T t = default;

        foreach (var next in source)
            Bits<T>.Or(next, ref t);

        return t;
    }

    /// <summary>Computes the Bitwise-XOR of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseXor<T>(this IEnumerable<T> source)
        where T : unmanaged
    {
        T t = default;

        foreach (var next in source)
            Bits<T>.Xor(next, ref t);

        return t;
    }

/// <summary>Provides the enumeration of individual bits from the given <typeparamref name="T"/>.</summary>
/// <typeparam name="T">The type of the item to yield.</typeparam>
/// <param name="bits">The item to use.</param>
[StructLayout(LayoutKind.Auto), NoStructuralTyping]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>([ProvidesContext] T bits) : IReadOnlyList<T>, IReadOnlySet<T>, ISet<T>, IList<T>
    where T : unmanaged
{
    static readonly unsafe int s_nativeSize = sizeof(nuint) * BitsInByte, s_typeSize = sizeof(T) * BitsInByte;

    // ReSharper disable once ReplaceWithPrimaryConstructorParameter
    readonly T _value = bits;

    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    bool ICollection<T>.IsReadOnly
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => true;
    }

    /// <summary>Gets the item to use.</summary>
    [CollectionAccess(Read), ProvidesContext] // ReSharper disable once ConvertToAutoProperty
    public readonly T Current
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
    }

    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Bits{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator Bits<T>([ProvidesContext] Enumerator value) => value.Current;

    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Bits{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator Bits<T>([ProvidesContext] T value) => new(value);

    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator Enumerator([ProvidesContext] Bits<T> value) => value.Current;

    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator T(Bits<T> value) => value.Current;

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void CopyTo(T[] array, int arrayIndex)
    {
        foreach (var next in this)
            array[arrayIndex++] = next;
    }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ICollection<T>.Add(T item) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ICollection<T>.Clear() { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void IList<T>.Insert(int index, T item) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void IList<T>.RemoveAt(int index) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.ExceptWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.IntersectWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.SymmetricExceptWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.UnionWith(IEnumerable<T>? other) { }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    bool ICollection<T>.Remove(T item) => false;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    bool ISet<T>.Add(T item) => false;

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int IndexOf(T item)
    {
        using var e = new Enumerator(item);

        if (!e.MoveNext() || e.Mask is var mask && e.Index is var index && e.MoveNext())
            return -1;

        using var that = GetEnumerator();

        for (var i = 0; that.MoveNext(); i++)
            if (that.Mask == mask && that.Index == index)
                return i;
            else if (that.Mask > mask || that.Index > index)
                return -1;

        return -1;
    }

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() => ((Enumerator)this).ToRemainingString();

    /// <summary>
    /// Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
    /// </summary>
    /// <returns>Itself.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetEnumerator() => _value;

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>An enumerator over <see cref="Bits{T}"/>.</summary>
    /// <param name="value">The item to use.</param>
    [StructLayout(LayoutKind.Auto)]
    public partial struct Enumerator(T value) : IEnumerator<T>
    {
        const int Start = -1;

        readonly T _value = value;

        /// <summary>Gets the current mask.</summary>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public nuint Mask
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] private set;
        }

        /// <summary>Gets the current index.</summary>
        [CLSCompliant(false), CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public nint Index
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] private set;
        } = Start;

        /// <summary>Gets the reconstruction of the original enumerable that can create this instance.</summary>
        [CollectionAccess(Read)]
        public readonly Bits<T> AsBits
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
        }

        /// <summary>Gets the underlying value that is being enumerated.</summary>
        [CollectionAccess(Read)]
        public readonly T AsValue
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
        }

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public readonly unsafe T Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get
            {
                T t = default;
                *((nuint*)&t + Index) ^= Mask;
                return t;
            }
        }

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        readonly object IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Current;
        }

        /// <summary>Implicitly calls the constructor.</summary>
        /// <param name="value">The value to pass into the constructor.</param>
        /// <returns>A new instance of <see cref="Enumerator"/> with <paramref name="value"/> passed in.</returns>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator Enumerator(T value) => new(value);

        /// <summary>Implicitly calls <see cref="Current"/>.</summary>
        /// <param name="value">The value to call <see cref="Current"/>.</param>
        /// <returns>The value that was passed in to this instance.</returns>
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator T(Enumerator value) => value.Current;

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly void IDisposable.Dispose() { }

        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset()
        {
            Index = Start;
            Mask = 0;
        }

        /// <inheritdoc />
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe bool MoveNext()
        {
            Mask <<= 1;

            if (Mask is 0)
            {
                Index++;
                Mask++;
            }

            fixed (T* ptr = &_value)
                if (sizeof(T) / sizeof(nuint) is not 0 && FindNativelySized(ptr) ||
                    sizeof(T) % sizeof(nuint) is not 0 && FindRest(ptr))
                    return true;

            Index = sizeof(T) / sizeof(nuint);
            Mask = FalsyMask();
            return false;
        }

        /// <inheritdoc />
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public readonly override string ToString()
        {
            var that = this;
            return that.ToRemainingString();
        }

        /// <summary>Enumerates over the remaining elements to give a <see cref="string"/> result.</summary>
        /// <returns>The <see cref="string"/> result of this instance.</returns>
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
        public unsafe string ToRemainingString()
        {
            var ptr = stackalloc char[s_typeSize];
            new Span<char>(ptr, s_typeSize).Fill('0');
            var last = ptr + s_typeSize - 1;

            while (MoveNext())
                *(last - (int)(Index * s_nativeSize) - TrailingZeroCount(Mask)) ^= '\x01';

            return new(ptr, 0, s_typeSize);
        }

        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static nuint FalsyMask() => (nuint)1 << s_nativeSize - 2;

        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static unsafe nuint LastRest() => ((nuint)1 << sizeof(T) % sizeof(nuint) * BitsInByte) - 1;

        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        unsafe bool FindNativelySized(T* ptr)
        {
            for (; Index < sizeof(T) / sizeof(nuint); Index++, Mask = 1)
                for (; Mask is not 0; Mask <<= 1)
                    if (IsNonZero(ptr))
                        return true;

            return false;
        }

        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        unsafe bool FindRest(T* ptr)
        {
            for (; (Mask & LastRest()) is not 0; Mask <<= 1)
                if (IsNonZero(ptr))
                    return true;

            return false;
        }

        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        unsafe bool IsNonZero(T* ptr) => (((nuint*)ptr)[Index] & Mask) is not 0;
    }
}

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable IDE0250
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly


/// <inheritdoc cref="Bits{T}"/>
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>
{
    /// <inheritdoc cref="IList{T}.this[int]"/>
    [CollectionAccess(CollectionAccessType.Read)]
    public unsafe T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            fixed (T* ptr = &_value)
                return Nth(ptr, index);
        }
    }

    /// <inheritdoc cref="IList{T}.this"/>
    T IList<T>.this[int index]
    {
        [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => this[index];
        [CollectionAccess(CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)] set { }
    }

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(CollectionAccessType.Read)]
    public unsafe int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            fixed (T* ptr = &_value)
                return PopCount(ptr);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable MA0051 // ReSharper disable once CognitiveComplexity
    static unsafe int PopCount(T* value)
#pragma warning restore MA0051
    {
        var ptr = (nuint*)value++;
        var sum = 0;

        if (sizeof(T) / (sizeof(nuint) * 16) > 0)
        {
            for (; ptr <= (nuint*)value - 16; ptr += 16)
                sum += BitOperations.PopCount(*ptr) +
                    BitOperations.PopCount(ptr[1]) +
                    BitOperations.PopCount(ptr[2]) +
                    BitOperations.PopCount(ptr[3]) +
                    BitOperations.PopCount(ptr[4]) +
                    BitOperations.PopCount(ptr[5]) +
                    BitOperations.PopCount(ptr[6]) +
                    BitOperations.PopCount(ptr[7]) +
                    BitOperations.PopCount(ptr[8]) +
                    BitOperations.PopCount(ptr[9]) +
                    BitOperations.PopCount(ptr[10]) +
                    BitOperations.PopCount(ptr[11]) +
                    BitOperations.PopCount(ptr[12]) +
                    BitOperations.PopCount(ptr[13]) +
                    BitOperations.PopCount(ptr[14]) +
                    BitOperations.PopCount(ptr[15]);

            if (sizeof(T) % sizeof(nuint) * 16 is 0)
                return sum;
        }

        if (sizeof(T) % (sizeof(nuint) * 16) / (sizeof(nuint) * 8) > 0)
        {
            for (; ptr <= (nuint*)value - 8; ptr += 8)
                sum += BitOperations.PopCount(*ptr) +
                    BitOperations.PopCount(ptr[1]) +
                    BitOperations.PopCount(ptr[2]) +
                    BitOperations.PopCount(ptr[3]) +
                    BitOperations.PopCount(ptr[4]) +
                    BitOperations.PopCount(ptr[5]) +
                    BitOperations.PopCount(ptr[6]) +
                    BitOperations.PopCount(ptr[7]);

            if (sizeof(T) % sizeof(nuint) * 8 is 0)
                return sum;
        }

        if (sizeof(T) % (sizeof(nuint) * 8) / (sizeof(nuint) * 4) > 0)
        {
            for (; ptr <= (nuint*)value - 4; ptr += 4)
                sum += BitOperations.PopCount(*ptr) +
                    BitOperations.PopCount(ptr[1]) +
                    BitOperations.PopCount(ptr[2]) +
                    BitOperations.PopCount(ptr[3]);

            if (sizeof(T) % sizeof(nuint) * 4 is 0)
                return sum;
        }

        if (sizeof(T) % (sizeof(nuint) * 4) / (sizeof(nuint) * 2) > 0)
        {
            for (; ptr <= (nuint*)value - 2; ptr += 2)
                sum += BitOperations.PopCount(*ptr) + BitOperations.PopCount(ptr[1]);

            if (sizeof(T) % sizeof(nuint) * 2 is 0)
                return sum;
        }

        if (sizeof(T) % (sizeof(nuint) * 2) / sizeof(nuint) > 0)
        {
            for (; ptr < value; ptr++)
                sum += BitOperations.PopCount(*ptr);

            if (sizeof(T) % sizeof(nuint) is 0)
                return sum;
        }

        if (sizeof(T) % sizeof(nuint) is 0)
            return sum;

        if (sizeof(T) % sizeof(nuint) / sizeof(ulong) > 0)
        {
            for (; ptr < value; ptr = (nuint*)((ulong*)ptr + 1))
                sum += BitOperations.PopCount(*ptr);

            if (sizeof(T) % sizeof(nuint) is 0)
                return sum;
        }

        if (sizeof(T) % sizeof(ulong) is 0)
            return sum;

        return sum + PopCountRemainder((byte*)ptr);
    }

    // ReSharper disable UnusedParameter.Local
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static unsafe int PopCountRemainder(byte* remainder) =>
        BitOperations.PopCount(
            (sizeof(T) % sizeof(nuint)) switch
            {
                1 => *remainder,
                2 => *(ushort*)remainder,
                3 => *(ushort*)remainder | (ulong)remainder[2] << 16,
                4 => *(uint*)remainder,
                5 => *(uint*)remainder | (ulong)remainder[4] << 32,
                6 => *(uint*)remainder | (ulong)*(ushort*)remainder[4] << 32,
                7 => *(uint*)remainder | (ulong)*(ushort*)remainder[4] << 32 | (ulong)remainder[6] << 48,
                _ => throw new ArgumentOutOfRangeException(nameof(remainder), (nuint)remainder, null),
            }
        );

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] // ReSharper disable once RedundantUnsafeContext
    static unsafe int TrailingZeroCount(nuint value)
#if NET7_0_OR_GREATER
        =>
            BitOperations.TrailingZeroCount(value);
#else
    {
        const int BitsInUInt = BitsInByte * sizeof(uint);

        for (var i = 0; i < (sizeof(nuint) + sizeof(uint) - 1) / sizeof(uint); i++)
            if (Map((uint)(value << i * BitsInUInt)) is var j and not 32)
                return j + i * BitsInUInt;

        return sizeof(nuint) * BitsInByte;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static int Map([ValueRange(0, 1u << 31)] uint value) =>
        value switch // Always a power of two.
        {
            0 => 32,
            1 << 0 => 0,
            1 << 1 => 1,
            1 << 2 => 2,
            1 << 3 => 3,
            1 << 4 => 4,
            1 << 5 => 5,
            1 << 6 => 6,
            1 << 7 => 7,
            1 << 8 => 8,
            1 << 9 => 9,
            1 << 10 => 10,
            1 << 11 => 11,
            1 << 12 => 12,
            1 << 13 => 13,
            1 << 14 => 14,
            1 << 15 => 15,
            1 << 16 => 10,
            1 << 17 => 11,
            1 << 18 => 12,
            1 << 19 => 13,
            1 << 20 => 14,
            1 << 21 => 15,
            1 << 22 => 10,
            1 << 23 => 11,
            1 << 24 => 12,
            1 << 25 => 13,
            1 << 26 => 14,
            1 << 27 => 15,
            1 << 28 => 10,
            1 << 29 => 11,
            1 << 30 => 12,
            1u << 31 => 13,
            _ => throw new ArgumentOutOfRangeException(nameof(value), value, null),
        };
#endif

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable MA0051 // ReSharper disable once CognitiveComplexity
    static unsafe T Nth(T* p, int index)
#pragma warning restore MA0051
    {
        var x = index;
        var ptr = (nuint*)p;

        for (; ptr < p + 1 && x > 0; ptr++)
            if (BitOperations.PopCount(*ptr) is var i && i <= x)
                x -= i;
            else
                break;

        for (; ptr < (byte*)p + sizeof(T) && x > 0; ptr = (nuint*)((byte*)ptr + 1))
            if (BitOperations.PopCount(*(byte*)ptr) is var i && i <= x)
                x -= i;
            else
                break;

        var last = *(byte*)ptr;

        for (var i = 0; i < BitsInByte; i++)
            if ((last & 1 << i) is not 0)
                if (x is 0)
                {
                    T t = default;
                    ((byte*)&t)[(byte*)ptr - (byte*)p] = (byte)(1 << i);
                    return t;
                }
                else
                    x--;

        throw new ArgumentOutOfRangeException(nameof(index), index, null);
    }
}

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable CA1502, MA0051, IDE0250
// ReSharper disable BadPreprocessorIndent CheckNamespace CognitiveComplexity StructCanBeMadeReadOnly


/// <inheritdoc cref="Bits{T}"/>
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>
{
    /// <summary>Computes the Bitwise-AND computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void And(in T read, ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            And(r, w);
    }

    /// <summary>Computes the Bitwise-AND-NOT computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void AndNot(in T read, ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            AndNot(r, w);
    }

    /// <summary>Computes the Bitwise-NOT computation, writing it to the first argument.</summary>
    /// <param name="reference">The <typeparamref name="T"/> to read and write from.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Not(ref T reference)
    {
        fixed (T* ptr = &reference)
            Not(ptr);
    }

    /// <summary>Computes the Bitwise-OR computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Or(in T read, ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            Or(r, w);
    }

    /// <summary>Computes the Bitwise-XOR computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Xor(in T read, ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            Xor(r, w);
    }

    /// <summary>Determines whether both references of <typeparamref name="T"/> contain the same bits.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameters <paramref name="left"/> and <paramref name="right"/>
    /// point to values with the same bits as each other; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool Eq(in T left, in T right)
    {
        fixed (T* l = &left)
        fixed (T* r = &right)
            return Eq(l, r);
    }

    /// <summary>Determines whether both references of <typeparamref name="T"/> contain the same bits.</summary>
    /// <param name="reference">The reference to determine if it is zeroed.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="reference"/>
    /// points to a value with all zeros; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool EqZero(in T reference)
    {
        fixed (T* ptr = &reference)
            return EqZero(ptr);
    }
#if !(NETFRAMEWORK && !NET45_OR_GREATER || NETSTANDARD1_0)
    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
    /// <param name="number">The bits to clamp.</param>
    /// <param name="min">The minimum accepted value.</param>
    /// <param name="max">The maximum accepted value.</param>
    /// <returns>
    /// The parameter <paramref name="number"/> if its bits are greater or equal to the parameter
    /// <paramref name="min"/>, and lesser or equal to the parameter <paramref name="number"/>; otherwise,
    /// <paramref name="min"/> if the parameter <paramref name="number"/> is lesser than
    /// <paramref name="min"/>; otherwise, <paramref name="max"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ref readonly T Clamp(in T number, in T min, in T max) => ref Max(Min(number, max), min);

    /// <summary>Returns the reference that contains the greater bits.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are greater or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe ref readonly T Max(in T left, in T right)
    {
        fixed (T* r = &left)
        fixed (T* w = &right)
            return ref Unsafe.AsRef<T>(Max(r, w));
    }

    /// <summary>Returns the reference that contains the lesser bits.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are greater or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe ref readonly T Min(in T left, in T right)
    {
        fixed (T* r = &left)
        fixed (T* w = &right)
            return ref Unsafe.AsRef<T>(Min(r, w));
    }
#endif

    /// <summary>Computes the Bitwise-AND computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void And(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                *(Vector512<byte>*)r = Vector512.BitwiseAnd(Vector512.Load(l), Vector512.Load(r));

            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.BitwiseAnd(Vector256.Load(l), Vector256.Load(r));

            if (sizeof(T) % 32 is 0)
                return;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.BitwiseAnd(Vector128.Load(l), Vector128.Load(r));

            if (sizeof(T) % 16 is 0)
                return;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.BitwiseAnd(Vector64.Load(l), Vector64.Load(r));

            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l & *(nuint*)r;

        if (sizeof(T) % sizeof(nuint) is 0)
            return;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l & *(ulong*)r;

        if (sizeof(T) % sizeof(ulong) is 0)
            return;

        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l & *(uint*)r;

        if (sizeof(T) % sizeof(uint) is 0)
            return;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l & *(ushort*)r);

        if (sizeof(T) % sizeof(ushort) is 0)
            return;

        for (; l < upper; l++, r++)
            *r = (byte)(*l & *r);
    }

    /// <summary>Computes the Bitwise-AND-NOT computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void AndNot(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                *(Vector512<byte>*)r = Vector512.AndNot(Vector512.Load(l), Vector512.Load(r));

            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.AndNot(Vector256.Load(l), Vector256.Load(r));

            if (sizeof(T) % 32 is 0)
                return;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.AndNot(Vector128.Load(l), Vector128.Load(r));

            if (sizeof(T) % 16 is 0)
                return;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.AndNot(Vector64.Load(l), Vector64.Load(r));

            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l & ~*(nuint*)r;

        if (sizeof(T) % sizeof(nuint) is 0)
            return;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l & ~*(ulong*)r;

        if (sizeof(T) % sizeof(ulong) is 0)
            return;

        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l & ~*(uint*)r;

        if (sizeof(T) % sizeof(uint) is 0)
            return;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l & ~*(ushort*)r);

        if (sizeof(T) % sizeof(ushort) is 0)
            return;

        for (; l < upper; l++, r++)
            *r = (byte)(*l & ~*r);
    }

    /// <summary>Computes the Bitwise-NOT computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="ptr">The <typeparamref name="T"/> to read and write from.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Not(T* ptr)
    {
        byte* x = (byte*)ptr, upper = (byte*)(ptr + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; x <= upper - 64; x += 64)
                *(Vector512<byte>*)x = Vector512.OnesComplement(Vector512.Load(x));

            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; x <= upper - 32; x += 32)
                *(Vector256<byte>*)x = Vector256.OnesComplement(Vector256.Load(x));

            if (sizeof(T) % 32 is 0)
                return;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; x <= upper - 16; x += 16)
                *(Vector128<byte>*)x = Vector128.OnesComplement(Vector128.Load(x));

            if (sizeof(T) % 16 is 0)
                return;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; x <= upper - 8; x += 8)
                *(Vector64<byte>*)x = Vector64.OnesComplement(Vector64.Load(x));

            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; x <= upper - sizeof(nuint); x += sizeof(nuint))
            *(nuint*)x = ~*(nuint*)x;

        if (sizeof(T) % sizeof(nuint) is 0)
            return;

        for (; x <= upper - sizeof(ulong); x += sizeof(ulong))
            *(ulong*)x = ~*(ulong*)x;

        if (sizeof(T) % sizeof(ulong) is 0)
            return;

        for (; x <= upper - sizeof(uint); x += sizeof(uint))
            *(uint*)x = ~*(uint*)x;

        if (sizeof(T) % sizeof(uint) is 0)
            return;

        for (; x <= upper - sizeof(ushort); x += sizeof(ushort))
            *(ushort*)x = (ushort)~*(ushort*)x;

        if (sizeof(T) % sizeof(ushort) is 0)
            return;

        for (; x < upper; x++)
            *x = (byte)~*x;
    }

    /// <summary>Computes the Bitwise-OR computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Or(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
               *(Vector512<byte>*)r = Vector512.BitwiseOr(Vector512.Load(l), Vector512.Load(r));

            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.BitwiseOr(Vector256.Load(l), Vector256.Load(r));

            if (sizeof(T) % 32 is 0)
                return;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.BitwiseOr(Vector128.Load(l), Vector128.Load(r));

            if (sizeof(T) % 16 is 0)
                return;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.BitwiseOr(Vector64.Load(l), Vector64.Load(r));

            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l | *(nuint*)r;

        if (sizeof(T) % sizeof(nuint) is 0)
            return;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l | *(ulong*)r;

        if (sizeof(T) % sizeof(ulong) is 0)
            return;

        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l | *(uint*)r;

        if (sizeof(T) % sizeof(uint) is 0)
            return;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l | *(ushort*)r);

        if (sizeof(T) % sizeof(ushort) is 0)
            return;

        for (; l < upper; l++, r++)
            *r = (byte)(*l | *r);
    }

    /// <summary>Computes the Bitwise-XOR computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Xor(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                *(Vector512<byte>*)r = Vector512.Xor(Vector512.Load(l), Vector512.Load(r));

            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.Xor(Vector256.Load(l), Vector256.Load(r));

            if (sizeof(T) % 32 is 0)
                return;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.Xor(Vector128.Load(l), Vector128.Load(r));

            if (sizeof(T) % 16 is 0)
                return;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.Xor(Vector64.Load(l), Vector64.Load(r));

            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l ^ *(nuint*)r;

        if (sizeof(T) % sizeof(nuint) is 0)
            return;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l ^ *(ulong*)r;

        if (sizeof(T) % sizeof(ulong) is 0)
            return;

        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l ^ *(uint*)r;

        if (sizeof(T) % sizeof(uint) is 0)
            return;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l ^ *(ushort*)r);

        if (sizeof(T) % sizeof(ushort) is 0)
            return;

        for (; l < upper; l++, r++)
            *r = (byte)(*l ^ *r);
    }

    /// <summary>Determines whether both pointers of <typeparamref name="T"/> contain the same bits.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameters <paramref name="left"/> and <paramref name="right"/>
    /// point to values with the same bits as each other; otherwise, <see langword="false"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool Eq(T* left, T* right)
    {
        byte* l = (byte*)left, r = (byte*)right, upper = (byte*)(left + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                if (!Vector512.EqualsAll(Vector512.Load(l), Vector512.Load(r)))
                    return false;

            if (sizeof(T) % 64 is 0)
                return true;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                if (!Vector256.EqualsAll(Vector256.Load(l), Vector256.Load(r)))
                    return false;

            if (sizeof(T) % 32 is 0)
                return true;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                if (!Vector128.EqualsAll(Vector128.Load(l), Vector128.Load(r)))
                    return false;

            if (sizeof(T) % 16 is 0)
                return true;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                if (!Vector64.EqualsAll(Vector64.Load(l), Vector64.Load(r)))
                    return false;

            if (sizeof(T) % 8 is 0)
                return true;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            if (*(nuint*)l != *(nuint*)r)
                return false;

        if (sizeof(T) % sizeof(nuint) is 0)
            return true;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            if (*(ulong*)l != *(ulong*)r)
                return false;

        if (sizeof(T) % sizeof(ulong) is 0)
            return true;

        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            if (*(uint*)l != *(uint*)r)
                return false;

        if (sizeof(T) % sizeof(uint) is 0)
            return true;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            if (*(ushort*)l != *(ushort*)r)
                return false;

        if (sizeof(T) % sizeof(ushort) is 0)
            return true;

        for (; l < upper; l++, r++)
            if (*l != *r)
                return false;

        return true;
    }

    /// <summary>Determines whether the pointer of <typeparamref name="T"/> contains all zeros.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="ptr">The pointer to determine if it is zeroed.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="ptr"/>
    /// points to a value with all zeros; otherwise, <see langword="false"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool EqZero(T* ptr)
    {
        byte* x = (byte*)ptr, upper = (byte*)(ptr + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; x <= upper - 64; x += 64)
                if (!Vector512.EqualsAll(Vector512.Load(x), Vector512<byte>.Zero))
                    return false;

            if (sizeof(T) % 64 is 0)
                return true;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; x <= upper - 32; x += 32)
                if (!Vector256.EqualsAll(Vector256.Load(x), Vector256<byte>.Zero))
                    return false;

            if (sizeof(T) % 32 is 0)
                return true;
        }

        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; x <= upper - 16; x += 16)
                if (!Vector128.EqualsAll(Vector128.Load(x), Vector128<byte>.Zero))
                    return false;

            if (sizeof(T) % 16 is 0)
                return true;
        }

        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; x <= upper - 8; x += 8)
                if (!Vector64.EqualsAll(Vector64.Load(x), Vector64<byte>.Zero))
                    return false;

            if (sizeof(T) % 8 is 0)
                return true;
        }
#endif
        for (; x <= upper - sizeof(nuint); x += sizeof(nuint))
            if (*(nuint*)x is not 0)
                return false;

        if (sizeof(T) % sizeof(nuint) is 0)
            return true;

        for (; x <= upper - sizeof(ulong); x += sizeof(ulong))
            if (*(ulong*)x is not 0)
                return false;

        if (sizeof(T) % sizeof(ulong) is 0)
            return true;

        for (; x <= upper - sizeof(uint); x += sizeof(uint))
            if (*(uint*)x is not 0)
                return false;

        if (sizeof(T) % sizeof(uint) is 0)
            return true;

        for (; x <= upper - sizeof(ushort); x += sizeof(ushort))
            if (*(ushort*)x is not 0)
                return false;

        if (sizeof(T) % sizeof(ushort) is 0)
            return true;

        for (; x < upper; x++)
            if (*x is not 0)
                return false;

        return true;
    }

    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
    /// <param name="number">The bits to clamp.</param>
    /// <param name="min">The minimum accepted value.</param>
    /// <param name="max">The maximum accepted value.</param>
    /// <returns>
    /// The parameter <paramref name="number"/> if its bits are greater or equal to the parameter
    /// <paramref name="min"/>, and lesser or equal to the parameter <paramref name="number"/>; otherwise,
    /// <paramref name="min"/> if the parameter <paramref name="number"/> is lesser than
    /// <paramref name="min"/>; otherwise, <paramref name="max"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe T* Clamp(T* number, T* min, T* max) => Max(Min(number, max), min);

    /// <summary>Returns the pointer that contains the greater bits.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are greater or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe T* Max(T* left, T* right)
    {
        byte* l = (byte*)left, r = (byte*)right, upper = (byte*)(left + 1);

        for (; l <= upper - sizeof(nuint); l += sizeof(nuint))
            if (*(nuint*)l != *(nuint*)r)
                return *(nuint*)l >= *(nuint*)r ? left : right;

        if (sizeof(T) % sizeof(nuint) is 0)
            return left;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong))
            if (*(ulong*)l != *(ulong*)r)
                return *(ulong*)l >= *(ulong*)r ? left : right;

        if (sizeof(T) % sizeof(ulong) is 0)
            return left;

        for (; l <= upper - sizeof(uint); l += sizeof(uint))
            if (*(uint*)l != *(uint*)r)
                return *(uint*)l >= *(uint*)r ? left : right;

        if (sizeof(T) % sizeof(uint) is 0)
            return left;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort))
            if (*(ushort*)l != *(ushort*)r)
                return *(ushort*)l >= *(ushort*)r ? left : right;

        if (sizeof(T) % sizeof(ushort) is 0)
            return left;

        for (; l < upper; l++)
            if (*l != *r)
                return *l >= *r ? left : right;

        return left;
    }

    /// <summary>Returns the pointer that contains the lesser bits.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are lesser or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe T* Min(T* left, T* right)
    {
        byte* l = (byte*)left, r = (byte*)right, upper = (byte*)(left + 1);

        for (; l <= upper - sizeof(nuint); l += sizeof(nuint))
            if (*(nuint*)l != *(nuint*)r)
                return *(nuint*)l <= *(nuint*)r ? left : right;

        if (sizeof(T) % sizeof(nuint) is 0)
            return left;

        for (; l <= upper - sizeof(ulong); l += sizeof(ulong))
            if (*(ulong*)l != *(ulong*)r)
                return *(ulong*)l <= *(ulong*)r ? left : right;

        if (sizeof(T) % sizeof(ulong) is 0)
            return left;

        for (; l <= upper - sizeof(uint); l += sizeof(uint))
            if (*(uint*)l != *(uint*)r)
                return *(uint*)l <= *(uint*)r ? left : right;

        if (sizeof(T) % sizeof(uint) is 0)
            return left;

        for (; l <= upper - sizeof(ushort); l += sizeof(ushort))
            if (*(ushort*)l != *(ushort*)r)
                return *(ushort*)l <= *(ushort*)r ? left : right;

        if (sizeof(T) % sizeof(ushort) is 0)
            return left;

        for (; l < upper; l++)
            if (*l != *r)
                return *l <= *r ? left : right;

        return left;
    }
}

// SPDX-License-Identifier: MPL-2.0
#pragma warning disable IDE0250
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly


/// <inheritdoc cref="Bits{T}"/>
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>
{
    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool Contains(T item)
    {
        using var that = GetEnumerator();

        while (that.MoveNext())
        {
            var current = that.Current;

            if (Eq(current, item))
                return true;
        }

        return false;
    }

    /// <inheritdoc cref="ISet{T}.IsProperSubsetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsProperSubsetOf([InstantHandle] IEnumerable<T> other)
    {
        T t = default;

        var collection = other
#if WAWA
           .ToList();
#else
           .ToCollectionLazily();
#endif

        // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
        foreach (var next in this)
            if (collection.Contains(next))
                Or(next, ref t);
            else
                return false;

        // ReSharper disable once LoopCanBeConvertedToQuery ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
        foreach (var next in collection)
            if (!Contains(next))
                return true;

        return false;
    }

    /// <inheritdoc cref="ISet{T}.IsProperSupersetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsProperSupersetOf([InstantHandle] IEnumerable<T> other)
    {
        T t = default;

        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (var next in other)
            if (Contains(next))
                Or(next, ref t);
            else
                return false;

        return !Eq(_value, t);
    }

    /// <inheritdoc cref="ISet{T}.IsSubsetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsSubsetOf([InstantHandle] IEnumerable<T> other)
    {
        var collection = other
#if WAWA
           .ToList();
#else
           .ToCollectionLazily();
#endif

        // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
        foreach (var next in this)
            if (!collection.Contains(next))
                return false;

        return true;
    }

    /// <inheritdoc cref="ISet{T}.IsSupersetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsSupersetOf([InstantHandle] IEnumerable<T> other) => other.All(Contains);

    /// <inheritdoc cref="ISet{T}.Overlaps" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool Overlaps([InstantHandle] IEnumerable<T> other) => other.Any(Contains);

    /// <inheritdoc cref="ISet{T}.SetEquals" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool SetEquals([InstantHandle] IEnumerable<T> other)
    {
        T t = default;

        foreach (var next in other)
            if ((Enumerator)next is var e && !e.MoveNext() || e.MoveNext())
                return false;
            else
                Or(next, ref t);

        return Eq(_value, t);
    }
}

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace


/// <summary>Extension methods that act as factories for <see cref="Matrix{T}"/>.</summary>
#pragma warning disable MA0048

    /// <summary>Wraps an <see cref="IList{T}"/> in a <see cref="Matrix{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterator">The collection to turn into a <see cref="Matrix{T}"/>.</param>
    /// <param name="countPerList">The length per count.</param>
    /// <returns>A <see cref="Matrix{T}"/> that wraps the parameter <paramref name="iterator"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterator))]
    public static Matrix<T>? AsMatrix<T>(this IEnumerable<T>? iterator, [NonNegativeValue] int countPerList) =>
#if WAWA
        iterator is null ? null : new(iterator as IList<T> ?? [..iterator], countPerList);
#else
        iterator is null ? null : new(iterator.ToListLazily(), countPerList);
#endif

    /// <summary>Wraps an <see cref="IList{T}"/> in a <see cref="Matrix{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterator">The collection to turn into a <see cref="Matrix{T}"/>.</param>
    /// <param name="countPerList">The length per count.</param>
    /// <returns>A <see cref="Matrix{T}"/> that wraps the parameter <paramref name="iterator"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterator))]
    public static Matrix<T>? AsMatrix<T>(this IEnumerable<T>? iterator, Func<int> countPerList) =>
#if WAWA
        iterator is null ? null : new(iterator as IList<T> ?? [..iterator], countPerList);
#else
        iterator is null ? null : new(iterator.ToListLazily(), countPerList);
#endif

/// <summary>Maps a 1-dimensional collection as 2-dimensional.</summary>
/// <typeparam name="T">The type of item within the list.</typeparam>
#if !WAWA
[NoStructuralTyping]
#endif
public sealed partial class Matrix<T> : IList<IList<T>>
{
    /// <summary>Represents a slice of a matrix.</summary>
    /// <param name="matrix">The matrix to reference.</param>
    /// <param name="ordinal">The first index of the matrix.</param>
#pragma warning disable IDE0044
    sealed class Slice([ProvidesContext] Matrix<T> matrix, [NonNegativeValue] int ordinal) : IList<T>
#pragma warning restore IDE0044
    {
        /// <inheritdoc />
        public T this[[NonNegativeValue] int index]
        {
            [Pure] get => matrix.List[Count * ordinal + index];
            set => matrix.List[Count * ordinal + index] = value;
        }

        /// <inheritdoc />
        public bool IsReadOnly
        {
            [Pure] get => matrix.List.IsReadOnly;
        }

        /// <inheritdoc />
        public int Count
        {
            [Pure] get => matrix.CountPerList;
        }

        /// <inheritdoc />
        public void Add(T item) => matrix.List.Add(item);

        /// <inheritdoc />
        public void Clear()
        {
            for (var i = 0; i < Count; i++)
                matrix.List.RemoveAt(Count * ordinal);
        }

        /// <inheritdoc />
        public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
        {
            for (var i = 0; i < Count; i++)
                array[arrayIndex + i] = this[i];
        }

        /// <inheritdoc />
        public void Insert([NonNegativeValue] int index, T item) => matrix.List.Insert(Count * ordinal + index, item);

        /// <inheritdoc />
        public void RemoveAt([NonNegativeValue] int index) => matrix.List.RemoveAt(Count * ordinal + index);

        /// <inheritdoc />
        [Pure]
        public bool Contains(T item) =>
            Enumerable
               .Range(0, Count)
               .Any(x => EqualityComparer<T>.Default.Equals(matrix.List[Count * ordinal + x], item));

        /// <inheritdoc />
        public bool Remove(T item) => Contains(item) && matrix.List.Remove(item);

        /// <inheritdoc />
        [Pure, ValueRange(-1, int.MaxValue)]
        public int IndexOf(T item) => Contains(item) ? matrix.List.IndexOf(item) - Count * ordinal : -1;

        /// <inheritdoc />
        [Pure]
        public IEnumerator<T> GetEnumerator() => matrix.List.Skip(Count * ordinal).Take(Count).GetEnumerator();

        /// <inheritdoc />
        [Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    readonly int _countPerListEager;

    readonly Func<int>? _countPerListLazy;

    readonly IList<T>? _listEager;

    readonly Func<IList<T>>? _listLazy;

    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
    /// <param name="list">The list to encapsulate.</param>
    /// <param name="countPerList">The length per count.</param>
    public Matrix(IList<T> list, [ValueRange(1, int.MaxValue)] int countPerList)
    {
        // Explicitly check, in case someone ignores the warning, or uses a variable.
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
        _countPerListEager = countPerList > 0
            ? countPerList
            : throw new ArgumentOutOfRangeException(nameof(countPerList), countPerList, "Value must be at least 1.");

        _listEager = list;
    }

    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
    /// <param name="list">The list to encapsulate.</param>
    /// <param name="countPerList">The length per count.</param>
    public Matrix(IList<T> list, Func<int> countPerList)
    {
        _countPerListLazy = countPerList;
        _listEager = list;
    }

    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
    /// <param name="list">The list to encapsulate.</param>
    /// <param name="countPerList">The length per count.</param>
    public Matrix(Func<IList<T>> list, [ValueRange(1, int.MaxValue)] int countPerList)
    {
        // Explicitly check, in case someone ignores the warning, or uses a variable.
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
        _countPerListEager = countPerList > 0
            ? countPerList
            : throw new ArgumentOutOfRangeException(nameof(countPerList), countPerList, "Value must be at least 1.");

        _listLazy = list;
    }

    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
    /// <param name="list">The list to encapsulate.</param>
    /// <param name="countPerList">The length per count.</param>
    public Matrix(Func<IList<T>> list, Func<int> countPerList)
    {
        _countPerListLazy = countPerList;
        _listLazy = list;
    }
#if !WAWA
    /// <summary>Performs the index operation on the <see cref="Matrix{T}"/>.</summary>
    /// <param name="x">The <c>x</c> position, which is the list to take.</param>
    /// <param name="y">The <c>y</c> position, which is the element from the list to take.</param>
    public T this[[NonNegativeValue] int x, [NonNegativeValue] int y]
    {
        [Pure] get => List[Count * x + y];
        set => List[Count * x + y] = value;
    }
#endif

    /// <inheritdoc cref="IList{T}.this"/>
    public IList<T> this[[NonNegativeValue] int index]
    {
        [Pure] get => new Slice(this, index);
        set => Add(value);
    }

    /// <summary>Gets the amount of items per list.</summary>
    public int CountPerList
    {
        [Pure] get => _countPerListLazy?.Invoke() ?? _countPerListEager;
    }

    /// <summary>Gets the encapsulated list.</summary>
    [ProvidesContext]
#pragma warning disable CS8603 // Unreachable.
    public IList<T> List
    {
        [Pure] // ReSharper disable once AssignNullToNotNullAttribute
        get => _listLazy?.Invoke() ?? _listEager;
    }
#pragma warning restore CS8603

    /// <inheritdoc />
    public bool IsReadOnly
    {
        [Pure] get => List.IsReadOnly;
    }

    /// <inheritdoc cref="ICollection{T}.Count" />
    [NonNegativeValue]
    public int Count
    {
        [Pure] get => List.Count / CountPerList;
    }

    /// <inheritdoc />
    public void Add(IList<T>? item) =>
        item?.ToList()
#pragma warning disable SA1110
#if NETSTANDARD && !NETSTANDARD1_3_OR_GREATER
           .For
#else
           .ForEach
#endif
                (List.Add);
#pragma warning restore SA1110

    /// <inheritdoc />
    public void Clear() => List.Clear();

    /// <inheritdoc />
    [Pure]
    public bool Contains(IList<T>? item) => item?.All(List.Contains) ?? false;

    /// <inheritdoc />
    public void CopyTo(IList<T>[] array, [NonNegativeValue] int arrayIndex)
    {
        for (var i = 0; i < Count; i++)
            array[arrayIndex + i] = this[i];
    }

    /// <inheritdoc />
    public void Insert([NonNegativeValue] int index, IList<T>? item)
    {
        if (item is not null)
            this[index] = item;
    }

    /// <inheritdoc />
    public void RemoveAt([NonNegativeValue] int index) => this[index].Clear();

    /// <inheritdoc />
    public bool Remove(IList<T>? item) => item?.Select(List.Remove).Any() ?? false;

    /// <inheritdoc />
    [Pure, ValueRange(-1, int.MaxValue)]
    public int IndexOf(IList<T>? item) => item?.Count > 0 ? List.IndexOf(item[0]) : -1;

    /// <inheritdoc />
    [Pure]
    public IEnumerator<IList<T>> GetEnumerator() =>
        Enumerable.Range(0, Count).Select(x => (IList<T>)new Slice(this, x)).GetEnumerator();

    /// <inheritdoc />
    [Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace



#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="CircularList{T}"/>.</summary>
#pragma warning disable MA0048

    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="CircularList{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="CircularList{T}"/>.</param>
    /// <returns>A <see cref="CircularList{T}"/> of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static CircularList<T>? ToCircularLazily<T>(this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as CircularList<T> ?? new(iterable.ToListLazily());
#endif

/// <summary>
/// Encapsulates an <see cref="IList{T}"/> where elements are treated as circular;
/// indices wrap around and will therefore never be out of range.
/// </summary>
/// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
/// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
[NoStructuralTyping]
public sealed partial class CircularList<T>([ProvidesContext] IList<T> list) : IList<T>, IReadOnlyList<T>
{
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    public T this[int index]
    {
        [CollectionAccess(Read)] get => list[Mod(index)];
        [CollectionAccess(ModifyExistingContent)] set => list[Mod(index)] = value;
    }

    /// <inheritdoc/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure, ValueRange(1, int.MaxValue)]
    public int Count => list.Count;

    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Add(T item) => list.Add(item);

    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();

    /// <inheritdoc/>
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => list.CopyTo(array, arrayIndex);

    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T item) => list.Insert(Mod(index), item);

    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index) => list.RemoveAt(Mod(index));

    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => list.Contains(item);

    /// <inheritdoc/>
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T item) => list.Remove(item);

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => list.IndexOf(item);

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public IEnumerator<T> GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
    public override string? ToString() => list.ToString();

    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    int Mod(int index) => Count is var i && i is not 0 ? (index % i + i) % i : throw CannotBeEmpty;
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace NullnessAnnotationConflictWithJetBrainsAnnotations



#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="ClippedList{T}"/>.</summary>
#pragma warning disable MA0048

    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="ClippedList{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="ClippedList{T}"/>.</param>
    /// <returns>A <see cref="ClippedList{T}"/> of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ClippedList<T>? ToClippedLazily<T>(this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as ClippedList<T> ?? new(iterable.ToListLazily());
#endif

/// <summary>
/// Encapsulates an <see cref="IList{T}"/> where indices are always clamped and therefore never be out of range.
/// </summary>
/// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
/// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
[NoStructuralTyping]
public sealed partial class ClippedList<T>([ProvidesContext] IList<T> list) : IList<T>, IReadOnlyList<T>
{
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    public T this[int index]
    {
        [CollectionAccess(Read)] get => list[Clamp(index)];
        [CollectionAccess(ModifyExistingContent)] set => list[Clamp(index)] = value;
    }

    /// <inheritdoc/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure, ValueRange(1, int.MaxValue)]
    public int Count => list.Count;

    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Add(T item) => list.Add(item);

    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();

    /// <inheritdoc/>
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => list.CopyTo(array, arrayIndex);

    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T item) => list.Insert(Clamp(index), item);

    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index) => list.RemoveAt(Clamp(index));

    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => list.Contains(item);

    /// <inheritdoc/>
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T item) => list.Remove(item);

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => list.IndexOf(item);

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public IEnumerator<T> GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
    public override string? ToString() => list.ToString();

    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    int Clamp(int index) => Count is var i && i is not 0 ? index.Clamp(0, i) : throw CannotBeEmpty;
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace



#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="GuardedList{T}"/>.</summary>
#pragma warning disable MA0048

    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="GuardedList{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="GuardedList{T}"/>.</param>
    /// <returns>A <see cref="GuardedList{T}"/> of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static GuardedList<T>? ToGuardedLazily<T>(this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as GuardedList<T> ?? new(iterable.ToListLazily());
#endif

/// <summary>
/// Encapsulates an <see cref="IList{T}"/> where applying an index will always result in an optional value;
/// an out of range value will always give the <see langword="default"/> value.
/// </summary>
/// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
/// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
[NoStructuralTyping]
public sealed partial class GuardedList<T>([ProvidesContext] IList<T> list) : IList<T?>, IReadOnlyList<T?>
{
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    public T? this[int index]
    {
        [CollectionAccess(Read)] get => IsIn(index) ? list[index] : default;
        [CollectionAccess(ModifyExistingContent)]
        set
        {
            if (value is not null && IsIn(index))
                list[index] = value;
        }
    }

    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;

    /// <inheritdoc />
    bool ICollection<T?>.IsReadOnly => IsReadOnly;

    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), NonNegativeValue, Pure]
    public int Count => list.Count;

    /// <inheritdoc />
    int ICollection<T?>.Count => Count;

    /// <inheritdoc cref="ICollection{T}.Add"/>
    [CollectionAccess(UpdatedContent)]
    public void Add(T? item)
    {
        if (item is not null)
            list.Add(item);
    }

    /// <inheritdoc cref="ICollection{T}.Clear"/>
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();

    /// <inheritdoc cref="ICollection{T}.CopyTo"/>
    [CollectionAccess(Read)]
    public void CopyTo(T?[] array, int arrayIndex)
    {
        if (Count <= array.Length - arrayIndex)
            list.CopyTo(array as T[], arrayIndex);
    }

    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T? item)
    {
        if (item is not null && IsIn(index))
            list.Insert(index, item);
    }

    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index)
    {
        if (IsIn(index))
            list.RemoveAt(index);
    }

    /// <inheritdoc />
    void ICollection<T?>.Add(T? item) => Add(item);

    /// <inheritdoc />
    void ICollection<T?>.Clear() => Clear();

    /// <inheritdoc />
    void ICollection<T?>.CopyTo(T?[] array, int arrayIndex) => CopyTo(array, arrayIndex);

    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T? item) => item is not null && list.Contains(item);

    /// <inheritdoc cref="ICollection{T}.Remove"/>
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T? item) => item is not null && list.Remove(item);

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    bool ICollection<T?>.Contains(T? item) => Contains(item);

    /// <inheritdoc />
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    bool ICollection<T?>.Remove(T? item) => Remove(item);

    /// <inheritdoc cref="IList{T}.IndexOf"/>
    [CollectionAccess(Read), Pure]
    public int IndexOf(T? item) => item is null ? -1 : list.IndexOf(item);

    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator"/>
    [CollectionAccess(Read), MustDisposeResource, Pure]
#if NETFRAMEWORK && !NET40_OR_GREATER // Good job .NET 2.0 - 3.5 Nullable Analysis.
#pragma warning disable CS8619
#endif
    public IEnumerator<T?> GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator<T> IEnumerable<T?>.GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
    public override string? ToString() => list.ToString();

    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    bool IsIn(int index) => index >= 0 && index < Count;
}

// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace



/// <summary>Provides the deconstruction to extract the head and tail of a collection.</summary>

    /// <summary>Separates the head from the tail of an <see cref="ICollection{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="collection">The enumerable to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="collection"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="collection"/>.</param>
    public static void Deconstruct<T>(
        this IList<T>? collection,
        out T? head,
        [NotNullIfNotNull(nameof(collection))] out IList<T>? tail
    )
    {
        head = collection is null ? default : collection.FirstOrDefault();
        tail = collection.Tail();
    }

    /// <summary>Gets the tail of the <see cref="ICollection{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="collection">The collection to extract the tail from.</param>
    /// <returns>
    /// The encapsulation of the parameter <paramref name="collection"/> that prevents the head from being accessed.
    /// </returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(collection))]
    public static HeadlessList<T>? Tail<T>(this IList<T>? collection) => collection is null ? null : new(collection);

/// <summary>Represents a list with no head.</summary>
/// <typeparam name="T">The type of list to encapsulate.</typeparam>
[NoStructuralTyping]
#pragma warning disable MA0048
public sealed partial class HeadlessList<T>([ProvidesContext] IList<T> list) : IList<T>
#pragma warning restore MA0048
{
    /// <inheritdoc cref="IList{T}.this" />
    [CollectionAccess(Read), Pure]
    public T this[int index]
    {
        get => index is not -1 ? list[index + 1] : throw new ArgumentOutOfRangeException(nameof(index));
        set => list[index + 1] = index is not -1 ? value : throw new ArgumentOutOfRangeException(nameof(index));
    }

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;

    /// <inheritdoc cref="ICollection{T}.Count" />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public int Count => list.Count - 1;

    /// <inheritdoc />
    [CollectionAccess(UpdatedContent)]
    public void Add(T item) => list.Add(item);

    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();

    /// <inheritdoc />
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex)
    {
        for (var i = 0; i < Count && arrayIndex + i < array.Length; i++)
            array[arrayIndex + i] = this[i];
    }

    /// <inheritdoc />
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T item) =>
        list.Insert(index is not -1 ? index + 1 : throw new ArgumentOutOfRangeException(nameof(index)), item);

    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index) =>
        list.RemoveAt(index is not -1 ? index + 1 : throw new ArgumentOutOfRangeException(nameof(index)));

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => list.Contains(item);

    /// <inheritdoc />
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T item) => list.Remove(item);

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) =>
        list.IndexOf(item) switch
        {
            0 => Find(item),
            -1 => -1,
            var x => x - 1,
        };

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator()
    {
        var ret = ((IEnumerable)list).GetEnumerator();
        ret.MoveNext();
        return ret;
    }

    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public IEnumerator<T> GetEnumerator()
    {
        var ret = list.GetEnumerator();
        ret.MoveNext();
        return ret;
    }

    /// <inheritdoc />
    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
    public override string? ToString() => list.ToString();

    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(-1, int.MaxValue)]
    int Find(T item)
    {
        var count = list.Count - 1;

        for (var i = 0; i < count; i++)
            if (EqualityComparer<T>.Default.Equals(list[i + 1], item))
                return i;

        return -1;
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry
// ReSharper disable once CheckNamespace

#if !NET20 && !NET30


/// <summary>Extension methods that act as factories for <see cref="Split{T}"/>.</summary>
#pragma warning disable MA0048

    /// <summary>Gets all booleans, in the order defined by <see cref="Split{T}"/>.</summary>
    public static bool[] Booleans { get; } = [true, false];

    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a number.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="count">The number of elements in the first half.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 enumerables containing the two halves of the underlying
    /// collection. The first half is as long as the parameter <paramref name="count"/> or shorter.
    /// </returns>
    [Pure]
    public static Split<IEnumerable<T>> SplitAt<T>(this ICollection<T> source, [NonNegativeValue] int count) =>
        new(source.Take(count), source.Skip(count));

    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="predicate">The method that decides where the item ends up.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 enumerables containing the two halves of the underlying
    /// collection. The first half lasts until the first element that returned <see langword="true"/>.
    /// </returns>
    [Pure]
    public static Split<IEnumerable<T>> SplitWhen<T>(
        [InstantHandle] this ICollection<T> source,
        [InstantHandle] Func<T, bool> predicate
    )
    {
        var index = source.TakeWhile(Not1(predicate)).Count();
        return source.SplitAt(index);
    }

    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="predicate">The method that decides where the item ends up.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 lists containing the elements that returned
    /// <see langword="true"/> and <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static Split<List<T>> SplitBy<T>(
        [InstantHandle] this IEnumerable<T> source,
        [InstantHandle] Predicate<T> predicate
    )
    {
        List<T> t = [], f = [];

        foreach (var item in source)
#pragma warning disable RCS1235 // While AddRange is faster, the item is required for context.
            (predicate(item) ? t : f).Add(item);
#pragma warning restore RCS1235

        return new(t, f);
    }

    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="predicate">The method that decides where the item ends up.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 lists containing the elements that returned
    /// <see langword="true"/> and <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static Split<SmallList<T>> SmallSplitBy<T>(
        [InstantHandle] this IEnumerable<T> source,
        [InstantHandle] Predicate<T> predicate
    )
    {
        SmallList<T> t = [], f = [];

        foreach (var item in source)
            (predicate(item) ? t : f).Add(item);

        return new(t, f);
    }
#endif

/// <summary>Represents a fixed collection of 2 items.</summary>
/// <typeparam name="T">The type of item in the collection.</typeparam>
/// <param name="truthy">The value representing a <see langword="true"/> value.</param>
/// <param name="falsy">The value representing a <see langword="false"/> value.</param>
public sealed partial class Split<T>(T truthy, T falsy) : ICollection<T>,
    IDictionary<bool, T>,
    IReadOnlyCollection<T>,
    IReadOnlyDictionary<bool, T>
{
#pragma warning disable SA1642
    /// <summary>Initializes a new instance of the <see cref="Split{T}"/> class.</summary>
    /// <param name="value">The value representing both values.</param>
#pragma warning restore SA1642
    public Split(T value)
        : this(value, value) { }

    /// <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
    [Pure]
    public T Falsy
    {
        get => falsy;
        set => falsy = value;
    }

    /// <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
    [Pure]
    public T Truthy
    {
        get => truthy;
        set => truthy = value;
    }

    /// <inheritdoc cref="ICollection{T}.IsReadOnly" />
    [Pure]
    bool ICollection<T>.IsReadOnly => false;

    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int ICollection<T>.Count => 2;

    /// <inheritdoc />
    [Pure]
    public ICollection<T> Values => this;

    /// <inheritdoc cref="ICollection{T}.IsReadOnly" />
    [Pure]
    bool ICollection<KeyValuePair<bool, T>>.IsReadOnly => false;

    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int ICollection<KeyValuePair<bool, T>>.Count => 2;

    /// <inheritdoc />
    [Pure]
    ICollection<bool> IDictionary<bool, T>.Keys => Booleans;

    /// <inheritdoc cref="IDictionary{TKey, TValue}.this" />
    [Pure]
    public T this[bool key]
    {
        get => key ? truthy : falsy;
        set => _ = key ? truthy = value : falsy = value;
    }

    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int IReadOnlyCollection<T>.Count => 2;

    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int IReadOnlyCollection<KeyValuePair<bool, T>>.Count => 2;

    /// <inheritdoc />
    [Pure]
    IEnumerable<bool> IReadOnlyDictionary<bool, T>.Keys => Booleans;

    /// <inheritdoc />
    [Pure]
    IEnumerable<T> IReadOnlyDictionary<bool, T>.Values => Values;

    /// <inheritdoc />
    public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
    {
        array[arrayIndex] = truthy;
        array[arrayIndex + 1] = falsy;
    }

    /// <inheritdoc />
    [Pure]
    public bool Contains(T item) =>
        EqualityComparer<T>.Default.Equals(truthy, item) || EqualityComparer<T>.Default.Equals(falsy, item);

    /// <inheritdoc />
    [Pure]
    public IEnumerator<T> GetEnumerator()
    {
        yield return truthy;
        yield return falsy;
    }

    /// <inheritdoc />
    void ICollection<T>.Add(T item) { }

    /// <inheritdoc cref="ICollection{T}.Clear" />
    void ICollection<T>.Clear() { }

    /// <inheritdoc />
    [Pure]
    bool ICollection<T>.Remove(T item) => false;

    /// <inheritdoc />
    [Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    public void Add(bool key, T value) => _ = key ? truthy = value : falsy = value;

    /// <inheritdoc />
    // ReSharper disable once NullnessAnnotationConflictWithJetBrainsAnnotations
    public void Add(KeyValuePair<bool, T> item) => _ = item.Key ? truthy = item.Value : falsy = item.Value;

    /// <inheritdoc />
    public void CopyTo(KeyValuePair<bool, T>[] array, [NonNegativeValue] int arrayIndex)
    {
        array[arrayIndex] = new(true, truthy);
        array[arrayIndex + 1] = new(false, falsy);
    }

    /// <inheritdoc />
    [Pure] // ReSharper disable once NullnessAnnotationConflictWithJetBrainsAnnotations
    public bool Contains(KeyValuePair<bool, T> item) =>
        item.Key
            ? EqualityComparer<T>.Default.Equals(truthy, item.Value)
            : EqualityComparer<T>.Default.Equals(falsy, item.Value);

    /// <inheritdoc cref="IDictionary{TKey, TValue}.TryGetValue" />
    [Pure]
    public bool TryGetValue(bool key, out T value)
    {
        value = key ? truthy : falsy;
        return true;
    }

    /// <inheritdoc cref="ICollection{T}.Clear" />
    void ICollection<KeyValuePair<bool, T>>.Clear() { }

    /// <inheritdoc />
    [Pure]
    bool ICollection<KeyValuePair<bool, T>>.Remove(KeyValuePair<bool, T> item) => false;

    /// <inheritdoc />
    [Pure]
    bool IDictionary<bool, T>.Remove(bool key) => false;

    /// <inheritdoc cref="IDictionary{TKey, TValue}.ContainsKey" />
    [Pure]
    bool IDictionary<bool, T>.ContainsKey(bool key) => true;

    /// <inheritdoc />
    [Pure]
    IEnumerator<KeyValuePair<bool, T>> IEnumerable<KeyValuePair<bool, T>>.GetEnumerator()
    {
        yield return new(true, truthy);
        yield return new(false, falsy);
    }

    /// <inheritdoc cref="IReadOnlyDictionary{TKey, TValue}.ContainsKey" />
    [Pure]
    bool IReadOnlyDictionary<bool, T>.ContainsKey(bool key) => true;

    /// <summary>Deconstructs a <see cref="Split{T}"/> into its components.</summary>
    /// <param name="t">The value to get assigned as <see cref="Truthy"/>.</param>
    /// <param name="f">The value to get assigned as <see cref="Falsy"/>.</param>
    public void Deconstruct(out T t, out T f)
    {
        t = truthy;
        f = falsy;
    }

    /// <inheritdoc />
    [Pure]
    public override string ToString() => $"Split({truthy}, {falsy})";
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable NullableWarningSuppressionIsUsed RedundantExtendsListEntry
// ReSharper disable once CheckNamespace

#pragma warning disable 8500, MA0102, RCS1146



/// <summary>Inlines 3 elements before falling back on the heap with an expandable <see cref="IList{T}"/>.</summary>
/// <typeparam name="T">The element type.</typeparam>
[NoStructuralTyping, StructLayout(LayoutKind.Sequential)]
public partial struct SmallList<T> :
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
    IConvertible,
#endif
    IEquatable<SmallList<T>>,
    IList<T>,
    IReadOnlyList<T>
{
    // DO NOT PLACE _rest BELOW GENERICS;
    // Doing so will cause only unmanaged generics to be mapped before the object,
    // leading to inconsistent mapping of memory when dereferencing pointers in HeadSpan functions.
    // See the following link for a lengthier explanation and example:
    //
    // ReSharper disable CommentTypo
    // https://sharplab.io/#v2:EYLgtghglgdgPgYgA4CcIHNIAIDuEUyzpYAmUAzhMADYCmWAHAKwAMLAsAFBcACLWPAIwA6AEoBXGABcoYWsICS02igD2SAMoqAblADGtcgG5e/IQDYBIidNnylUleq0pdB8sIAyEAJ6rxUgDSsCQm3JwA9BFYALIQMBi0JLiqKADW5FgQmbQAHki0eo4kIFxRWADkAILAqtq0FVgotACO4lDNmfFYqgBmveS0UljAhRDig1hSABb0qsAAVoXDeqpymb0d5FLCZdEVAEK01Ko4jc1tHYZYMKo9/YPDo3rjkzNzi8tYq+tZvY4oXbhbT4LK1eoaKQoLAAXhutBwWBqdVoAB4hCwAHwACgARJsUNtcQAaLC4warGAkXEASjCIOhoxOOEh0LhMARWCOzPRgixeIJRNJ5MKqiptLCXEklF6tC4AG8uFhlVhsdiMQAqGkAMioKNZNIA2gwALqKGDkApFPEACVoEGSfS5x1OvKxuCgM3uAyGWBYuRYDAlSpVas1OqZpwNhpYZqUluWtvtjt6SPBaIxmI9Xr6PuG/rYwc4AF8uHssABVGCQBLoJJYCi4WbNKazBswSnkCiODs+LDUKCGUqRfbI+qNHCpDKt+iUORZTKjXqpeTlw4us5ZajUe5ZLDkcQkEi0GBNVrtTrex5+0iGJCe+ijIi3vTUfD1wU7MucBlglEOWF4URMc0VgKQcUEUkACY6S4X9IxwAD2U5blXTAiDoNg8JpQgWUFRDZU1TArVdXTBwjSguMLStKQkwdXcQNRdDs2mK9fQLIMsJVVVsWIiMN3ImMqITa1cTteinVQnAmOkLMcE9Vjc2vAsWCLAisHKAB5B52IDBgUnSchSS7Dt6EY5j4mSKSZPArIW22FBxCKcQ0G3Hx1PKKBj1sF4d1uHBSWPS0HxfN80BkMUehQY9oUcbdnz8cQeneFB5MGIFuKI6QSIQwTKPNETaLE5Nd2s5j5JzHT8z0otS3CQ1WScqRvES2itDaE8ZAgagaRNLgHKatMUVRAAVHERqwT9SQmikxRIGl8M4bj5iWIoAH4sAAfU6YZkJwbEsPUkaNs2z9AKmrbZqpQCrtCLg6q4BqoSalr/Da89Oqgbrev656imdHkxuxCaLpm0UqQWzhFSWlVjq2s64Quzbbpu8G7vCZbPnWradsAjl9qw4sgA==
    // ReSharper restore CommentTypo

    [ProvidesContext]
    IList<T>? _rest;

    T? _first, _second, _third;

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with no elements.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList() { }

    /// <summary>
    /// Initializes a new instance of the <see cref="SmallList{T}"/> struct.
    /// Collects the enumerable; allocating the heaped list lazily.
    /// </summary>
    /// <param name="enumerable">The enumerable to collect.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList([InstantHandle] IEnumerable<T>? enumerable)
        : this(enumerable?.GetEnumerator()) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="SmallList{T}"/> struct.
    /// Mutates the enumerator; allocating the heaped list lazily.
    /// </summary>
    /// <param name="enumerator">The enumerator to mutate.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(IEnumerator<T>? enumerator)
    {
        if (enumerator is null || !enumerator.MoveNext())
            return;

        _first = enumerator.Current;

        if (!enumerator.MoveNext())
        {
            UnsafelySetNullishTo(out _rest, 1);
            return;
        }

        _second = enumerator.Current;

        if (!enumerator.MoveNext())
        {
            UnsafelySetNullishTo(out _rest, 2);
            return;
        }

        _third = enumerator.Current;

        if (!enumerator.MoveNext())
        {
            _rest = [];
            return;
        }

        List<T> list = [];

        do
            list.Add(enumerator.Current);
        while (enumerator.MoveNext());

        _rest = list;
    }

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 1 element.</summary>
    /// <param name="first">The first element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first)
    {
        _first = first;
        UnsafelySetNullishTo(out _rest, 1);
    }

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 2 elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second)
    {
        _first = first;
        _second = second;
        UnsafelySetNullishTo(out _rest, 2);
    }

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 3 elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second, T third)
        : this(first, second, third, []) { }

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with arbitrary elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The rest of the elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second, T third, IList<T> rest)
    {
        _first = first;
        _second = second;
        _third = third;
        _rest = rest;
    }

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with arbitrary elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The rest of the elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second, T third, params T[] rest)
        : this(first, second, third, (IList<T>)rest) { }

    /// <summary>Gets the empty list.</summary>
    public static SmallList<T> Empty
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] get => default;
    }

    /// <summary>Gets a value indicating whether determines whether the collection is empty.</summary>
    public readonly bool IsEmpty
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _rest is null;
    }

    /// <inheritdoc />
    public readonly bool IsReadOnly
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => false;
    }

    /// <inheritdoc cref="ICollection{T}.Count" />
    public readonly int Count
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => _rest.ToAddress() is < InlinedLength and var address ? (int)address : _rest!.Count + InlinedLength;
    }

    /// <summary>Gets the number of head elements used.</summary>
    public readonly int HeadCount
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Math.Min(Count, 3);
    }

    /// <summary>Gets the deep clone of this instance.</summary>
    public readonly SmallList<T> Cloned
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            var clone = Uninit(Count);
            CopyTo(ref clone);
            return clone;
        }
    }

    /// <inheritdoc cref="IList{T}.this" />
    public T this[int index]
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        readonly get
        {
            BoundsCheck(index, out _);

            return index switch
            {
                0 => _first!,
                1 => _second!,
                2 => _third!,
                _ => _rest![index - InlinedLength],
            };
        }
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            BoundsCheck(index, out _);

            _ = index switch
            {
                0 => _first = value,
                1 => _second = value,
                2 => _third = value,
                _ => _rest![index - InlinedLength] = value,
            };
        }
    }

    /// <summary>Gets or sets the first element.</summary>
    public T First
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] readonly get => this[0];
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => this[0] = value;
    }

    /// <summary>Gets or sets the second element.</summary>
    [CollectionAccess(Read), Pure]
    public T Second
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] readonly get => this[1];
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => this[1] = value;
    }

    /// <summary>Gets or sets the third element.</summary>
    [CollectionAccess(Read), Pure]
    public T Third
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] readonly get => this[2];
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => this[2] = value;
    }

    /// <summary>Gets the rest of the elements.</summary>
    public readonly IList<T>? Rest
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), ProvidesContext, Pure]
        get => _rest.ToAddress() < InlinedLength ? null : _rest;
    }

    /// <summary>Determines whether both sequence are equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both sequences are equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(SmallList<T> left, SmallList<T> right) => left.Equals(right);

    /// <summary>Determines whether both sequence are not equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both sequences are not equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(SmallList<T> left, SmallList<T> right) => !left.Equals(right);

    /// <summary>Creates the collection with 1 item in it.</summary>
    /// <param name="value">The single item to use.</param>
    /// <returns>The collection with 1 item.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>(T value) => new(value);

    /// <summary>Creates the collection with 2 items in it.</summary>
    /// <param name="tuple">The tuple containing 2 items to destructure and use.</param>
    /// <returns>The collection with 2 items.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second) tuple) => new(tuple.First, tuple.Second);

    /// <summary>Creates the collection with 3 items in it.</summary>
    /// <param name="tuple">The tuple containing 3 items to destructure and use.</param>
    /// <returns>The collection with 3 items.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second, T Third) tuple) =>
        new(tuple.First, tuple.Second, tuple.Third);

    /// <summary>Creates the collection with 3 or more items in it.</summary>
    /// <param name="tuple">The tuple containing 3 or more items to destructure and use.</param>
    /// <returns>The collection with 3 or more items.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second, T Third, IList<T> List) tuple) =>
        new(tuple.First, tuple.Second, tuple.Third, tuple.List);

    /// <summary>Skips initialization of inlined elements.</summary>
    /// <param name="length">The length of the <see cref="SmallList{T}"/>.</param>
    /// <returns>The <see cref="SmallList{T}"/> of length <paramref name="length"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Uninit(int length)
    {
        Unsafe.SkipInit(out SmallList<T> output);
        RestFromLength(length, out output._rest);
        return output;
    }

    /// <summary>Skips initialization of unreachable inlined elements.</summary>
    /// <param name="length">The length of the <see cref="SmallList{T}"/>.</param>
    /// <returns>The <see cref="SmallList{T}"/> of length <paramref name="length"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Zeroed(int length)
    {
        var output = Uninit(length);

        switch (length)
        {
            case >= 3:
                output._third = default;
                goto case 2;
            case 2:
                output._second = default;
                goto case 1;
            case 1:
                output._first = default;
                break;
        }

        return output;
    }

    /// <inheritdoc />
    [CollectionAccess(UpdatedContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Add(T item)
    {
        switch (Count)
        {
            case 0:
                _first = item;
                UnsafelySetNullishTo(out _rest, 1);
                break;
            case 1:
                _second = item;
                UnsafelySetNullishTo(out _rest, 2);
                break;
            case 2:
                (_third, _rest) = (item, []);
                break;
            default:
                EnsureMutability().Add(item);
                break;
        }
    }

    /// <summary>Adds the elements of the specified collection to the end of the <see cref="SmallList{T}"/>.</summary>
    /// <param name="collection">
    /// The collection whose elements should be added to the end of the <see cref="SmallList{T}"/>.
    /// </param>
    [CollectionAccess(UpdatedContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddRange(IEnumerable<T>? collection)
    {
        if (collection?.ToCollectionLazily() is not { Count: var count and not 0 } c)
            return;

        if (InlinedLength - HeadCount is var stackExpand && stackExpand is not 0)
        {
            using var e = c.GetEnumerator();

            for (var i = 0; i < stackExpand; i++)
                if (e.MoveNext())
                    Add(e.Current);
                else
                    return;
        }

        if (count - stackExpand <= 0)
            return;

        var rest = _rest as List<T> ?? [.. _rest!];
        rest.AddRange(stackExpand is 0 ? c : c.Skip(stackExpand).ToCollectionLazily());
        _rest = rest;
    }

    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear() => _rest = null;

    /// <summary>Copies all values onto the destination.</summary>
    /// <param name="list">The destination.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="list"/> has less elements than itself.
    /// </exception>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void CopyTo(ref SmallList<T> list)
    {
        if (Count is var count && count is 0)
            return;

        list.BoundsCheck(count - 1, out _);

        // Takes advantage of fallthrough in switch-cases.
        switch (count)
        {
            case > InlinedLength:
                IList<T>
                    from = _rest!,
                    to = list._rest!;

                for (var i = 0; i < from.Count; i++)
                    to[i] = from[i];

                goto case 3;
            case 3:
                list._third = _third;
                goto case 2;
            case 2:
                list._second = _second;
                goto case 1;
            case 1:
                list._first = _first;
                break;
        }
    }

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
    {
        // Takes advantage of fallthrough in switch-cases.
        switch (Count)
        {
            case > InlinedLength:
                _rest!.CopyTo(array, arrayIndex + InlinedLength);
                goto case 3;
            case 3:
                array[arrayIndex + 2] = _third!;
                goto case 2;
            case 2:
                array[arrayIndex + 1] = _second!;
                goto case 1;
            case 1:
                array[arrayIndex] = _first!;
                break;
        }
    }

    /// <summary>Deconstructs this instance with its properties.</summary>
    /// <param name="head">The first three elements.</param>
    /// <param name="tail">The remaining elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out (T? First, T? Second, T? Third) head, out IList<T> tail) =>
        (head, tail) = ((_first, _second, _third), Rest ?? []);

    /// <summary>Deconstructs this instance with the 3 first elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out T? first, out T? second, out T? third) =>
        (first, second, third) = (_first, _second, _third);

    /// <summary>Deconstructs this instance with its properties.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The remaining elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out T? first, out T? second, out T? third, out IList<T> rest) =>
        (first, second, third, rest) = (_first, _second, _third, Rest ?? []);
#if !UNMANAGED_SPAN
#pragma warning disable 8500
    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <param name="del">The function to use.</param>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HeadSpan([InstantHandle, RequireStaticDelegate] SpanAction<T> del) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount));

    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
    /// <param name="param">The reference parameter to pass into the function.</param>
    /// <param name="del">The function to use.</param>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HeadSpan<TParam>(
        TParam param,
        [InstantHandle, RequireStaticDelegate] SpanAction<T, TParam> del
    ) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount), param);

    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
    /// <param name="param">The reference parameter to pass into the function.</param>
    /// <param name="del">The function to use.</param>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HeadSpan<TParam>(
        ReadOnlySpan<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanActionReadOnlySpan<T, TParam> del
    ) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount), param);

    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
    /// <param name="param">The reference parameter to pass into the function.</param>
    /// <param name="del">The function to use.</param>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void HeadSpan<TParam>(
        Span<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanActionSpan<T, TParam> del
    ) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount), param);
#endif

    /// <inheritdoc />
    [CollectionAccess(UpdatedContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Insert(int index, T item)
    {
        BoundsCheck(index, out var count);

        switch (count)
        {
            case 0:
                UnsafelySetNullishTo(out _rest, 1);
                break;
            case 1:
                UnsafelySetNullishTo(out _rest, 2);
                break;
            case 2:
                _rest = [];
                break;
            case >= InlinedLength:
                EnsureMutability().Insert(0, _third!);
                break;
        }

        switch (index)
        {
            case 0:
                _third = _second;
                _second = _first;
                _first = item;
                break;
            case 1:
                _third = _second;
                _second = item;
                break;
            case 2:
                _third = item;
                break;
        }
    }

    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveAt(int index)
    {
        BoundsCheck(index, out var count);

        if (index is 0)
            _first = _second;

        if (index is 0 or 1)
            _second = _third;

        if (index < InlinedLength && _rest is [var head, ..])
            _third = head;

        if (count > InlinedLength)
            EnsureMutability().RemoveAt(Math.Max(index - InlinedLength, 0));
        else
            UnsafelySetNullishTo(out _rest, (byte)count);
    }

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Contains(T item) =>
        Count switch
        {
            0 => Eq(_first, item),
            1 => Eq(_first, item) || Eq(_second, item),
            2 => Eq(_first, item) || Eq(_second, item) || Eq(_third, item),
            _ => Eq(_first, item) || Eq(_second, item) || Eq(_third, item) || _rest!.Contains(item),
        };

    /// <summary>Determines whether the item exists in the collection.</summary>
    /// <param name="item">The item to check.</param>
    /// <param name="comparer">The comparer to use.</param>
    /// <returns>The value determining whether the parameter <paramref name="item"/> exists in the collection.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Contains(T item, IEqualityComparer<T> comparer) =>
        Count switch
        {
            0 => comparer.Equals(_first!, item),
            1 => comparer.Equals(_first!, item) || comparer.Equals(_second!, item),
            2 => comparer.Equals(_first!, item) || comparer.Equals(_second!, item) || comparer.Equals(_third!, item),
            _ => comparer.Equals(_first!, item) ||
                comparer.Equals(_second!, item) ||
                comparer.Equals(_third!, item) ||
                _rest!.Contains(item, comparer),
        };

    /// <inheritdoc cref="object.Equals(object)"/>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override bool Equals([NotNullWhen(true)] object? obj) => obj is SmallList<T> other && Equals(other);

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals(SmallList<T> other) =>
        Count == other.Count &&
        Eq(_first, other._first) &&
        Eq(_second, other._second) &&
        Eq(_third, other._third) &&
        (other.Rest is [_, ..] rest ? Rest?.SequenceEqual(rest) ?? false : other.Rest is null);

    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Remove(T item)
    {
        switch (Count)
        {
            case 0: return false;
            case 1: return Eq(_first, item) && (_rest = null) is var _;
            case 2:
                if (Eq(_first, item))
                {
                    UnsafelySetNullishTo(out _rest, 1);
                    return (_first = _second) is var _;
                }

                if (!Eq(_second, item))
                    return false;

                UnsafelySetNullishTo(out _rest, 1);
                return true;
            default:
                return Eq(_first, item) ? RemoveHead(_first = _second) :
                    Eq(_second, item) ? RemoveHead(_second = _third) :
                    Eq(_third, item) ? RemoveHead() : EnsureMutability().Remove(item);
        }
    }

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override int GetHashCode()
    {
        unchecked
        {
            const int Prime = 397;
            var hashCode = 0;

            switch (Count)
            {
                case > InlinedLength:
                    hashCode = _rest!.GetHashCode();
                    goto case 3;
                case 3:
                    hashCode = hashCode * Prime ^ EqualityComparer<T?>.Default.GetHashCode(_third!);
                    goto case 2;
                case 2:
                    hashCode = hashCode * Prime ^ EqualityComparer<T?>.Default.GetHashCode(_second!);
                    goto case 1;
                case 1:
                    hashCode = hashCode * Prime ^ EqualityComparer<T?>.Default.GetHashCode(_first!);
                    break;
            }

            return hashCode;
        }
    }

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int IndexOf(T item) =>
        Count switch
        {
            0 => Eq(_first, item) ? 0 : -1,
            1 => Eq(_first, item) ? 0 :
                Eq(_second, item) ? 1 : -1,
            2 => Eq(_first, item) ? 0 :
                Eq(_second, item) ? 1 :
                Eq(_third, item) ? 2 : -1,
            _ => Eq(_first, item) ? 0 :
                Eq(_second, item) ? 1 :
                Eq(_third, item) ? 2 :
                _rest!.IndexOf(item) is var i && i is -1 ? i : i + 3,
        };

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() =>
        Count switch
        {
            0 => "[]",
            1 => $"[{_first}]",
            2 => $"[{_first}, {_second}]",
            3 => $"[{_first}, {_second}, {_third}]",
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            _ => $"[{_first}, {_second}, {_third}, {_rest!.Conjoin()}]",
#else
            _ => $"[{_first}, {_second}, {_third}, {_rest}]",
#endif
        };

    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator" />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetEnumerator() => new(this);

    /// <summary>Gets the enumeration object that returns the values in reversed order.</summary>
    /// <returns>The backwards enumerator.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetReversedEnumerator() => new(this, true);

    /// <summary>Forms a slice out of the current list that begins at a specified index.</summary>
    /// <param name="start">The index at which to begin the slice.</param>
    /// <returns>
    /// A list that consists of all elements of the current list from <paramref name="start"/> to the end of the span.
    /// </returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable IDE0057
    public readonly SmallList<T> Slice(int start) => Slice(start, Count - start);
#pragma warning restore IDE0057
    /// <summary>Forms a slice out of the current list starting at a specified index for a specified length.</summary>
    /// <param name="start">The index at which to begin this slice.</param>
    /// <param name="length">The desired length for the slice.</param>
    /// <returns>
    /// A span that consists of <paramref name="length"/> elements from
    /// the current span starting at <paramref name="start"/>.
    /// </returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly SmallList<T> Slice(int start, int length)
    {
        var count = Count;
        start = Math.Max(start, 0);
        length = Math.Min(length, count - start);

        if (length <= 0)
            return default;

        if (start is 0 && length == count)
            return Cloned;

        Unsafe.SkipInit(out SmallList<T> output);

        if (length >= InlinedLength && _rest?.Skip(start).Take(length - InlinedLength).ToList() is { } list)
            output._rest = list;
        else
            RestFromLength(length, out output._rest);

        switch (length)
        {
            case >= 3:
                output._third = start is 0 ? _third : _rest![start - 1];
                goto case 2;
            case 2:
                output._second = start switch
                {
                    0 => _second,
                    1 => _third,
                    _ => _rest![start - 2],
                };

                goto case 1;
            case 1:
                output._first = start switch
                {
                    0 => _first,
                    1 => _second,
                    2 => _third,
                    _ => _rest![start - 3],
                };

                break;
        }

        return output;
    }
#if !UNMANAGED_SPAN
    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TResult">The resulting type of the function.</typeparam>
    /// <param name="del">The function to use.</param>
    /// <returns>The result of the parameter <paramref name="del"/>.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public TResult HeadSpan<TResult>([InstantHandle, RequireStaticDelegate] SpanFunc<T, TResult> del) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount));

    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
    /// <typeparam name="TResult">The resulting type of the function.</typeparam>
    /// <param name="param">The reference parameter to pass into the function.</param>
    /// <param name="del">The function to use.</param>
    /// <returns>The result of the parameter <paramref name="del"/>.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public TResult HeadSpan<TParam, TResult>(
        TParam param,
        [InstantHandle, RequireStaticDelegate] SpanFunc<T, TParam, TResult> del
    ) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount), param);

    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
    /// <typeparam name="TResult">The resulting type of the function.</typeparam>
    /// <param name="param">The reference parameter to pass into the function.</param>
    /// <param name="del">The function to use.</param>
    /// <returns>The result of the parameter <paramref name="del"/>.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public TResult HeadSpan<TParam, TResult>(
        ReadOnlySpan<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanFuncReadOnlySpan<T, TParam, TResult> del
    ) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount), param);

    /// <summary>Creates the temporary span to be passed into the function.</summary>
    /// <typeparam name="TParam">The type of reference parameter to pass into the function.</typeparam>
    /// <typeparam name="TResult">The resulting type of the function.</typeparam>
    /// <param name="param">The reference parameter to pass into the function.</param>
    /// <param name="del">The function to use.</param>
    /// <returns>The result of the parameter <paramref name="del"/>.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public TResult HeadSpan<TParam, TResult>(
        Span<TParam> param,
        [InstantHandle, RequireStaticDelegate] SpanFuncSpan<T, TParam, TResult> del
    ) =>
        del(MemoryMarshal.CreateSpan(ref _first!, HeadCount), param);
#endif
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly TypeCode IConvertible.GetTypeCode() => TypeCode.Object;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly bool IConvertible.ToBoolean(IFormatProvider? provider) => !IsEmpty;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly byte IConvertible.ToByte(IFormatProvider? provider) => unchecked((byte)Count);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly char IConvertible.ToChar(IFormatProvider? provider) => unchecked((char)Count);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly DateTime IConvertible.ToDateTime(IFormatProvider? provider) => new(Count, DateTimeKind.Utc);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly decimal IConvertible.ToDecimal(IFormatProvider? provider) => Count;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly double IConvertible.ToDouble(IFormatProvider? provider) => Count;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly short IConvertible.ToInt16(IFormatProvider? provider) => unchecked((short)Count);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly int IConvertible.ToInt32(IFormatProvider? provider) => Count;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly long IConvertible.ToInt64(IFormatProvider? provider) => Count;

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly sbyte IConvertible.ToSByte(IFormatProvider? provider) => unchecked((sbyte)Count);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly float IConvertible.ToSingle(IFormatProvider? provider) => Count;

    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly string IConvertible.ToString(IFormatProvider? provider) => ToString();

    /// <inheritdoc />
    [DoesNotReturn, MethodImpl(MethodImplOptions.AggressiveInlining)]
    readonly object IConvertible.ToType(Type conversionType, IFormatProvider? provider) =>
        throw new InvalidOperationException();

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly ushort IConvertible.ToUInt16(IFormatProvider? provider) => unchecked((ushort)Count);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly uint IConvertible.ToUInt32(IFormatProvider? provider) => unchecked((uint)Count);

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly ulong IConvertible.ToUInt64(IFormatProvider? provider) => unchecked((ulong)Count);
#endif

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void RestFromLength(int length, out IList<T>? rest)
    {
        if (length is 0 or 1 or 2 or 3)
            RestFromLengthWithoutAllocations(length, out rest);
        else
            rest = new T[length - InlinedLength];
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void RestFromLengthWithoutAllocations(int length, out IList<T>? rest)
    {
        switch (length)
        {
            case <= 0:
                rest = null;
                break;
            case 1:
                UnsafelySetNullishTo(out rest, 1);
                break;
            case 2:
                UnsafelySetNullishTo(out rest, 2);
                break;
            case 3:
                rest = [];
                break;
            default:
                Unsafe.SkipInit(out rest);
                break;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static bool Eq(T? x, T? y) => x is null ? y is null : y is not null && EqualityComparer<T>.Default.Equals(x, y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    readonly void BoundsCheck(int index, [ValueRange(1, int.MaxValue)] out int count)
    {
        count = Count;

        if (unchecked((uint)index >= count))
            throw new ArgumentOutOfRangeException(nameof(index), index, $"Must be between 0 and {count - 1}");
    }

    // ReSharper disable once UnusedParameter.Local
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    bool RemoveHead(in T? _ = default)
    {
        if (_rest is [var head, ..])
        {
            _third = head;
            EnsureMutability().RemoveAt(0);
        }
        else
            UnsafelySetNullishTo(out _rest, 2);

        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    IList<T> EnsureMutability() =>
        _rest = _rest switch
        {
            { IsReadOnly: false, Count: not 0 } x => x, // ReSharper disable once RedundantAssignment
            { Count: not 0 } x => [.. x],
            _ => (IList<T>)[],
        };

    /// <summary>An enumerator over <see cref="SmallList{T}"/>.</summary>
    [StructLayout(LayoutKind.Auto)]
    public struct Enumerator : IEnumerator<T>
    {
        readonly bool _isReversed;

        readonly int _count;

        readonly SmallList<T> _list;

        int _state = -1;

        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="list">The <see cref="SmallList{T}"/> to enumerate over.</param>
        /// <param name="isReversed">Determines whether to go backwards.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(SmallList<T> list, bool isReversed = false)
        {
            _list = list;
            _isReversed = isReversed;
            _count = list.Count;
        }

        /// <inheritdoc />
        public T Current { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; private set; } = default!;

        /// <inheritdoc />
        readonly object? IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Current;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void Dispose() { }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset() => _state = -1;

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() =>
            ++_state < _count &&
            (Current = (_isReversed ? _count - _state - 1 : _state) switch
            {
                0 => _list._first!,
                1 => _list._second!,
                2 => _list._third!,
                var x => _list._rest![x - InlinedLength],
            }) is var _;
    }
}

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable NullableWarningSuppressionIsUsed RedundantExtendsListEntry RedundantUnsafeContext
// ReSharper disable once CheckNamespace


/// <summary>Extension methods that act as factories for <see cref="SmallList{T}"/>.</summary>
#pragma warning disable MA0048

#if NETCOREAPP3_1_OR_GREATER
    /// <inheritdoc cref="global::System.MemoryExtensions.Contains"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool Contains<T>(this scoped PooledSmallList<T> span, T item)
        where T : IEquatable<T>? =>
        span.View.Contains(item);
#endif
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <summary>Removes the first occurence of a specific object from the <see cref="PooledSmallList{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="span">The <see cref="PooledSmallList{T}"/> to remove an element from.</param>
    /// <param name="item">The item to remove from the <see cref="PooledSmallList{T}"/>.</param>
    /// <returns>
    /// Whether or not it found the parameter <paramref name="item"/> within the bounds of the
    /// parameter <paramref name="span"/>, and substantially removed it from the collection.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Remove<T>(this scoped PooledSmallList<T> span, T item)
        where T : IEquatable<T>?
    {
        var i = span.IndexOf(item);

        if (i is -1)
            return false;

        span.RemoveAt(i);
        return true;
    }

    /// <inheritdoc cref="global::System.MemoryExtensions.IndexOf"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int IndexOf<T>(this scoped PooledSmallList<T> span, T item)
        where T : IEquatable<T>? =>
        span.View.IndexOf(item);

    /// <summary>Creates a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="capacity">
    /// The initial allocation, which puts it on the heap immediately but can save future resizing.
    /// </param>
    /// <returns>The created instance of <see cref="PooledSmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static PooledSmallList<T> AsPooledSmallList<T>(this int capacity) => new(capacity);
#endif

    /// <inheritdoc cref="SmallList{T}.op_Implicit(T)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> AsSmallList<T>(this T value) => value;

    /// <inheritdoc cref="SmallList{T}.op_Implicit(ValueTuple{T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T2> AsSmallList<T1, T2>(this (T1 First, T2 Second) tuple)
        where T1 : T2 =>
        tuple;

    /// <inheritdoc cref="SmallList{T}.op_Implicit(ValueTuple{T, T, T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T3> AsSmallList<T1, T2, T3>(this (T1 First, T2 Second, T3 Third) tuple)
        where T1 : T3
        where T2 : T3 =>
        tuple;

    /// <inheritdoc cref="SmallList{T}.Uninit"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> AsUninitSmallList<T>(this int length) => SmallList<T>.Uninit(length);

    /// <inheritdoc cref="SmallList{T}.Zeroed"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> AsZeroedSmallList<T>(this int length) => SmallList<T>.Zeroed(length);

    /// <summary>Collects the enumerable; allocating the heaped list lazily.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="SmallList{T}"/>.</param>
    /// <returns>A <see cref="SmallList{T}"/> of <paramref name="iterable"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> ToSmallList<T>([InstantHandle] this IEnumerable<T>? iterable) => [..iterable];

    /// <summary>Mutates the enumerator; allocating the heaped list lazily.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterator">The collection to turn into a <see cref="SmallList{T}"/>.</param>
    /// <returns>A <see cref="SmallList{T}"/> of <paramref name="iterator"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> ToSmallList<T>(this IEnumerator<T>? iterator) => new(iterator);

// SPDX-License-Identifier: MPL-2.0
// ReSharper disable NullableWarningSuppressionIsUsed RedundantExtendsListEntry RedundantUnsafeContext
// ReSharper disable once CheckNamespace EmptyNamespace


// ReSharper disable once RedundantNameQualifier RedundantUsingDirective


#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
/// <summary>Provides the method needed for collection expressions in <see cref="PooledSmallList{T}"/>.</summary>
#pragma warning disable MA0048, SA1600
static class PooledSmallListBuilder
#pragma warning restore MA0048, SA1600
{
    /// <summary>Converts the buffer into an expandable buffer.</summary>
    /// <typeparam name="T">The type of span.</typeparam>
    /// <param name="span">The span.</param>
    /// <returns>The <see cref="PooledSmallList{T}"/> that encapsulates the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static PooledSmallList<T> From<T>(ReadOnlySpan<T> span) => default(PooledSmallList<T>).Append(span);
}
#pragma warning disable CA1000, CA1065, CA1819, IDISP012, RCS1158
/// <summary>Inlines elements before falling back on the heap using <see cref="ArrayPool{T}"/>.</summary>
/// <typeparam name="T">The type of the collection.</typeparam>
/// <param name="view">The view to hold as the initial value.</param>
[CollectionBuilder(typeof(PooledSmallListBuilder), nameof(From))]
[method: MethodImpl(MethodImplOptions.AggressiveInlining)]
#if !NO_REF_STRUCTS
public ref
#endif
    partial struct PooledSmallList<T>(Span<T> view)
#if UNMANAGED_SPAN
    where T : unmanaged
#endif
{
    [NonNegativeValue]
    int _length;

    // ReSharper disable once ReplaceWithPrimaryConstructorParameter
    Span<T> _view = view;

    T[]? _rental;

    /// <summary>Initializes a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList()
        : this([]) { }

    /// <summary>Initializes a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    /// <param name="capacity">
    /// The initial allocation, which puts it on the heap immediately but can save future resizing.
    /// </param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList(int capacity)
        : this([]) =>
        _view = _rental = Rent(capacity);

    /// <inheritdoc cref="Span{T}.Empty"/>
    public static PooledSmallList<T> Empty
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => default;
    }

    /// <inheritdoc cref="Span{T}.IsEmpty"/>
    public readonly bool IsEmpty
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => View.IsEmpty;
    }

    /// <summary>Gets a value indicating whether the elements are inlined.</summary>
    [CLSCompliant(false)]
    public readonly bool IsInlined
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         MemberNotNullWhen(false, nameof(_rental), nameof(DangerouslyTransferOwnership)),
         Pure]
        get => _rental is null;
    }

    /// <inheritdoc cref="Span{T}.Length"/>
    public int Length
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure] readonly get => _length;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var newLength = Math.Max(value, 0);
            var relativeLength = newLength - _length;
            MakeRoom(relativeLength);
            _length = newLength;
        }
    }

    /// <summary>Gets the buffer.</summary>
    public readonly Span<T> View
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _view[.._length];
    }

    /// <inheritdoc cref="ICollection{T}.Clear"/>
    public PooledSmallList<T> Reset
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            _length = 0;
            return this;
        }
    }

    /// <summary>Gets the entire exposed view.</summary>
    public PooledSmallList<T> Stretched
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            _length = _view.Length;
            return this;
        }
    }

    /// <summary>Gets the inner heap array, or a copy of the inlined array.</summary>
    public readonly T[] ToArrayLazily
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => _rental ?? _view.ToArray();
    }

    /// <summary>Gets and transfers responsibility of disposing the inner array to the caller.</summary>
    public T[]? DangerouslyTransferOwnership
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         MustUseReturnValue("Dispose array by passing it into System.Memory.ArrayPool<T>.Shared.Return")]
        get
        {
            if (IsInlined)
                return null;

            var rental = _rental;
            _length = 0;
            _view = default;
            _rental = null;
            return rental;
        }
    }

    /// <inheritdoc cref="Span{T}.Slice(int, int)"/>
    public readonly Span<T> this[[NonNegativeValue] int start, [NonNegativeValue] int length]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => View.Slice(start, length);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] set => value.CopyTo(View.Slice(start, length));
    }

    /// <inheritdoc cref="Span{T}.this"/>
    public readonly Span<T> this[Range range]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => View[range];
        [MethodImpl(MethodImplOptions.AggressiveInlining)] set => value.CopyTo(View[range]);
    }

    /// <inheritdoc cref="Span{T}.this"/>
    public readonly ref T this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => ref View[index];
    }

    /// <inheritdoc cref="Span{T}.this"/>
    public readonly ref T this[Index index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => ref View[index];
    }

    /// <inheritdoc cref="Span{T}.op_Equality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(PooledSmallList<T> left, PooledSmallList<T> right) => left.View == right.View;

    /// <inheritdoc cref="Span{T}.op_Inequality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(PooledSmallList<T> left, PooledSmallList<T> right) => !(left == right);

    /// <summary>Implicitly converts the buffer into an expandable buffer.</summary>
    /// <param name="span">The span.</param>
    /// <returns>The <see cref="PooledSmallList{T}"/> that encapsulates the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator PooledSmallList<T>(Span<T> span) => new(span);

    /// <inheritdoc cref="AsSpan{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static PooledSmallList<T> From<TRef>(ref TRef reference)
        where TRef : struct =>
        AsSpan(ref reference);

    /// <summary>Reinterprets the reference as the continuous buffer of <typeparamref name="T"/>.</summary>
    /// <typeparam name="TRef">The generic representing the continuous buffer of <typeparamref name="T"/>.</typeparam>
    /// <param name="reference">The reference.</param>
    /// <returns>The span.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> AsSpan<TRef>(ref TRef reference)
        where TRef : struct =>
        Validate<TRef>.AsSpan(ref reference);

    /// <inheritdoc cref="IDisposable.Dispose"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Dispose()
    {
        if (!IsInlined)
            ArrayPool<T>.Shared.Return(DangerouslyTransferOwnership);
    }
#pragma warning disable 809, S3877
    /// <inheritdoc />
    [DoesNotReturn, Obsolete("Will always throw", true)]
    public readonly override bool Equals(object? obj) => throw Unreachable;

    /// <inheritdoc />
    [DoesNotReturn, Obsolete("Will always throw", true)]
    public readonly override int GetHashCode() => throw Unreachable;
#pragma warning restore 809, S3877
    /// <inheritdoc cref="Span{T}.ToString"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() =>
        typeof(T) == typeof(char) ? View.ToString() : View.ToArray().Conjoin();

    /// <inheritdoc cref="ICollection{T}.Add"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Append(T item)
    {
        if (HasRoom(1))
        {
            _view[_length++] = item;
            return this;
        }

        var replacement = Rent(1);
        _view.CopyTo(replacement);
        replacement[_length++] = item;
        Swap(replacement);
        return this;
    }

    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Append(scoped ReadOnlySpan<T> collection)
    {
        if (HasRoom(collection.Length))
        {
            collection.CopyTo(_view[_length..]);
            _length += collection.Length;
            return this;
        }

        var replacement = Rent(collection.Length);
        _view.CopyTo(replacement);
        collection.CopyTo(_view[_length..]);
        _length += collection.Length;
        Swap(replacement);
        return this;
    }

    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Append([InstantHandle] IEnumerable<T> collection)
    {
        if (collection.TryGetNonEnumeratedCount(out var count))
            MakeRoom(count);

        foreach (var x in collection)
            Append(x);

        return this;
    }

    /// <inheritdoc cref="ICollection{T}.Add"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Prepend(T item)
    {
        if (HasRoom(1))
        {
            View.CopyTo(_view[1..]);
            _length++;
            _view[0] = item;
            return this;
        }

        var replacement = Rent(1);
        _view.CopyTo(replacement.AsSpan()[1..]);
        replacement[0] = item;
        _length++;
        Swap(replacement);
        return this;
    }

    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Prepend(scoped ReadOnlySpan<T> collection)
    {
        if (HasRoom(collection.Length))
        {
            View.CopyTo(_view[collection.Length..]);
            collection.CopyTo(_view);
            _length += collection.Length;
            return this;
        }

        var replacement = Rent(collection.Length);
        _view.CopyTo(replacement.AsSpan()[collection.Length..]);
        collection.CopyTo(_view);
        _length += collection.Length;
        Swap(replacement);
        return this;
    }

    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Prepend([InstantHandle] IEnumerable<T> collection) => Insert(0, collection);

    /// <inheritdoc cref="IList{T}.Insert"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Insert([NonNegativeValue] int offset, T item)
    {
        if (HasRoom(1))
        {
            Copy(offset, item, _view);
            return this;
        }

        var replacement = Rent(1);
        Copy(offset, item, replacement);
        Swap(replacement);
        return this;
    }

    /// <inheritdoc cref="IList{T}.Insert"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Insert([NonNegativeValue] int index, scoped ReadOnlySpan<T> items)
    {
        if (HasRoom(items.Length))
        {
            Copy(index, items, _view);
            return this;
        }

        var replacement = Rent(items.Length);
        Copy(index, items, replacement);
        Swap(replacement);
        return this;
    }

    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Insert([NonNegativeValue] int index, [InstantHandle] IEnumerable<T> collection)
    {
        MakeRoom(collection);

        using var e = collection.GetEnumerator();

        for (var i = index; e.MoveNext(); i++)
            Insert(i, e.Current);

        return this;
    }

    /// <inheritdoc cref="IList{T}.RemoveAt"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt([NonNegativeValue] int index) => RemoveAt(index, 1);

    /// <summary>Removes the <see cref="PooledSmallList{T}"/> item at the specified offset and length.</summary>
    /// <param name="offset">The offset of the slice to remove.</param>
    /// <param name="length">The length of the slice to remove.</param>
    /// <returns>Itself.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt([NonNegativeValue] int offset, [NonNegativeValue] int length)
    {
        View[(offset + length)..].CopyTo(View[offset..]);
        _length -= length;
        return this;
    }

    /// <inheritdoc cref="IList{T}.RemoveAt"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt(Index index)
    {
        var offset = index.GetOffset(_length);
        RemoveAt(offset, 1);
        return this;
    }

    /// <summary>Removes the <see cref="PooledSmallList{T}"/> item at the specified range.</summary>
    /// <param name="range">The range of the slice to remove.</param>
    /// <returns>Itself.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt(Range range)
    {
        range.GetOffsetAndLength(_length, out var offset, out var length);
        RemoveAt(offset, length);
        return this;
    }

    /// <summary>Shrinks the collection.</summary>
    /// <param name="amount">The amount of elements to shrink.</param>
    /// <returns>Itself.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Shrink([NonNegativeValue] int amount)
    {
        Length -= amount;
        return this;
    }

    /// <inheritdoc cref="Span{T}.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Span<T>.Enumerator GetEnumerator() => View.GetEnumerator();

    /// <summary>Gets the specific element, returning the default value when out-of-bounds.</summary>
    /// <param name="i">The index.</param>
    /// <returns>The element, or default.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ref T Nth([NonNegativeValue] int i)
    {
        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
        if (i >= 0 && i < _length)
            return ref _view[i];

        return ref Unsafe.NullRef<T>();
    }

    /// <summary>Gets the specific element, returning the default value when out-of-bounds.</summary>
    /// <param name="i">The index.</param>
    /// <returns>The element, or default.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ref T Nth(Index i)
    {
        var offset = i.GetOffset(_length);
        return ref Nth(offset);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void Copy([NonNegativeValue] int offset, T insertion, scoped Span<T> destination)
    {
        switch (offset)
        {
            case 0:
                View.CopyTo(destination[1..]);
                break;
            case var _ when offset == _length:
                View.CopyTo(destination);
                break;
            default:
                View[offset..].CopyTo(destination[(offset + 1)..]);
                View[..offset].CopyTo(destination);
                break;
        }

        destination[offset] = insertion;
        _length++;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void Copy([NonNegativeValue] int offset, scoped ReadOnlySpan<T> insertion, scoped Span<T> destination)
    {
        switch (offset)
        {
            case 0:
                View.CopyTo(destination[insertion.Length..]);
                insertion.CopyTo(destination);
                break;
            case var _ when offset == _length:
                insertion.CopyTo(destination[offset..]);
                View.CopyTo(destination);
                break;
            default:
                View[offset..].CopyTo(destination[(offset + insertion.Length)..]);
                insertion.CopyTo(destination[offset..]);
                View[..offset].CopyTo(destination);
                break;
        }

        _length += insertion.Length;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void Swap(T[] replacement)
    {
        if (!IsInlined)
            ArrayPool<T>.Shared.Return(_rental);

        _view = _rental = replacement;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void MakeRoom([NonNegativeValue] int by)
    {
        if (HasRoom(by))
            return;

        var replacement = Rent(by);
        View.CopyTo(replacement);
        Swap(replacement);
        _length += by;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void MakeRoom([NoEnumeration] IEnumerable<T> collection)
    {
        if (collection.TryGetNonEnumeratedCount(out var count))
            MakeRoom(count);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly bool HasRoom(int by) => _length + by <= _view.Length;

    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly T[] Rent([NonNegativeValue] int by)
    {
        var sum = unchecked((uint)(_view.Length + by));
        var length = unchecked((int)sum.RoundUpToPowerOf2());
        return ArrayPool<T>.Shared.Rent(length);
    }

    /// <summary>Validator of generics representing the continuous buffer over the element type.</summary>
    /// <typeparam name="TRef">The generic representing the continuous buffer over the element type.</typeparam>
    public static class Validate<TRef>
        where TRef : struct
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static Validate() => Go(typeof(TRef));

        /// <summary>Gets the inlined length.</summary>
        [NonNegativeValue]
        public static int InlinedLength { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            Unsafe.SizeOf<TRef>() / Unsafe.SizeOf<T>();

        /// <summary>Reinterprets the reference as the continuous buffer over the element type.</summary>
        /// <param name="reference">The reference.</param>
        /// <returns>The span.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static Span<T> AsSpan(ref TRef reference) =>
            MemoryMarshal.CreateSpan(ref Unsafe.As<TRef, T>(ref reference), InlinedLength);

        // ReSharper disable once SuggestBaseTypeForParameter
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool Go(Type type) =>
            type
               .GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
               .Where(x => x.FieldType is var y && y != typeof(T) && (!y.IsValueType || y != x.DeclaringType && Go(y)))
               .Select(Throw)
               .Any();

        [DoesNotReturn, MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool Throw(FieldInfo _) =>
            throw new TypeLoadException(
                $"\"{typeof(TRef).UnfoldedName()}\" contains fields other than {typeof(T).UnfoldedName()}."
            );
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0

// ReSharper disable RedundantExtendsListEntry RedundantUnsafeContext RedundantUsingDirective
// ReSharper disable once CheckNamespace

#pragma warning disable RCS1242 // Normally causes defensive copies; Parameter is unused though.


/// <summary>Factory methods for creating inlined <see cref="SmallList{T}"/> instances.</summary>

    /// <summary>Number of items to keep inline for <see cref="SmallList{T}"/>.</summary>
    /// <remarks><para>
    /// And Saint Attila raised the <see cref="SmallList{T}"/> up on high, saying, "O Lord, bless this Thy
    /// <see cref="SmallList{T}"/> that, with it, Thou mayest blow Thine allocation costs to tiny bits in Thy mercy.".
    /// </para><para>
    /// And the Lord did grin, and the people did feast upon the lambs and sloths and carp and anchovies and orangutans
    /// and breakfast cereals and fruit bats and large chu...
    /// </para><para>
    /// And the Lord spake, saying, "First shalt thou recreate the <c>smallvec</c> (https://crates.io/crates/smallvec)
    /// crate. Then, shalt thou keep three inline. No more. No less. Three shalt be the number thou shalt keep inline,
    /// and the number to keep inline shalt be three. Four shalt thou not keep inline, nor either keep inline thou two,
    /// excepting that thou then proceed to three. Five is right out. Once the number three,  being the third number,
    /// be reached, then, lobbest thou thy <see cref="SmallList{T}"/> towards thy heap, who, being slow and
    /// cache-naughty in My sight, shall snuff it.".
    /// </para><para>
    /// (Source: https://github.com/rhaiscript/rhai/blob/ca18cdd7f47f8ae8bd6e2b7a950ad4815d62f026/src/lib.rs#L373).
    /// </para></remarks>
#pragma warning disable RCS1158
    public const int InlinedLength = 3;
#pragma warning restore RCS1158

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with no elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>() => [];

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 1 element.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first) => first;

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 2 elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first, T second) => new(first, second);

    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 3 elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first, T second, T third) => new(first, second, third);

    /// <summary>Creates a new instance of the <see cref="SmallList{T}"/> struct with arbitrary elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The rest of the elements.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first, T second, T third, params T[] rest) =>
        new(first, second, third, rest);
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <summary>Allocates an inlined list of the specified size.</summary>
    /// <remarks><para>
    /// The returned <see cref="PooledSmallList{T}"/> will point to uninitialized memory.
    /// Be sure to call <see cref="Span{T}.Fill"/> or otherwise written to first before enumeration or reading.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <param name="_">The discard, which is used to let the compiler track lifetimes.</param>
    /// <returns>The <see cref="Span{T}"/> of the specified size.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL // ReSharper disable once NullableWarningSuppressionIsUsed
    public static PooledSmallList<T> New1<T>(in T _ = default!) =>
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        Ref(ref AsRef(_));
#else
    public static unsafe PooledSmallList<T> New1<T>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Unsafe.SkipInit(out T one);
#pragma warning disable 9091 // InlineAttribute makes this okay.
        return Ref(ref one);
#pragma warning restore 9091
    }
#endif

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New2<T>(in Two<T> _ = default)
#else
    public static PooledSmallList<T> New2<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<T>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New4<T>(in Two<Two<T>> _ = default)
#else
    public static PooledSmallList<T> New4<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<T>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New8<T>(in Two<Two<Two<T>>> _ = default)
#else
    public static PooledSmallList<T> New8<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<T>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New16<T>(in Two<Two<Two<Two<T>>>> _ = default)
#else
    public static PooledSmallList<T> New16<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<T>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New32<T>(in Two<Two<Two<Two<Two<T>>>>> _ = default)
#else
    public static PooledSmallList<T> New32<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<Two<T>>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New64<T>(in Two<Two<Two<Two<Two<Two<T>>>>>> _ = default)
#else
    public static PooledSmallList<T> New64<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<Two<Two<T>>>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New128<T>(in Two<Two<Two<Two<Two<Two<Two<T>>>>>>> _ = default)
#else
    public static PooledSmallList<T> New128<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New256<T>(in Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>> _ = default)
#else
    public static PooledSmallList<T> New256<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New512<T>(in Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>> _ = default)
#else
    public static PooledSmallList<T> New512<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> New1024<T>(in Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>> _ = default)
#else
    public static PooledSmallList<T> New1024<T>(in bool _ = false)
#endif
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            From<T, Two<Two<Two<Two<Two<Two<Two<Two<Two<Two<T>>>>>>>>>>>(_);

    /// <inheritdoc cref="New1{T}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
#if DEBUG || CSHARPREPL
    public static PooledSmallList<T> From<T, TRef>(in TRef _ = default)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        where TRef : struct =>
        PooledSmallList<T>.From(ref AsRef(_));
#else
    public static unsafe PooledSmallList<T> From<T, TRef>(in bool _ = false)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        where TRef : struct
    {
        Unsafe.SkipInit(out TRef two);
#pragma warning disable 9091 // InlineAttribute makes this okay.
        return PooledSmallList<T>.From(ref two);
#pragma warning restore 9091
    }
#endif
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <summary>Defines the base class for an assertion, where a function is expected to return true.</summary>
/// <param name="that">The condition that must be true.</param>
/// <param name="message">The message to display when <paramref name="that"/> is false.</param>
/// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
#if CSHARPREPL
public
#endif
abstract partial class Assert(
    bool that,
    string? message = null,
    [CallerArgumentExpression(nameof(that))] string thatEx = ""
)
{
#if !CSHARPREPL
    static readonly IList<Type> s_assertions = typeof(Assert).Assembly.TryGetTypes().Where(IsAssertable).ToListLazily();
#endif

    /// <summary>Initializes a new instance of the <see cref="Assert"/> class.</summary>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
    /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
    protected Assert(
        [InstantHandle] Func<bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(Update(that, that, ref message, f => f?[thatEx]), message, thatEx) { }

    /// <summary>Gets the amount of available assertions.</summary>
    [Pure]
    public static int Length =>
#if CSHARPREPL
        Runner.Count();
#else
        s_assertions.Count;
#endif

    /// <summary>
    /// Gets the enumeration responsible for running every <see cref="Assert"/> instance
    /// defined in the current <see cref="Assembly"/>, and returning every instance of a failed assert.
    /// </summary>
    [Pure]
    public static IEnumerable<Result> Runner =>
#if CSHARPREPL
        AppDomain
           .CurrentDomain
           .GetAssemblies()
           .SelectMany(ManyQueries.TryGetTypes)
           .Where(IsAssertable)
#else
        s_assertions
#endif
           .Select(x => new Result(x));

    /// <summary>Gets the message of the assertion if it failed, or null.</summary>
    [Pure]
    public string? Message { get; } = that ? null : message ?? FormatAttribute.Default[thatEx];

    /// <summary>Gets the name of the assertion.</summary>
    [Pure]
    public string Name => GetType().UnfoldedFullName();

    /// <summary>Assertion that the enumerable must contain an item.</summary>
    /// <param name="x">The enumerable that must contain an item.</param>
    /// <returns>Whether the parameter <paramref name="x"/> contains an item.</returns>
    [Format("Expected @x to have any items, received an empty collection."), Pure]
    public static bool Any([InstantHandle] IEnumerable x)
    {
        // ReSharper disable once ObjectProducedWithMustDisposeAnnotatedMethodIsNotDisposed
        var e = x.GetEnumerator();

        try
        {
            return e.MoveNext();
        }
        finally
        {
            (e as IDisposable)?.Dispose();
        }
    }

    /// <summary>Assertion that the enumerable must be empty.</summary>
    /// <param name="x">The enumerable that must be empty.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is empty.</returns>
    [Format("Expected @x to be an empty collection, received #x."), Pure]
    public static bool Empty([InstantHandle] IEnumerable x) => !Any(x);

    /// <summary>Assertion that the enumerable must be null or empty.</summary>
    /// <param name="x">The enumerable that must be null or empty.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is null or empty.</returns>
    [Format("Expected @x to be null or empty, received #x."), Pure]
    public static bool EmptyOrNull([InstantHandle, NotNullWhen(false)] IEnumerable? x) => x is null || !Any(x);

    /// <summary>Updates the value of the referenced parameter if the provided assertion fails.</summary>
    /// <param name="exposure">The exposed <see cref="Delegate"/> used to get metadata from.</param>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to update.</param>
    /// <param name="formatter">The factory of the message.</param>
    /// <returns>The returned value when calling the parameter <paramref name="that"/>.</returns>
    [MustUseReturnValue]
    public static bool Update(
        [InstantHandle] Delegate exposure,
        [InstantHandle] Func<bool> that,
        ref string? message,
        [InstantHandle] Converter<FormatAttribute?, string?> formatter
    ) =>
        that() || (message ??= formatter(exposure.Method.GetCustomAttribute<FormatAttribute>())) is var _ && false;

    /// <summary>Assertion that both parameters must contain the same items.</summary>
    /// <typeparam name="T">The type of items to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> have the same items.</returns>
    [Format("Expected @x to have the same items as @y, received #x and #y."), Pure]
    public static bool SequenceEqualTo<T>([InstantHandle] IEnumerable<T> x, [InstantHandle] IEnumerable<T> y) =>
        x.SequenceEqual(y);

    /// <summary>Assertion that both parameters must be equal.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> are the same.</returns>
    [Format("Expected @x to be equal to @y, received #x and #y."), Pure]
    public static bool EqualTo<T>(T x, T y) => EqualityComparer<T>.Default.Equals(x, y);

    /// <summary>Assertion that the left-hand side must be greater than the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is greater than <paramref name="y"/>.</returns>
    [Format("Expected @x to be strictly greater than @y, received #x which is less than or equal to #y."), Pure]
    public static bool GreaterThan<T>(T x, T y) => Compare(x, y) > 0;

    /// <summary>Assertion that the left-hand side must be greater than or equal to the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is greater than or equal to <paramref name="y"/>.</returns>
    [Format("Expected @x to be greater than or equal to @y, received #x which is strictly less than #y."), Pure]
    public static bool GreaterThanOrEqualTo<T>(T x, T y) => Compare(x, y) >= 0;

    /// <summary>Assertion that the left-hand side must be less than the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is less than <paramref name="y"/>.</returns>
    [Format("Expected @x to be strictly less than @y, received #x which is greater than or equal to #y."), Pure]
    public static bool LessThan<T>(T x, T y) => Compare(x, y) < 0;

    /// <summary>Assertion that the left-hand side must be less than or equal to the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is less than or equal to <paramref name="y"/>.</returns>
    [Format("Expected @x to be less than or equal to @y, received #x which is strictly greater than #y."), Pure]
    public static bool LessThanOrEqualTo<T>(T x, T y) => Compare(x, y) <= 0;

    /// <summary>Assertion that the enumerable must not be null.</summary>
    /// <param name="x">The value that must not be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is not null.</returns>
    [Format("Expected @x to be not null, received null."), Pure]
    public static bool NotNull([NotNullWhen(true)] object? x) => x is not null;

    /// <summary>Assertion that the enumerable must not be null.</summary>
    /// <typeparam name="T">The type of value to do the null check on.</typeparam>
    /// <param name="x">The value that must not be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is not null.</returns>
    [Format("Expected @x to be not null, received null."), Pure]
    public static bool NotNull<T>([NotNullWhen(true)] T x) => x is not null;

    /// <summary>Assertion that the enumerable must be null.</summary>
    /// <param name="x">The value that must be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is null.</returns>
    [Format("Expected @x to be null, received #x."), Pure]
    public static bool Null([NotNullWhen(false)] object? x) => x is null;

    /// <summary>Assertion that the enumerable must be null.</summary>
    /// <typeparam name="T">The type of value to do the null check on.</typeparam>
    /// <param name="x">The value that must be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is null.</returns>
    [Format("Expected @x to be null, received #x."), Pure]
    public static bool Null<T>([NotNullWhen(false)] T x) => x is null;

    /// <summary>Assertion that both parameters must not be equal.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> are not the same.</returns>
    [Format("Expected @x to not be equal to @y, received #x."), Pure]
    public static bool UnequalTo<T>(T x, T y) => !EqualTo(x, y);

    /// <summary>Compares the two instances. This method is used for any comparing assertion methods.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>The resulting value from comparing parameters <paramref name="x"/> and <paramref name="y"/>.</returns>
    [Pure]
    public static int Compare<T>(T x, T y) => Comparer<T>.Default.Compare(x, y);
#if NET7_0_OR_GREATER
#pragma warning disable RCS1158
    /// <summary>Creates the assertion that two values must be equal to each other within an error of margin.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="margin">The lossy value to which both instances are considered equal.</param>
    /// <returns>The assertion that determines equality of two values within a margin of error.</returns>
    [Pure]
    public static Func<T, T, bool> RoughlyEqualTo<T>(T margin)
        where T : INumber<T> =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            T.Abs(x - y) <= T.Abs(margin);
#pragma warning restore RCS1158
#else
    /// <summary>Creates the assertion that two items must be equal to each other within an error of margin.</summary>
    /// <param name="margin">The lossy value to which both instances are considered equal.</param>
    /// <returns>The assertion that determines equality of two items within a margin of error.</returns>
    [Pure]
    public static Func<float, float, bool> RoughlyEqualTo(float margin) =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            Math.Abs(x - y) <= Math.Abs(margin);

    /// <inheritdoc cref="RoughlyEqualTo(float)"/>
    [Pure]
    public static Func<double, double, bool> RoughlyEqualTo(double margin) =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            Math.Abs(x - y) <= Math.Abs(margin);

    /// <inheritdoc cref="RoughlyEqualTo(float)"/>
    [Pure]
    public static Func<decimal, decimal, bool> RoughlyEqualTo(decimal margin) =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            Math.Abs(x - y) <= Math.Abs(margin);
#endif

    /// <summary>Executes every assertion and gets all of the assertions that failed.</summary>
    /// <returns>All assertions that failed.</returns>
    [Pure]
    public static IEnumerable<string> AllMessages() => Runner.RunAll().Where(x => x.Failed).Select(x => $"{x}");

    /// <summary>Creates the assertion that the value must be within a certain range.</summary>
    /// <param name="range">The range of values to accept. The range is considered to be inclusive on both ends.</param>
    /// <returns>The assertion that determines whether a value is within the specific range.</returns>
    [Pure]
    public static Predicate<int> InRangeOf(Range range) =>
        [Format("Expected @x to be approximately within the range, received #x.")](x) =>
            x >= range.Start.Value && x <= range.End.Value;
#if NET7_0_OR_GREATER
    /// <summary>Creates the assertion that the value must be within a certain range.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="range">The range of values to accept. The range is considered to be inclusive on both ends.</param>
    /// <returns>The assertion that determines whether a value is within the specific range.</returns>
    [Pure]
    public static Predicate<T> InRangeOf<T>(Range range)
        where T : INumberBase<T> =>
        [Format("Expected @x to be approximately within the range, received #x.")](x) =>
            int.CreateSaturating(x) is var i && i >= range.Start.Value && i <= range.End.Value;
#endif

    /// <summary>Creates the assertion that the value must be within a certain range.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="low">The inclusive lower boundary.</param>
    /// <param name="high">The inclusive higher boundary.</param>
    /// <returns>The assertion that determines whether a value is within the specific range.</returns>
    [Pure]
    public static Predicate<T> InRangeOf<T>(T low, T high) =>
        [Format("Expected @x to be approximately within the range, received #x.")](x) =>
            GreaterThanOrEqualTo(x, low) && LessThanOrEqualTo(x, high);

    /// <summary>Creates the assertion that the parameter must contain specific items.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="items">The items that will be eventually compared to.</param>
    /// <returns>The assertion that determines whether a value contains the pre-determined items.</returns>
    [Pure]
    public static Predicate<IEnumerable<T>> Structured<T>(params T[] items) =>
        [Format("Expected @x to have fixed specific items, received #x.")](x) => SequenceEqualTo(x, items);

    /// <summary>Returns the parameter.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="items">The items that will be returned directly.</param>
    /// <returns>The parameter <paramref name="items"/>.</returns>
    [Pure]
    public static T[] Params<T>(params T[] items) => items;

    /// <inheritdoc />
    [Pure]
    public override string ToString() => new Result(this, GetType()).ToString();

    /// <summary>
    /// Determines whether the type implements <see cref="Assert"/> and can be instantiated.
    /// </summary>
    /// <param name="type">The type to check.</param>
    /// <returns>Whether the type implements <see cref="Assert"/> and can be instantiated.</returns>
    [Pure]
    static bool IsAssertable([NotNullWhen(true)] Type? type) =>
        type is { IsAbstract: false, IsClass: true, IsGenericType: false } &&
        ParameterlessConstructor(type) is not null &&
        type.FindPathToNull(x => x.BaseType).Contains(typeof(Assert));

    /// <summary>Gets the parameterless constructor, ignoring possible exceptions thrown.</summary>
    /// <param name="type">The type to get the parameterless exception from.</param>
    /// <returns>
    /// The <see cref="ConstructorInfo"/> containing no parameters from the parameter <paramref name="type"/>,
    /// if one exists.
    /// </returns>
    [Pure]
    static ConstructorInfo? ParameterlessConstructor(Type type)
    {
        try
        {
            return type.GetConstructor(Type.EmptyTypes);
        }
        catch (FileNotFoundException)
        {
            return null;
        }
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <summary>
/// Methods that provide functions for enumerations of <see cref="Assert.Result"/> instances.
/// </summary>
#pragma warning disable MA0048

    /// <summary>Eagerly executes all asserts of the passed in enumerator.</summary>
    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to execute.</param>
    /// <returns>The collected result of all assertions.</returns>
    [Pure]
    public static IList<Assert.Result> RunAll(this IEnumerator<Assert.Result> enumerator)
    {
        SmallList<Assert.Result> collected = [];

        while (enumerator.MoveNext())
            collected.Add(enumerator.Current.Run());

        return collected;
    }

    /// <summary>Eagerly executes all asserts of the passed in enumerable.</summary>
    /// <param name="enumerable">The <see cref="IEnumerable{T}"/> to execute.</param>
    /// <returns>The collected result of all assertions.</returns>
    [Pure] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
    public static IList<Assert.Result> RunAll([InstantHandle] this IEnumerable<Assert.Result> enumerable) =>
        enumerable.Select(x => x.Run()).ToListLazily();

/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>Represents the result of running an assertion.</summary>
    public readonly partial struct Result
    {
        /// <summary>Initializes a new instance of the <see cref="Result"/> struct.</summary>
        /// <param name="setup">The setup to store.</param>
        public Result(Type? setup = null) => Setup = setup;

        /// <summary>Initializes a new instance of the <see cref="Result"/> struct.</summary>
        /// <param name="assertion">The assertion to store.</param>
        /// <param name="setup">The setup to store.</param>
        public Result(Assert? assertion, Type? setup = null)
        {
            Assertion = assertion;
            Setup = setup ?? assertion?.GetType();
        }

        /// <summary>Initializes a new instance of the <see cref="Result"/> struct.</summary>
        /// <param name="error">The error to store.</param>
        /// <param name="setup">The setup to store.</param>
        public Result(Exception? error, Type? setup)
        {
            Error = error;
            Setup = setup;
        }

        /// <summary>Gets a value indicating whether <see cref="Assertion"/> has failed.</summary>
        [MemberNotNullWhen(false, nameof(Assertion)), Pure]
        public bool Failed => !Succeeded;

        /// <summary>Gets a value indicating whether <see cref="Error"/> is set.</summary>
        [MemberNotNullWhen(true, nameof(Error)), Pure]
        public bool HasError => Error is not null;

        /// <summary>Gets a value indicating whether this <see cref="Result"/> has executed.</summary>
        [Pure]
        public bool HasExecuted => !IsDefault;

        /// <summary>Gets a value indicating whether <see cref="Assertion"/> was successfully instantiated.</summary>
        [MemberNotNullWhen(true, nameof(Assertion)), Pure]
        public bool Instantiated => Assertion is not null;

        /// <summary>Gets a value indicating whether this <see cref="Result"/> is the default instance.</summary>
        [Pure]
        public bool IsDefault => Assertion is null && Error is null && Setup is null;

        /// <summary>Gets a value indicating whether <see cref="Assertion"/> has succeeded.</summary>
        [MemberNotNullWhen(true, nameof(Assertion)), Pure]
        public bool Succeeded => Instantiated && Assertion.Message is null;

        /// <summary>Gets the message of the assertion.</summary>
        [Pure]
        public string? Message => Instantiated ? Assertion.Message : null;

        /// <summary>Gets the name of the assertion type.</summary>
        [Pure]
        public string Name => Setup.UnfoldedFullName();

        /// <summary>Gets the assertion that ran.</summary>
        [Pure]
        public Assert? Assertion { get; }

        /// <summary>Gets the error that was thrown while instantiating <see cref="Assertion"/>.</summary>
        [Pure]
        public Exception? Error { get; }

        /// <summary>Gets the default instance.</summary>
        [Pure]
        public Result Default => default;

        /// <summary>Gets the type that was attempted to be instantiated.</summary>
        [Pure]
        public Type? Setup { get; }

        /// <summary>Gets the fail message.</summary>
        /// <returns>The fail message.</returns>
        [Pure]
        string Fail => Setup is null ? "Assertion failed! " : $"Assertion {Setup.Name} failed! ";

        /// <inheritdoc />
        [Pure]
        public override string ToString() =>
            IsDefault ? "N/A" :
            Instantiated ? Succeeded ? "OK" : $"{Fail}{Assertion.Message}" :
            HasError ? $"{Fail}Unexpectedly threw {Error.GetType().UnfoldedFullName()}: {Error}" : "Not determined";

        /// <summary>Executes the assertion and returns the new <see cref="Result"/>.</summary>
        /// <returns>The new instance of <see cref="Result"/> that contains the assertion results.</returns>
        [MustUseReturnValue]
        public Result Run()
        {
            if (Setup is null)
                return default;

            try
            {
                return new(Activator.CreateInstance(Setup, true) as Assert, Setup);
            }
#pragma warning disable CA1031
            catch (Exception ex)
#pragma warning restore CA1031
            {
                return new(ex, Setup);
            }
        }
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace

#pragma warning disable 1591, MA0048, SA1600 // Temporary because I don't feel like documenting yet.

/// <summary>Defines the base class for an assertion, where a value is expected to return true.</summary>
/// <typeparam name="T">The type of value to assert with.</typeparam>
abstract partial class Assert<T> : Assert
{
    /// <inheritdoc cref="Assert.EqualTo{T}"/>
    [Format("Expected @x to be equal to @y, received #x and #y.")]
    public static bool EqualTo(T x, T y) => EqualTo<T>(x, y);

    /// <inheritdoc cref="Assert.GreaterThan{T}"/>
    [Format("Expected @x to be strictly greater than @y, received #x which is less than or equal to #y.")]
    public static bool GreaterThan(T x, T y) => GreaterThan<T>(x, y);

    /// <inheritdoc cref="Assert.GreaterThanOrEqualTo{T}"/>
    [Format("Expected @x to be greater than or equal to @y, received #x which is strictly less than #y.")]
    public static bool GreaterThanOrEqualTo(T x, T y) => GreaterThanOrEqualTo<T>(x, y);

    /// <inheritdoc cref="Assert.LessThan{T}"/>
    [Format("Expected @x to be strictly less than @y, received #x which is greater than or equal to #y.")]
    public static bool LessThan(T x, T y) => LessThan<T>(x, y);

    /// <inheritdoc cref="Assert.LessThanOrEqualTo{T}"/>
    [Format("Expected @x to be less than or equal to @y, received #x which is strictly greater than #y.")]
    public static bool LessThanOrEqualTo(T x, T y) => LessThanOrEqualTo<T>(x, y);

    /// <inheritdoc cref="Assert.NotNull{T}"/>
    [Format("Expected @x to be not null, received null.")]
    public static bool NotNull(T x) => NotNull<T>(x);

    /// <inheritdoc cref="Assert.Null{T}"/>
    [Format("Expected @x to be null, received #x.")]
    public static bool Null(T x) => Null<T>(x);

    /// <inheritdoc cref="Assert.SequenceEqualTo{T}"/>
    [Format("Expected @x to have the same items as @y, received #x and #y.")]
    public static bool SequenceEqualTo([InstantHandle] IEnumerable<T> x, [InstantHandle] IEnumerable<T> y) =>
        SequenceEqualTo<T>(x, y);

    /// <inheritdoc cref="Assert.UnequalTo{T}"/>
    [Format("Expected @x to not be equal to @y, received #x.")]
    public static bool UnequalTo(T x, T y) => UnequalTo<T>(x, y);

    /// <inheritdoc cref="Assert.Compare{T}"/>
    [Pure]
    public static int Compare(T x, T y) => Compare<T>(x, y);

    /// <inheritdoc cref="Assert.InRangeOf{T}(T, T)"/>
    [Pure]
    public static Predicate<T> InRangeOf(T low, T high) => InRangeOf<T>(low, high);

    /// <inheritdoc cref="Assert.Structured{T}"/>
    [Pure]
    public static Predicate<IEnumerable<T>> Structured(params T[] expected) => Structured<T>(expected);

    /// <inheritdoc cref="Assert.Params{T}"/>
    [Pure]
    public static T[] Params(params T[] items) => Params<T>(items);
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>Represents the way an assertion be formatted.</summary>
    /// <param name="template">The template that is formatted and shown when the declaring member fails.</param>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed partial class FormatAttribute(string template) : Attribute
    {
        /// <summary>The value that is substituted for the function body of the assertion.</summary>
        public const string Assertion = "!!";

        /// <summary>The value that is substituted for the function body of the first parameter's factory.</summary>
        public const string XFactory = "@x";

        /// <summary>The value that is substituted for first parameter.</summary>
        public const string XValue = "#x";

        /// <summary>The value that is substituted for the function body of the second parameter's factory.</summary>
        public const string YFactory = "@y";

        /// <summary>The value that is substituted for second parameter.</summary>
        public const string YValue = "#y";

        /// <summary>Gets the default formatter.</summary>
        [Pure]
        public static FormatAttribute Default { get; } = new($"Expected {Assertion} to be true.");

        /// <summary>Returns the formatted <see cref="Template"/> by inserting the parameter.</summary>
        /// <param name="assertion">The value to replace <see cref="Assertion"/> with.</param>
        [Pure]
        public string this[string assertion] => Template.Replace(Assertion, assertion.Collapse());

        /// <summary>Returns the formatted <see cref="Template"/> by inserting the parameters.</summary>
        /// <param name="assertion">The value to replace <see cref="Assertion"/> with.</param>
        /// <param name="xFactory">The value to replace <see cref="XFactory"/> with.</param>
        /// <param name="xValue">The value to replace <see cref="XValue"/> with.</param>
        [Pure]
        public string this[string assertion, string xFactory, object? xValue] =>
            xFactory.Collapse() is var factory && xValue.Stringify() is var value
                ? this[assertion, factory, value, factory, value]
                : throw Unreachable;

        /// <summary>Returns the formatted <see cref="Template"/> by inserting the parameters.</summary>
        /// <param name="assertion">The value to replace <see cref="Assertion"/> with.</param>
        /// <param name="xFactory">The value to replace <see cref="XFactory"/> with.</param>
        /// <param name="xValue">The value to replace <see cref="XValue"/> with.</param>
        /// <param name="yFactory">The value to replace <see cref="YFactory"/> with.</param>
        /// <param name="yValue">The value to replace <see cref="YValue"/> with.</param>
        [Pure]
        public string this[string assertion, string xFactory, object? xValue, string yFactory, object? yValue] =>
            new StringBuilder(Template)
               .Replace(Assertion, assertion.Collapse())
               .Replace(XFactory, xFactory.Collapse())
               .Replace(XValue, xValue.Stringify())
               .Replace(YFactory, yFactory.Collapse())
               .Replace(YValue, yValue.Stringify())
               .ToString();

        /// <summary>Gets the template, before any substitution occurs.</summary>
        [Pure]
        public string Template => template;
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>Defines the base class for an assertion, where the type must throw.</summary>
    protected abstract partial class Throws : Throws<Exception>
    {
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, message, thatEx) { }
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>
    /// Defines the base class for an assertion, where the type must throw <typeparamref name="TException"/>.
    /// </summary>
    /// <typeparam name="TException">The type of exception to expect to be thrown.</typeparam>
    public abstract partial class Throws<TException> : Assert
        where TException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Assert.Throws{TException}"/> class.
        /// </summary>
        /// <param name="that">The condition that must throw <typeparamref name="TException"/>.</param>
        /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
        /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        protected Throws(
            [InstantHandle] Action that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(Try(that, ref message, thatEx), message, thatEx) { }

        /// <inheritdoc cref="Assert.Throws{TException}(Action, string, string)"/>
        protected Throws(
            [InstantHandle] Func<object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(Try(() => that(), ref message, thatEx), message, thatEx) { }

        /// <summary>Invokes the callback, expecting <typeparamref name="TException"/> to be thrown.</summary>
        /// <param name="that">The condition that must throw <typeparamref name="TException"/>.</param>
        /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
        /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        /// <returns>
        /// Whether <typeparamref name="TException"/> is thrown by the parameter <paramref name="that"/>.
        /// </returns>
        static bool Try(Action that, [NotNullWhen(false)] ref string? message, string thatEx)
        {
            try
            {
                that();
                return (message ??= Format(thatEx)) is var _ && false;
            }
            catch (TException)
            {
                return true;
            }
#pragma warning disable CA1031
            catch (Exception e)
#pragma warning restore CA1031
            {
                return (message ??= Format(thatEx, e)) is var _ && false;
            }
        }

        /// <summary>Creates the formatted error message.</summary>
        /// <param name="thatEx">The context of where the error came from.</param>
        /// <param name="e">The caught exception, if one exists.</param>
        /// <returns>The formatted error message.</returns>
        static string Format(string thatEx, Exception? e = null) =>
            $"Expected {thatEx.Collapse()} to throw {typeof(TException).UnfoldedName()}, instead received {Format(e)}.";

        /// <summary>Formats the exception.</summary>
        /// <param name="e">The caught exception, if one exists.</param>
        /// <returns>The formatted exception.</returns>
        static string Format(Exception? e) =>
            e is null
                ? "no exception"
#if NET6_0_OR_GREATER
                : $"{e.GetType().UnfoldedName()}: {e.Message}. {e.StackTrace?.ReplaceLineEndings(" ")}";
#else
                : $"{e.GetType().UnfoldedName()}: {e.Message}. {e.StackTrace?.Replace('\n', ' ')}";
#endif
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <inheritdoc cref="Assert{T}"/>
abstract partial class Assert<T>
{
    /// <inheritdoc cref="Assert.Throws{TException}"/>
    public new abstract partial class Throws<TException> : Assert.Throws<TException>
        where TException : Exception
    {
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <inheritdoc cref="Assert{T}"/>
abstract partial class Assert<T>
{
    /// <summary>Defines the base class for an assertion, where the type must throw.</summary>
    protected new abstract partial class Throws : Throws<Exception>
    {
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }

        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }
    }
}
#endif

// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace


/// <inheritdoc cref="Assert{T}"/>
abstract partial class Assert<T>
{
    /// <summary>Initializes a new instance of the <see cref="Assert{T}"/> class.</summary>
    /// <param name="it">The context value.</param>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
    /// <param name="itEx">The context of where <paramref name="it"/> came from.</param>
    /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
    protected Assert(
        T it,
        [InstantHandle] Predicate<T> that,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : base(Update(that, () => that(it), ref message, f => f?[thatEx, itEx, it]), message, thatEx) { }

    /// <summary>Initializes a new instance of the <see cref="Assert{T}"/> class.</summary>
    /// <param name="x">The first context value.</param>
    /// <param name="y">The second context value.</param>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
    /// <param name="xEx">The context of where <paramref name="x"/> came from.</param>
    /// <param name="yEx">The context of where <paramref name="y"/> came from.</param>
    /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
    protected Assert(
        T x,
        T y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : base(Update(that, () => that(x, y), ref message, f => f?[thatEx, xEx, x, yEx, y]), message, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, Predicate{T}, string, string, string)"/>
    protected Assert(
        [InstantHandle] Predicate<T> that,
        T it,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(it, that, message, itEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, Predicate{T}, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> it,
        [InstantHandle] Predicate<T> that,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(it(), that, message, itEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, Predicate{T}, string, string, string)"/>
    protected Assert(
        [InstantHandle] Predicate<T> that,
        [InstantHandle] Func<T> it,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(it(), that, message, itEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        T x,
        [InstantHandle] Func<T, T, bool> that,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y, that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        T x,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y, that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        T x,
        [InstantHandle] Func<T> y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y(), that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        T y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y, that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T> y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y(), that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y(), that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T, T, bool> that,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y, that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        T x,
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y(), that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y(), that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> x,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y, that, message, xEx, yEx, thatEx) { }

    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        T x,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y(), that, message, xEx, yEx, thatEx) { }
}
#endif

/// <summary>Methods that creates enumerations from individual items.</summary>
static partial class ManyQueries
{
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(Assembly? assembly) => assembly.TryGetTypes();
}

/// <summary>Signifies to ignore this when determining potential interfaces that can be implemented.</summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Event | AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Struct)]
sealed partial class NoStructuralTypingAttribute : Attribute;

/// <summary>Method to inline.</summary>
[AttributeUsage(AttributeTargets.Method)]
sealed partial class InlineAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
    /// <param name="remove">The value to set.</param>
    public InlineAttribute(bool remove = true) => Remove = remove;

    /// <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
    public bool Remove { get; }
}

/// <summary>Provides stringification methods.</summary>
static class Stringifier
{
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(T? source) => source.Stringify();
}

/// <summary>Polyfill for <c>nameof()</c>.</summary>
static class Morsels;

/// <summary>Gets the nothing value, used when the inner value is unspecified.</summary>
static object None => Emik.Results.Result.None;

