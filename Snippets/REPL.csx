// <auto-generated/>
#pragma warning disable CS0208
#define NET8_0
#define NET80
#define NET8_0_OR_GREATER
#define NET80_OR_GREATER
#define NET7_0_OR_GREATER
#define NET70_OR_GREATER
#define NET6_0_OR_GREATER
#define NET60_OR_GREATER
#define NET5_0_OR_GREATER
#define NET50_OR_GREATER
#define NETCOREAPP
#define NETSTANDARD2_1_OR_GREATER
#define NETSTANDARD2_0_OR_GREATER
#define NETSTANDARD1_6_OR_GREATER
#define NETSTANDARD1_5_OR_GREATER
#define NETSTANDARD1_4_OR_GREATER
#define NETSTANDARD1_3_OR_GREATER
#define NETSTANDARD1_2_OR_GREATER
#define NETSTANDARD1_1_OR_GREATER
#define NETSTANDARD1_0_OR_GREATER
#define NETSTANDARD
#define NO_ALLOWS_REF_STRUCT
#define FORCE_SERILOG
#define CSHARPREPL
#define DEBUG
global using System;
global using System.Buffers;
global using System.Buffers.Binary;
global using System.Buffers.Text;
global using System.CodeDom.Compiler;
global using System.Collections;
global using System.Collections.Concurrent;
global using System.Collections.Frozen;
global using System.Collections.Generic;
global using System.Collections.Immutable;
global using System.Collections.ObjectModel;
global using System.Collections.Specialized;
global using System.ComponentModel;
global using System.ComponentModel.DataAnnotations;
global using System.ComponentModel.DataAnnotations.Schema;
global using System.ComponentModel.Design;
global using System.ComponentModel.Design.Serialization;
global using System.Configuration.Assemblies;
global using System.Data;
global using System.Data.Common;
global using System.Data.Odbc;
global using System.Data.OleDb;
global using System.Data.Sql;
global using System.Data.SqlClient;
global using System.Data.SqlTypes;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.Diagnostics.Contracts;
global using System.Diagnostics.Eventing;
global using System.Diagnostics.Eventing.Reader;
global using System.Diagnostics.Metrics;
global using System.Diagnostics.PerformanceData;
global using System.Diagnostics.SymbolStore;
global using System.Diagnostics.Tracing;
global using System.Drawing;
global using System.Drawing.Configuration;
global using System.Drawing.Design;
global using System.Drawing.Drawing2D;
global using System.Drawing.Imaging;
global using System.Drawing.Printing;
global using System.Drawing.Text;
global using System.Dynamic;
global using System.Formats;
global using System.Formats.Asn1;
global using System.Globalization;
global using System.IO;
global using System.IO.Compression;
global using System.IO.Enumeration;
global using System.IO.IsolatedStorage;
global using System.IO.MemoryMappedFiles;
global using System.IO.Packaging;
global using System.IO.Pipes;
global using System.IO.Ports;
global using System.Linq;
global using System.Linq.Expressions;
global using System.Linq.Expressions.Interpreter;
global using System.Media;
global using System.Net;
global using System.Net.Cache;
global using System.Net.Http;
global using System.Net.Http.Headers;
global using System.Net.Http.Json;
global using System.Net.Http.Metrics;
global using System.Net.Mail;
global using System.Net.Mime;
global using System.Net.NetworkInformation;
global using System.Net.PeerToPeer;
global using System.Net.PeerToPeer.Collaboration;
global using System.Net.Security;
global using System.Net.Sockets;
global using System.Net.WebSockets;
global using System.Numerics;
global using System.Reflection;
global using System.Reflection.Emit;
global using System.Reflection.Metadata;
global using System.Reflection.Metadata.Ecma335;
global using System.Reflection.PortableExecutable;
global using System.Resources;
global using System.Runtime;
global using System.Runtime.CompilerServices;
global using System.Runtime.ConstrainedExecution;
global using System.Runtime.ExceptionServices;
global using System.Runtime.InteropServices;
global using System.Runtime.InteropServices.ComTypes;
global using System.Runtime.InteropServices.Marshalling;
global using System.Runtime.InteropServices.ObjectiveC;
global using System.Runtime.Intrinsics;
global using System.Runtime.Intrinsics.Arm;
global using System.Runtime.Intrinsics.Wasm;
global using System.Runtime.Intrinsics.X86;
global using System.Runtime.Loader;
global using System.Runtime.Remoting;
global using System.Runtime.Serialization;
global using System.Runtime.Serialization.Formatters;
global using System.Runtime.Serialization.Formatters.Binary;
global using System.Runtime.Serialization.Json;
global using System.Runtime.Versioning;
global using System.Security;
global using System.Security.AccessControl;
global using System.Security.Authentication;
global using System.Security.Authentication.ExtendedProtection;
global using System.Security.Claims;
global using System.Security.Cryptography;
global using System.Security.Cryptography.Pkcs;
global using System.Security.Cryptography.X509Certificates;
global using System.Security.Cryptography.Xml;
global using System.Security.Permissions;
global using System.Security.Policy;
global using System.Security.Principal;
global using System.ServiceModel;
global using System.ServiceModel.Syndication;
global using System.ServiceProcess;
global using System.Text;
global using System.Text.Encodings;
global using System.Text.Encodings.Web;
global using System.Text.Json;
global using System.Text.Json.Nodes;
global using System.Text.Json.Serialization;
global using System.Text.Json.Serialization.Metadata;
global using System.Text.RegularExpressions;
global using System.Text.Unicode;
global using System.Threading;
global using System.Threading.Channels;
global using System.Threading.Tasks;
global using System.Threading.Tasks.Dataflow;
global using System.Threading.Tasks.Sources;
global using System.Timers;
global using System.Transactions;
global using System.Web;
global using System.Windows;
global using System.Windows.Input;
global using System.Windows.Markup;
global using System.Xml;
global using System.Xml.Linq;
global using System.Xml.Resolvers;
global using System.Xml.Schema;
global using System.Xml.Serialization;
global using System.Xml.XPath;
global using System.Xml.Xsl;
global using System.Xml.Xsl.Runtime;
global using CommunityToolkit.Common;
global using CommunityToolkit.Common.Collections;
global using CommunityToolkit.Common.Deferred;
global using CommunityToolkit.Common.Extensions;
global using CommunityToolkit.Common.Helpers;
global using CommunityToolkit.Diagnostics;
global using CommunityToolkit.Helpers;
global using CommunityToolkit.HighPerformance;
global using CommunityToolkit.HighPerformance.Buffers;
global using CommunityToolkit.HighPerformance.Buffers.Views;
global using CommunityToolkit.HighPerformance.Enumerables;
global using CommunityToolkit.HighPerformance.Helpers;
global using CommunityToolkit.HighPerformance.Memory;
global using CommunityToolkit.HighPerformance.Memory.Views;
global using CommunityToolkit.HighPerformance.Streams;
global using Emik.Results;
global using Emik.Results.Extensions;
global using FastGenericNew;
global using JetBrains.Annotations;
global using Serilog;
global using Serilog.Capturing;
global using Serilog.Configuration;
global using Serilog.Context;
global using Serilog.Core;
global using Serilog.Core.Enrichers;
global using Serilog.Core.Filters;
global using Serilog.Core.Pipeline;
global using Serilog.Core.Sinks;
global using Serilog.Data;
global using Serilog.Debugging;
global using Serilog.Events;
global using Serilog.Filters;
global using Serilog.Formatting;
global using Serilog.Formatting.Compact;
global using Serilog.Formatting.Display;
global using Serilog.Formatting.Json;
global using Serilog.Parsing;
global using Serilog.Policies;
global using Serilog.Rendering;
global using Serilog.Settings;
global using Serilog.Settings.KeyValuePairs;
global using Serilog.Sinks;
global using Serilog.Sinks.File;
global using Serilog.Sinks.SystemConsole;
global using Serilog.Sinks.SystemConsole.Formatting;
global using Serilog.Sinks.SystemConsole.Output;
global using Serilog.Sinks.SystemConsole.Platform;
global using Serilog.Sinks.SystemConsole.Rendering;
global using Serilog.Sinks.SystemConsole.Themes;
global using TextCopy;
global using static Emik.Results.Please;
global using static Emik.Results.Result;
global using static FastGenericNew.FastNew;
global using static TextCopy.ClipboardService;
global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
global using Expression = System.Linq.Expressions.Expression;
global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;
global using GeneratedSource = (string HintName, string Source);
using static System.Runtime.CompilerServices.RuntimeHelpers;
using static System.Runtime.CompilerServices.RuntimeHelpers;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static JetBrains.Annotations.CollectionAccessType;
using static System.Runtime.CompilerServices.RuntimeHelpers;
using static System.Runtime.CompilerServices.RuntimeHelpers;
using static JetBrains.Annotations.CollectionAccessType;
using SecurityAction = System.Security.Permissions.SecurityAction;
using static System.Security.Permissions.SecurityAction;
using static System.Security.Permissions.SecurityPermissionFlag;
using static JetBrains.Annotations.CollectionAccessType;
using static System.Linq.Expressions.Expression;
using static System.Enum;
using static System.Linq.Expressions.Expression;
using Enum = System.Enum;
using static System.Linq.Expressions.Expression;
// SPDX-License-Identifier: MPL-2.0
#if ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
// ReSharper disable once CheckNamespace EmptyNamespace
/// <summary>Encapsulates a single value to be exposed as a <see cref="Memory{T}"/> of size 1.</summary>
/// <typeparam name="T">The type of value.</typeparam>
/// <param name="value">The value to encapsulate.</param>
public sealed partial class OnceMemoryManager<T>(T value) : MemoryManager<T>
{
    GCHandle _handle;
    T _value = value;
    /// <summary>Gets the value.</summary>
    public ref T Value
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => ref _value;
    }
    /// <summary>Wraps the <typeparamref name="T"/> instance into the <see cref="OnceMemoryManager{T}"/>.</summary>
    /// <param name="value">The value to wrap.</param>
    /// <returns>The wrapped value.</returns>
    public static explicit operator OnceMemoryManager<T>(T value) => new(value);
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable IDISP010
    protected override void Dispose(bool disposing)
#pragma warning restore IDISP010
    {
        if (_handle.IsAllocated)
            _handle.Free();
    }
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override void Unpin() => Dispose(true);
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public override unsafe MemoryHandle Pin(int elementIndex = 0) =>
        typeof(T).IsValueType
            ? default
            : new(
                (void*)(_handle.IsAllocated ? _handle : _handle = GCHandle.Alloc(_value, GCHandleType.Pinned))
               .AddrOfPinnedObject()
            );
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public override Span<T> GetSpan() => Ref(ref _value);
}
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
// ReSharper disable once RedundantNameQualifier
    /// <summary>Represents the rented array from <see cref="ArrayPool{T}"/>.</summary>
    /// <typeparam name="T">The type of array to rent.</typeparam>
    public struct Rented<T> : IDisposable
    {
        T[]? _array;
        /// <summary>Initializes a new instance of the <see cref="Rent"/> struct. Rents the array.</summary>
        /// <param name="length">The length of the array to retrieve.</param>
        /// <param name="span">
        /// The resulting <see cref="Span{T}"/>. Note that while <see cref="ArrayPool{T}.Rent"/> may return
        /// </param>
        public Rented(in int length, out Span<T> span) =>
            span = (_array = ArrayPool<T>.Shared.Rent(length)).AsSpan().UnsafelyTake(length);
        /// <inheritdoc />
        void IDisposable.Dispose()
        {
            if (_array is null)
                return;
            ArrayPool<T>.Shared.Return(_array);
            _array = null;
        }
    }
    /// <summary>Allocates the buffer on the stack or heap, and gives it to the caller.</summary>
    /// <remarks><para>See <see cref="Span.MaxStackalloc"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="T">The type of buffer.</typeparam>
    /// <param name="it">The length of the buffer.</param>
    /// <param name="span">The temporary allocation.</param>
    /// <returns>The allocated buffer.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource, Pure]
    public static Rented<T> Alloc<T>(this in int it, out Span<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            it switch
            {
                <= 0 when (span = default) is var _ => default,
#if !CSHARPREPL
                _ when !IsReferenceOrContainsReferences<T>() &&
                    IsStack<T>(it) &&
                    (span = Stackalloc<T>(it)) is var _ => default,
#endif
                _ => new(it, out span),
            };
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable BadPreprocessorIndent RedundantUnsafeContext UseSymbolAlias
// ReSharper disable once CheckNamespace
#pragma warning disable 8500
// ReSharper disable once RedundantNameQualifier RedundantUsingDirective
/// <summary>Defines methods for spans.</summary>
/// <remarks><para>See <see cref="MaxStackalloc"/> for details about stack- and heap-allocation.</para></remarks>
    /// <summary>Provides reinterpret span methods.</summary>
    /// <typeparam name="TTo">The type to convert to.</typeparam>
    public static class To<TTo>
    {
        /// <summary>
        /// Encapsulates the functionality to determine if a conversion is supported between two types.
        /// </summary>
        /// <typeparam name="TFrom">The type to convert from.</typeparam>
        public static class Is<TFrom>
#if !NO_ALLOWS_REF_STRUCT
            where TFrom : allows ref struct
#endif
        {
            /// <summary>
            /// Gets a value indicating whether the conversion between types
            /// <typeparamref name="TFrom"/> and <see name="TTo"/> in <see cref="To{TTo}"/> is defined.
            /// </summary>
            public static unsafe bool Supported { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
#if NETSTANDARD && !NETSTANDARD2_0_OR_GREATER
                typeof(TTo) == typeof(TFrom);
#else
                typeof(TFrom) == typeof(TTo) ||
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
                Unsafe.SizeOf<TFrom>() >= Unsafe.SizeOf<TTo>() &&
#else
                sizeof(TFrom) >= sizeof(TTo) &&
#endif
                (IsReinterpretable(typeof(TFrom), typeof(TTo)) ||
                    !IsReferenceOrContainsReferences<TFrom>() && !IsReferenceOrContainsReferences<TTo>());
#endif
            /// <summary>
            /// Gets the error that occurs when converting between types would cause undefined behavior.
            /// </summary>
            public static NotSupportedException Error
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                get => new($"Cannot convert from {typeof(TFrom).Name} to {typeof(TTo).Name}.");
            }
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
            [Pure]
            static bool IsReinterpretable(Type first, Type second) =>
                first.FindPathToNull(Next).CartesianProduct(second.FindPathToNull(Next)).Any(x => x.First == x.Second);
            [Pure]
            static Type? Next(Type x) => x.IsValueType && x.GetFields() is [{ FieldType: var y }] ? y : null;
#endif
        }
        /// <summary>
        /// Converts a <see cref="ReadOnlySpan{T}"/> of type <typeparamref name="TFrom"/>
        /// to a <see cref="ReadOnlySpan{T}"/> of type <see name="TTo"/> in <see cref="To{TTo}"/>.
        /// </summary>
        /// <typeparam name="TFrom">The type to convert from.</typeparam>
        /// <param name="source">The <see cref="ReadOnlySpan{T}"/> to convert from.</param>
        /// <exception cref="NotSupportedException">
        /// Thrown when <see cref="Is{TFrom}.Supported"/> is <see langword="false"/>.
        /// </exception>
        /// <returns>
        /// The reinterpretation of the parameter <paramref name="source"/> from its original type
        /// <typeparamref name="TFrom"/> to the destination type <see name="TTo"/> in <see cref="To{TTo}"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static unsafe ReadOnlySpan<TTo> From<TFrom>(ReadOnlySpan<TFrom> source) =>
#if NET9_0_OR_GREATER
            typeof(TTo) == typeof(TFrom) || Is<TFrom>.Supported
                ? Unsafe.As<ReadOnlySpan<TFrom>, ReadOnlySpan<TTo>>(ref AsRef(source))
                : throw Is<TFrom>.Error;
#else
            typeof(TTo) == typeof(TFrom) || Is<TFrom>.Supported
                ? *(ReadOnlySpan<TTo>*)&source
                : throw Is<TFrom>.Error;
#endif
        /// <summary>
        /// Converts a <see cref="Span{T}"/> of type <typeparamref name="TFrom"/>
        /// to a <see cref="Span{T}"/> of type <see name="TTo"/> in <see cref="To{TTo}"/>.
        /// </summary>
        /// <typeparam name="TFrom">The type to convert from.</typeparam>
        /// <param name="source">The <see cref="Span{T}"/> to convert from.</param>
        /// <exception cref="NotSupportedException">
        /// Thrown when <see cref="Is{TFrom}.Supported"/> is <see langword="false"/>.
        /// </exception>
        /// <returns>
        /// The reinterpretation of the parameter <paramref name="source"/> from its original
        /// type <typeparamref name="TFrom"/> to the destination type <see name="TTo"/> in <see cref="To{TTo}"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static unsafe Span<TTo> From<TFrom>(Span<TFrom> source) =>
#if NET9_0_OR_GREATER
            typeof(TTo) == typeof(TFrom) || Is<TFrom>.Supported
                ? Unsafe.As<Span<TFrom>, Span<TTo>>(ref AsRef(source))
                : throw Is<TFrom>.Error;
#else
            typeof(TTo) == typeof(TFrom) || Is<TFrom>.Supported ? *(Span<TTo>*)&source : throw Is<TFrom>.Error;
#endif
    }
    /// <summary>The maximum size for stack allocations in bytes.</summary>
    /// <remarks><para>
    /// Stack allocating arrays is an incredibly powerful tool that gets rid of a lot of the overhead that comes from
    /// instantiating arrays normally. Notably, that all classes (such as <see cref="Array"/> or <see cref="List{T}"/>)
    /// are heap allocated, and moreover are garbage collected. This can put a strain in methods that are called often.
    /// </para><para>
    /// However, there isn't as much stack memory available as there is heap, which can cause a DoS (Denial of Service)
    /// vulnerability if you aren't careful. Use this constant to determine if you should use a heap allocation.
    /// </para></remarks>
    public const int MaxStackalloc = 1 << 11;
    /// <summary>Sets the reference to the address within the null range.</summary>
    /// <remarks><para>
    /// This is a highly unsafe function. The runtime reserves the first 2kiB for null-behaving values, which means a
    /// valid reference will never be within this range. This allows reference types to be a disjoint union of a valid
    /// reference, and an 11-bit number. Be careful with the values returned by this function: <see langword="null"/>
    /// comparisons can <see langword="return"/> <see langword="false"/>, but will behave as such.
    /// </para></remarks>
    /// <typeparam name="T">The type of the nullable reference type.</typeparam>
    /// <param name="reference">
    /// The resulting reference that contains the address of the parameter <paramref name="address"/>.
    /// </param>
    /// <param name="address">The number to set.</param>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void UnsafelySetNullishTo<T>(out T? reference, byte address)
        where T : class
    {
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        fixed (T* ptr = &reference)
            *(nuint*)ptr = address;
#else
        Unsafe.SkipInit(out reference);
        Unsafe.As<T?, nuint>(ref reference) = address;
#endif
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="System.MemoryExtensions.Equals(ReadOnlySpan{char}, ReadOnlySpan{char}, StringComparison)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool EqualsIgnoreCase(this string left, scoped ReadOnlySpan<char> right) =>
        left.AsSpan().Equals(right, StringComparison.OrdinalIgnoreCase);
    /// <inheritdoc cref="System.MemoryExtensions.Equals(ReadOnlySpan{char}, ReadOnlySpan{char}, StringComparison)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool EqualsIgnoreCase(this IMemoryOwner<char> left, scoped ReadOnlySpan<char> right) =>
        left.Memory.Span.ReadOnly().Equals(right, StringComparison.OrdinalIgnoreCase);
    /// <inheritdoc cref="System.MemoryExtensions.Equals(ReadOnlySpan{char}, ReadOnlySpan{char}, StringComparison)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool EqualsIgnoreCase(this Memory<char> left, scoped ReadOnlySpan<char> right) =>
        left.Span.ReadOnly().Equals(right, StringComparison.OrdinalIgnoreCase);
    /// <inheritdoc cref="System.MemoryExtensions.Equals(ReadOnlySpan{char}, ReadOnlySpan{char}, StringComparison)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool EqualsIgnoreCase(this scoped Span<char> left, scoped ReadOnlySpan<char> right) =>
        left.ReadOnly().Equals(right, StringComparison.OrdinalIgnoreCase);
    /// <inheritdoc cref="System.MemoryExtensions.Equals(ReadOnlySpan{char}, ReadOnlySpan{char}, StringComparison)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool EqualsIgnoreCase(this ReadOnlyMemory<char> left, scoped ReadOnlySpan<char> right) =>
        left.Span.Equals(right, StringComparison.OrdinalIgnoreCase);
    /// <inheritdoc cref="System.MemoryExtensions.Equals(ReadOnlySpan{char}, ReadOnlySpan{char}, StringComparison)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool EqualsIgnoreCase(this scoped ReadOnlySpan<char> left, scoped ReadOnlySpan<char> right) =>
        left.Equals(right, StringComparison.OrdinalIgnoreCase);
#if NET6_0_OR_GREATER
    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(
        this Memory<T> span,
        ReadOnlyMemory<T> other,
        IEqualityComparer<T>? comparer = null
    ) =>
        span.Span.SequenceEqual(other.Span, comparer);
    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(
        this ReadOnlyMemory<T> span,
        ReadOnlyMemory<T> other,
        IEqualityComparer<T>? comparer = null
    ) =>
        span.Span.SequenceEqual(other.Span, comparer);
#else
    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(this Memory<T> span, ReadOnlyMemory<T> other)
        where T : IEquatable<T>? =>
        span.Span.SequenceEqual(other.Span);
    /// <inheritdoc cref="System.MemoryExtensions.SequenceEqual{T}(Span{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool SequenceEqual<T>(this ReadOnlyMemory<T> span, ReadOnlyMemory<T> other)
        where T : IEquatable<T>? =>
        span.Span.SequenceEqual(other.Span);
#endif
#endif
    /// <summary>Reads the raw memory of the object.</summary>
    /// <typeparam name="T">The type of value to read.</typeparam>
    /// <param name="value">The value to read.</param>
    /// <returns>The raw memory of the parameter <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static byte[] Raw<T>(T value)
#if !NO_ALLOWS_REF_STRUCT
        where T : allows ref struct
#endif
        =>
            [.. MemoryMarshal.CreateReadOnlySpan(ref Unsafe.As<T, byte>(ref AsRef(value)), Unsafe.SizeOf<T>())];
    /// <summary>Determines if a given length and type should be stack-allocated.</summary>
    /// <remarks><para>
    /// See <see cref="MaxStackalloc"/> for details about stack- and heap-allocation.
    /// </para></remarks>
    /// <typeparam name="T">The type of array.</typeparam>
    /// <param name="length">The amount of items.</param>
    /// <returns>
    /// The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
    /// </returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsStack<T>([NonNegativeValue] int length)
#if !NO_ALLOWS_REF_STRUCT
        where T : allows ref struct
#endif
        =>
            InBytes<T>(length) <= MaxStackalloc;
    /// <summary>Gets the byte length needed to allocate the current length, used in <see cref="IsStack{T}"/>.</summary>
    /// <typeparam name="T">The type of array.</typeparam>
    /// <param name="length">The amount of items.</param>
    /// <returns>
    /// The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
    /// </returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    public static unsafe int InBytes<T>([NonNegativeValue] int length)
#if !NO_ALLOWS_REF_STRUCT
        where T : allows ref struct
#endif
        =>
            length *
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
            Unsafe.SizeOf<T>();
#else
            sizeof(T);
#endif
    /// <summary>Returns the memory address of a given reference object.</summary>
    /// <remarks><para>The value is not pinned; do not read values from this location.</para></remarks>
    /// <param name="_">The reference <see cref="object"/> for which to get the address.</param>
    /// <returns>The memory address of the reference object.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static nuint ToAddress<T>(this T? _)
        where T : class
#if CSHARPREPL
        =>
            Unsafe.As<T, nuint>(ref _);
#else
    {
        IL.Emit.Ldarg_0();
        return IL.Return<nuint>();
    }
#endif
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <summary>Creates a new <see cref="ReadOnlySpan{T}"/> of length 1 around the specified reference.</summary>
    /// <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> In<T>(in T reference) =>
#if NET8_0_OR_GREATER || CSHARPREPL
        new(ref AsRef(reference));
#elif NET7_0_OR_GREATER
        new(AsRef(reference));
#else
        MemoryMarshal.CreateReadOnlySpan(ref AsRef(reference), 1);
#endif
    /// <summary>Creates a new reinterpreted <see cref="ReadOnlySpan{T}"/> over the specified reference.</summary>
    /// <typeparam name="TFrom">The source type.</typeparam>
    /// <typeparam name="TTo">The destination type.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    public static ReadOnlySpan<TTo> In<TFrom, TTo>(in TFrom reference)
        where TFrom : struct
        where TTo : struct =>
        MemoryMarshal.Cast<TFrom, TTo>(In(reference));
#endif
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <summary>Converts the <see cref="Memory{T}"/> to the <see cref="ReadOnlyMemory{T}"/>.</summary>
    /// <typeparam name="T">The type of memory.</typeparam>
    /// <param name="memory">The memory to convert.</param>
    /// <returns>The <see cref="ReadOnlyMemory{T}"/> of the parameter <paramref name="memory"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<T> ReadOnly<T>(this Memory<T> memory) => memory;
#endif
    /// <summary>Converts the <see cref="Span{T}"/> to the <see cref="ReadOnlySpan{T}"/>.</summary>
    /// <typeparam name="T">The type of span.</typeparam>
    /// <param name="span">The span to convert.</param>
    /// <returns>The <see cref="ReadOnlySpan{T}"/> of the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> ReadOnly<T>(this Span<T> span) => span;
    /// <summary>Creates a new <see cref="Span{T}"/> of length 1 around the specified reference.</summary>
    /// <typeparam name="T">The type of <paramref name="reference"/>.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> Ref<T>(ref T reference) =>
#if NET7_0_OR_GREATER
        new(ref reference);
#else
        MemoryMarshal.CreateSpan(ref reference, 1);
#endif
    /// <summary>Creates a new reinterpreted <see cref="Span{T}"/> over the specified reference.</summary>
    /// <typeparam name="TFrom">The source type.</typeparam>
    /// <typeparam name="TTo">The destination type.</typeparam>
    /// <param name="reference">A reference to data.</param>
    /// <returns>The created span over the parameter <paramref name="reference"/>.</returns>
    public static Span<TTo> Ref<TFrom, TTo>(ref TFrom reference)
        where TFrom : struct
        where TTo : struct =>
        MemoryMarshal.Cast<TFrom, TTo>(Ref(ref reference));
#if !CSHARPREPL
    /// <summary>Creates the stack allocation of the type.</summary>
    /// <typeparam name="T">The type of the resulting <see cref="Span{T}"/>.</typeparam>
    /// <param name="length">The length of the stack-allocation. This value is unchecked.</param>
    /// <returns>The resulting <see cref="Span{T}"/> pointing to the created stack allocation.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe Span<T> Stackalloc<T>([NonNegativeValue] in int length)
    {
        System.Diagnostics.Debug.Assert(length >= 0, "length is non-negative");
        if (IsReferenceOrContainsReferences<T>())
            throw new InvalidOperationException($"You cannot stack-allocate {typeof(T).Name} because it is managed.");
        var ptr = stackalloc byte[InBytes<T>(length)];
        return new(ptr, length);
    }
#endif
    /// <summary>Reinterprets the given read-only reference as a mutable reference.</summary>
    /// <typeparam name="T">The underlying type of the reference.</typeparam>
    /// <param name="source">The read-only reference to reinterpret.</param>
    /// <returns>A mutable reference to a value of type <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe ref T AsRef<T>(in T source)
#if !NO_ALLOWS_REF_STRUCT
        where T : allows ref struct
#endif
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
    {
        fixed (T* ptr = &source)
            return ref *ptr;
    }
#else
        =>
            ref Unsafe.AsRef(source);
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
    /// <summary>Separates the head from the tail of a <see cref="Memory{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="memory">The memory to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="memory"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="memory"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deconstruct<T>(this Memory<T> memory, out T? head, out Memory<T> tail)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (memory.IsEmpty)
        {
            head = default;
            tail = default;
            return;
        }
        head = memory.Span.UnsafelyIndex(0);
        tail = memory[1..];
    }
    /// <summary>Separates the head from the tail of a <see cref="Memory{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="memory">The memory to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="memory"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="memory"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deconstruct<T>(this ReadOnlyMemory<T> memory, out T? head, out ReadOnlyMemory<T> tail)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (memory.IsEmpty)
        {
            head = default;
            tail = default;
            return;
        }
        head = memory.Span.UnsafelyIndex(0);
        tail = memory[1..];
    }
#endif
    /// <summary>Separates the head from the tail of a <see cref="Span{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="span"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="span"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deconstruct<T>(this Span<T> span, out T? head, out Span<T> tail)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (span.IsEmpty)
        {
            head = default;
            tail = default;
            return;
        }
        head = span.UnsafelyIndex(0);
        tail = span.UnsafelySkip(1);
    }
    /// <summary>Separates the head from the tail of a <see cref="ReadOnlySpan{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="span"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="span"/>.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Deconstruct<T>(this ReadOnlySpan<T> span, out T? head, out ReadOnlySpan<T> tail)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (span.IsEmpty)
        {
            head = default;
            tail = default;
            return;
        }
        head = span.UnsafelyIndex(0);
        tail = span.UnsafelySkip(1);
    }
#if NET461_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER || NO_SYSTEM_MEMORY
    /// <summary>
    /// Gets the index of an element of a given <see cref="Memory{T}"/> from its <see cref="Span{T}"/>.
    /// </summary>
    /// <typeparam name="T">The type if items in the input <see cref="Memory{T}"/>.</typeparam>
    /// <param name="memory">The input <see cref="Memory{T}"/> to calculate the index for.</param>
    /// <param name="span">The reference to the target item to get the index for.</param>
    /// <returns>The index of <paramref name="memory"/> within <paramref name="span"/>, or <c>-1</c>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int IndexOf<T>(ReadOnlyMemory<T> memory, scoped ReadOnlySpan<T> span) =>
        memory.Span.IndexOf(ref MemoryMarshal.GetReference(span));
    /// <summary>Gets the index of an element of a given <see cref="Span{T}"/> from its reference.</summary>
    /// <typeparam name="T">The type if items in the input <see cref="Span{T}"/>.</typeparam>
    /// <param name="span">The input <see cref="Span{T}"/> to calculate the index for.</param>
    /// <param name="value">The reference to the target item to get the index for.</param>
    /// <returns>The index of <paramref name="value"/> within <paramref name="span"/>, or <c>-1</c>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe int IndexOf<T>(this scoped ReadOnlySpan<T> span, scoped ref T value)
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        =>
            Unsafe.ByteOffset(ref MemoryMarshal.GetReference(span), ref value) is var byteOffset &&
            byteOffset / (nint)(uint)sizeof(T) is var elementOffset &&
            (nuint)elementOffset < (uint)span.Length
                ? (int)elementOffset
                : -1;
#else
    {
        fixed (T* ptr = &value)
            return (nint)((T*)span.Pointer - ptr) is var elementOffset && (nuint)elementOffset < (uint)span.Length
                ? (int)elementOffset
                : -1;
    }
#endif
    /// <inheritdoc cref="IndexOf{T}(ReadOnlySpan{T}, ref T)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int IndexOf<T>(this scoped Span<T> origin, scoped ref T target) =>
        origin.ReadOnly().IndexOf(ref target);
#endif
#if !NET7_0_OR_GREATER
    /// <inheritdoc cref="IndexOfAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int IndexOfAny<T>(this scoped Span<T> span, scoped ReadOnlySpan<T> values)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>?
#else
        where T : IEquatable<T>?
#endif
        =>
            span.ReadOnly().IndexOfAny(values);
    /// <summary>
    /// Searches for the first index of any of the specified values similar
    /// to calling IndexOf several times with the logical OR operator.
    /// </summary>
    /// <typeparam name="T">The type of the span and values.</typeparam>
    /// <param name="span">The span to search.</param>
    /// <param name="values">The set of values to search for.</param>
    /// <returns>The first index of the occurrence of any of the values in the span. If not found, returns -1.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe int IndexOfAny<T>(this scoped ReadOnlySpan<T> span, scoped ReadOnlySpan<T> values)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>?
#else
        where T : IEquatable<T>?
#endif
    {
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var searchSpace = (T*)span.Pointer;
        var value = (T*)values.Pointer;
#else
        fixed (T* searchSpace = span)
        fixed (T* value = values)
#endif
            return SpanHelpers.IndexOfAny(searchSpace, span.Length, value, values.Length);
    }
#endif
    /// <inheritdoc cref="IndexOf{T}(ReadOnlySpan{T}, ref T)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe int OffsetOf<T>(this scoped ReadOnlySpan<T> origin, scoped ReadOnlySpan<T> target) =>
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        origin.IndexOf(ref MemoryMarshal.GetReference(target));
#else
        origin.IndexOf(ref *(T*)target.Pointer);
#endif
    /// <inheritdoc cref="IndexOf{T}(ReadOnlySpan{T}, ref T)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int OffsetOf<T>(this scoped Span<T> origin, scoped ReadOnlySpan<T> target) =>
        origin.ReadOnly().OffsetOf(target);
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <summary>Converts the provided <see cref="Span{T}"/> to the <see cref="Memory{T}"/>.</summary>
    /// <typeparam name="T">The type if items in the input <see cref="Span{T}"/>.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to convert.</param>
    /// <param name="memory">The bounds.</param>
    /// <returns>The parameter <paramref name="span"/> as <see cref="ReadOnlyMemory{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<T> AsMemory<T>(this scoped ReadOnlySpan<T> span, ReadOnlyMemory<T> memory) =>
        memory.Span.IndexOf(ref MemoryMarshal.GetReference(span)) is var i and not -1
            ? memory.Slice(i, span.Length)
            : default;
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
    /// <summary>Gets the specific slice from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="owner">The <see cref="IMemoryOwner{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="owner"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<T> Nth<T>(this IMemoryOwner<T> owner, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            owner.Memory.Nth(range);
    /// <summary>Gets the specific slice from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="span">The <see cref="ReadOnlyMemory{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<T> Nth<T>(this ReadOnlyMemory<T> span, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            range.TryGetOffsetAndLength(span.Length, out var off, out var len) ? span.Slice(off, len) : default;
    /// <summary>Gets the specific slice from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="span">The <see cref="Memory{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Memory<T> Nth<T>(this Memory<T> span, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            range.TryGetOffsetAndLength(span.Length, out var off, out var len) ? span.Slice(off, len) : default;
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="owner">The <see cref="IMemoryOwner{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="owner"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this IMemoryOwner<T> owner, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            owner.Memory.Nth(index);
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="memory">The <see cref="ReadOnlyMemory{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="memory"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this ReadOnlyMemory<T> memory, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)index < (uint)memory.Length ? memory.Span[index] : default;
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="owner">The <see cref="IMemoryOwner{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="owner"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this IMemoryOwner<T> owner, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            owner.Memory.Nth(index);
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="memory">The <see cref="ReadOnlyMemory{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="memory"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this ReadOnlyMemory<T> memory, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index.GetOffset(memory.Length) is var o && (uint)o < (uint)memory.Length
                ? memory.Span.UnsafelyIndex(o)
                : default;
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="owner">The <see cref="IMemoryOwner{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="owner"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this IMemoryOwner<T> owner, int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            owner.Memory.NthLast(index);
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="memory">The <see cref="ReadOnlyMemory{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="memory"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this ReadOnlyMemory<T> memory, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)(index - 1) < (uint)memory.Length ? memory.Span[memory.Length - index] : default;
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="memory">The <see cref="Memory{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="memory"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this Memory<T> memory, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)index < (uint)memory.Length ? memory.Span.UnsafelyIndex(index) : default;
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="memory">The <see cref="Memory{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="memory"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this Memory<T> memory, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index.GetOffset(memory.Length) is var off && (uint)off < (uint)memory.Length
                ? memory.Span.UnsafelyIndex(off)
                : default;
    /// <summary>Gets a specific item from the memory.</summary>
    /// <typeparam name="T">The type of item in the memory.</typeparam>
    /// <param name="memory">The <see cref="Memory{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="memory"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this Memory<T> memory, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)(index - 1) < (uint)memory.Length ? memory.Span.UnsafelyIndex(memory.Length - index) : default;
#endif
    /// <summary>Gets the specific slice from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="ReadOnlySpan{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> Nth<T>(this ReadOnlySpan<T> span, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            range.TryGetOffsetAndLength(span.Length, out var off, out var len) ? span.UnsafelySlice(off, len) : default;
    /// <summary>Gets the specific slice from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>A slice from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> Nth<T>(this Span<T> span, Range range)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            range.TryGetOffsetAndLength(span.Length, out var off, out var len) ? span.UnsafelySlice(off, len) : default;
    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="ReadOnlySpan{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped ReadOnlySpan<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)index < (uint)span.Length ? span.UnsafelyIndex(index) : default;
    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="ReadOnlySpan{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped ReadOnlySpan<T> span, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index.GetOffset(span.Length) is var o && (uint)o < (uint)span.Length ? span.UnsafelyIndex(o) : default;
    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="ReadOnlySpan{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this scoped ReadOnlySpan<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)(index - 1) < (uint)span.Length ? span.UnsafelyIndex(span.Length - index) : default;
    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped Span<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)index < (uint)span.Length ? span.UnsafelyIndex(index) : default;
    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Nth<T>(this scoped Span<T> span, Index index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            index.GetOffset(span.Length) is var o && (uint)o < (uint)span.Length ? span.UnsafelyIndex(o) : default;
    /// <summary>Gets a specific item from the span.</summary>
    /// <typeparam name="T">The type of item in the span.</typeparam>
    /// <param name="span">The <see cref="Span{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="span"/>, or <see langword="default"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? NthLast<T>(this scoped Span<T> span, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            (uint)(index - 1) < (uint)span.Length ? span.UnsafelyIndex(span.Length - index) : default;
    /// <inheritdoc cref="Span{T}.this"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T UnsafelyIndex<T>(this scoped ReadOnlySpan<T> body, [NonNegativeValue] int index)
    {
        System.Diagnostics.Debug.Assert((uint)index < (uint)body.Length, "index is in range");
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        return Unsafe.Add(ref MemoryMarshal.GetReference(body), index);
#else
        return body[index];
#endif
    }
    /// <inheritdoc cref="Enumerable.Skip{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> UnsafelySkip<T>(this ReadOnlySpan<T> body, [NonNegativeValue] int start)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)start <= (uint)body.Length, "start is in range");
        return UnsafelySlice(body, start, body.Length - start);
    }
    /// <inheritdoc cref="Span{T}.Slice(int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> UnsafelySlice<T>(
        this ReadOnlySpan<T> body,
        [NonNegativeValue] int start,
        [NonNegativeValue] int length
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)(start + length) <= (uint)body.Length, "start and length is in range");
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        return MemoryMarshal.CreateReadOnlySpan(ref Unsafe.Add(ref MemoryMarshal.GetReference(body), start), length);
#else
        return body.Slice(start, length);
#endif
    }
    /// <inheritdoc cref="Enumerable.Take{T}(IEnumerable{T}, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> UnsafelyTake<T>(this ReadOnlySpan<T> body, [NonNegativeValue] int end)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)end <= (uint)body.Length, "end is in range");
        return UnsafelySlice(body, 0, end);
    }
    /// <inheritdoc cref="Span{T}.this"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T UnsafelyIndex<T>(this scoped Span<T> body, [NonNegativeValue] int index)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)index < (uint)body.Length, "index is in range");
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        return Unsafe.Add(ref MemoryMarshal.GetReference(body), index);
#else
        return body[index];
#endif
    }
    /// <inheritdoc cref="Enumerable.Skip{T}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> UnsafelySkip<T>(this Span<T> body, [NonNegativeValue] int start)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)start <= (uint)body.Length, "start is in range");
        return UnsafelySlice(body, start, body.Length - start);
    }
    /// <inheritdoc cref="Span{T}.Slice(int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> UnsafelySlice<T>(
        this Span<T> body,
        [NonNegativeValue] int start,
        [NonNegativeValue] int length
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)(start + length) <= (uint)body.Length, "start and length is in range");
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        return MemoryMarshal.CreateSpan(ref Unsafe.Add(ref MemoryMarshal.GetReference(body), start), length);
#else
        return body.Slice(start, length);
#endif
    }
    /// <inheritdoc cref="Enumerable.Take{T}(IEnumerable{T}, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> UnsafelyTake<T>(this Span<T> body, [NonNegativeValue] int end)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        System.Diagnostics.Debug.Assert((uint)end <= (uint)body.Length, "end is in range");
        return UnsafelySlice(body, 0, end);
    }
// SPDX-License-Identifier: MPL-2.0
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
// ReSharper disable once CheckNamespace
// ReSharper disable once RedundantUsingDirective
/// <inheritdoc cref="SpanSimdQueries"/>
// ReSharper disable NullableWarningSuppressionIsUsed RedundantNameQualifier RedundantSuppressNullableWarningExpression UseSymbolAlias
    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this scoped Span<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.ReadOnly().Average();
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this ReadOnlyMemory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.Span.Average();
#endif
    /// <summary>Gets the average.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <param name="span">The span to get the average of.</param>
    /// <returns>The average of <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this scoped ReadOnlySpan<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            Divider(span.Sum(), span.Length);
    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this scoped Span<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.ReadOnly().Sum();
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this ReadOnlyMemory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.Span.Sum();
#endif
    /// <summary>Gets the sum.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <param name="span">The span to get the sum of.</param>
    /// <returns>The sum of <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this scoped ReadOnlySpan<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
    {
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP_3_0_OR_GREATER || NET5_0_OR_GREATER
        if (IsNumericPrimitive<T>() &&
#if NET7_0_OR_GREATER
            System.Numerics.Vector<T>.IsSupported &&
#endif
            System.Numerics.Vector.IsHardwareAccelerated &&
            System.Numerics.Vector<T>.Count > 2 &&
            span.Length >= System.Numerics.Vector<T>.Count * 4)
            return SumVectorized(span);
#endif
        if (typeof(T).IsEnum)
            return UnderlyingSum(span);
        T sum = default!;
        foreach (var value in span)
            checked
            {
                sum = Adder(sum, value);
            }
        return sum;
    }
    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this scoped Span<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Average(span.ReadOnly(), converter);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this ReadOnlyMemory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Average(span.Span, converter);
#endif
    /// <summary>Gets the average.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <typeparam name="TResult">The type of return.</typeparam>
    /// <param name="span">The span to get the average of.</param>
    /// <param name="converter">The mapping of each element.</param>
    /// <returns>The average of each mapping of <paramref name="span"/> by <paramref name="converter"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this scoped ReadOnlySpan<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            Divider(span.Sum(converter), span.Length);
    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this scoped Span<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            span.ReadOnly().Sum(converter);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this ReadOnlyMemory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            span.Span.Sum(converter);
#endif
    /// <summary>Gets the sum.</summary>
    /// <typeparam name="T">The type of <see cref="Span{T}"/>.</typeparam>
    /// <typeparam name="TResult">The type of return.</typeparam>
    /// <param name="span">The span to get the sum of.</param>
    /// <param name="converter">The mapping of each element.</param>
    /// <returns>The sum of each mapping of <paramref name="span"/> by <paramref name="converter"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this scoped ReadOnlySpan<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
    {
        TResult sum = default!;
        foreach (var x in span)
            sum = Adder(sum, converter(x));
        return sum;
    }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this IMemoryOwner<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.Memory.Span.ReadOnly().Average();
    /// <inheritdoc cref="Average{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Average<T>(this Memory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.Span.ReadOnly().Average();
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this IMemoryOwner<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.Memory.Span.ReadOnly().Sum();
    /// <inheritdoc cref="Sum{T}(ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Sum<T>(this Memory<T> span)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            span.Span.ReadOnly().Sum();
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this IMemoryOwner<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            span.Memory.Span.ReadOnly().Average(converter);
    /// <inheritdoc cref="Average{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Average<T, TResult>(
        this Memory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            span.Span.ReadOnly().Average(converter);
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this IMemoryOwner<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            span.Memory.Span.Sum(converter);
    /// <inheritdoc cref="Sum{T, TResult}(ReadOnlySpan{T}, Converter{T, TResult})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TResult Sum<T, TResult>(
        this Memory<T> span,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
#if !NET8_0_OR_GREATER
        where TResult : struct
#endif
        =>
            span.Span.ReadOnly().Sum(converter);
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP_3_0_OR_GREATER || NET5_0_OR_GREATER
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining)]
    static System.Numerics.Vector<T> LoadUnsafe<T>(scoped ref T source, nuint elementOffset)
#if NET8_0_OR_GREATER
        =>
            System.Numerics.Vector.LoadUnsafe(ref source, elementOffset);
#else
        where T : struct
    {
        source = ref Unsafe.Add(ref source, (nint)elementOffset);
        return Unsafe.ReadUnaligned<Vector<T>>(ref Unsafe.As<T, byte>(ref source));
    }
#endif
#endif
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP_3_0_OR_GREATER || NET5_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable MA0051
    static T SumVectorized<T>(scoped ReadOnlySpan<T> span)
#pragma warning restore MA0051
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
    {
        ref var ptr = ref MemoryMarshal.GetReference(span);
        var length = (nuint)span.Length;
        var accumulator = System.Numerics.Vector<T>.Zero;
        System.Numerics.Vector<T> overflowTestVector = new(MinValue<T>());
        nuint index = 0;
        var limit = length - (nuint)System.Numerics.Vector<T>.Count * 4;
        do
        {
            var data = LoadUnsafe(ref ptr, index);
            var accumulator2 = accumulator + data;
            var overflowTracking = (accumulator2 ^ accumulator) & (accumulator2 ^ data);
            data = LoadUnsafe(ref ptr, index + (nuint)System.Numerics.Vector<T>.Count);
            accumulator = accumulator2 + data;
            overflowTracking |= (accumulator ^ accumulator2) & (accumulator ^ data);
            data = LoadUnsafe(ref ptr, index + (nuint)System.Numerics.Vector<T>.Count * 2);
            accumulator2 = accumulator + data;
            overflowTracking |= (accumulator2 ^ accumulator) & (accumulator2 ^ data);
            data = LoadUnsafe(ref ptr, index + (nuint)System.Numerics.Vector<T>.Count * 3);
            accumulator = accumulator2 + data;
            overflowTracking |= (accumulator ^ accumulator2) & (accumulator ^ data);
            if ((overflowTracking & overflowTestVector) != System.Numerics.Vector<T>.Zero)
                throw new OverflowException();
            index += (nuint)System.Numerics.Vector<T>.Count * 4;
        } while (index < limit);
        limit = length - (nuint)System.Numerics.Vector<T>.Count;
        if (index < limit)
        {
            var overflowTracking = System.Numerics.Vector<T>.Zero;
            do
            {
                var data = LoadUnsafe(ref ptr, index);
                var accumulator2 = accumulator + data;
                overflowTracking |= (accumulator2 ^ accumulator) & (accumulator2 ^ data);
                accumulator = accumulator2;
                index += (nuint)System.Numerics.Vector<T>.Count;
            } while (index < limit);
            if ((overflowTracking & overflowTestVector) != System.Numerics.Vector<T>.Zero)
                throw new OverflowException();
        }
        T result = default!;
        for (var i = 0; i < System.Numerics.Vector<T>.Count; i++)
            checked
            {
                result = Adder(result, accumulator[i]);
            }
        while (index < length)
        {
            checked
            {
                result = Adder(result, Unsafe.Add(ref ptr, index));
            }
            index++;
        }
        return result;
    }
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T UnderlyingSum<T>(scoped ReadOnlySpan<T> span) =>
        typeof(T).GetEnumUnderlyingType() switch
        {
            var x when x == typeof(sbyte) => (T)(object)To<sbyte>.From(span).Sum(),
            var x when x == typeof(byte) => (T)(object)To<byte>.From(span).Sum(),
            var x when x == typeof(short) => (T)(object)To<short>.From(span).Sum(),
            var x when x == typeof(ushort) => (T)(object)To<ushort>.From(span).Sum(),
            var x when x == typeof(int) => (T)(object)To<int>.From(span).Sum(),
            var x when x == typeof(uint) => (T)(object)To<uint>.From(span).Sum(),
            var x when x == typeof(long) => (T)(object)To<long>.From(span).Sum(),
            var x when x == typeof(ulong) => (T)(object)To<ulong>.From(span).Sum(),
            var x when x == typeof(nint) => (T)(object)To<nint>.From(span).Sum(),
            var x when x == typeof(nuint) => (T)(object)To<nuint>.From(span).Sum(),
            _ => throw Unreachable,
        };
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="SpanSimdQueries"/>
// ReSharper disable NullableWarningSuppressionIsUsed RedundantNameQualifier RedundantSuppressNullableWarningExpression
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this IMemoryOwner<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable.Memory.Span);
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this Memory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable.Span);
#endif
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this scoped Span<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this ReadOnlyMemory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable.Span);
#endif
    /// <inheritdoc cref="Enumerable.Max{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T>(this scoped ReadOnlySpan<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMax>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this IMemoryOwner<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable.Memory.Span);
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this Memory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable.Span);
#endif
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this scoped Span<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this ReadOnlyMemory<T> enumerable)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable.Span);
#endif
    /// <inheritdoc cref="Enumerable.Min{T}(IEnumerable{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T>(this scoped ReadOnlySpan<T> enumerable)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, SMin>(enumerable);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this IMemoryOwner<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable.Memory.Span, keySelector);
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this Memory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable.Span, keySelector);
#endif
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this scoped Span<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable, keySelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this ReadOnlyMemory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable.Span, keySelector);
#endif
    /// <inheritdoc cref="Enumerable.MaxBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Max<T, TResult>(
        this scoped ReadOnlySpan<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMax>(enumerable, keySelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this IMemoryOwner<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable.Memory.Span, keySelector);
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this Memory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable.Span, keySelector);
#endif
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this scoped Span<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable, keySelector);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this ReadOnlyMemory<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable.Span, keySelector);
#endif
    /// <inheritdoc cref="Enumerable.MinBy{TSource, TKey}(IEnumerable{TSource}, Func{TSource, TKey})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Min<T, TResult>(
        this scoped ReadOnlySpan<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> keySelector
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
            MinMax<T, TResult, SMin>(enumerable, keySelector);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool Compare<T, TS>(T l, T r) =>
        0 switch
        {
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(byte) => (byte)(object)l! > (byte)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(byte) => (byte)(object)l! < (byte)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(double) => (double)(object)l! > (double)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(double) => (double)(object)l! < (double)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(float) => (float)(object)l! > (float)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(float) => (float)(object)l! < (float)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(int) => (int)(object)l! > (int)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(int) => (int)(object)l! < (int)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(nint) => (nint)(object)l! > (nint)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(nint) => (nint)(object)l! < (nint)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(nuint) => (nuint)(object)l! > (nuint)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(nuint) => (nuint)(object)l! < (nuint)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(sbyte) => (sbyte)(object)l! > (sbyte)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(sbyte) => (sbyte)(object)l! < (sbyte)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(short) => (short)(object)l! > (short)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(short) => (short)(object)l! < (short)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(uint) => (uint)(object)l! > (uint)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(uint) => (uint)(object)l! < (uint)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(ulong) => (ulong)(object)l! > (ulong)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(ulong) => (ulong)(object)l! < (ulong)(object)r!,
            _ when typeof(TS) == typeof(SMax) && typeof(T) == typeof(ushort) => (ushort)(object)l! > (ushort)(object)r!,
            _ when typeof(TS) == typeof(SMin) && typeof(T) == typeof(ushort) => (ushort)(object)l! < (ushort)(object)r!,
            _ when typeof(TS) == typeof(SMax) => Comparer<T>.Default.Compare(l, r) > 0,
            _ when typeof(TS) == typeof(SMin) => Comparer<T>.Default.Compare(l, r) < 0,
            _ => throw Unreachable,
        };
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static System.Numerics.Vector<T> LoadUnsafe<T>(scoped in T source)
#if !NET8_0_OR_GREATER
        where T : struct
#endif
        =>
#if CSHARPREPL
            System.Numerics.Vector.LoadUnsafe(ref AsRef(source));
#elif NET8_0_OR_GREATER
            System.Numerics.Vector.LoadUnsafe(source);
#else
            Unsafe.ReadUnaligned<System.Numerics.Vector<T>>(ref Unsafe.As<T, byte>(ref Unsafe.AsRef(source)));
#endif
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T MinMax<T, TS>(this scoped ReadOnlySpan<T> span)
#if UNMANAGED_SPAN
        where T : unmanaged
#elif !NET8_0_OR_GREATER
        where T : struct
#endif
    {
        T value;
        if (span.IsEmpty)
            return default!;
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
        if (!IsNumericPrimitive<T>() ||
#if NET7_0_OR_GREATER
            !System.Numerics.Vector<T>.IsSupported ||
#endif
            !System.Numerics.Vector.IsHardwareAccelerated ||
            span.Length < System.Numerics.Vector<T>.Count
        )
#endif
        {
            value = span.UnsafelyIndex(0);
            for (var i = 1; i < span.Length; i++)
                if (span.UnsafelyIndex(i) is var next && Compare<T, TS>(next, value))
                    value = next;
            return value;
        }
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
        ref var current = ref MemoryMarshal.GetReference(span);
        ref var lastVectorStart = ref Unsafe.Add(ref current, span.Length - System.Numerics.Vector<T>.Count);
        var best = LoadUnsafe(current);
        current = ref Unsafe.Add(ref current, System.Numerics.Vector<T>.Count)!;
        for (;
            Unsafe.IsAddressLessThan(ref current, ref lastVectorStart);
            current = ref Unsafe.Add(ref current, System.Numerics.Vector<T>.Count)!)
            best = 0 switch
            {
                _ when typeof(TS) == typeof(SMax) => System.Numerics.Vector.Max(best, LoadUnsafe(current)),
                _ when typeof(TS) == typeof(SMin) => System.Numerics.Vector.Min(best, LoadUnsafe(current)),
                _ => throw Unreachable,
            };
        best = 0 switch
        {
            _ when typeof(TS) == typeof(SMax) => System.Numerics.Vector.Max(best, LoadUnsafe(lastVectorStart)),
            _ when typeof(TS) == typeof(SMin) => System.Numerics.Vector.Min(best, LoadUnsafe(lastVectorStart)),
            _ => throw Unreachable,
        };
        value = best[0];
        for (var i = 1; i < System.Numerics.Vector<T>.Count; i++)
            if (0 switch
            {
                _ when typeof(TS) == typeof(SMax) => Compare<T, TS>(best[i], value),
                _ when typeof(TS) == typeof(SMin) => Compare<T, TS>(best[i], value),
                _ => throw Unreachable,
            })
                value = best[i];
        return value;
#endif
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    static T MinMax<T, TResult, TS>(
        this scoped ReadOnlySpan<T> enumerable,
        [InstantHandle, RequireStaticDelegate] Converter<T, TResult> converter
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        if (enumerable.IsEmpty)
            return default!;
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var bestValue = enumerable[0];
        var bestKey = converter(bestValue);
        for (var i = 1; i < enumerable.Length; i++)
            if (converter(enumerable[i]) is var next &&
                0 switch
                {
                    _ when typeof(TS) == typeof(SMax) => Compare<TResult, TS>(next, bestKey),
                    _ when typeof(TS) == typeof(SMin) => Compare<TResult, TS>(next, bestKey),
                    _ => throw Unreachable,
                })
            {
                bestKey = next;
                bestValue = enumerable[i];
            }
#else
        ref var bestValue = ref MemoryMarshal.GetReference(enumerable);
        ref var current = ref Unsafe.Add(ref bestValue, 1);
        ref var last = ref Unsafe.Add(ref bestValue, enumerable.Length);
        var bestKey = converter(bestValue);
        for (; Unsafe.IsAddressLessThan(ref current, ref last); current = ref Unsafe.Add(ref current, 1)!)
            if (converter(current) is var next &&
                0 switch
                {
                    _ when typeof(TS) == typeof(SMax) => Compare<TResult, TS>(next, bestKey),
                    _ when typeof(TS) == typeof(SMin) => Compare<TResult, TS>(next, bestKey),
                    _ => throw Unreachable,
                })
            {
                bestKey = next;
                bestValue = ref current;
            }
#endif
        return bestValue;
    }
    struct SMin;
    struct SMax;
// SPDX-License-Identifier: MPL-2.0
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
// ReSharper disable once CheckNamespace RedundantUsingDirective
/// <summary>Contains extension methods for fast SIMD operations.</summary>
// ReSharper disable NullableWarningSuppressionIsUsed RedundantSuppressNullableWarningExpression
    /// <summary>Determines whether the type is a numeric primitive.</summary>
    /// <typeparam name="T">The type to test.</typeparam>
    /// <returns>Whether the type parameter <typeparamref name="T"/> is a primitive representing a number.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsNumericPrimitive<T>()
#if !NO_ALLOWS_REF_STRUCT
        where T : allows ref struct
#endif
        =>
        typeof(T) == typeof(byte) ||
        typeof(T) == typeof(double) ||
        typeof(T) == typeof(float) ||
        typeof(T) == typeof(int) ||
        typeof(T) == typeof(long) ||
        typeof(T) == typeof(nint) ||
        typeof(T) == typeof(nuint) ||
        typeof(T) == typeof(sbyte) ||
        typeof(T) == typeof(short) ||
        typeof(T) == typeof(uint) ||
        typeof(T) == typeof(ulong) ||
        typeof(T) == typeof(ushort);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <inheritdoc cref="Range{T}(Span{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this IMemoryOwner<T> source) => Range(source.Memory.Span);
    /// <inheritdoc cref="Range{T}(Span{T}, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this IMemoryOwner<T> source, int index) => Range(source.Memory.Span, index);
    /// <inheritdoc cref="Range{T}(Span{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this Memory<T> source) => Range(source.Span);
    /// <inheritdoc cref="Range{T}(Span{T}, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this Memory<T> source, int index) => Range(source.Span, index);
#endif
    /// <summary>Creates the range.</summary>
    /// <typeparam name="T">The type of number.</typeparam>
    /// <param name="source">The <see cref="Span{T}"/> to mutate.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this Span<T> source)
    {
        switch (source.Length)
        {
            case 0: return source;
            case 1:
                MemoryMarshal.GetReference(source) = default!;
                return source;
            case var length:
                if (!IsNumericPrimitive<T>() && !IsSupported<T>())
                    _ = Fail<T>();
                SpanRange<T>(length).CopyTo(source);
                return source;
        }
    }
    /// <summary>Creates the range.</summary>
    /// <typeparam name="T">The type of number.</typeparam>
    /// <param name="source">The <see cref="Span{T}"/> to mutate.</param>
    /// <param name="index">The starting index.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Range<T>(this Span<T> source, int index)
    {
        if (source.Length is 0)
            return source;
        if (!IsNumericPrimitive<T>() && !IsSupported<T>())
            _ = Fail<T>();
        SpanRange<T>(index + source.Length).UnsafelySkip(index).CopyTo(source);
        return source;
    }
    /// <inheritdoc cref="InAscendingOrder{T}.Memory"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<byte> AsMemory(this byte length) => MemoryRange<byte>(length + 1)[length..];
    /// <inheritdoc cref="InAscendingOrder{T}.Memory"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<char> AsMemory(this char length) => MemoryRange<char>(length + 1)[length..];
    /// <inheritdoc cref="InAscendingOrder{T}.Memory"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<sbyte> AsMemory(this sbyte length) => MemoryRange<sbyte>(length + 1)[length..];
    /// <inheritdoc cref="InAscendingOrder{T}.Memory"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<short> AsMemory(this short length) => MemoryRange<short>(length + 1)[length..];
    /// <inheritdoc cref="InAscendingOrder{T}.Memory"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<ushort> AsMemory(this ushort length) => MemoryRange<ushort>(length + 1)[length..];
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<byte> AsSpan(this byte length) => SpanRange<byte>(length + 1).UnsafelySkip(length);
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<char> AsSpan(this char length) => SpanRange<char>(length + 1).UnsafelySkip(length);
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<sbyte> AsSpan(this sbyte length) => SpanRange<sbyte>(length + 1).UnsafelySkip(length);
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<short> AsSpan(this short length) => SpanRange<short>(length + 1).UnsafelySkip(length);
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<ushort> AsSpan(this ushort length) => SpanRange<ushort>(length + 1).UnsafelySkip(length);
#if NET5_0_OR_GREATER
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<Half> AsSpan(this Half length)
    {
        var i = (int)length;
        return SpanRange<Half>(i).UnsafelySkip(i);
    }
#endif
    /// <inheritdoc cref="InAscendingOrder{T}.Memory"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlyMemory<T> MemoryRange<T>(this int length) => InAscendingOrder<T>.Memory(length);
    /// <inheritdoc cref="InAscendingOrder{T}.Span"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ReadOnlySpan<T> SpanRange<T>(this int length) => InAscendingOrder<T>.Span(length);
    static class InAscendingOrder<T>
    {
        const int InitialCapacity = 512;
        static T[] s_values = [];
        /// <summary>Gets the read-only span containing the set of values up to the specified parameter.</summary>
        /// <param name="length">The amount of items required.</param>
        /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
        /// <returns>
        /// The <see cref="ReadOnlySpan{T}"/> containing a range from 0 to <paramref name="length"/> - 1.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<T> Span(int length)
        {
            if (typeof(T) == typeof(char))
                return To<T>.From(length.SpanRange<ushort>());
            ReadOnlySpan<T> original = s_values;
            if (length <= original.Length)
                return original.UnsafelyTake(length);
            var replacement = new T[Math.Max(length.RoundUpToPowerOf2(), InitialCapacity / Unsafe.SizeOf<T>())];
            Span<T> span = replacement;
            original.CopyTo(span);
            Populate(span.UnsafelySkip(original.Length - (!original.IsEmpty).ToByte()));
            s_values = replacement;
            return span.UnsafelyTake(length);
        }
        /// <summary>Gets the read-only span containing the set of values up to the specified parameter.</summary>
        /// <param name="length">The amount of items required.</param>
        /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
        /// <returns>
        /// The <see cref="ReadOnlySpan{T}"/> containing a range from 0 to <paramref name="length"/> - 1.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ReadOnlyMemory<T> Memory(int length)
        {
            if (typeof(T) == typeof(char))
                return Unsafe.As<ReadOnlyMemory<ushort>, ReadOnlyMemory<T>>(ref AsRef(length.MemoryRange<ushort>()));
            _ = Span(length);
            return new(s_values, 0, length);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void Populate(scoped Span<T> span)
        {
            ref var start = ref Unsafe.Add(ref MemoryMarshal.GetReference(span), 1);
            ref var end = ref Unsafe.Add(ref start, span.Length);
            for (; Unsafe.IsAddressLessThan(ref start, ref end); start = ref Unsafe.Add(ref start, 1)!)
            {
                start = Unsafe.Subtract(ref start, 1);
                Increment(ref start);
            }
        }
    }
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator InvertIf RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias
#if ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
#pragma warning disable IDE0032
/// <summary>Methods to split spans into multiple spans.</summary>
    /// <summary>
    /// Defines the values for <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/> without a compile-time strategy.
    /// </summary>
    /// <typeparam name="TBody">The type of element from the span.</typeparam>
    /// <typeparam name="TSeparator">The type of separator.</typeparam>
    public interface ISplitMemory<TBody, TSeparator> : IEnumerable<ReadOnlyMemory<TBody>>
    {
        /// <summary>Gets the body.</summary>
        public ReadOnlyMemory<TBody> Body { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
        /// <summary>Gets the separator.</summary>
        public ReadOnlyMemory<TSeparator> Separator { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
    }
    /// <inheritdoc cref="SplitSpanFactory.SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAny> SplitOnAny<T>(this ReadOnlyMemory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        new(span, separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAny> SplitOnAny<T>(this Memory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        span.ReadOnly().SplitOnAny(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAll> SplitOn<T>(this ReadOnlyMemory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        new(span, separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchAll> SplitOn<T>(this Memory<T> span, ReadOnlyMemory<T> separator)
        where T : IEquatable<T> =>
        span.ReadOnly().SplitOn(separator);
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this ReadOnlyMemory<T> span,
        OnceMemoryManager<SearchValues<T>> separator
    )
        where T : IEquatable<T> =>
        new(span, separator.Memory);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this Memory<T> span,
        OnceMemoryManager<SearchValues<T>> separator
    )
        where T : IEquatable<T> =>
        span.ReadOnly().SplitOn(separator);
#endif
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchOne> SplitOn<T>(this ReadOnlyMemory<T> span, OnceMemoryManager<T> separator)
        where T : IEquatable<T> =>
        new(span, separator.Memory);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<T, T, MatchOne> SplitOn<T>(this Memory<T> span, OnceMemoryManager<T> separator)
        where T : IEquatable<T> =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<byte, byte, MatchOne> SplitOn(this Memory<byte> span, byte separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<byte, byte, MatchOne> SplitOn(this ReadOnlyMemory<byte> span, byte separator) =>
        new(span, separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchOne> SplitOn(this Memory<char> span, char separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchOne> SplitOn(this ReadOnlyMemory<char> span, char separator) =>
        new(span, separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<sbyte, sbyte, MatchOne> SplitOn(this Memory<sbyte> span, sbyte separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<sbyte, sbyte, MatchOne> SplitOn(this ReadOnlyMemory<sbyte> span, sbyte separator) =>
        new(span, separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<short, short, MatchOne> SplitOn(this Memory<short> span, short separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<short, short, MatchOne> SplitOn(this ReadOnlyMemory<short> span, short separator) =>
        new(span, separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<ushort, ushort, MatchOne> SplitOn(this Memory<ushort> span, ushort separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<ushort, ushort, MatchOne> SplitOn(this ReadOnlyMemory<ushort> span, ushort separator) =>
        new(span, separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchOne> SplitOn(this string span, char separator) =>
        new(span.AsMemory(), separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAny> SplitOnAny(this string span, string separator) =>
        span.AsMemory().SplitOnAny(separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAny> SplitOnAny(this string span, ReadOnlyMemory<char> separator) =>
        span.AsMemory().SplitOnAny(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAny> SplitOnAny(this ReadOnlyMemory<char> span, string separator) =>
        span.SplitOnAny(separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAll> SplitOn(this string span, string separator) =>
        span.AsMemory().SplitOn(separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAll> SplitOn(this string span, ReadOnlyMemory<char> separator) =>
        span.AsMemory().SplitOn(separator);
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, char, MatchAll> SplitOn(this ReadOnlyMemory<char> span, string separator) =>
        span.SplitOn(separator.AsMemory());
    /// <inheritdoc cref="SplitSpanFactory.SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this string span) =>
        span.AsMemory().SplitLines();
    /// <inheritdoc cref="SplitSpanFactory.SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this ReadOnlyMemory<char> span) =>
#if NET8_0_OR_GREATER
        new(span, BreakingSearch.Memory);
#else
        new(span, Breaking.AsMemory());
#endif
    /// <inheritdoc cref="SplitSpanFactory.SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this Memory<char> span) =>
        span.ReadOnly().SplitLines();
    /// <inheritdoc cref="SplitSpanFactory.SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this string span) =>
        span.AsMemory().SplitWhitespace();
    /// <inheritdoc cref="SplitSpanFactory.SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this ReadOnlyMemory<char> span) =>
#if NET8_0_OR_GREATER
        new(span, UnicodeSearch.Memory);
#else
        new(span, Unicode.AsMemory());
#endif
    /// <inheritdoc cref="SplitSpanFactory.SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this Memory<char> span) =>
        span.ReadOnly().SplitWhitespace();
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitSpanFactory.SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitMemory<char, SearchValues<char>, MatchAny> SplitOn(
        this string span,
        OnceMemoryManager<SearchValues<char>> separator
    ) =>
        span.AsMemory().SplitOn(separator);
#endif
/// <summary>Represents a split entry.</summary>
/// <typeparam name="TBody">The type of element from the span.</typeparam>
/// <typeparam name="TSeparator">The type of separator.</typeparam>
/// <typeparam name="TStrategy">The strategy for splitting elements.</typeparam>
[StructLayout(LayoutKind.Auto)]
[method: MethodImpl(MethodImplOptions.AggressiveInlining)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct SplitMemory<TBody, TSeparator, TStrategy>(
        ReadOnlyMemory<TBody> body,
        ReadOnlyMemory<TSeparator> separator
    ) : IEquatable<object>,
    IEquatable<SplitMemory<TBody, TSeparator, TStrategy>>,
    ISplitMemory<TBody, TSeparator>
    where TBody : IEquatable<TBody>?
#if !NET7_0_OR_GREATER
    where TSeparator : IEquatable<TSeparator>?
#endif
{
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Accumulator{TAccumulator}"/>
    public delegate TAccumulator RefAccumulator<TAccumulator>(TAccumulator accumulator, ReadOnlyMemory<TBody> next)
#if !NO_ALLOWS_REF_STRUCT
        where TAccumulator : allows ref struct
#endif
    ;
    readonly ReadOnlyMemory<TBody> _body = body;
    readonly ReadOnlyMemory<TSeparator> _separator = separator;
    /// <summary>
    /// Initializes a new instance of the <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/> struct.
    /// </summary>
    /// <param name="body">The line to split.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SplitMemory(ReadOnlyMemory<TBody> body)
        : this(body, default) { }
    /// <inheritdoc />
    public readonly ReadOnlyMemory<TBody> Body
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.First"/>
    public readonly ReadOnlyMemory<TBody> First
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Last"/>
    public readonly ReadOnlyMemory<TBody> Last
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetReversedEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }
    /// <inheritdoc />
    public readonly ReadOnlyMemory<TSeparator> Separator
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Single"/>
    public readonly ReadOnlyMemory<TBody> Single
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() && e.Current is var ret && !e.MoveNext() ? ret : default;
    }
    /// <summary>Gets itself as <see cref="SplitSpan{TBody, TSeparator, TStrategy}"/>.</summary>
    public readonly SplitSpan<TBody, TSeparator, TStrategy> SplitSpan
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => new(_body.Span, _separator.Span);
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.this[int]"/>
    public readonly ReadOnlyMemory<TBody> this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException(nameof(index), index, "must be positive");
            var e = GetEnumerator();
            for (var i = 0; i <= index; i++)
                if (!e.MoveNext())
                    return default;
            return e.Current;
        }
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.this[Index]"/>
    public readonly ReadOnlyMemory<TBody> this[Index index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            if (index.Value is var value && !index.IsFromEnd)
            {
                var forwards = GetEnumerator();
                for (var i = 0; i <= value; i++)
                    if (!forwards.MoveNext())
                        return default;
                return forwards.Current;
            }
            var backwards = GetReversedEnumerator();
            for (var i = 0; i <= value; i++)
                if (!backwards.MoveNext())
                    return default;
            return backwards.Current;
        }
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.op_Equality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(
        SplitMemory<TBody, TSeparator, TStrategy> left,
        SplitMemory<TBody, TSeparator, TStrategy> right
    ) =>
        left.Equals(right);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.op_Inequality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(
        SplitMemory<TBody, TSeparator, TStrategy> left,
        SplitMemory<TBody, TSeparator, TStrategy> right
    ) =>
        !left.Equals(right);
    /// <summary>
    /// Explicitly converts the parameter by creating the new instance of
    /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/> by using the constructor
    /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}(ReadOnlyMemory{TBody})"/>.
    /// </summary>
    /// <param name="body">The parameter to pass onto the constructor.</param>
    /// <returns>
    /// The new instance of <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/>
    /// by passing the parameter <paramref name="body"/> to the constructor
    /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}(ReadOnlyMemory{TBody})"/>.
    /// </returns>
    [Pure]
    public static explicit operator SplitMemory<TBody, TSeparator, TStrategy>(ReadOnlyMemory<TBody> body) => new(body);
    /// <summary>
    /// Implicitly converts the parameter by creating the new instance of
    /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/> by using the constructor
    /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}(ReadOnlyMemory{TBody}, ReadOnlyMemory{TSeparator})"/>.
    /// </summary>
    /// <param name="tuple">The parameter to pass onto the constructor.</param>
    /// <returns>
    /// The new instance of <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/>
    /// by passing the parameter <paramref name="tuple"/> to the constructor
    /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}(ReadOnlyMemory{TBody}, ReadOnlyMemory{TSeparator})"/>.
    /// </returns>
    [Pure]
    public static implicit operator SplitMemory<TBody, TSeparator, TStrategy>(
        (ReadOnlyMemory<TBody> Body, ReadOnlyMemory<TSeparator> Separator) tuple
    ) =>
        new(tuple.Body, tuple.Separator);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Deconstruct"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out ReadOnlyMemory<TBody> head, out SplitMemory<TBody, TSeparator, TStrategy> tail)
    {
        if (GetEnumerator() is var e && !e.MoveNext())
        {
            head = default;
            tail = default;
            return;
        }
        head = e.Current;
        tail = new(e.Body, _separator);
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ConcatEqual{TOtherSeparator, TOtherStrategy}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool ConcatEqual<TOtherSeparator, TOtherStrategy>(
         SplitMemory<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        =>
            SplitSpan.ConcatEqual(other.SplitSpan);
    /// <inheritdoc cref="object.Equals(object)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override bool Equals(object? obj) =>
        obj is SplitMemory<TBody, TSeparator, TStrategy> other && Equals(other);
    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals(SplitMemory<TBody, TSeparator, TStrategy> other) =>
        _body.Span.SequenceEqual(other._body.Span) &&
        _separator.Span.SequenceEqual(To<TSeparator>.From(other._separator.Span));
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.SequenceEqual{TOtherSeparator, TOtherStrategy}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool SequenceEqual<TOtherSeparator, TOtherStrategy>(
         SplitMemory<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        =>
            SplitSpan.SequenceEqual(other.SplitSpan);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Count"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int Count()
    {
        var e = GetEnumerator();
        var count = 0;
        while (e.MoveNext())
            count++;
        return count;
    }
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override int GetHashCode() =>
        unchecked(typeof(SplitMemory<TBody, TSeparator, TStrategy>).GetHashCode() * 7);
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() => SplitSpan.ToString();
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(ReadOnlyMemory<TBody> divider) => ToString(divider.Span);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToString(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(scoped ReadOnlySpan<TBody> divider) => SplitSpan.ToString(divider);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToStringArray"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string[] ToStringArray() => SplitSpan.ToStringArray();
    /// <summary>Copies the values to a new <see cref="ReadOnlyMemory{T}"/> <see cref="Array"/>.</summary>
    /// <returns>
    /// The <see cref="ReadOnlyMemory{T}"/> <see cref="Array"/> containing the copied values of this instance.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReadOnlyMemory<TBody>[] ToArrayMemories()
    {
        using var ret = 4.Alloc<ReadOnlyMemory<TBody>>();
        foreach (var next in this)
            ret.Append(next);
        return ret.View.ToArray();
    }
    /// <inheritdoc cref="ToArrayMemories(ReadOnlyMemory{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReadOnlyMemory<TBody>[] ToArrayMemories(ReadOnlyMemory<TBody> divider)
    {
        if (GetEnumerator() is var e && !e.MoveNext())
            return [];
        using var ret = 4.Alloc<ReadOnlyMemory<TBody>>();
        ret.Append(e.Current);
        while (e.MoveNext())
        {
            ret.Append(divider);
            ret.Append(e.Current);
        }
        return ret.View.ToArray();
    }
    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MustDisposeResource(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetEnumerator() => new(this);
    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MustDisposeResource(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReversedEnumerator GetReversedEnumerator() => new(this);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Skipped"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly SplitMemory<TBody, TSeparator, TStrategy> Skipped([NonNegativeValue] int count)
    {
        Enumerator e = this;
        for (; count > 0 && e.MoveNext(); count--) { }
        return e.SplitMemory;
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.SkippedLast"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly SplitMemory<TBody, TSeparator, TStrategy> SkippedLast([NonNegativeValue] int count)
    {
        ReversedEnumerator e = this;
        for (; count > 0 && e.MoveNext(); count--) { }
        return e.SplitMemory;
    }
    /// <inheritdoc />
    [MustDisposeResource(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    IEnumerator<ReadOnlyMemory<TBody>> IEnumerable<ReadOnlyMemory<TBody>>.GetEnumerator() => GetEnumerator();
    /// <summary>Gets the accumulated result of a set of callbacks where each element is passed in.</summary>
    /// <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
    /// <param name="seed">The accumulator.</param>
    /// <param name="func">An accumulator function to be invoked on each element.</param>
    /// <returns>The accumulated result of <paramref name="seed"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] RefAccumulator<TAccumulator> func
    )
#if !NO_ALLOWS_REF_STRUCT
        where TAccumulator : allows ref struct
#endif
    {
        var accumulator = seed;
        foreach (var next in this)
            accumulator = func(accumulator, next);
        return accumulator;
    }
    /// <inheritdoc cref="SplitSpan{TBody,TSeparator,TStrategy}.Aggregate{TAccumulator}(TAccumulator, SplitSpan{TBody, TSeparator, TStrategy}.Accumulator{TAccumulator})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] Func<TAccumulator, ReadOnlyMemory<TBody>, TAccumulator> func
    )
#if !NO_ALLOWS_REF_STRUCT
        where TAccumulator : allows ref struct
#endif
    {
        var accumulator = seed;
        foreach (var next in this)
            accumulator = func(accumulator, next);
        return accumulator;
    }
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray()"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray() => SplitSpan.ToArray();
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(ReadOnlyMemory<TBody> divider) => ToArray(divider.Span);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArray(ReadOnlySpan{TBody})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(scoped ReadOnlySpan<TBody> divider) => SplitSpan.ToArray(divider);
    /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ToArrays"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[][] ToArrays() => SplitSpan.ToArrays();
    /// <summary>
    /// Represents the enumeration object that views <see cref="SplitMemory{TBody, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public partial struct Enumerator(ReadOnlyMemory<TBody> body, ReadOnlyMemory<TSeparator> separator)
        : IEnumerator<ReadOnlyMemory<TBody>>
    {
        readonly ReadOnlyMemory<TSeparator> _separator = separator;
        readonly ReadOnlyMemory<TBody> _original = body;
        ReadOnlyMemory<TBody> _body = body, _current;
        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(ReadOnlyMemory<TBody> body)
            : this(body, default) { }
        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(SplitMemory<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }
        /// <inheritdoc cref="SplitMemory{TBody, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlyMemory<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _body = value;
        }
        /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator.SplitSpan"/>
        public readonly SplitMemory<TBody, TSeparator, TStrategy> SplitMemory
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get => new(_body, _separator);
        }
        /// <inheritdoc />
        readonly object IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }
        /// <inheritdoc />
        public readonly ReadOnlyMemory<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }
        /// <inheritdoc cref="SplitMemory{TBody, TSeparator, TStrategy}.Separator"/>
        public readonly ReadOnlyMemory<TSeparator> Separator
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _separator = value;
        }
        /// <summary>
        /// Explicitly converts the parameter by creating the new instance
        /// of <see cref="Enumerator"/> by using the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.Enumerator(ReadOnlyMemory{TBody})"/>.
        /// </summary>
        /// <param name="body">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerator"/> by passing the
        /// parameter <paramref name="body"/> to the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.Enumerator(ReadOnlyMemory{TBody})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static explicit operator SplitMemory<TBody, TSeparator, TStrategy>.Enumerator(
            ReadOnlyMemory<TBody> body
        ) =>
            new(body);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance
        /// of <see cref="Enumerator"/> by using the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.Enumerator(ReadOnlyMemory{TBody}, ReadOnlyMemory{TSeparator})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerator"/> by passing the
        /// parameter <paramref name="tuple"/> to the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.Enumerator(ReadOnlyMemory{TBody}, ReadOnlyMemory{TSeparator})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator SplitMemory<TBody, TSeparator, TStrategy>.Enumerator(
            (ReadOnlyMemory<TBody> Body, ReadOnlyMemory<TSeparator> Separator) tuple
        ) =>
            new(tuple.Body, tuple.Separator);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance
        /// of <see cref="Enumerator"/> by using the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.Enumerator(SplitMemory{TBody, TSeparator, TStrategy})"/>.
        /// </summary>
        /// <param name="split">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerator"/> by passing the
        /// parameter <paramref name="split"/> to the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.Enumerator(SplitMemory{TBody, TSeparator, TStrategy})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator SplitMemory<TBody, TSeparator, TStrategy>.Enumerator(
            SplitMemory<TBody, TSeparator, TStrategy> split
        ) =>
            new(split);
        /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator.Move"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Move(
            ReadOnlyMemory<TSeparator> sep,
            scoped ref ReadOnlyMemory<TBody> body,
            out ReadOnlyMemory<TBody> current
        )
        {
            var b = body.Span;
            var ret = SplitSpan<TBody, TSeparator, TStrategy>.Enumerator.Move(sep.Span, ref b, out var c);
            current = c.AsMemory(body);
            body = b.AsMemory(body);
            return ret;
        }
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => Move(_separator, ref _body, out _current);
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly void IDisposable.Dispose() { }
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IEnumerator.Reset() => _body = _original;
    }
    /// <summary>
    /// Represents the enumeration object that views <see cref="SplitMemory{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public partial struct ReversedEnumerator(ReadOnlyMemory<TBody> body, ReadOnlyMemory<TSeparator> separator)
        : IEnumerator<ReadOnlyMemory<TBody>>
    {
        readonly ReadOnlyMemory<TBody> _original = body;
        readonly ReadOnlyMemory<TSeparator> _separator = separator;
        ReadOnlyMemory<TBody> _body = body, _current;
        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(ReadOnlyMemory<TBody> body)
            : this(body, default) { }
        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(SplitMemory<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }
        /// <inheritdoc cref="SplitMemory{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlyMemory<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _body = value;
        }
        /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.ReversedEnumerator.SplitSpan"/>
        public readonly SplitMemory<TBody, TSeparator, TStrategy> SplitMemory
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get => new(_body, _separator);
        }
        /// <inheritdoc />
        readonly object IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }
        /// <inheritdoc cref="IEnumerator{T}.Current"/>
        public readonly ReadOnlyMemory<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }
        /// <inheritdoc cref="SplitMemory{T, TSeparator, TStrategy}.Separator"/>
        public readonly ReadOnlyMemory<TSeparator> Separator
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _separator = value;
        }
        /// <summary>
        /// Explicitly converts the parameter by creating the new instance
        /// of <see cref="ReversedEnumerator"/> by using the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.ReversedEnumerator(ReadOnlyMemory{TBody})"/>.
        /// </summary>
        /// <param name="body">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="ReversedEnumerator"/> by passing
        /// the parameter <paramref name="body"/> to the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.ReversedEnumerator(ReadOnlyMemory{TBody})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static explicit operator SplitMemory<TBody, TSeparator, TStrategy>.ReversedEnumerator(
            ReadOnlyMemory<TBody> body
        ) =>
            new(body);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance
        /// of <see cref="ReversedEnumerator"/> by using the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.ReversedEnumerator(ReadOnlyMemory{TBody}, ReadOnlyMemory{TSeparator})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="ReversedEnumerator"/> by passing
        /// the parameter <paramref name="tuple"/> to the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.ReversedEnumerator(ReadOnlyMemory{TBody}, ReadOnlyMemory{TSeparator})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator SplitMemory<TBody, TSeparator, TStrategy>.ReversedEnumerator(
            (ReadOnlyMemory<TBody> Body, ReadOnlyMemory<TSeparator> Separator) tuple
        ) =>
            new(tuple.Body, tuple.Separator);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance
        /// of <see cref="ReversedEnumerator"/> by using the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.ReversedEnumerator(SplitMemory{TBody, TSeparator, TStrategy})"/>.
        /// </summary>
        /// <param name="split">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="ReversedEnumerator"/> by passing
        /// the parameter <paramref name="split"/> to the constructor
        /// <see cref="SplitMemory{TBody, TSeparator, TStrategy}.ReversedEnumerator(SplitMemory{TBody, TSeparator, TStrategy})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator SplitMemory<TBody, TSeparator, TStrategy>.ReversedEnumerator(
            SplitMemory<TBody, TSeparator, TStrategy> split
        ) =>
            new(split);
        /// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator.Move"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool MoveNext(
            ReadOnlyMemory<TSeparator> sep,
            scoped ref ReadOnlyMemory<TBody> body,
            out ReadOnlyMemory<TBody> current
        )
        {
            var b = body.Span;
            var ret = SplitSpan<TBody, TSeparator, TStrategy>.ReversedEnumerator.Move(sep.Span, ref b, out var c);
            current = c.AsMemory(body);
            body = b.AsMemory(body);
            return ret;
        }
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => MoveNext(_separator, ref _body, out _current);
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly void IDisposable.Dispose() { }
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void IEnumerator.Reset() => _body = _original;
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible InvertIf RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias
#pragma warning disable IDE0032
/// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}"/>
public partial struct SplitSpan<TBody, TSeparator, TStrategy>
{
    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Enumerator GetEnumerator() => new(this);
    /// <summary>Returns itself but with the number of elements specified skipped. This is evaluated eagerly.</summary>
    /// <param name="count">The number of elements to skip.</param>
    /// <returns>Itself but skipping the parameter <paramref name="count"/> number of elements.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly SplitSpan<TBody, TSeparator, TStrategy> Skipped([NonNegativeValue] int count)
    {
        Enumerator e = this;
        for (; count > 0 && e.MoveNext(); count--) { }
        return e.SplitSpan;
    }
    /// <summary>
    /// Represents the forwards enumeration object that views <see cref="SplitSpan{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public
#if !NO_REF_STRUCTS
        ref
#endif
        partial struct Enumerator(ReadOnlySpan<TBody> body, ReadOnlySpan<TSeparator> separator)
    {
        readonly ReadOnlySpan<TSeparator> _separator = separator;
        ReadOnlySpan<TBody> _body = body, _current;
        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(ReadOnlySpan<TBody> body)
            : this(body, default) { }
        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(SplitSpan<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }
        /// <inheritdoc cref="SplitSpan{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlySpan<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _body = value;
        }
        /// <inheritdoc cref="IEnumerator.Current"/>
        public readonly ReadOnlySpan<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }
        /// <inheritdoc cref="SplitSpan{T, TSeparator, TStrategy}.Separator"/>
        public readonly ReadOnlySpan<TSeparator> Separator
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _separator = value;
        }
        /// <summary>
        /// Reconstructs the <see cref="SplitSpan{TBody, TSeparator, TStrategy}"/> based on the current state.
        /// </summary>
        public readonly SplitSpan<TBody, TSeparator, TStrategy> SplitSpan
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get => new(_body, _separator);
        }
        /// <summary>
        /// Explicitly converts the parameter by creating the new instance
        /// of <see cref="Enumerator"/> by using the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator(ReadOnlySpan{TBody})"/>.
        /// </summary>
        /// <param name="body">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerator"/> by passing
        /// the parameter <paramref name="body"/> to the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator(ReadOnlySpan{TBody})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static explicit operator SplitSpan<TBody, TSeparator, TStrategy>.Enumerator(ReadOnlySpan<TBody> body) =>
            new(body);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance
        /// of <see cref="Enumerator"/> by using the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator(SplitSpan{TBody, TSeparator, TStrategy})"/>.
        /// </summary>
        /// <param name="split">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerator"/> by passing
        /// the parameter <paramref name="split"/> to the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.Enumerator(SplitSpan{TBody, TSeparator, TStrategy})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator SplitSpan<TBody, TSeparator, TStrategy>.Enumerator(
            SplitSpan<TBody, TSeparator, TStrategy> split
        ) =>
            new(split);
        /// <summary>Performs one step of an enumeration over the provided spans.</summary>
        /// <param name="sep">The separator span.</param>
        /// <param name="body">The span that contains the current state of the enumeration.</param>
        /// <param name="current">The current span.</param>
        /// <returns>
        /// <see langword="true"/> if a step was performed successfully;
        /// <see langword="false"/> if the end of the collection is reached.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Move(
            scoped ReadOnlySpan<TSeparator> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        ) =>
            0 switch
            {
                _ when body.IsEmpty && (current = default) is var _ => false,
                _ when sep.IsEmpty => (current = body) is var _ && (body = default) is var _,
                _ when typeof(TStrategy) == typeof(MatchAll) => MoveNextAll(To<TBody>.From(sep), ref body, out current),
#if NET8_0_OR_GREATER
                _ when typeof(TStrategy) == typeof(MatchAny) && typeof(TSeparator) == typeof(SearchValues<TBody>) =>
                    MoveNextAny(To<SearchValues<TBody>>.From(sep), ref body, out current),
#endif
                _ when typeof(TStrategy) == typeof(MatchAny) => MoveNextAny(To<TBody>.From(sep), ref body, out current),
                _ when typeof(TStrategy) == typeof(MatchOne) => MoveNextOne(To<TBody>.From(sep), ref body, out current),
                _ => throw Error,
            };
        /// <inheritdoc cref="IEnumerator.MoveNext"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => Move(_separator, ref _body, out _current);
        /// <summary>
        /// Checks if two sequences of type <see name="TBody"/> are equal while iterating through the next element.
        /// </summary>
        /// <typeparam name="TOtherSeparator">The type of separator used in the other sequence.</typeparam>
        /// <typeparam name="TOtherStrategy">The strategy used for splitting the other sequence.</typeparam>
        /// <param name="other">The enumerator for the other sequence.</param>
        /// <param name="reader">The <see cref="ReadOnlySpan{T}"/> representing this sequence.</param>
        /// <param name="otherReader">The <see cref="ReadOnlySpan{T}"/> representing the other sequence.</param>
        /// <param name="ret">
        /// Output parameter indicating if the sequences are equal.
        /// Note that this value is undefined if <see langword="false"/> is returned.
        /// </param>
        /// <returns>
        /// The value <see langword="true"/> if enumeration should be stopped; otherwise, <see langword="false"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool EqualityMoveNext<TOtherSeparator, TOtherStrategy>(
            scoped ref SplitSpan<TBody, TOtherSeparator, TOtherStrategy>.Enumerator other,
            scoped ref ReadOnlySpan<TBody> reader,
            scoped ref ReadOnlySpan<TBody> otherReader,
            out bool ret
        )
#if !NET7_0_OR_GREATER
            where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        {
            Unsafe.SkipInit(out ret);
            if (reader.Length is var length && otherReader.Length is var otherLength && length == otherLength)
                return SameLength(ref other, ref reader, ref otherReader, ref ret);
            if (length < otherLength)
            {
                if (!reader.SequenceEqual(otherReader.UnsafelyTake(length)) || !MoveNext())
                {
                    ret = false;
                    return true;
                }
                reader = Current;
                otherReader = otherReader.UnsafelySkip(length);
                return false;
            }
            if (!reader.UnsafelyTake(otherLength).SequenceEqual(otherReader) || !other.MoveNext())
            {
                ret = false;
                return true;
            }
            reader = reader.UnsafelyTake(otherLength);
            otherReader = other.Current;
            return false;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAll(
            scoped ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAll), "TStrategy is MatchAll");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
        Retry:
            switch (body.IndexOf(sep))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case 0:
                    if (body.Length != sep.Length)
                    {
                        body = body.UnsafelySkip(sep.Length);
                        goto Retry;
                    }
                    current = default;
                    return false;
                case var i:
                    current = body.UnsafelyTake(i);
                    body = body.UnsafelySkip(i + sep.Length);
                    return true;
            }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAny(
            scoped ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
#if NET7_0_OR_GREATER
            switch (body.IndexOfAnyExcept(sep))
            {
                case -1:
                    current = default;
                    return false;
                case 0: break;
                case var i:
                    body = body.UnsafelySkip(i);
                    break;
            }
            if (body.IndexOfAny(sep) is not -1 and var length)
            {
                current = body.UnsafelyTake(length);
                body = body.UnsafelySkip(length + 1);
                return true;
            }
            current = body;
            body = default;
#else
        Retry:
            var min = int.MaxValue;
            foreach (var next in sep)
                switch (body.IndexOf(next))
                {
                    case -1: continue;
                    case 0:
                        if (body.Length is not 1)
                        {
                            body = body.UnsafelySkip(1);
                            goto Retry;
                        }
                        current = default;
                        return false;
                    case var i when i < min:
                        min = i;
                        continue;
                }
            if (min is not int.MaxValue)
            {
                current = body.UnsafelyTake(min);
                body = body.UnsafelySkip(min + 1);
                return true;
            }
            current = body;
            body = default;
#endif
            return true;
        }
#if NET8_0_OR_GREATER
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAny(
            scoped ReadOnlySpan<SearchValues<TBody>> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            var single = sep.UnsafelyIndex(0);
            switch (body.IndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case 0: break;
                case var offset:
                    body = body.UnsafelySkip(offset);
                    break;
            }
            if (body.IndexOfAny(single) is not -1 and var length)
            {
                current = body.UnsafelyTake(length);
                body = body.UnsafelySkip(length + 1);
                return true;
            }
            current = body;
            body = default;
            return true;
        }
#endif
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextOne(
            scoped ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchOne), "TStrategy is MatchOne");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            var single = sep.UnsafelyIndex(0);
#if NET7_0_OR_GREATER
            switch (body.IndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case 0: break;
                case var offset:
                    body = body.UnsafelySkip(offset);
                    break;
            }
            if (body.IndexOf(single) is not -1 and var length)
            {
                current = body.UnsafelyTake(length);
                body = body.UnsafelySkip(length + 1);
                return true;
            }
            current = body;
            body = default;
            return true;
#else
        Retry:
            switch (body.IndexOf(single))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case 0:
                    if (body.Length is not 1)
                    {
                        body = body.UnsafelySkip(1);
                        goto Retry;
                    }
                    current = default;
                    return false;
                case var i:
                    current = body.UnsafelyTake(i);
                    body = body.UnsafelySkip(i + 1);
                    return true;
            }
#endif
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        bool SameLength<TOtherSeparator, TOtherStrategy>(
            ref SplitSpan<TBody, TOtherSeparator, TOtherStrategy>.Enumerator other,
            ref ReadOnlySpan<TBody> reader,
            ref ReadOnlySpan<TBody> otherReader,
            ref bool ret
        )
#if !NET7_0_OR_GREATER
            where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
        {
            if (!reader.SequenceEqual(otherReader))
            {
                ret = false;
                return true;
            }
            if (!MoveNext())
            {
                ret = !other.MoveNext();
                return true;
            }
            if (!other.MoveNext())
            {
                ret = false;
                return true;
            }
            reader = Current;
            otherReader = other.Current;
            return false;
        }
    }
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible InvertIf RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias
#pragma warning disable IDE0032
/// <inheritdoc cref="SplitSpan{TBody, TSeparator, TStrategy}"/>
public partial struct SplitSpan<TBody, TSeparator, TStrategy>
{
    /// <inheritdoc cref="IEnumerable.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ReversedEnumerator GetReversedEnumerator() => new(this);
    /// <summary>
    /// Returns itself but with the number of elements from the end specified skipped. This is evaluated eagerly.
    /// </summary>
    /// <param name="count">The number of elements to skip from the end.</param>
    /// <returns>Itself but skipping from the end the parameter <paramref name="count"/> number of elements.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly SplitSpan<TBody, TSeparator, TStrategy> SkippedLast([NonNegativeValue] int count)
    {
        Enumerator e = this;
        for (; count > 0 && e.MoveNext(); count--) { }
        return e.SplitSpan;
    }
    /// <summary>
    /// Represents the backwards enumeration object that views <see cref="SplitSpan{T, TSeparator, TStrategy}"/>.
    /// </summary>
    [StructLayout(LayoutKind.Auto)]
    [method: MethodImpl(MethodImplOptions.AggressiveInlining)]
    public
#if !NO_REF_STRUCTS
        ref
#endif
        partial struct ReversedEnumerator(ReadOnlySpan<TBody> body, ReadOnlySpan<TSeparator> separator)
    {
        readonly ReadOnlySpan<TSeparator> _separator = separator;
        ReadOnlySpan<TBody> _body = body, _current;
        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="body">The body.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(ReadOnlySpan<TBody> body)
            : this(body, default) { }
        /// <summary>Initializes a new instance of the <see cref="ReversedEnumerator"/> struct.</summary>
        /// <param name="split">The enumerable to enumerate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReversedEnumerator(SplitSpan<TBody, TSeparator, TStrategy> split)
            : this(split._body, split._separator) { }
        /// <inheritdoc cref="SplitSpan{T, TSeparator, TStrategy}.Body"/>
        public readonly ReadOnlySpan<TBody> Body
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _body = value;
        }
        /// <inheritdoc cref="IEnumerator.Current"/>
        public readonly ReadOnlySpan<TBody> Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _current;
        }
        /// <inheritdoc cref="SplitSpan{T, TSeparator, TStrategy}.Separator"/>
        public readonly ReadOnlySpan<TSeparator> Separator
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] init => _separator = value;
        }
        /// <summary>
        /// Reconstructs the <see cref="SplitSpan{TBody, TSeparator, TStrategy}"/> based on the current state.
        /// </summary>
        public readonly SplitSpan<TBody, TSeparator, TStrategy> SplitSpan
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get => new(_body, _separator);
        }
        /// <summary>
        /// Explicitly converts the parameter by creating the new instance
        /// of <see cref="ReversedEnumerator"/> by using the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.ReversedEnumerator(ReadOnlySpan{TBody})"/>.
        /// </summary>
        /// <param name="body">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="ReversedEnumerator"/> by passing
        /// the parameter <paramref name="body"/> to the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.ReversedEnumerator(ReadOnlySpan{TBody})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static explicit operator SplitSpan<TBody, TSeparator, TStrategy>.ReversedEnumerator(
            ReadOnlySpan<TBody> body
        ) =>
            new(body);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance
        /// of <see cref="ReversedEnumerator"/> by using the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.ReversedEnumerator(SplitSpan{TBody, TSeparator, TStrategy})"/>.
        /// </summary>
        /// <param name="split">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="ReversedEnumerator"/> by passing
        /// the parameter <paramref name="split"/> to the constructor
        /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}.ReversedEnumerator(SplitSpan{TBody, TSeparator, TStrategy})"/>.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator SplitSpan<TBody, TSeparator, TStrategy>.ReversedEnumerator(
            SplitSpan<TBody, TSeparator, TStrategy> split
        ) =>
            new(split);
        /// <summary>Performs one step of an enumeration over the provided spans.</summary>
        /// <param name="sep">The separator span.</param>
        /// <param name="body">The span that contains the current state of the enumeration.</param>
        /// <param name="current">The current span.</param>
        /// <returns>
        /// <see langword="true"/> if a step was performed successfully;
        /// <see langword="false"/> if the end of the collection is reached.
        /// </returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Move(
            scoped ReadOnlySpan<TSeparator> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        ) =>
            0 switch
            {
                _ when body.IsEmpty && (current = default) is var _ => false,
                _ when sep.IsEmpty => (current = body) is var _ && (body = default) is var _,
                _ when typeof(TStrategy) == typeof(MatchAll) => MoveNextAll(To<TBody>.From(sep), ref body, out current),
#if NET8_0_OR_GREATER
                _ when typeof(TStrategy) == typeof(MatchAny) && typeof(TSeparator) == typeof(SearchValues<TBody>) =>
                    MoveNextAny(To<SearchValues<TBody>>.From(sep), ref body, out current),
#endif
                _ when typeof(TStrategy) == typeof(MatchAny) => MoveNextAny(To<TBody>.From(sep), ref body, out current),
                _ when typeof(TStrategy) == typeof(MatchOne) => MoveNextOne(To<TBody>.From(sep), ref body, out current),
                _ => throw Error,
            };
        /// <inheritdoc cref="IEnumerator.MoveNext"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() => Move(_separator, ref _body, out _current);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAll(
            scoped ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAll), "TStrategy is MatchAll");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            if (sep.Length < body.Length)
            {
                current = default;
                return false;
            }
        Retry:
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
            switch (body.LastIndexOf(sep))
#else
            int lower = 0, upper = body.Length - sep.Length;
            for (; lower < upper; lower++)
                if (body.UnsafelySkip(lower).UnsafelyTake(sep.Length).SequenceEqual(sep))
                    break;
            if (lower == upper)
                lower = -1;
            switch (+lower)
#endif
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case var i when i == body.Length - sep.Length:
                    if (body.Length != sep.Length)
                    {
                        body = body.UnsafelyTake(i);
                        goto Retry;
                    }
                    current = default;
                    return false;
                case var i:
                    current = body.UnsafelySkip(i + sep.Length);
                    body = body.UnsafelyTake(i);
                    return true;
            }
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAny(
            scoped ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
#if NET7_0_OR_GREATER
            switch (body.LastIndexOfAnyExcept(sep))
            {
                case -1:
                    current = default;
                    return false;
                case var i when i == body.Length - 1: break;
                case var i:
                    body = body.UnsafelyTake(i + 1);
                    break;
            }
            if (body.LastIndexOfAny(sep) is not -1 and var length)
            {
                current = body.UnsafelySkip(length + 1);
                body = body.UnsafelyTake(length);
                return true;
            }
            current = body;
            body = default;
#else
        Retry:
            var max = -1;
            foreach (var next in sep)
                switch (body.LastIndexOf(next))
                {
                    case -1: continue;
                    case var i when i == body.Length - 1:
                        if (body.Length is not 1)
                        {
                            body = body.UnsafelyTake(body.Length - 1);
                            goto Retry;
                        }
                        current = default;
                        return false;
                    case var i when i > max:
                        max = i;
                        continue;
                }
            if (max is not -1)
            {
                current = body.UnsafelySkip(max + 1);
                body = body.UnsafelyTake(max);
                return true;
            }
            current = body;
            body = default;
#endif
            return true;
        }
#if NET8_0_OR_GREATER
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextAny(
            scoped ReadOnlySpan<SearchValues<TBody>> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchAny), "TStrategy is MatchAny");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            ref var single = ref MemoryMarshal.GetReference(sep);
            switch (body.LastIndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case var i when i == body.Length - 1: break;
                case var i:
                    body = body.UnsafelyTake(i + 1);
                    break;
            }
            if (body.LastIndexOfAny(single) is not -1 and var length)
            {
                current = body.UnsafelySkip(length + 1);
                body = body.UnsafelyTake(length);
                return true;
            }
            current = body;
            body = default;
            return true;
        }
#endif
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool MoveNextOne(
            scoped ReadOnlySpan<TBody> sep,
            scoped ref ReadOnlySpan<TBody> body,
            out ReadOnlySpan<TBody> current
        )
        {
            System.Diagnostics.Debug.Assert(typeof(TStrategy) == typeof(MatchOne), "TStrategy is MatchOne");
            System.Diagnostics.Debug.Assert(!sep.IsEmpty, "separator is non-empty");
            var single = sep.UnsafelyIndex(0);
#if NET7_0_OR_GREATER
            switch (body.LastIndexOfAnyExcept(single))
            {
                case -1:
                    current = default;
                    return false;
                case var i when i == body.Length - 1: break;
                case var offset:
                    body = body.UnsafelyTake(offset + 1);
                    break;
            }
            if (body.IndexOf(single) is not -1 and var length)
            {
                current = body.UnsafelySkip(length + 1);
                body = body.UnsafelyTake(length);
                return true;
            }
            current = body;
            body = default;
            return true;
#else
        Retry:
            switch (body.LastIndexOf(single))
            {
                case -1:
                    current = body;
                    body = default;
                    return true;
                case var i when i == body.Length - 1:
                    if (body.Length is not 1)
                    {
                        body = body.UnsafelyTake(1);
                        goto Retry;
                    }
                    current = default;
                    return false;
                case var i:
                    current = body.UnsafelySkip(i);
                    body = body.UnsafelyTake(i - 1);
                    return true;
            }
#endif
        }
    }
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable BadPreprocessorIndent CheckNamespace ConvertToAutoPropertyWhenPossible InvertIf RedundantNameQualifier RedundantReadonlyModifier RedundantUsingDirective StructCanBeMadeReadOnly UseSymbolAlias
#pragma warning disable IDE0032, RCS1158
/// <summary>Methods to split spans into multiple spans.</summary>
    /// <summary>The type that indicates to match all elements.</summary>
    public struct MatchAll;
    /// <summary>The type that indicates to match any element.</summary>
    public struct MatchAny;
    /// <summary>The type that indicates to match exactly one element.</summary>
    public struct MatchOne;
    /// <summary>Splits a span by the specified separator.</summary>
    /// <typeparam name="T">The type of element from the span.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="separator">The separator.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAny> SplitOnAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            new(span, separator);
    /// <inheritdoc cref="SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAny> SplitOnAny<T>(this Span<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            span.ReadOnly().SplitOnAny(separator);
    /// <summary>Splits a span by the specified separator.</summary>
    /// <typeparam name="T">The type of element from the span.</typeparam>
    /// <param name="span">The span to split.</param>
    /// <param name="separator">The separator.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAll> SplitOn<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            new(span, separator);
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchAll> SplitOn<T>(this Span<T> span, ReadOnlySpan<T> separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>
#endif
        =>
            span.ReadOnly().SplitOn(separator);
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this ReadOnlySpan<T> span,
        in SearchValues<T> separator
    )
        where T : IEquatable<T> =>
        new(span, In(separator));
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, SearchValues<T>, MatchAny> SplitOn<T>(
        this Span<T> span,
        in SearchValues<T> separator
    )
        where T : IEquatable<T> =>
        span.ReadOnly().SplitOn(separator);
#endif
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchOne> SplitOn<T>(this ReadOnlySpan<T> span, in T separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>?
#endif
        =>
            new(span, In(separator));
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<T, T, MatchOne> SplitOn<T>(this Span<T> span, in T separator)
#if UNMANAGED_SPAN
        where T : unmanaged, IEquatable<T>
#else
        where T : IEquatable<T>?
#endif
        =>
            span.ReadOnly().SplitOn(separator);
#endif
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<byte, byte, MatchOne> SplitOn(this ReadOnlySpan<byte> span, byte separator) =>
        new(span, separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<byte, byte, MatchOne> SplitOn(this Span<byte> span, byte separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchOne> SplitOn(this ReadOnlySpan<char> span, char separator) =>
        new(span, separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchOne> SplitOn(this Span<char> span, char separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<sbyte, sbyte, MatchOne> SplitOn(this ReadOnlySpan<sbyte> span, sbyte separator) =>
        new(span, separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<sbyte, sbyte, MatchOne> SplitOn(this Span<sbyte> span, sbyte separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<short, short, MatchOne> SplitOn(this ReadOnlySpan<short> span, short separator) =>
        new(span, separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<short, short, MatchOne> SplitOn(this Span<short> span, short separator) =>
        span.ReadOnly().SplitOn(separator);
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<ushort, ushort, MatchOne> SplitOn(this ReadOnlySpan<ushort> span, ushort separator) =>
        new(span, separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<ushort, ushort, MatchOne> SplitOn(this Span<ushort> span, ushort separator) =>
        span.ReadOnly().SplitOn(separator);
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchOne> SplitSpanOn(this string span, char separator) =>
        span.AsSpan().SplitOn(separator);
    /// <inheritdoc cref="SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAny> SplitSpanOnAny(this string span, string separator) =>
        span.AsSpan().SplitOnAny(separator.AsSpan());
    /// <inheritdoc cref="SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAny> SplitOnAny(this string span, ReadOnlySpan<char> separator) =>
        span.AsSpan().SplitOnAny(separator);
    /// <inheritdoc cref="SplitOnAny{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAny> SplitOnAny(this ReadOnlySpan<char> span, string separator) =>
        span.SplitOnAny(separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAll> SplitSpanOn(this string span, string separator) =>
        span.AsSpan().SplitOn(separator.AsSpan());
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAll> SplitOn(this string span, ReadOnlySpan<char> separator) =>
        span.AsSpan().SplitOn(separator);
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, ReadOnlySpan{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, char, MatchAll> SplitOn(this ReadOnlySpan<char> span, string separator) =>
        span.SplitOn(separator.AsSpan());
    /// <inheritdoc cref="SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitSpanLines(this string span) =>
        span.AsSpan().SplitLines();
    /// <summary>Splits a span by line breaks.</summary>
    /// <remarks><para>Line breaks are considered any character in <see cref="Breaking"/>.</para></remarks>
    /// <param name="span">The span to split.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this ReadOnlySpan<char> span) =>
#if NET8_0_OR_GREATER
        new(span, BreakingSearch.GetSpan());
#else
        new(span, Breaking.AsSpan());
#endif
    /// <inheritdoc cref="SplitLines(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitLines(this Span<char> span) =>
        span.ReadOnly().SplitLines();
    /// <inheritdoc cref="SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitSpanWhitespace(this string span) =>
        span.AsSpan().SplitWhitespace();
    /// <summary>Splits a span by whitespace.</summary>
    /// <remarks><para>Whitespace is considered any character in <see cref="Unicode"/>.</para></remarks>
    /// <param name="span">The span to split.</param>
    /// <returns>The enumerable object that references the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this ReadOnlySpan<char> span) =>
#if NET8_0_OR_GREATER
        new(span, UnicodeSearch.Memory.Span);
#else
        new(span, Unicode.AsSpan());
#endif
    /// <inheritdoc cref="SplitWhitespace(ReadOnlySpan{char})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char,
#if NET8_0_OR_GREATER
        SearchValues<char>,
#else
        char,
#endif
        MatchAny> SplitWhitespace(this Span<char> span) =>
        span.ReadOnly().SplitWhitespace();
#endif
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="SplitOn{T}(ReadOnlySpan{T}, in SearchValues{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SplitSpan<char, SearchValues<char>, MatchAny> SplitSpanOn(
        this string span,
        in SearchValues<char> separator
    ) =>
        span.AsSpan().SplitOn(separator);
#endif
/// <summary>Represents a split entry.</summary>
/// <typeparam name="TBody">The type of element from the span.</typeparam>
/// <typeparam name="TSeparator">The type of separator.</typeparam>
/// <typeparam name="TStrategy">The strategy for splitting elements.</typeparam>
/// <param name="body">The line to split.</param>
/// <param name="separator">The separator.</param>
[StructLayout(LayoutKind.Auto)]
[method: MethodImpl(MethodImplOptions.AggressiveInlining)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
#if !NO_REF_STRUCTS
    ref
#endif
    partial struct SplitSpan<TBody, TSeparator, TStrategy>(ReadOnlySpan<TBody> body, ReadOnlySpan<TSeparator> separator)
#if UNMANAGED_SPAN
    where TBody : unmanaged, IEquatable<TBody>?
#else
    where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
    where TSeparator : IEquatable<TSeparator>?
#endif
{
    /// <summary>Represents the accumulator function for the enumeration of this type.</summary>
    /// <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
    /// <param name="accumulator">The accumulator.</param>
    /// <param name="next">The next slice from the enumeration.</param>
    /// <returns>The final accumulator value.</returns>
    public delegate TAccumulator Accumulator<TAccumulator>(TAccumulator accumulator, ReadOnlySpan<TBody> next)
#if !NO_ALLOWS_REF_STRUCT
        where TAccumulator : allows ref struct
#endif
    ;
    readonly ReadOnlySpan<TBody> _body = body;
    readonly ReadOnlySpan<TSeparator> _separator = separator;
    /// <summary>Initializes a new instance of the <see cref="SplitSpan{T, TSeparator, TStrategy}"/> struct.</summary>
    /// <param name="body">The line to split.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SplitSpan(ReadOnlySpan<TBody> body)
        : this(body, default) { }
    /// <summary>Gets the error thrown by this type.</summary>
    public static NotSupportedException Error
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => new($"Unrecognized type: {typeof(TStrategy).Name}");
    }
    /// <summary>Gets the line to split.</summary>
    public readonly ReadOnlySpan<TBody> Body
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _body;
    }
    /// <summary>Gets the first element.</summary>
    public readonly ReadOnlySpan<TBody> First
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }
    /// <summary>Gets the last element.</summary>
    public readonly ReadOnlySpan<TBody> Last
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetReversedEnumerator() is var e && e.MoveNext() ? e.Current : default;
    }
    /// <summary>Gets the separator.</summary>
    public readonly ReadOnlySpan<TSeparator> Separator
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _separator;
    }
    /// <summary>Gets the single element.</summary>
    public readonly ReadOnlySpan<TBody> Single
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => GetEnumerator() is var e && e.MoveNext() && e.Current is var ret && !e.MoveNext() ? ret : default;
    }
    /// <summary>Gets the specified index.</summary>
    /// <param name="index">The index to get.</param>
    /// <exception cref="ArgumentOutOfRangeException">The parameter <paramref name="index"/> is negative.</exception>
    public readonly ReadOnlySpan<TBody> this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            if (index < 0)
                throw new ArgumentOutOfRangeException(nameof(index), index, "must be positive");
            var e = GetEnumerator();
            for (var i = 0; i <= index; i++)
                if (!e.MoveNext())
                    return default;
            return e.Current;
        }
    }
    /// <summary>Gets the specified index.</summary>
    /// <param name="index">The index to get.</param>
    public readonly ReadOnlySpan<TBody> this[Index index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            if (index.Value is var value && !index.IsFromEnd)
            {
                var forwards = GetEnumerator();
                for (var i = 0; i <= value; i++)
                    if (!forwards.MoveNext())
                        return default;
                return forwards.Current;
            }
            var backwards = GetReversedEnumerator();
            for (var i = 0; i <= value; i++)
                if (!backwards.MoveNext())
                    return default;
            return backwards.Current;
        }
    }
    /// <summary>Determines whether both splits are equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both splits are equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(
        scoped SplitSpan<TBody, TSeparator, TStrategy> left,
        scoped SplitSpan<TBody, TSeparator, TStrategy> right
    ) =>
        left.Equals(right);
    /// <summary>Determines whether both splits are not equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both splits are not equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(
        scoped SplitSpan<TBody, TSeparator, TStrategy> left,
        scoped SplitSpan<TBody, TSeparator, TStrategy> right
    ) =>
        !left.Equals(right);
    /// <summary>
    /// Explicitly converts the parameter by creating the new instance of
    /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}"/> by using the constructor
    /// <see cref="SplitSpan{TBody, TSeparator, TStrategy}(ReadOnlySpan{TBody})"/>.
    /// </summary>
    /// <param name="body">The parameter to pass onto the constructor.</param>
    /// <returns>
    /// The new instance of SplitSpan{TBody, TSeparator, TStrategy} by passing the parameter <paramref name="body"/>
    /// to the constructor <see cref="SplitSpan{TBody, TSeparator, TStrategy}(ReadOnlySpan{TBody})"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static explicit operator SplitSpan<TBody, TSeparator, TStrategy>(ReadOnlySpan<TBody> body) => new(body);
    /// <summary>Separates the head from the tail of this <see cref="SplitSpan{T, TSeparator, TStrategy}"/>.</summary>
    /// <param name="head">The first element of this enumeration.</param>
    /// <param name="tail">The rest of this enumeration.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out ReadOnlySpan<TBody> head, out SplitSpan<TBody, TSeparator, TStrategy> tail)
    {
        if (GetEnumerator() is var e && !e.MoveNext())
        {
            head = default;
            tail = default;
            return;
        }
        head = e.Current;
        tail = new(e.Body, _separator);
    }
    /// <summary>Determines whether both splits are eventually equal when concatenating all slices.</summary>
    /// <typeparam name="TOtherSeparator">The type of separator for the other side.</typeparam>
    /// <typeparam name="TOtherStrategy">The strategy for splitting for the other side.</typeparam>
    /// <param name="other">The other side.</param>
    /// <returns>
    /// The value <paramref langword="true"/> if both sequences are equal, otherwise; <paramref langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly unsafe bool ConcatEqual<TOtherSeparator, TOtherStrategy>(
        scoped SplitSpan<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
    {
        if (GetEnumerator() is var e && other.GetEnumerator() is var otherE && !e.MoveNext())
            return !otherE.MoveNext();
        if (!otherE.MoveNext())
            return false;
        ReadOnlySpan<TBody> reader = e.Current, otherReader = otherE.Current;
        while (true)
#pragma warning disable 9080
            if (e.EqualityMoveNext(ref otherE, ref reader, ref otherReader, out var ret))
#pragma warning restore 9080
                return ret;
    }
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Always returns false", true), Pure]
    public readonly override bool Equals(object? obj) => false;
    /// <inheritdoc cref="IEquatable{T}.Equals(T)" />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals(scoped SplitSpan<TBody, TSeparator, TStrategy> other) =>
        _body.SequenceEqual(other._body) && _separator.SequenceEqual(other._separator);
    /// <summary>Determines whether both splits are equal.</summary>
    /// <typeparam name="TOtherSeparator">The type of separator for the right-hand side.</typeparam>
    /// <typeparam name="TOtherStrategy">The strategy for splitting elements for the right-hand side.</typeparam>
    /// <param name="other">The side to compare to.</param>
    /// <returns>
    /// The value <paramref langword="true"/> if both sequences are equal, otherwise; <paramref langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool SequenceEqual<TOtherSeparator, TOtherStrategy>(
        scoped in SplitSpan<TBody, TOtherSeparator, TOtherStrategy> other
    )
#if !NET7_0_OR_GREATER
        where TOtherSeparator : IEquatable<TOtherSeparator>?
#endif
    {
        Enumerator e = this;
        var eOther = other.GetEnumerator();
        while (e.MoveNext())
            if (!eOther.MoveNext() || !e.Current.SequenceEqual(eOther.Current))
                return false;
        return !eOther.MoveNext();
    }
    /// <summary>Computes the length.</summary>
    /// <returns>The length.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int Count()
    {
        var count = 0;
        for (var e = GetEnumerator(); e.MoveNext(); count++) { }
        return count;
    }
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override int GetHashCode() => unchecked(typeof(TBody).GetHashCode() * 31);
    /// <inheritdoc />
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() =>
        typeof(TBody) == typeof(char)
            ? Aggregate(new StringBuilder(), StringBuilderAccumulator).ToString()
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            : ToArrays().Stringify(3, true);
#else
            : throw new NotSupportedException();
#endif
    /// <summary>
    /// Converts the elements of the collection to a <see cref="string"/> representation,
    /// using the specified divider between elements.
    /// </summary>
    /// <param name="divider">The divider to insert between elements.</param>
    /// <returns>A <see cref="string"/> representation of the collection.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string ToString(scoped ReadOnlySpan<TBody> divider)
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        if (GetEnumerator() is var e && !e.MoveNext())
            return "";
        using var ret = 4.Alloc<TBody>();
        ret.Append(e.Current);
        while (e.MoveNext())
        {
            ret.Append(divider);
            ret.Append(e.Current);
        }
        return typeof(TBody) == typeof(char) ? ret.View.ToString() : ret.View.ToArray().Conjoin();
#else
        var e = GetEnumerator();
        if (!e.MoveNext())
            return "";
        List<TBody> ret = [];
        foreach (var next in e.Current)
            ret.Add(next);
        while (e.MoveNext())
        {
            foreach (var next in divider)
                ret.Add(next);
            foreach (var next in e.Current)
                ret.Add(next);
        }
        return ret.Conjoin(typeof(TBody) == typeof(char) ? "" : ", ");
#endif
    }
    /// <summary>Copies the values to a new <see cref="string"/> <see cref="Array"/>.</summary>
    /// <returns>The <see cref="string"/> <see cref="Array"/> containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly string[] ToStringArray()
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = 4.Alloc<string>();
        foreach (var next in this)
            ret.Append(typeof(TBody) == typeof(char) ? next.ToString() : next.ToArray().Conjoin());
        return ret.View.ToArray();
#else
        List<string> ret = [];
        foreach (var next in this)
            ret.Add(typeof(TBody) == typeof(char) ? next.ToString() : next.ToArray().Conjoin());
        return [.. ret];
#endif
    }
    /// <summary>Gets the accumulated result of a set of callbacks where each element is passed in.</summary>
    /// <typeparam name="TAccumulator">The type of the accumulator value.</typeparam>
    /// <param name="seed">The accumulator.</param>
    /// <param name="func">An accumulator function to be invoked on each element.</param>
    /// <returns>The accumulated result of <paramref name="seed"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    public readonly TAccumulator Aggregate<TAccumulator>(
        TAccumulator seed,
        [InstantHandle, RequireStaticDelegate] Accumulator<TAccumulator> func
    )
#if !NO_ALLOWS_REF_STRUCT
        where TAccumulator : allows ref struct
#endif
    {
        var accumulator = seed;
        foreach (var next in this)
            accumulator = func(accumulator, next);
        return accumulator;
    }
    /// <summary>Copies the values to a new flattened array.</summary>
    /// <returns>The array containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray()
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = 4.Alloc<TBody>();
        foreach (var next in this)
            ret.Append(next);
        return ret.View.ToArray();
#else
        List<TBody> ret = [];
        foreach (var next in this)
            foreach (var element in next)
                ret.Add(element);
        return [.. ret];
#endif
    }
    /// <summary>Copies the values to a new flattened array.</summary>
    /// <param name="divider">The separator between each element.</param>
    /// <returns>The array containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[] ToArray(scoped ReadOnlySpan<TBody> divider)
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        if (GetEnumerator() is var e && !e.MoveNext())
            return [];
        using var ret = 4.Alloc<TBody>();
        ret.Append(e.Current);
        while (e.MoveNext())
        {
            ret.Append(divider);
            ret.Append(e.Current);
        }
        return ret.View.ToArray();
#else
        if (GetEnumerator() is var e && !e.MoveNext())
            return [];
        List<TBody> ret = [];
        foreach (var next in e.Current)
            ret.Add(next);
        while (e.MoveNext())
        {
            foreach (var next in divider)
                ret.Add(next);
            foreach (var next in e.Current)
                ret.Add(next);
        }
        return [.. ret];
#endif
    }
    /// <summary>Copies the values to a new nested array.</summary>
    /// <returns>The nested array containing the copied values of this instance.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly TBody[][] ToArrays()
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        using var ret = 4.Alloc<TBody[]>();
        foreach (var next in this)
            ret.Append(next.ToArray());
        return ret.View.ToArray();
#else
        List<TBody[]> ret = [];
        foreach (var next in this)
            ret.Add(next.ToArray());
        return [.. ret];
#endif
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe StringBuilder StringBuilderAccumulator(StringBuilder builder, scoped ReadOnlySpan<TBody> span)
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        =>
            builder.Append(To<char>.From(span));
#else
        {
#if NETFRAMEWORK && !NET46_OR_GREATER || NETSTANDARD && !NETSTANDARD1_3_OR_GREATER
            for (var i = 0; i < span.Length; i++)
                builder.Append(((char*)span.Pointer)[i]);
            return builder;
#else
#pragma warning disable 8500
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
            var ptr = span.Pointer;
#else
            fixed (TBody* ptr = span)
#endif
#pragma warning restore 8500
                return builder.Append((char*)ptr, span.Length);
#endif
        }
#endif
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="CircularList{T}"/>.</summary>
    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="CircularList{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="CircularList{T}"/>.</param>
    /// <returns>A <see cref="CircularList{T}"/> of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static CircularList<T>? ToCircular<T>(this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as CircularList<T> ?? new(iterable.ToIList());
#endif
/// <summary>
/// Encapsulates an <see cref="IList{T}"/> where elements are treated as circular;
/// indices wrap around and will therefore never be out of range.
/// </summary>
/// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
/// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
public sealed partial class CircularList<T>([ProvidesContext] IList<T> list) : IList<T>, IReadOnlyList<T>
{
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    public T this[int index]
    {
        [CollectionAccess(Read)] get => list[Mod(index)];
        [CollectionAccess(ModifyExistingContent)] set => list[Mod(index)] = value;
    }
    /// <inheritdoc/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure, ValueRange(1, int.MaxValue)]
    public int Count => list.Count;
    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Add(T item) => list.Add(item);
    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();
    /// <inheritdoc/>
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => list.CopyTo(array, arrayIndex);
    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T item) => list.Insert(Mod(index), item);
    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index) => list.RemoveAt(Mod(index));
    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => list.Contains(item);
    /// <inheritdoc/>
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T item) => list.Remove(item);
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => list.IndexOf(item);
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public IEnumerator<T> GetEnumerator() => list.GetEnumerator();
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public override string ToString() => list.ToString().OrEmpty();
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    int Mod(int index) => Count is not 0 and var count ? index.Mod(count) : throw CannotBeEmpty;
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace NullnessAnnotationConflictWithJetBrainsAnnotations
#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="ClampedList{T}"/>.</summary>
    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="ClampedList{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="ClampedList{T}"/>.</param>
    /// <returns>A <see cref="ClampedList{T}"/> of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ClampedList<T>? ToClamped<T>(this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as ClampedList<T> ?? new(iterable.ToIList());
#endif
/// <summary>
/// Encapsulates an <see cref="IList{T}"/> where indices are always clamped and therefore never be out of range.
/// </summary>
/// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
/// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
public sealed partial class ClampedList<T>([ProvidesContext] IList<T> list) : IList<T>, IReadOnlyList<T>
{
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    public T this[int index]
    {
        [CollectionAccess(Read)] get => list[Clamp(index)];
        [CollectionAccess(ModifyExistingContent)] set => list[Clamp(index)] = value;
    }
    /// <inheritdoc/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure, ValueRange(1, int.MaxValue)]
    public int Count => list.Count;
    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Add(T item) => list.Add(item);
    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();
    /// <inheritdoc/>
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => list.CopyTo(array, arrayIndex);
    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T item) => list.Insert(Clamp(index), item);
    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index) => list.RemoveAt(Clamp(index));
    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => list.Contains(item);
    /// <inheritdoc/>
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T item) => list.Remove(item);
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => list.IndexOf(item);
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    public IEnumerator<T> GetEnumerator() => list.GetEnumerator();
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public override string ToString() => list.ToString().OrEmpty();
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    int Clamp(int index) => Count is var i && i is not 0 ? index.Clamp(0, i) : throw CannotBeEmpty;
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="GuardedList{T}"/>.</summary>
    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="GuardedList{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="GuardedList{T}"/>.</param>
    /// <returns>A <see cref="GuardedList{T}"/> of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static GuardedList<T>? ToGuardedLazily<T>(this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as GuardedList<T> ?? new(iterable.ToIList());
#endif
/// <summary>
/// Encapsulates an <see cref="IList{T}"/> where applying an index will always result in an optional value;
/// an out of range value will always give the <see langword="default"/> value.
/// </summary>
/// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
/// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
public sealed partial class GuardedList<T>([ProvidesContext] IList<T> list) : IList<T?>, IReadOnlyList<T?>
{
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    public T? this[int index]
    {
        [CollectionAccess(Read)] get => IsIn(index) ? list[index] : default;
        [CollectionAccess(ModifyExistingContent)]
        set
        {
            if (value is not null && IsIn(index))
                list[index] = value;
        }
    }
    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool IsReadOnly => list.IsReadOnly;
    /// <inheritdoc />
    bool ICollection<T?>.IsReadOnly => IsReadOnly;
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), NonNegativeValue, Pure]
    public int Count => list.Count;
    /// <inheritdoc />
    int ICollection<T?>.Count => Count;
    /// <inheritdoc cref="ICollection{T}.Add"/>
    [CollectionAccess(UpdatedContent)]
    public void Add(T? item)
    {
        if (item is not null)
            list.Add(item);
    }
    /// <inheritdoc cref="ICollection{T}.Clear"/>
    [CollectionAccess(ModifyExistingContent)]
    public void Clear() => list.Clear();
    /// <inheritdoc cref="ICollection{T}.CopyTo"/>
    [CollectionAccess(Read)]
    public void CopyTo(T?[] array, int arrayIndex)
    {
        if (Count <= array.Length - arrayIndex)
            list.CopyTo(array as T[], arrayIndex);
    }
    /// <inheritdoc/>
    [CollectionAccess(UpdatedContent)]
    public void Insert(int index, T? item)
    {
        if (item is not null && IsIn(index))
            list.Insert(index, item);
    }
    /// <inheritdoc/>
    [CollectionAccess(ModifyExistingContent)]
    public void RemoveAt(int index)
    {
        if (IsIn(index))
            list.RemoveAt(index);
    }
    /// <inheritdoc />
    void ICollection<T?>.Add(T? item) => Add(item);
    /// <inheritdoc />
    void ICollection<T?>.Clear() => Clear();
    /// <inheritdoc />
    void ICollection<T?>.CopyTo(T?[] array, int arrayIndex) => CopyTo(array, arrayIndex);
    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T? item) => item is not null && list.Contains(item);
    /// <inheritdoc cref="ICollection{T}.Remove"/>
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    public bool Remove(T? item) => item is not null && list.Remove(item);
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    bool ICollection<T?>.Contains(T? item) => Contains(item);
    /// <inheritdoc />
    [CollectionAccess(Read | ModifyExistingContent), Pure]
    bool ICollection<T?>.Remove(T? item) => Remove(item);
    /// <inheritdoc cref="IList{T}.IndexOf"/>
    [CollectionAccess(Read), Pure]
    public int IndexOf(T? item) => item is null ? -1 : list.IndexOf(item);
    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator"/>
    [CollectionAccess(Read), MustDisposeResource, Pure]
#pragma warning disable 8619
    public IEnumerator<T?> GetEnumerator() => list.GetEnumerator();
#pragma warning restore 8619
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator<T?> IEnumerable<T?>.GetEnumerator() => list.GetEnumerator();
    /// <inheritdoc/>
    [CollectionAccess(Read), Pure]
    IEnumerator IEnumerable.GetEnumerator() => list.GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public override string ToString() => list.ToString().OrEmpty();
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    bool IsIn(int index) => index >= 0 && index < Count;
}
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Extension methods that act as factories for <see cref="Matrix{T}"/>.</summary>
    /// <summary>Maps a 1-dimensional collection as 2-dimensional.</summary>
    /// <typeparam name="T">The type of item within the list.</typeparam>
    public sealed partial class Matrix<T> : IList<IList<T>>
    {
        /// <summary>Represents a slice of a matrix.</summary>
        /// <param name="matrix">The matrix to reference.</param>
        /// <param name="ordinal">The first index of the matrix.</param>
        sealed class Slice([ProvidesContext] Matrix<T> matrix, [NonNegativeValue] int ordinal) : IList<T>
        {
            /// <inheritdoc />
            public T this[[NonNegativeValue] int index]
            {
                [Pure] get => matrix.List[Count * ordinal + index];
                set => matrix.List[Count * ordinal + index] = value;
            }
            /// <inheritdoc />
            public bool IsReadOnly
            {
                [Pure] get => matrix.List.IsReadOnly;
            }
            /// <inheritdoc />
            public int Count
            {
                [Pure] get => matrix.CountPerList;
            }
            /// <inheritdoc />
            public void Add(T item) => matrix.List.Insert(Count * (ordinal + 1), item);
            /// <inheritdoc />
            public void Clear()
            {
                for (int i = 0, count = Count; i < count; i++)
                    matrix.List.RemoveAt(count * ordinal);
            }
            /// <inheritdoc />
            public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
            {
                for (int i = 0, count = Count; i < count; i++)
                    array[arrayIndex + i] = matrix.List[count * ordinal + i];
            }
            /// <inheritdoc />
            public void Insert([NonNegativeValue] int index, T item)
            {
                if (Count is var count && index >= 0 && index < count)
                    matrix.List.Insert(Count * ordinal + index, item);
            }
            /// <inheritdoc />
            public void RemoveAt([NonNegativeValue] int index)
            {
                if (Count is var count && index >= 0 && index < count)
                    matrix.List.RemoveAt(Count * ordinal + index);
            }
            /// <inheritdoc />
            [Pure]
            public bool Contains(T item) => IndexOf(item) is not -1;
            /// <inheritdoc />
            public bool Remove(T item)
            {
                for (int i = 0, count = Count; i < count; i++)
                    if (count * ordinal + i is var view && EqualityComparer<T>.Default.Equals(matrix.List[view], item))
                    {
                        matrix.List.RemoveAt(view);
                        return true;
                    }
                return false;
            }
            /// <inheritdoc />
            [Pure, ValueRange(-1, int.MaxValue)]
            public int IndexOf(T item)
            {
                for (int i = 0, count = Count; i < count; i++)
                    if (EqualityComparer<T>.Default.Equals(matrix.List[count * ordinal + i], item))
                        return i;
                return -1;
            }
            /// <inheritdoc />
            [Pure]
            public IEnumerator<T> GetEnumerator()
            {
                var count = Count;
                return matrix.List.Skip(count * ordinal).Take(count).GetEnumerator();
            }
            /// <inheritdoc />
            [Pure]
            IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        }
        readonly int _countPerListEager;
        readonly Func<int>? _countPerListLazy;
        readonly IList<T>? _listEager;
        readonly Func<IList<T>>? _listLazy;
        /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
        /// <param name="list">The list to encapsulate.</param>
        /// <param name="countPerList">The length per count.</param>
        public Matrix(IList<T> list, [ValueRange(1, int.MaxValue)] int countPerList)
        {
            _countPerListEager = countPerList > 0
                ? countPerList
                : throw new ArgumentOutOfRangeException(
                    nameof(countPerList),
                    countPerList,
                    "Value must be at least 1."
                );
            _listEager = list;
        }
        /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
        /// <param name="list">The list to encapsulate.</param>
        /// <param name="countPerList">The length per count.</param>
        public Matrix(IList<T> list, Func<int> countPerList)
        {
            _countPerListLazy = countPerList;
            _listEager = list;
        }
        /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
        /// <param name="list">The list to encapsulate.</param>
        /// <param name="countPerList">The length per count.</param>
        public Matrix(Func<IList<T>> list, [ValueRange(1, int.MaxValue)] int countPerList)
        {
            _countPerListEager = countPerList > 0
                ? countPerList
                : throw new ArgumentOutOfRangeException(
                    nameof(countPerList),
                    countPerList,
                    "Value must be at least 1."
                );
            _listLazy = list;
        }
        /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
        /// <param name="list">The list to encapsulate.</param>
        /// <param name="countPerList">The length per count.</param>
        public Matrix(Func<IList<T>> list, Func<int> countPerList)
        {
            _countPerListLazy = countPerList;
            _listLazy = list;
        }
        /// <inheritdoc cref="IList{T}.this"/>
        public IList<T> this[[NonNegativeValue] int index]
        {
            [Pure] get => new Slice(this, index);
            set => Add(value);
        }
#if !WAWA
        /// <summary>Performs the index operation on the <see cref="Matrix{T}"/>.</summary>
        /// <param name="x">The <c>x</c> position, which is the list to take.</param>
        /// <param name="y">The <c>y</c> position, which is the element from the list to take.</param>
        public T this[[NonNegativeValue] int x, [NonNegativeValue] int y]
        {
            [Pure] get => List[Count * x + y];
            set => List[Count * x + y] = value;
        }
#endif
        /// <inheritdoc />
        public bool IsReadOnly
        {
            [Pure] get => List.IsReadOnly;
        }
        /// <inheritdoc cref="ICollection{T}.Count" />
        [NonNegativeValue]
        public int Count
        {
            [Pure] get => List.Count / CountPerList;
        }
        /// <summary>Gets the amount of items per list.</summary>
        public int CountPerList
        {
            [Pure] get => _countPerListLazy?.Invoke() ?? _countPerListEager;
        }
        /// <summary>Gets the encapsulated list.</summary>
        [ProvidesContext]
        public IList<T> List
        {
            [Pure]
#pragma warning disable 8603
            get => _listLazy?.Invoke() ?? _listEager;
#pragma warning restore 8603
        }
#if !WAWA
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Matrix{T}"/>
        /// by using the constructor <see cref="Matrix{T}(IList{T}, int)"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of Matrix{T} by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Matrix{T}(IList{T}, int)"/>.
        /// </returns>
        [Pure]
        public static implicit operator Matrix<T>((IList<T> List, int CountPerList) tuple) =>
            new(tuple.List, tuple.CountPerList);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Matrix{T}"/>
        /// by using the constructor <see cref="Matrix{T}(IList{T}, Func{int})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of Matrix{T} by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Matrix{T}(IList{T}, Func{int})"/>.
        /// </returns>
        [Pure]
        public static implicit operator Matrix<T>((IList<T> List, Func<int> CountPerList) tuple) =>
            new(tuple.List, tuple.CountPerList);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Matrix{T}"/>
        /// by using the constructor <see cref="Matrix{T}(Func{IList{T}}, int)"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Matrix{T}"/> by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Matrix{T}(Func{IList{T}}, int)"/>.
        /// </returns>
        [Pure]
        public static implicit operator Matrix<T>((Func<IList<T>> List, int CountPerList) tuple) =>
            new(tuple.List, tuple.CountPerList);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Matrix{T}"/>
        /// by using the constructor <see cref="Matrix{T}(Func{IList{T}}, Func{int})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Matrix{T}"/> by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Matrix{T}(Func{IList{T}}, Func{int})"/>.
        /// </returns>
        [Pure]
        public static implicit operator Matrix<T>((Func<IList<T>> List, Func<int> CountPerList) tuple) =>
            new(tuple.List, tuple.CountPerList);
#endif
        /// <inheritdoc />
        public void Add(IList<T>? item)
        {
            if (item is null)
                return;
            for (int i = 0, count = item.Count; i < count; i++)
                List.Add(item[i]);
        }
        /// <inheritdoc />
        public void Clear() => List.Clear();
        /// <inheritdoc />
        [Pure]
        public bool Contains(IList<T>? item) => IndexOf(item) is not -1;
        /// <inheritdoc />
        public void CopyTo(IList<T>[] array, [NonNegativeValue] int arrayIndex)
        {
            for (var i = 0; i < Count; i++)
                array[arrayIndex + i] = this[i];
        }
        /// <inheritdoc />
        public void Insert([NonNegativeValue] int index, IList<T>? item)
        {
            if (item is not null)
                this[index] = item;
        }
        /// <inheritdoc />
        public void RemoveAt([NonNegativeValue] int index) => this[index].Clear();
        /// <inheritdoc />
        public bool Remove(IList<T>? item)
        {
            if (item is null)
                return false;
            for (int i = 0, count = Count; i < count; i++)
                if (this[i].SequenceEqual(item))
                {
                    RemoveAt(i);
                    return true;
                }
            return false;
        }
        /// <inheritdoc />
        [Pure, ValueRange(-1, int.MaxValue)]
        public int IndexOf(IList<T>? item)
        {
            if (item is null)
                return -1;
            for (int i = 0, count = Count; i < count; i++)
                if (this[i].SequenceEqual(item))
                    return i;
            return -1;
        }
        /// <inheritdoc />
        [Pure]
        public IEnumerator<IList<T>> GetEnumerator() =>
            Enumerable.Range(0, Count).Select(IList<T> (x) => new Slice(this, x)).GetEnumerator();
        /// <inheritdoc />
        [Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }
#endif
#if !WAWA
    /// <summary>Wraps an <see cref="IList{T}"/> in a <see cref="Matrix{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterator">The collection to turn into a <see cref="Matrix{T}"/>.</param>
    /// <param name="countPerList">The length per count.</param>
    /// <returns>A <see cref="Matrix{T}"/> that wraps the parameter <paramref name="iterator"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterator))]
    public static Matrix<T>? AsMatrix<T>(this IEnumerable<T>? iterator, [NonNegativeValue] int countPerList) =>
        iterator is null ? null : new(iterator.ToIList(), countPerList);
#endif
    /// <summary>Wraps an <see cref="IList{T}"/> in a <see cref="Matrix{T}"/>.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterator">The collection to turn into a <see cref="Matrix{T}"/>.</param>
    /// <param name="countPerList">The length per count.</param>
    /// <returns>A <see cref="Matrix{T}"/> that wraps the parameter <paramref name="iterator"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterator))]
    public static Matrix<T>? AsMatrix<T>(
        this
#if WAWA
            IList<T>?
#else
            IEnumerable<T>?
#endif
            iterator,
        Func<int> countPerList
    ) =>
#if WAWA
        iterator is null ? null : new(iterator, countPerList);
#else
        iterator is null ? null : new(iterator.ToIList(), countPerList);
#endif
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable 8500
// ReSharper disable BadPreprocessorIndent CheckNamespace RedundantUnsafeContext StructCanBeMadeReadOnly
/// <inheritdoc cref="Bits{T}"/>
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>
{
    /// <inheritdoc cref="IList{T}.this[int]"/>
    [CollectionAccess(CollectionAccessType.Read)]
    public unsafe T this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            fixed (T* ptr = &_value)
                return Nth(ptr, index);
        }
    }
    /// <inheritdoc cref="IList{T}.this"/>
    T IList<T>.this[[NonNegativeValue] int index]
    {
        [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => this[index];
        [CollectionAccess(CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)] set { }
    }
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(CollectionAccessType.Read)]
    public unsafe int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            fixed (T* ptr = &_value)
                return PopCount(ptr);
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static unsafe void MovePopCount(ref byte* ptr, in byte* upper, ref int x)
    {
        for (; sizeof(T) >= sizeof(nuint) && ptr <= upper - sizeof(nuint); ptr += sizeof(nuint))
            if (BitOperations.PopCount(*(nuint*)ptr) is var i && i <= x)
                x -= i;
            else
                break;
        for (; sizeof(T) % sizeof(nuint) >= sizeof(ulong) && ptr <= upper - sizeof(ulong); ptr += sizeof(ulong))
            if (BitOperations.PopCount(*(ulong*)ptr) is var i && i <= x)
                x -= i;
            else
                break;
        for (; sizeof(T) % sizeof(ulong) >= sizeof(uint) && ptr <= upper - sizeof(uint); ptr += sizeof(uint))
            if (BitOperations.PopCount(*(uint*)ptr) is var i && i <= x)
                x -= i;
            else
                break;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe byte Find(ref byte* ptr, in byte* upper, int x)
    {
        for (; ptr < upper; ptr++)
        {
            if ((*ptr & 1) is not 0 && x-- is 0)
                return 1;
            if ((*ptr & 1 << 1) is not 0 && x-- is 0)
                return 1 << 1;
            if ((*ptr & 1 << 2) is not 0 && x-- is 0)
                return 1 << 2;
            if ((*ptr & 1 << 3) is not 0 && x-- is 0)
                return 1 << 3;
            if ((*ptr & 1 << 4) is not 0 && x-- is 0)
                return 1 << 4;
            if ((*ptr & 1 << 5) is not 0 && x-- is 0)
                return 1 << 5;
            if ((*ptr & 1 << 6) is not 0 && x-- is 0)
                return 1 << 6;
            if ((*ptr & 1 << 7) is not 0 && x-- is 0)
                return 1 << 7;
        }
        return 0;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable MA0051
    static unsafe int PopCount(T* value)
#pragma warning restore MA0051
    {
        var ptr = (nuint*)value++;
        var sum = 0;
        if (sizeof(T) / (sizeof(nuint) * 16) > 0)
        {
            for (; ptr <= (nuint*)value - 16; ptr += 16)
                sum += BitOperations.PopCount(*ptr) +
                    BitOperations.PopCount(ptr[1]) +
                    BitOperations.PopCount(ptr[2]) +
                    BitOperations.PopCount(ptr[3]) +
                    BitOperations.PopCount(ptr[4]) +
                    BitOperations.PopCount(ptr[5]) +
                    BitOperations.PopCount(ptr[6]) +
                    BitOperations.PopCount(ptr[7]) +
                    BitOperations.PopCount(ptr[8]) +
                    BitOperations.PopCount(ptr[9]) +
                    BitOperations.PopCount(ptr[10]) +
                    BitOperations.PopCount(ptr[11]) +
                    BitOperations.PopCount(ptr[12]) +
                    BitOperations.PopCount(ptr[13]) +
                    BitOperations.PopCount(ptr[14]) +
                    BitOperations.PopCount(ptr[15]);
            if (sizeof(T) % sizeof(nuint) * 16 is 0)
                return sum;
        }
        if (sizeof(T) % (sizeof(nuint) * 16) / (sizeof(nuint) * 8) > 0)
        {
            for (; ptr <= (nuint*)value - 8; ptr += 8)
                sum += BitOperations.PopCount(*ptr) +
                    BitOperations.PopCount(ptr[1]) +
                    BitOperations.PopCount(ptr[2]) +
                    BitOperations.PopCount(ptr[3]) +
                    BitOperations.PopCount(ptr[4]) +
                    BitOperations.PopCount(ptr[5]) +
                    BitOperations.PopCount(ptr[6]) +
                    BitOperations.PopCount(ptr[7]);
            if (sizeof(T) % sizeof(nuint) * 8 is 0)
                return sum;
        }
        if (sizeof(T) % (sizeof(nuint) * 8) / (sizeof(nuint) * 4) > 0)
        {
            for (; ptr <= (nuint*)value - 4; ptr += 4)
                sum += BitOperations.PopCount(*ptr) +
                    BitOperations.PopCount(ptr[1]) +
                    BitOperations.PopCount(ptr[2]) +
                    BitOperations.PopCount(ptr[3]);
            if (sizeof(T) % sizeof(nuint) * 4 is 0)
                return sum;
        }
        if (sizeof(T) % (sizeof(nuint) * 4) / (sizeof(nuint) * 2) > 0)
        {
            for (; ptr <= (nuint*)value - 2; ptr += 2)
                sum += BitOperations.PopCount(*ptr) + BitOperations.PopCount(ptr[1]);
            if (sizeof(T) % sizeof(nuint) * 2 is 0)
                return sum;
        }
        if (sizeof(T) % (sizeof(nuint) * 2) / sizeof(nuint) > 0)
        {
            for (; ptr < value; ptr++)
                sum += BitOperations.PopCount(*ptr);
            if (sizeof(T) % sizeof(nuint) is 0)
                return sum;
        }
        if (sizeof(T) % sizeof(nuint) is 0)
            return sum;
        if (sizeof(T) % sizeof(nuint) / sizeof(ulong) > 0)
        {
            for (; ptr < value; ptr = (nuint*)((ulong*)ptr + 1))
                sum += BitOperations.PopCount(*ptr);
            if (sizeof(T) % sizeof(nuint) is 0)
                return sum;
        }
        if (sizeof(T) % sizeof(ulong) is 0)
            return sum;
        return sum + PopCountRemainder((byte*)ptr);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe int TrailingZeroCount(nuint value)
#if NET7_0_OR_GREATER
        =>
            BitOperations.TrailingZeroCount(value);
#else
    {
        const int BitsInUInt = BitsInByte * sizeof(uint);
        for (var i = 0; i < (sizeof(nuint) + sizeof(uint) - 1) / sizeof(uint); i++)
            if (Map((uint)(value << i * BitsInUInt)) is var j and not 32)
                return j + i * BitsInUInt;
        return sizeof(nuint) * BitsInByte;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static int Map([ValueRange(0, 1u << 31)] uint value) =>
        value switch
        {
            0 => 32,
            1 << 0 => 0,
            1 << 1 => 1,
            1 << 2 => 2,
            1 << 3 => 3,
            1 << 4 => 4,
            1 << 5 => 5,
            1 << 6 => 6,
            1 << 7 => 7,
            1 << 8 => 8,
            1 << 9 => 9,
            1 << 10 => 10,
            1 << 11 => 11,
            1 << 12 => 12,
            1 << 13 => 13,
            1 << 14 => 14,
            1 << 15 => 15,
            1 << 16 => 10,
            1 << 17 => 11,
            1 << 18 => 12,
            1 << 19 => 13,
            1 << 20 => 14,
            1 << 21 => 15,
            1 << 22 => 10,
            1 << 23 => 11,
            1 << 24 => 12,
            1 << 25 => 13,
            1 << 26 => 14,
            1 << 27 => 15,
            1 << 28 => 10,
            1 << 29 => 11,
            1 << 30 => 12,
            1u << 31 => 13,
            _ => throw new ArgumentOutOfRangeException(nameof(value), value, null),
        };
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static unsafe int PopCountRemainder(byte* remainder) =>
        BitOperations.PopCount(
            (sizeof(T) % sizeof(ulong)) switch
            {
                1 => *remainder,
                2 => *(ushort*)remainder,
                3 => *(ushort*)remainder | (ulong)remainder[2] << 16,
                4 => *(uint*)remainder,
                5 => *(uint*)remainder | (ulong)remainder[4] << 32,
                6 => *(uint*)remainder | (ulong)*(ushort*)remainder[4] << 32,
                7 => *(uint*)remainder | (ulong)*(ushort*)remainder[4] << 32 | (ulong)remainder[6] << 48,
                _ => throw new InvalidOperationException("sizeof(T) is assumed to be within [1, 7]."),
            }
        );
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe T Create(T* p, byte* ptr, byte i)
    {
        T t = default;
        ((byte*)&t)[ptr - (byte*)p] = i;
        return t;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe T Nth(T* p, [NonNegativeValue] int index)
    {
        var x = index;
        var ptr = (byte*)p;
        var upper = (byte*)(p + 1);
        if (sizeof(T) >= sizeof(uint))
            MovePopCount(ref ptr, upper, ref x);
        return Find(ref ptr, upper, x) is not 0 and var i
            ? Create(p, ptr, i)
            : throw new ArgumentOutOfRangeException(nameof(index), index, null);
    }
}
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable 8500, MA0051
// ReSharper disable BadPreprocessorIndent CheckNamespace CognitiveComplexity StructCanBeMadeReadOnly
/// <inheritdoc cref="Bits{T}"/>
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>
{
    /// <summary>Computes the Bitwise-AND computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void And(scoped in T read, scoped ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            And(r, w);
    }
    /// <summary>Computes the Bitwise-AND-NOT computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void AndNot(scoped in T read, scoped ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            AndNot(r, w);
    }
    /// <summary>Computes the Bitwise-NOT computation, writing it to the first argument.</summary>
    /// <param name="reference">The <typeparamref name="T"/> to read and write from.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Not(scoped ref T reference)
    {
        fixed (T* ptr = &reference)
            Not(ptr);
    }
    /// <summary>Computes the Bitwise-OR computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Or(scoped in T read, scoped ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            Or(r, w);
    }
    /// <summary>Computes the Bitwise-XOR computation, writing it to the second argument.</summary>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Xor(scoped in T read, scoped ref T write)
    {
        fixed (T* r = &read)
        fixed (T* w = &write)
            Xor(r, w);
    }
    /// <summary>Determines whether both references of <typeparamref name="T"/> contain the same bits.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameters <paramref name="left"/> and <paramref name="right"/>
    /// point to values with the same bits as each other; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool Eq(scoped in T left, scoped in T right)
    {
        fixed (T* l = &left)
        fixed (T* r = &right)
            return Eq(l, r);
    }
    /// <summary>Determines whether both references of <typeparamref name="T"/> contain the same bits.</summary>
    /// <param name="reference">The reference to determine if it is zeroed.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="reference"/>
    /// points to a value with all zeros; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool EqZero(scoped in T reference)
    {
        fixed (T* ptr = &reference)
            return EqZero(ptr);
    }
#if !(NETFRAMEWORK && !NET45_OR_GREATER || NETSTANDARD1_0)
    /// <summary>Clamps a value such that it is not smaller or larger than the defined amount.</summary>
    /// <param name="number">The bits to clamp.</param>
    /// <param name="min">The minimum accepted value.</param>
    /// <param name="max">The maximum accepted value.</param>
    /// <returns>
    /// The parameter <paramref name="number"/> if its bits are greater or equal to the parameter
    /// <paramref name="min"/>, and lesser or equal to the parameter <paramref name="number"/>; otherwise,
    /// <paramref name="min"/> if the parameter <paramref name="number"/> is lesser than
    /// <paramref name="min"/>; otherwise, <paramref name="max"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ref readonly T Clamp(in T number, in T min, in T max) => ref Max(Min(number, max), min);
    /// <summary>Returns the reference that contains the greater bits.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are greater or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe ref readonly T Max(in T left, in T right)
    {
        fixed (T* r = &left)
        fixed (T* w = &right)
            return ref Unsafe.AsRef<T>(Max(r, w));
    }
    /// <summary>Returns the reference that contains the lesser bits.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are greater or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe ref readonly T Min(in T left, in T right)
    {
        fixed (T* r = &left)
        fixed (T* w = &right)
            return ref Unsafe.AsRef<T>(Min(r, w));
    }
#endif
    /// <summary>Computes the Bitwise-AND computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void And(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                *(Vector512<byte>*)r = Vector512.BitwiseAnd(Vector512.Load(l), Vector512.Load(r));
            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.BitwiseAnd(Vector256.Load(l), Vector256.Load(r));
            if (sizeof(T) % 32 is 0)
                return;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.BitwiseAnd(Vector128.Load(l), Vector128.Load(r));
            if (sizeof(T) % 16 is 0)
                return;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.BitwiseAnd(Vector64.Load(l), Vector64.Load(r));
            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l & *(nuint*)r;
        if (sizeof(T) % sizeof(nuint) is 0)
            return;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l & *(ulong*)r;
        if (sizeof(T) % sizeof(ulong) is 0)
            return;
        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l & *(uint*)r;
        if (sizeof(T) % sizeof(uint) is 0)
            return;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l & *(ushort*)r);
        if (sizeof(T) % sizeof(ushort) is 0)
            return;
        for (; l < upper; l++, r++)
            *r = (byte)(*l & *r);
    }
    /// <summary>Computes the Bitwise-AND-NOT computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void AndNot(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                *(Vector512<byte>*)r = Vector512.AndNot(Vector512.Load(l), Vector512.Load(r));
            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.AndNot(Vector256.Load(l), Vector256.Load(r));
            if (sizeof(T) % 32 is 0)
                return;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.AndNot(Vector128.Load(l), Vector128.Load(r));
            if (sizeof(T) % 16 is 0)
                return;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.AndNot(Vector64.Load(l), Vector64.Load(r));
            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l & ~*(nuint*)r;
        if (sizeof(T) % sizeof(nuint) is 0)
            return;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l & ~*(ulong*)r;
        if (sizeof(T) % sizeof(ulong) is 0)
            return;
        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l & ~*(uint*)r;
        if (sizeof(T) % sizeof(uint) is 0)
            return;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l & ~*(ushort*)r);
        if (sizeof(T) % sizeof(ushort) is 0)
            return;
        for (; l < upper; l++, r++)
            *r = (byte)(*l & ~*r);
    }
    /// <summary>Computes the Bitwise-NOT computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="ptr">The <typeparamref name="T"/> to read and write from.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Not(T* ptr)
    {
        byte* x = (byte*)ptr, upper = (byte*)(ptr + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; x <= upper - 64; x += 64)
                *(Vector512<byte>*)x = Vector512.OnesComplement(Vector512.Load(x));
            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; x <= upper - 32; x += 32)
                *(Vector256<byte>*)x = Vector256.OnesComplement(Vector256.Load(x));
            if (sizeof(T) % 32 is 0)
                return;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; x <= upper - 16; x += 16)
                *(Vector128<byte>*)x = Vector128.OnesComplement(Vector128.Load(x));
            if (sizeof(T) % 16 is 0)
                return;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; x <= upper - 8; x += 8)
                *(Vector64<byte>*)x = Vector64.OnesComplement(Vector64.Load(x));
            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; x <= upper - sizeof(nuint); x += sizeof(nuint))
            *(nuint*)x = ~*(nuint*)x;
        if (sizeof(T) % sizeof(nuint) is 0)
            return;
        for (; x <= upper - sizeof(ulong); x += sizeof(ulong))
            *(ulong*)x = ~*(ulong*)x;
        if (sizeof(T) % sizeof(ulong) is 0)
            return;
        for (; x <= upper - sizeof(uint); x += sizeof(uint))
            *(uint*)x = ~*(uint*)x;
        if (sizeof(T) % sizeof(uint) is 0)
            return;
        for (; x <= upper - sizeof(ushort); x += sizeof(ushort))
            *(ushort*)x = (ushort)~*(ushort*)x;
        if (sizeof(T) % sizeof(ushort) is 0)
            return;
        for (; x < upper; x++)
            *x = (byte)~*x;
    }
    /// <summary>Computes the Bitwise-OR computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Or(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
               *(Vector512<byte>*)r = Vector512.BitwiseOr(Vector512.Load(l), Vector512.Load(r));
            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.BitwiseOr(Vector256.Load(l), Vector256.Load(r));
            if (sizeof(T) % 32 is 0)
                return;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.BitwiseOr(Vector128.Load(l), Vector128.Load(r));
            if (sizeof(T) % 16 is 0)
                return;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.BitwiseOr(Vector64.Load(l), Vector64.Load(r));
            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l | *(nuint*)r;
        if (sizeof(T) % sizeof(nuint) is 0)
            return;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l | *(ulong*)r;
        if (sizeof(T) % sizeof(ulong) is 0)
            return;
        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l | *(uint*)r;
        if (sizeof(T) % sizeof(uint) is 0)
            return;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l | *(ushort*)r);
        if (sizeof(T) % sizeof(ushort) is 0)
            return;
        for (; l < upper; l++, r++)
            *r = (byte)(*l | *r);
    }
    /// <summary>Computes the Bitwise-XOR computation, writing it to the second argument.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="read">The <typeparamref name="T"/> to read from.</param>
    /// <param name="write">The <typeparamref name="T"/> to write to.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe void Xor(T* read, T* write)
    {
        byte* l = (byte*)read, r = (byte*)write, upper = (byte*)(read + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                *(Vector512<byte>*)r = Vector512.Xor(Vector512.Load(l), Vector512.Load(r));
            if (sizeof(T) % 64 is 0)
                return;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                *(Vector256<byte>*)r = Vector256.Xor(Vector256.Load(l), Vector256.Load(r));
            if (sizeof(T) % 32 is 0)
                return;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                *(Vector128<byte>*)r = Vector128.Xor(Vector128.Load(l), Vector128.Load(r));
            if (sizeof(T) % 16 is 0)
                return;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                *(Vector64<byte>*)r = Vector64.Xor(Vector64.Load(l), Vector64.Load(r));
            if (sizeof(T) % 8 is 0)
                return;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            *(nuint*)r = *(nuint*)l ^ *(nuint*)r;
        if (sizeof(T) % sizeof(nuint) is 0)
            return;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            *(ulong*)r = *(ulong*)l ^ *(ulong*)r;
        if (sizeof(T) % sizeof(ulong) is 0)
            return;
        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            *(uint*)r = *(uint*)l ^ *(uint*)r;
        if (sizeof(T) % sizeof(uint) is 0)
            return;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            *(ushort*)r = (ushort)(*(ushort*)l ^ *(ushort*)r);
        if (sizeof(T) % sizeof(ushort) is 0)
            return;
        for (; l < upper; l++, r++)
            *r = (byte)(*l ^ *r);
    }
    /// <summary>Determines whether both pointers of <typeparamref name="T"/> contain the same bits.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameters <paramref name="left"/> and <paramref name="right"/>
    /// point to values with the same bits as each other; otherwise, <see langword="false"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool Eq(T* left, T* right)
    {
        byte* l = (byte*)left, r = (byte*)right, upper = (byte*)(left + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; l <= upper - 64; l += 64, r += 64)
                if (!Vector512.EqualsAll(Vector512.Load(l), Vector512.Load(r)))
                    return false;
            if (sizeof(T) % 64 is 0)
                return true;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; l <= upper - 32; l += 32, r += 32)
                if (!Vector256.EqualsAll(Vector256.Load(l), Vector256.Load(r)))
                    return false;
            if (sizeof(T) % 32 is 0)
                return true;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; l <= upper - 16; l += 16, r += 16)
                if (!Vector128.EqualsAll(Vector128.Load(l), Vector128.Load(r)))
                    return false;
            if (sizeof(T) % 16 is 0)
                return true;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; l <= upper - 8; l += 8, r += 8)
                if (!Vector64.EqualsAll(Vector64.Load(l), Vector64.Load(r)))
                    return false;
            if (sizeof(T) % 8 is 0)
                return true;
        }
#endif
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint), r += sizeof(nuint))
            if (*(nuint*)l != *(nuint*)r)
                return false;
        if (sizeof(T) % sizeof(nuint) is 0)
            return true;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong), r += sizeof(ulong))
            if (*(ulong*)l != *(ulong*)r)
                return false;
        if (sizeof(T) % sizeof(ulong) is 0)
            return true;
        for (; l <= upper - sizeof(uint); l += sizeof(uint), r += sizeof(uint))
            if (*(uint*)l != *(uint*)r)
                return false;
        if (sizeof(T) % sizeof(uint) is 0)
            return true;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort), r += sizeof(ushort))
            if (*(ushort*)l != *(ushort*)r)
                return false;
        if (sizeof(T) % sizeof(ushort) is 0)
            return true;
        for (; l < upper; l++, r++)
            if (*l != *r)
                return false;
        return true;
    }
    /// <summary>Determines whether the pointer of <typeparamref name="T"/> contains all zeros.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="ptr">The pointer to determine if it is zeroed.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="ptr"/>
    /// points to a value with all zeros; otherwise, <see langword="false"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe bool EqZero(T* ptr)
    {
        byte* x = (byte*)ptr, upper = (byte*)(ptr + 1);
#if NET8_0_OR_GREATER
        if (Vector512.IsHardwareAccelerated && sizeof(T) >= 64)
        {
            for (; x <= upper - 64; x += 64)
                if (!Vector512.EqualsAll(Vector512.Load(x), Vector512<byte>.Zero))
                    return false;
            if (sizeof(T) % 64 is 0)
                return true;
        }
#endif
#if NET7_0_OR_GREATER
        if (Vector256.IsHardwareAccelerated && sizeof(T) >= 32)
        {
            for (; x <= upper - 32; x += 32)
                if (!Vector256.EqualsAll(Vector256.Load(x), Vector256<byte>.Zero))
                    return false;
            if (sizeof(T) % 32 is 0)
                return true;
        }
        if (Vector128.IsHardwareAccelerated && sizeof(T) >= 16)
        {
            for (; x <= upper - 16; x += 16)
                if (!Vector128.EqualsAll(Vector128.Load(x), Vector128<byte>.Zero))
                    return false;
            if (sizeof(T) % 16 is 0)
                return true;
        }
        if (Vector64.IsHardwareAccelerated && sizeof(T) >= 8)
        {
            for (; x <= upper - 8; x += 8)
                if (!Vector64.EqualsAll(Vector64.Load(x), Vector64<byte>.Zero))
                    return false;
            if (sizeof(T) % 8 is 0)
                return true;
        }
#endif
        for (; x <= upper - sizeof(nuint); x += sizeof(nuint))
            if (*(nuint*)x is not 0)
                return false;
        if (sizeof(T) % sizeof(nuint) is 0)
            return true;
        for (; x <= upper - sizeof(ulong); x += sizeof(ulong))
            if (*(ulong*)x is not 0)
                return false;
        if (sizeof(T) % sizeof(ulong) is 0)
            return true;
        for (; x <= upper - sizeof(uint); x += sizeof(uint))
            if (*(uint*)x is not 0)
                return false;
        if (sizeof(T) % sizeof(uint) is 0)
            return true;
        for (; x <= upper - sizeof(ushort); x += sizeof(ushort))
            if (*(ushort*)x is not 0)
                return false;
        if (sizeof(T) % sizeof(ushort) is 0)
            return true;
        for (; x < upper; x++)
            if (*x is not 0)
                return false;
        return true;
    }
    /// <summary>Clamps a value such that it is not smaller or larger than the defined amount.</summary>
    /// <param name="number">The bits to clamp.</param>
    /// <param name="min">The minimum accepted value.</param>
    /// <param name="max">The maximum accepted value.</param>
    /// <returns>
    /// The parameter <paramref name="number"/> if its bits are greater or equal to the parameter
    /// <paramref name="min"/>, and lesser or equal to the parameter <paramref name="number"/>; otherwise,
    /// <paramref name="min"/> if the parameter <paramref name="number"/> is lesser than
    /// <paramref name="min"/>; otherwise, <paramref name="max"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe T* Clamp(T* number, T* min, T* max) => Max(Min(number, max), min);
    /// <summary>Returns the pointer that contains the greater bits.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are greater or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe T* Max(T* left, T* right)
    {
        byte* l = (byte*)left, r = (byte*)right, upper = (byte*)(left + 1);
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint))
            if (*(nuint*)l != *(nuint*)r)
                return *(nuint*)l >= *(nuint*)r ? left : right;
        if (sizeof(T) % sizeof(nuint) is 0)
            return left;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong))
            if (*(ulong*)l != *(ulong*)r)
                return *(ulong*)l >= *(ulong*)r ? left : right;
        if (sizeof(T) % sizeof(ulong) is 0)
            return left;
        for (; l <= upper - sizeof(uint); l += sizeof(uint))
            if (*(uint*)l != *(uint*)r)
                return *(uint*)l >= *(uint*)r ? left : right;
        if (sizeof(T) % sizeof(uint) is 0)
            return left;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort))
            if (*(ushort*)l != *(ushort*)r)
                return *(ushort*)l >= *(ushort*)r ? left : right;
        if (sizeof(T) % sizeof(ushort) is 0)
            return left;
        for (; l < upper; l++)
            if (*l != *r)
                return *l >= *r ? left : right;
        return left;
    }
    /// <summary>Returns the pointer that contains the lesser bits.</summary>
    /// <remarks><para>This method assumes the pointers are fixed.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The parameter <paramref name="left"/> if its bits are lesser or equal to the
    /// parameter <paramref name="right"/>; otherwise, <paramref name="right"/>.
    /// </returns>
    [CLSCompliant(false), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe T* Min(T* left, T* right)
    {
        byte* l = (byte*)left, r = (byte*)right, upper = (byte*)(left + 1);
        for (; l <= upper - sizeof(nuint); l += sizeof(nuint))
            if (*(nuint*)l != *(nuint*)r)
                return *(nuint*)l <= *(nuint*)r ? left : right;
        if (sizeof(T) % sizeof(nuint) is 0)
            return left;
        for (; l <= upper - sizeof(ulong); l += sizeof(ulong))
            if (*(ulong*)l != *(ulong*)r)
                return *(ulong*)l <= *(ulong*)r ? left : right;
        if (sizeof(T) % sizeof(ulong) is 0)
            return left;
        for (; l <= upper - sizeof(uint); l += sizeof(uint))
            if (*(uint*)l != *(uint*)r)
                return *(uint*)l <= *(uint*)r ? left : right;
        if (sizeof(T) % sizeof(uint) is 0)
            return left;
        for (; l <= upper - sizeof(ushort); l += sizeof(ushort))
            if (*(ushort*)l != *(ushort*)r)
                return *(ushort*)l <= *(ushort*)r ? left : right;
        if (sizeof(T) % sizeof(ushort) is 0)
            return left;
        for (; l < upper; l++)
            if (*l != *r)
                return *l <= *r ? left : right;
        return left;
    }
}
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable 8500
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly
/// <inheritdoc cref="Bits{T}"/>
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>
{
    /// <summary>Determines whether the item has only a single bit.</summary>
    /// <param name="item">The element to test.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="item"/>
    /// has a single bit set; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsSingle(scoped in T item) =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        0 switch
        {
            _ when typeof(T) == typeof(sbyte) => unchecked((uint)(sbyte)(object)item).IsPow2(),
            _ when typeof(T) == typeof(byte) => ((uint)(byte)(object)item).IsPow2(),
            _ when typeof(T) == typeof(short) => unchecked((uint)(short)(object)item).IsPow2(),
            _ when typeof(T) == typeof(ushort) => ((uint)(ushort)(object)item).IsPow2(),
            _ when typeof(T) == typeof(int) => unchecked((uint)(int)(object)item).IsPow2(),
            _ when typeof(T) == typeof(uint) => ((uint)(object)item).IsPow2(),
            _ when typeof(T) == typeof(long) => unchecked((ulong)(long)(object)item).IsPow2(),
            _ when typeof(T) == typeof(ulong) => ((ulong)(object)item).IsPow2(),
            _ when typeof(T) == typeof(nint) => ((nuint)(nint)(object)item).IsPow2(),
            _ when typeof(T) == typeof(nuint) => ((nuint)(object)item).IsPow2(),
            _ when !typeof(T).IsEnum => (Enumerator)item is var e && e.MoveNext() && !e.MoveNext(),
            _ => (typeof(T) == typeof(Enum) ? item.GetType() : typeof(T)).GetEnumUnderlyingType() switch
            {
                var x when x == typeof(sbyte) => unchecked((uint)(sbyte)(object)item).IsPow2(),
                var x when x == typeof(byte) => ((uint)(byte)(object)item).IsPow2(),
                var x when x == typeof(short) => unchecked((uint)(short)(object)item).IsPow2(),
                var x when x == typeof(ushort) => ((uint)(ushort)(object)item).IsPow2(),
                var x when x == typeof(int) => unchecked((uint)(int)(object)item).IsPow2(),
                var x when x == typeof(uint) => ((uint)(object)item).IsPow2(),
                var x when x == typeof(long) => unchecked((ulong)(long)(object)item).IsPow2(),
                var x when x == typeof(ulong) => ((ulong)(object)item).IsPow2(),
                var x when x == typeof(nint) => ((nuint)(nint)(object)item).IsPow2(),
                var x when x == typeof(nuint) => ((nuint)(object)item).IsPow2(),
                _ => (Enumerator)item is var e && e.MoveNext() && !e.MoveNext(),
            },
        };
#else
        (Enumerator)item is var e && e.MoveNext() && !e.MoveNext();
#endif
    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool Contains(T item)
    {
        if (!IsSingle(item))
            return false;
        And(_value, ref item);
        return !EqZero(item);
    }
    /// <inheritdoc cref="ISet{T}.IsProperSubsetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsProperSubsetOf([InstantHandle] IEnumerable<T> other)
    {
        T t = default;
        var collection = other.ToICollection();
        foreach (var next in this)
            if (collection.Contains(next))
                Or(next, ref t);
            else
                return false;
        foreach (var next in collection)
            if (!Contains(next))
                return true;
        return false;
    }
    /// <inheritdoc cref="ISet{T}.IsProperSupersetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsProperSupersetOf([InstantHandle] IEnumerable<T> other)
    {
        T t = default;
        foreach (var next in other)
            if (Contains(next))
                Or(next, ref t);
            else
                return false;
        return !Eq(_value, t);
    }
    /// <inheritdoc cref="ISet{T}.IsSubsetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsSubsetOf([InstantHandle] IEnumerable<T> other)
    {
        var collection = other.ToICollection();
        return this.All(collection.Contains);
    }
    /// <inheritdoc cref="ISet{T}.IsSupersetOf" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool IsSupersetOf([InstantHandle] IEnumerable<T> other) => other.All(Contains);
    /// <inheritdoc cref="ISet{T}.Overlaps" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool Overlaps([InstantHandle] IEnumerable<T> other) => other.Any(Contains);
    /// <inheritdoc cref="ISet{T}.SetEquals" />
    [CollectionAccess(CollectionAccessType.Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public bool SetEquals([InstantHandle] IEnumerable<T> other)
    {
        T t = default;
        foreach (var next in other)
            if (IsSingle(next))
                Or(next, ref t);
            else
                return false;
        return Eq(_value, t);
    }
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly RedundantReadonlyModifier
#pragma warning disable 8500, IDE0251, MA0102
/// <summary>Extension methods that act as factories for <see cref="Bits{T}"/>.</summary>
    /// <summary>Creates the <see cref="Bits{T}"/> from the item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Bits{T}"/> instance with the parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Bits<T> AsBits<T>(this T source)
#if KTANE
        where T : struct
#else
        where T : unmanaged
#endif
        =>
            source;
    /// <summary>Computes the Bitwise-AND of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseAnd<T>(this IEnumerable<T> source)
#if KTANE
        where T : struct
#else
        where T : unmanaged
#endif
    {
        T t = default;
        foreach (var next in source)
            Bits<T>.And(next, ref t);
        return t;
    }
    /// <summary>Computes the Bitwise-AND-NOT of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseAndNot<T>(this IEnumerable<T> source)
#if KTANE
        where T : struct
#else
        where T : unmanaged
#endif
    {
        T t = default;
        foreach (var next in source)
            Bits<T>.AndNot(next, ref t);
        return t;
    }
#if !(NETFRAMEWORK && !NET45_OR_GREATER || NETSTANDARD1_0)
    /// <summary>Returns the reference that contains the most bits.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the most bits of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseMax<T>(this IEnumerable<T> source)
        where T : unmanaged =>
        source.Aggregate(default(T), (acc, next) => Bits<T>.Max(acc, next));
    /// <summary>Returns the reference that contains the least bits.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the least bits of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseMin<T>(this IEnumerable<T> source)
        where T : unmanaged =>
        source.Aggregate(default(T), (acc, next) => Bits<T>.Min(acc, next));
#endif
    /// <summary>Computes the Bitwise-OR of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseOr<T>(this IEnumerable<T> source)
#if KTANE
        where T : struct
#else
        where T : unmanaged
#endif
    {
        T t = default;
        foreach (var next in source)
            Bits<T>.Or(next, ref t);
        return t;
    }
    /// <summary>Computes the Bitwise-XOR of the <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The value <typeparamref name="T"/> containing the Bitwise-OR of <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T BitwiseXor<T>(this IEnumerable<T> source)
#if KTANE
        where T : struct
#else
        where T : unmanaged
#endif
    {
        T t = default;
        foreach (var next in source)
            Bits<T>.Xor(next, ref t);
        return t;
    }
/// <summary>Provides the enumeration of individual bits from the given <typeparamref name="T"/>.</summary>
/// <typeparam name="T">The type of the item to yield.</typeparam>
/// <param name="bits">The item to use.</param>
[StructLayout(LayoutKind.Auto)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Bits<T>([ProvidesContext] T bits) : IReadOnlyList<T>, IReadOnlySet<T>, ISet<T>, IList<T>
#if KTANE
    where T : struct
#else
    where T : unmanaged
#endif
{
    static readonly unsafe int s_nativeSize = sizeof(nuint) * BitsInByte, s_typeSize = sizeof(T) * BitsInByte;
    readonly T _value = bits;
    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    bool ICollection<T>.IsReadOnly
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => true;
    }
    /// <summary>Gets the item to use.</summary>
    [CollectionAccess(Read), ProvidesContext]
    public readonly T Current
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
    }
    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Bits{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator Bits<T>([ProvidesContext] Enumerator value) => value.Current;
    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Bits{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator Bits<T>([ProvidesContext] T value) => new(value);
    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator Enumerator([ProvidesContext] Bits<T> value) => value.Current;
    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator T(Bits<T> value) => value.Current;
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void CopyTo(T[] array, int arrayIndex)
    {
        foreach (var next in this)
            array[arrayIndex++] = next;
    }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ICollection<T>.Add(T item) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ICollection<T>.Clear() { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void IList<T>.Insert(int index, T item) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void IList<T>.RemoveAt(int index) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.ExceptWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.IntersectWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.SymmetricExceptWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ISet<T>.UnionWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    bool ICollection<T>.Remove(T item) => false;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    bool ISet<T>.Add(T item) => false;
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int IndexOf(T item)
    {
        if ((Enumerator)item is var e && !e.MoveNext() ||
            e.Mask is var mask && e.Index is var index && e.MoveNext())
            return -1;
        var that = (Enumerator)this;
        for (var i = 0; that.MoveNext(); i++)
            if (that.Mask == mask && that.Index == index)
                return i;
            else if (that.Mask > mask || that.Index > index)
                return -1;
        return -1;
    }
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() => ((Enumerator)this).ToRemainingString();
    /// <summary>
    /// Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
    /// </summary>
    /// <returns>Itself.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    public readonly Enumerator GetEnumerator() => _value;
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
#pragma warning disable DOC100
    /// <summary>Reinterprets the bits in <see cref="Current"/> as <typeparamref name="TResult"/>.</summary>
    /// <remarks><para>
    /// If the type <typeparamref name="TResult"/> is smaller than <typeparamref name="T"/>,
    /// the result is truncated to the left. Otherwise, if the type <typeparamref name="TResult"/>
    /// is larger than <typeparamref name="T"/>, the result is zero-padded to the left.
    /// </para>
    /// <example>
    /// <para>Visual description of how the coercion works:</para>
    /// <code lang="C#"><![CDATA[
    /// var bits = ((ushort)0b0101_0110).AsBits();
    /// var padding = bits.Coerce<int>();
    /// var truncation = bits.Coerce<byte>();
    /// ]]></code></example></remarks>
    /// <typeparam name="TResult">The type to reinterpret the bits as.</typeparam>
    /// <returns>The result of reinterpreting <see cref="Current"/> as <typeparamref name="TResult"/>.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public unsafe TResult Coerce<TResult>()
#if KTANE
        where TResult : struct
#else
        where TResult : unmanaged
#endif
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static TResult Copy(T value)
        {
            TResult ret = default;
            *(T*)&ret = value;
            return ret;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static TResult Read(T value) => *(TResult*)&value;
        return sizeof(T) >= sizeof(TResult) ? Read(_value) : Copy(_value);
    }
    /// <summary>Reinterprets the bits in <see cref="Current"/> as <typeparamref name="TResult"/>.</summary>
    /// <remarks><para>
    /// If the type <typeparamref name="TResult"/> is smaller than <typeparamref name="T"/>,
    /// the result is truncated to the right. Otherwise, if the type <typeparamref name="TResult"/>
    /// is larger than <typeparamref name="T"/>, the result is zero-padded to the right.
    /// </para>
    /// <example>
    /// <para>Visual description of how the coercion works:</para>
    /// <code lang="C#"><![CDATA[
    /// var bits = ((ushort)0b0101_0110).AsBits();
    /// var padding = bits.Coerce<int>();
    /// var truncation = bits.Coerce<byte>();
    /// ]]></code></example></remarks>
    /// <typeparam name="TResult">The type to reinterpret the bits as.</typeparam>
    /// <returns>The result of reinterpreting <see cref="Current"/> as <typeparamref name="TResult"/>.</returns>
#pragma warning restore DOC100
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public unsafe TResult CoerceLeft<TResult>()
#if KTANE
        where TResult : struct
#else
        where TResult : unmanaged
#endif
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static TResult Copy(T value)
        {
            TResult ret = default;
            ((T*)(&ret + 1))[-1] = value;
            return ret;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static TResult Read(T value) => ((TResult*)(&value + 1))[-1];
        return sizeof(T) == sizeof(TResult) ? Coerce<TResult>() :
            sizeof(T) > sizeof(TResult) ? Read(_value) : Copy(_value);
    }
    /// <summary>An enumerator over <see cref="Bits{T}"/>.</summary>
    /// <param name="value">The item to use.</param>
    [StructLayout(LayoutKind.Auto)]
    public partial struct Enumerator(T value) : IEnumerator<T>
    {
        const int Start = -1;
        readonly T _value = value;
        /// <summary>Gets the current mask.</summary>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public nuint Mask
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] private set;
        }
        /// <summary>Gets the current index.</summary>
        [CLSCompliant(false), CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public nint Index
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] private set;
        } = Start;
        /// <summary>Gets the reconstruction of the original enumerable that can create this instance.</summary>
        [CollectionAccess(Read)]
        public readonly Bits<T> AsBits
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
        }
        /// <summary>Gets the underlying value that is being enumerated.</summary>
        [CollectionAccess(Read)]
        public readonly T AsValue
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _value;
        }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public readonly unsafe T Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get
            {
                T t = default;
                *((nuint*)&t + Index) ^= Mask;
                return t;
            }
        }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        readonly object IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Current;
        }
        /// <summary>Implicitly calls the constructor.</summary>
        /// <param name="value">The value to pass into the constructor.</param>
        /// <returns>A new instance of <see cref="Enumerator"/> with <paramref name="value"/> passed in.</returns>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static implicit operator Enumerator(T value) => new(value);
        /// <summary>Implicitly calls <see cref="Current"/>.</summary>
        /// <param name="value">The value to call <see cref="Current"/>.</param>
        /// <returns>The value that was passed in to this instance.</returns>
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static explicit operator T(Enumerator value) => value.Current;
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly void IDisposable.Dispose() { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset()
        {
            Index = Start;
            Mask = 0;
        }
        /// <inheritdoc />
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe bool MoveNext()
        {
            Mask <<= 1;
            if (Mask is 0)
            {
                Index++;
                Mask++;
            }
            fixed (T* ptr = &_value)
                if (sizeof(T) / sizeof(nuint) is not 0 && FindNativelySized(ptr) ||
                    sizeof(T) % sizeof(nuint) is not 0 && FindRest(ptr))
                    return true;
            Index = sizeof(T) / sizeof(nuint);
            Mask = FalsyMask();
            return false;
        }
        /// <inheritdoc />
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public readonly override string ToString()
        {
            var that = this;
            return that.ToRemainingString();
        }
        /// <summary>Enumerates over the remaining elements to give a <see cref="string"/> result.</summary>
        /// <returns>The <see cref="string"/> result of this instance.</returns>
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
        public unsafe string ToRemainingString()
        {
            var ptr = stackalloc char[s_typeSize];
            new Span<char>(ptr, s_typeSize).Fill('0');
            var last = ptr + s_typeSize - 1;
            while (MoveNext())
                *(last - (int)(Index * s_nativeSize) - TrailingZeroCount(Mask)) ^= '\x01';
            return new(ptr, 0, s_typeSize);
        }
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static nuint FalsyMask() => (nuint)1 << s_nativeSize - 2;
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static unsafe nuint LastRest() => ((nuint)1 << sizeof(T) % sizeof(nuint) * BitsInByte) - 1;
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        unsafe bool FindNativelySized(T* ptr)
        {
            if (Index < 0)
                return false;
            for (; Index < sizeof(T) / sizeof(nuint); Index++, Mask = 1)
                for (; Mask is not 0; Mask <<= 1)
                    if (IsNonZero(ptr))
                        return true;
            return false;
        }
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        unsafe bool FindRest(T* ptr)
        {
            if (Index != sizeof(T) / sizeof(nuint))
                return false;
            for (; (Mask & LastRest()) is not 0; Mask <<= 1)
                if (IsNonZero(ptr))
                    return true;
            return false;
        }
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        unsafe bool IsNonZero(T* ptr) => (((nuint*)ptr)[Index] & Mask) is not 0;
    }
}
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly
/// <summary>Extension methods that act as factories for <see cref="Once{T}"/>.</summary>
    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> Yield<T>(this T source, bool condition = true) => condition ? source : [];
    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> Yield<T>(this T source, Func<bool> condition) => condition() ? source : [];
    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <param name="condition">The condition that must be true for <paramref name="source"/> to be used.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> Yield<T>(this T source, Predicate<T> condition) => condition(source) ? source : [];
    /// <summary>Creates a <see cref="Once{T}"/> from an item if it isn't null.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> YieldValued<T>(this T? source)
        where T : class =>
        source is null ? [] : source;
    /// <summary>Creates a <see cref="Once{T}"/> from an item if it isn't null.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
    [Pure]
    public static Once<T> YieldValued<T>(this T? source)
        where T : struct =>
        source.HasValue ? source.Value : [];
/// <summary>A factory for creating iterator types that yields an item once.</summary>
/// <typeparam name="T">The type of the item to yield.</typeparam>
/// <param name="value">The item to use.</param>
[StructLayout(LayoutKind.Auto)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    partial struct Once<T>([ProvidesContext] T value) : IComparable<Once<T>>,
    IEquatable<Once<T>>,
    IList<T>,
    IOrderedEnumerable<T>,
    IReadOnlyList<T>,
    IReadOnlySet<T>,
    ISet<T>
{
    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ICollection<T>.IsReadOnly => true;
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    int IReadOnlyCollection<T>.Count => HasValue ? 1 : 0;
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    int ICollection<T>.Count => HasValue ? 1 : 0;
    /// <summary>Gets a value indicating whether this is a default value.</summary>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public bool HasValue { get; } = true;
    /// <summary>Gets the item to use.</summary>
    [CollectionAccess(Read), ProvidesContext, Pure]
    public T Current => value;
    /// <inheritdoc cref="IList{T}.this"/>
    [Pure]
    T IList<T>.this[int _]
    {
        [CollectionAccess(Read)] get => value;
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)] set { }
    }
    /// <inheritdoc cref="IList{T}.this[int]"/>
    [CollectionAccess(Read), Pure]
    T IReadOnlyList<T>.this[int _] => value;
    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Once{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public static explicit operator Once<T>([ProvidesContext] Enumerator value) => value.Current;
    /// <summary>Implicitly calls the constructor.</summary>
    /// <param name="value">The value to pass into the constructor.</param>
    /// <returns>A new instance of <see cref="Once{T}"/> with <paramref name="value"/> passed in.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public static implicit operator Once<T>([ProvidesContext] T value) => new(value);
    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    public static implicit operator Enumerator([ProvidesContext] Once<T> value) => value.Current;
    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
    /// <param name="value">The value to call <see cref="Current"/>.</param>
    /// <returns>The value that was passed in to this instance.</returns>
    [CollectionAccess(Read), Pure]
    public static implicit operator T(Once<T> value) => value.Current;
    /// <summary>Determines whether both items are equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both items are equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(Once<T> left, Once<T> right) => left.Equals(right);
    /// <summary>Determines whether both items are unequal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both items are not unequal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(Once<T> left, Once<T> right) => !left.Equals(right);
    /// <summary>Determines whether the left-hand side is greater than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left-hand side is greater than the right.</returns>
    public static bool operator >(Once<T> left, Once<T> right) => left.CompareTo(right) > 0;
    /// <summary>Determines whether the left-hand side is greater than or equal to the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left-hand side is greater than or equal to the right.</returns>
    public static bool operator >=(Once<T> left, Once<T> right) => left.CompareTo(right) >= 0;
    /// <summary>Determines whether the left-hand side is less than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left-hand side is less than the right.</returns>
    public static bool operator <(Once<T> left, Once<T> right) => left.CompareTo(right) < 0;
    /// <summary>Determines whether the left-hand side is less than or equal to than the right.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the left-hand side is less than or equal to than the right.</returns>
    public static bool operator <=(Once<T> left, Once<T> right) => left.CompareTo(right) <= 0;
    /// <inheritdoc />
    [CollectionAccess(Read)]
    public void CopyTo(T[] array, int arrayIndex) => array[arrayIndex] = value;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ICollection<T>.Add(T? item) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ICollection<T>.Clear() { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IList<T>.Insert(int index, T? item) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void IList<T>.RemoveAt(int index) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.ExceptWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.IntersectWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.SymmetricExceptWith(IEnumerable<T>? other) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    void ISet<T>.UnionWith(IEnumerable<T>? other) { }
    /// <inheritdoc cref="ICollection{T}.Contains"/>
    [CollectionAccess(Read), Pure]
    public bool Contains(T item) => EqualityComparer<T>.Default.Equals(value, item);
    /// <inheritdoc cref="ISet{T}.IsProperSubsetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsProperSubsetOf([InstantHandle] IEnumerable<T> other) =>
        HasValue
            ? other.Any()
            : other.ToICollection() is { Count: > 1 } c && Overlaps(c);
    /// <inheritdoc cref="ISet{T}.IsProperSupersetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsProperSupersetOf([InstantHandle] IEnumerable<T> other) => HasValue && !other.Any();
    /// <inheritdoc cref="ISet{T}.IsSubsetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsSubsetOf([InstantHandle] IEnumerable<T> other) => !HasValue || Overlaps(other);
    /// <inheritdoc cref="ISet{T}.IsSupersetOf" />
    [CollectionAccess(Read), Pure]
    public bool IsSupersetOf([InstantHandle] IEnumerable<T> other) =>
        !HasValue || other.ToICollection() is { Count: <= 1 } c && Overlaps(c);
    /// <inheritdoc cref="ISet{T}.Overlaps" />
    [CollectionAccess(Read), Pure]
    public bool Overlaps([InstantHandle] IEnumerable<T> other) => other.Contains(value);
    /// <inheritdoc cref="ISet{T}.SetEquals" />
    [CollectionAccess(Read), Pure]
    public bool SetEquals([InstantHandle] IEnumerable<T> other) => HasValue ? !other.Any() : other.SequenceEqual(this);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ICollection<T>.Remove(T? item) => false;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    bool ISet<T>.Add(T? item) => false;
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public override bool Equals(object? other) => other is Once<T> once && Equals(once);
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public bool Equals(Once<T> other) => EqualityComparer<T>.Default.Equals(value, other);
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public int CompareTo(Once<T> other) => Comparer<T>.Default.Compare(value, other.Current);
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public override int GetHashCode() =>
        value is null ? -2 : unchecked(EqualityComparer<T>.Default.GetHashCode(value) * 37);
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public int IndexOf(T item) => Contains(item) ? 0 : -1;
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public override string ToString() => value?.ToString() ?? "";
    /// <summary>
    /// Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
    /// </summary>
    /// <returns>Itself.</returns>
    [CollectionAccess(Read), MustDisposeResource(false), Pure]
    public Enumerator GetEnumerator() => HasValue ? new(value) : default;
    /// <inheritdoc />
    [CollectionAccess(Read), MustDisposeResource(false), Pure]
    IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(Read), MustDisposeResource(false), Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MustDisposeResource(false), Pure]
    IOrderedEnumerable<T> IOrderedEnumerable<T>.CreateOrderedEnumerable<TKey>(
        Func<T, TKey> keySelector,
        IComparer<TKey>? comparer,
        bool descending
    ) =>
        this;
    /// <summary>An enumerator over <see cref="Once{T}"/>.</summary>
    /// <param name="value">The item to use.</param>
    [StructLayout(LayoutKind.Auto)]
    public partial struct Enumerator(T value) : IEnumerator<T>
    {
        static readonly object s_fallback = new();
        readonly bool _hasValue = true;
        bool _canMove = true;
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public readonly T Current => value;
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        readonly object IEnumerator.Current => value ?? s_fallback;
        /// <summary>Implicitly calls the constructor.</summary>
        /// <param name="value">The value to pass into the constructor.</param>
        /// <returns>A new instance of <see cref="Once{T}"/> with <paramref name="value"/> passed in.</returns>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
        public static implicit operator Enumerator(T value) => new(value);
        /// <summary>Implicitly calls <see cref="Current"/>.</summary>
        /// <param name="value">The value to call <see cref="Current"/>.</param>
        /// <returns>The value that was passed in to this instance.</returns>
        [CollectionAccess(Read), Pure]
        public static explicit operator T(Enumerator value) => value.Current;
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        readonly void IDisposable.Dispose() { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public bool MoveNext() => _canMove && !(_canMove = false);
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        public void Reset() => _canMove = _hasValue;
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for read-only lists.</summary>
    /// <summary>Encapsulates an <see cref="IList{T}"/> and make all mutating methods a no-op.</summary>
    /// <typeparam name="T">The type of element in the list.</typeparam>
    /// <param name="list">The list to encapsulate.</param>
    sealed partial class ReadOnlyList<T>([ProvidesContext] IList<T> list) : IList<T>, IReadOnlyList<T>
    {
        /// <inheritdoc />
        [Pure]
        public bool IsReadOnly => true;
        /// <inheritdoc cref="ICollection{T}.Count"/>
        [CollectionAccess(Read), Pure]
        public int Count => list.Count;
        /// <inheritdoc cref="IList{T}.this" />
        [Pure]
        public T this[int index]
        {
            [CollectionAccess(Read)] get => list[index];
            [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)] set { }
        }
        /// <inheritdoc />
        [CollectionAccess(Read)]
        public void CopyTo(T[] array, int arrayIndex) => list.CopyTo(array, arrayIndex);
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        void ICollection<T>.Add(T? item) { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        void ICollection<T>.Clear() { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        void IList<T>.Insert(int index, T? item) { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        void IList<T>.RemoveAt(int index) { }
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public bool Contains(T item) => list.Contains(item);
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
        bool ICollection<T>.Remove(T? item) => false;
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public int IndexOf(T item) => list.IndexOf(item);
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public IEnumerator<T> GetEnumerator() => list.GetEnumerator();
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public override string ToString() => list.ToString() ?? "";
    }
    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to a read-only list.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a read-only list.</param>
    /// <returns>A read-only list of <paramref name="iterable"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IReadOnlyList<T>? ReadOnly<T>(this IEnumerable<T>? iterable) =>
        iterable is null
            ? null
            : iterable as IReadOnlyList<T> ?? new ReadOnlyList<T>(iterable as IList<T> ?? [.. iterable]);
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace StructCanBeMadeReadOnly
/// <summary>Extension methods that act as factories for <see cref="Yes{T}"/>.</summary>
    /// <summary>A factory for creating iterator types that yield the same item forever.</summary>
    /// <typeparam name="T">The type of the item to yield.</typeparam>
    /// <param name="value">The item to use.</param>
    [StructLayout(LayoutKind.Auto)]
    public
#if !NO_READONLY_STRUCTS
        readonly
#endif
        partial struct Yes<T>([ProvidesContext] T value) : IEnumerable<T>, IEnumerator<T>
    {
        /// <inheritdoc />
        [CollectionAccess(Read), ProvidesContext, Pure]
        public T Current => value;
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        object IEnumerator.Current => value ?? new object();
        /// <summary>Implicitly calls the constructor.</summary>
        /// <param name="value">The value to pass into the constructor.</param>
        /// <returns>A new instance of <see cref="Yes{T}"/> with <paramref name="value"/> passed in.</returns>
        [CollectionAccess(Read), Pure]
        public static implicit operator Yes<T>([ProvidesContext] T value) => new(value);
        /// <summary>Implicitly calls <see cref="Current"/>.</summary>
        /// <param name="value">The value to call <see cref="Current"/>.</param>
        /// <returns>The value that was passed in to this instance.</returns>
        [CollectionAccess(Read), Pure]
        public static implicit operator T(Yes<T> value) => value.Current;
        /// <summary>Returns itself.</summary>
        /// <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="Yes{T}"/>.</para></remarks>
        /// <returns>Itself.</returns>
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MustDisposeResource(false), Pure]
        public Yes<T> GetEnumerator() => this;
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        void IDisposable.Dispose() { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
        void IEnumerator.Reset() { }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
        bool IEnumerator.MoveNext() => true;
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MustDisposeResource(false), Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MustDisposeResource(false), Pure]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
    }
    /// <summary>Creates a <see cref="Yes{T}"/> from an item.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="source">The item.</param>
    /// <returns>The <see cref="Yes{T}"/> instance that can be yielded forever.</returns>
    [Pure]
    public static Yes<T> Forever<T>(this T source) => source;
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable UnusedMember.Local
// ReSharper disable once CheckNamespace
#pragma warning disable 8619
/// <summary>Extension methods for improving nullability awareness for enumerables.</summary>
    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="iterable">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IEnumerable<T?>? ItemCanBeNull<T>(this IEnumerable<T>? iterable) => iterable;
    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="iterator">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="iterator"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterator))]
    public static IEnumerator<T?>? ItemCanBeNull<T>(this IEnumerator<T>? iterator) => iterator;
    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="collection">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(collection))]
    public static IReadOnlyCollection<T?>? ItemCanBeNull<T>(this IReadOnlyCollection<T>? collection) => collection;
    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="list">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(list))]
    public static IReadOnlyList<T?>? ItemCanBeNull<T>(this IReadOnlyList<T>? list) => list;
    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
    /// <param name="set">The item to return with adjusted nullability.</param>
    /// <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(set))]
    public static IReadOnlySet<T?>? ItemCanBeNull<T>(this IReadOnlySet<T>? set) => set;
    /// <summary>Returns the list if all items are non-null.</summary>
    /// <typeparam name="T">The type of list.</typeparam>
    /// <param name="list">The list to filter.</param>
    /// <returns>
    /// The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
    /// otherwise <see langword="null"/>.
    /// </returns>
    [Pure]
    public static IList<T>? ItemNotNull<T>(this IList<T?>? list)
    {
        if (list is null)
            return null;
        for (var i = 0; i < list.Count; i++)
            if (list[i] is null)
                return null;
        return list;
    }
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
#pragma warning disable IDE0180
/// <summary>Extension methods for randomized getters.</summary>
    /// <summary>Shuffles a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to shuffle.</param>
    /// <param name="selector">The indices to swap with, when left unspecified, uses <see cref="Rand"/>.</param>
    /// <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
    public static IList<T> Shuffle<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<int, int, int>? selector = null
    )
    {
        selector ??= Rand();
        var list = iterable.ToIList();
        for (var j = list.Count; j >= 1; j--)
        {
            var item = selector(0, j);
            if (item >= j - 1)
                continue;
            var t = list[item];
            list[item] = list[j - 1];
            list[j - 1] = t;
        }
        return list;
    }
    /// <inheritdoc cref="Shuffle{T}(IEnumerable{T}, Func{int, int, int})" />
    public static Span<T> Shuffle<T>(this Span<T> iterable, [InstantHandle] Func<int, int, int>? selector = null)
    {
        selector ??= Rand();
        for (var j = iterable.Length; j >= 1; j--)
        {
            var item = selector(0, j);
            if (item >= j - 1)
                continue;
            var t = iterable[item];
            iterable[item] = iterable[j - 1];
            iterable[j - 1] = t;
        }
        return iterable;
    }
    /// <summary>Shuffles a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to shuffle.</param>
    /// <param name="selector">The indices to swap with, when left unspecified, uses <see cref="Rand"/>.</param>
    /// <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
    [MustUseReturnValue]
    public static T PickRandom<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<int, int, int>? selector = null
    )
    {
        static T Fallback([InstantHandle] IEnumerable<T> iterable, [InstantHandle] Func<int, int, int> selector)
        {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
            using var list = iterable.ToPooledSmallList();
            return list[selector(0, list.Length)];
#else
            var list = iterable.ToList();
            return list[selector(0, list.Count)]
#endif
        }
        selector ??= Rand();
        return iterable switch
        {
            IList<T> list => list[selector(0, list.Count)],
            IReadOnlyList<T> list => list[selector(0, list.Count)],
            _ when iterable.TryCount() is { } count => iterable.ElementAt(selector(0, count)),
            _ => Fallback(iterable, selector),
        };
    }
    /// <inheritdoc cref="PickRandom{T}(IEnumerable{T}, Func{int, int, int})" />
    [MustUseReturnValue]
    public static T PickRandom<T>([InstantHandle] this scoped Span<T> iterable, Func<int, int, int>? selector = null) =>
        iterable.ReadOnly().PickRandom(selector);
    /// <inheritdoc cref="PickRandom{T}(IEnumerable{T}, Func{int, int, int})" />
    [MustUseReturnValue]
    public static T PickRandom<T>(
        [InstantHandle] this scoped ReadOnlySpan<T> iterable,
        Func<int, int, int>? selector = null
    )
    {
        selector ??= Rand();
        return iterable[selector(0, iterable.Length)];
    }
    [Pure]
    static Func<int, int, int> Rand() =>
#if KTANE
        UnityEngine.Random.Range;
#elif NET6_0_OR_GREATER
        Random.Shared.Next;
#else
        new Random().Next;
#endif
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NETSTANDARD1_0
// ReSharper disable BadPreprocessorIndent CheckNamespace StructCanBeMadeReadOnly
#pragma warning disable 8500
/// <summary>Provides methods for determining similarity between two sequences.</summary>
    const string E = "Value must be non-negative and less than the length.";
    const StringComparison DefaultCharComparer = StringComparison.Ordinal;
    /// <summary>Calculates the Jaro similarity between two strings.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro(this string? left, string? right) =>
        string.Equals(left, right, DefaultCharComparer) ? 1 : left.Jaro(right, EqualityComparer<char>.Default);
    /// <summary>Calculates the Jaro similarity between two strings.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro(this string? left, string? right, [InstantHandle] Func<char, char, bool>? comparer) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        Jaro(left, right, static x => x.Length, static (x, i) => x[i], comparer);
    /// <summary>Calculates the Jaro similarity between two strings.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro(this string? left, string? right, IEqualityComparer<char>? comparer) =>
        left.Jaro(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
    /// <remarks><para>Like <see cref="Jaro(string, string)"/>, but with a bias to common sub-slices.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik(this string? left, string? right) =>
        string.Equals(left, right, DefaultCharComparer) ? 1 : left.JaroEmik(right, EqualityComparer<char>.Default);
    /// <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, Func{char, char, bool})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik(this string? left, string? right, [InstantHandle] Func<char, char, bool>? comparer) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        JaroEmik(left, right, static x => x.Length, static (x, i) => x[i], comparer);
    /// <summary>Calculates the Jaro-Emik similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, IEqualityComparer{char})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik(this string? left, string? right, IEqualityComparer<char>? comparer) =>
        left.JaroEmik(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
    /// <remarks><para>Like <see cref="Jaro(string, string)"/>, but with a bias to common prefixes.</para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler(this string? left, string? right) =>
        string.Equals(left, right, DefaultCharComparer) ? 1 : left.JaroWinkler(right, EqualityComparer<char>.Default);
    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, Func{char, char, bool})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler(
        this string? left,
        string? right,
        [InstantHandle] Func<char, char, bool>? comparer
    ) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        JaroWinkler(left, right, static x => x.Length, static (x, i) => x[i], comparer);
    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro(string, string, IEqualityComparer{char})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler(
        this string? left,
        string? right,
        IEqualityComparer<char>? comparer
    ) =>
        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this IList<T>? left, IList<T>? right) => left.Jaro(right, EqualityComparer<T>.Default);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this IList<T>? left, IList<T>? right, [InstantHandle] Func<T, T, bool>? comparer) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        Jaro(left, right, static x => x.Count, static (x, i) => x[i], comparer);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
        left.Jaro(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(this IList<T>? left, IList<T>? right) =>
        left.Jaro(right, EqualityComparer<T>.Default);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, Func{T, T, bool})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this IList<T>? left,
        IList<T>? right,
        [InstantHandle] Func<T, T, bool>? comparer
    ) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        Jaro(left, right, static x => x.Count, static (x, i) => x[i], comparer);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, IEqualityComparer{T})"/>, but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
        left.Jaro(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right) =>
        left.JaroWinkler(right, EqualityComparer<T>.Default);
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, Func{T, T, bool})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this IList<T>? left,
        IList<T>? right,
        [InstantHandle] Func<T, T, bool>? comparer
    ) =>
        ReferenceEquals(left, right) ? 1 :
        left is null || right is null ? 0 :
        JaroWinkler(left, right, static x => x.Count, static (x, i) => x[i], comparer);
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, IEqualityComparer{T})"/>, but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.Jaro(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(this scoped Span<T> left, scoped ReadOnlySpan<T> right, IEqualityComparer<T>? comparer)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.ReadOnly().Jaro(right, comparer);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static unsafe double Jaro<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var l = left.Pointer;
        var r = right.Pointer;
#else
        fixed (T* l = left)
        fixed (T* r = right)
#endif
            return Jaro(
                new Fat<T>(l, left.Length),
                new(r, right.Length),
                static x => x.Length,
                static (x, i) => x[i],
                comparer
            );
    }
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double Jaro<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.ReadOnly().Jaro(right, comparer);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.JaroEmik(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.ReadOnly().JaroEmik(right, comparer);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static unsafe double JaroEmik<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var l = left.Pointer;
        var r = right.Pointer;
#else
        fixed (T* l = left)
        fixed (T* r = right)
#endif
            return JaroEmik(
                new Fat<T>(l, left.Length),
                new(r, right.Length),
                static x => x.Length,
                static (x, i) => x[i],
                comparer
            );
    }
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroEmik<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.ReadOnly().JaroEmik(right, comparer);
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.JaroWinkler(right, comparer is null ? null : comparer.Equals);
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        IEqualityComparer<T>? comparer
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.ReadOnly().JaroWinkler(right, comparer);
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static unsafe double JaroWinkler<T>(
        this scoped ReadOnlySpan<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
        var l = left.Pointer;
        var r = right.Pointer;
#else
        fixed (T* l = left)
        fixed (T* r = right)
#endif
            return JaroWinkler(
                new Fat<T>(l, left.Length),
                new(r, right.Length),
                static x => x.Length,
                static (x, i) => x[i],
                comparer
            );
    }
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T}(Span{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [Pure, ValueRange(0, 1)]
    public static double JaroWinkler<T>(
        this scoped Span<T> left,
        scoped ReadOnlySpan<T> right,
        [InstantHandle] Func<T, T, bool>? comparer = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            left.ReadOnly().JaroWinkler(right, comparer);
    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="counter">The function that gets the count.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double Jaro<T, TItem>(
        T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        Jaro(left, right, counter(left), counter(right), indexer, comparer);
    /// <summary>Calculates the Jaro similarity between two instances.</summary>
    /// <typeparam name="T">The type of instance.</typeparam>
    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="leftLength">The left-hand side's length.</param>
    /// <param name="rightLength">The right-hand side's length.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double Jaro<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        JaroInner(left, right, leftLength, rightLength, indexer, comparer ?? EqualityComparer<TItem>.Default.Equals);
    /// <summary>Calculates the Jaro-Emik similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, Func{T, int}, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="counter">The function that gets the count.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroEmik<T, TItem>(
        T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        JaroEmik(left, right, counter(left), counter(right), indexer, comparer);
    /// <summary>Calculates the Jaro-Emik similarity between two instances.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, int, int, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common sub-slices.
    /// </para></remarks>
    /// <typeparam name="T">The type of instance.</typeparam>
    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="leftLength">The left-hand side's length.</param>
    /// <param name="rightLength">The right-hand side's length.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroEmik<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    )
    {
        comparer ??= EqualityComparer<TItem>.Default.Equals;
        var jaro = JaroInner(left, right, leftLength, rightLength, indexer, comparer);
        if (leftLength is 0 || rightLength is 0)
            return jaro;
        var slice = Slice(left, right, leftLength, rightLength, indexer, comparer) * Grade(leftLength, rightLength);
        return Math.Max(jaro, slice);
    }
    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, Func{T, int}, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="counter">The function that gets the count.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroWinkler<T, TItem>(
        T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    ) =>
        JaroWinkler(left, right, counter(left), counter(right), indexer, comparer);
    /// <summary>Calculates the Jaro-Winkler similarity between two instances.</summary>
    /// <remarks><para>
    /// Like <see cref="Jaro{T, TItem}(T, T, int, int, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
    /// but with a bias to common prefixes.
    /// </para></remarks>
    /// <typeparam name="T">The type of instance.</typeparam>
    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <param name="leftLength">The left-hand side's length.</param>
    /// <param name="rightLength">The right-hand side's length.</param>
    /// <param name="indexer">The function that acts as an indexer.</param>
    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
    [MustUseReturnValue, ValueRange(0, 1)]
    public static double JaroWinkler<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
    )
    {
        comparer ??= EqualityComparer<TItem>.Default.Equals;
        var jaroDistance = JaroInner(left, right, leftLength, rightLength, indexer, comparer);
        var prefixLength = NumberOfEquals(left, right, leftLength, rightLength, indexer, comparer);
        var distance = JaroWinklerDistance(jaroDistance, prefixLength);
        return Math.Min(distance, 1);
    }
    [MustUseReturnValue, ValueRange(0, 1)]
    static double JaroAllocated<T, TItem>(
        scoped Span<byte> visited,
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    )
    {
        int rightPreviousIndex = 0, transpositionCount = 0;
        double matchCount = 0;
        visited.Clear();
        for (var i = 0; i < leftLength; i++)
            if (InBounds(leftLength, rightLength, i))
                rightPreviousIndex = Next(
                    visited,
                    left,
                    right,
                    leftLength,
                    rightLength,
                    i,
                    rightPreviousIndex,
                    comparer,
                    indexer,
                    ref matchCount,
                    ref transpositionCount
                );
        return matchCount is 0 ? 0 : JaroDistance(leftLength, rightLength, matchCount, transpositionCount);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, ValueRange(0, 1)]
    static double JaroInner<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    )
    {
        if (leftLength is 0 || rightLength is 0)
            return (leftLength is 0 && rightLength is 0).ToByte();
        if (leftLength is 1 && rightLength is 1)
            return EqualsAt(left, right, 0, 0, comparer, indexer).ToByte();
        using var _ = rightLength.Alloc<byte>(out var span);
        return JaroAllocated(span, left, right, leftLength, rightLength, indexer, comparer);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
    static int Next<T, TItem>(
        scoped Span<byte> visited,
        T left,
        T right,
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightPreviousIndex,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [NonNegativeValue] ref double matchCount,
        [NonNegativeValue] ref int transpositionCount
    )
    {
        for (var rightIndex = 0; rightIndex < rightLength; rightIndex++)
        {
            if (!ShouldProceed(visited, left, right, leftLength, rightLength, leftIndex, rightIndex, comparer, indexer))
                continue;
            visited[rightIndex]++;
            matchCount++;
            if (rightIndex < rightPreviousIndex)
                transpositionCount++;
            return rightIndex;
        }
        return rightPreviousIndex;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    static bool ShouldProceed<T, TItem>(
        Span<byte> visited,
        T leftLength,
        T rightLength,
        [ValueRange(2, int.MaxValue)] int aLen,
        [ValueRange(2, int.MaxValue)] int bLen,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightIndex,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer
    ) =>
        InBounds(aLen, bLen, leftIndex, rightIndex) &&
        visited[rightIndex] is 0 &&
        EqualsAt(leftLength, rightLength, leftIndex, rightIndex, comparer, indexer);
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    static bool EqualsAt<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightIndex,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer
    ) =>
        comparer(indexer(left, leftIndex), indexer(right, rightIndex));
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, ValueRange(0, 1)]
    static double Slice<T, TItem>(
        T left,
        T right,
        [NonNegativeValue] int leftLength,
        [NonNegativeValue] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    )
    {
        var score = 0;
        var isLeftSmaller = leftLength < rightLength;
        var small = isLeftSmaller ? left : right;
        var smallLength = isLeftSmaller ? leftLength : rightLength;
        var big = isLeftSmaller ? right : left;
        var bigLength = isLeftSmaller ? rightLength : leftLength;
        for (var i = 0; i < bigLength; i++)
        {
            var highestPossibleScore = Math.Min(bigLength - i - 1, smallLength);
            if (score >= highestPossibleScore)
                break;
            score = SliceInner(big, small, bigLength, smallLength, indexer, comparer, i, score);
        }
        return (double)score / smallLength;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
    static int SliceInner<T, TItem>(
        T big,
        T small,
        [NonNegativeValue] int bigLength,
        [NonNegativeValue] int smallLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer,
        [NonNegativeValue] int i,
        [NonNegativeValue] int score
    )
    {
        var lower = -1;
        for (var j = 0; j < smallLength && i + j < bigLength; j++)
            if (EqualsAt(big, small, i + j, j, comparer, indexer))
                score = Math.Max(score, j - lower);
            else
                lower = j;
        return score;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
    static int NumberOfEquals<T, TItem>(
        T left,
        T right,
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
        [InstantHandle] Func<TItem, TItem, bool> comparer
    )
    {
        var sharedLength = Math.Min(leftLength, rightLength);
        for (var sharedIndex = 0; sharedIndex < sharedLength; sharedIndex++)
            if (!EqualsAt(left, right, sharedIndex, sharedIndex, comparer, indexer))
                return sharedIndex;
        return sharedLength;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static bool InBounds(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex
    ) =>
        MinBound(leftLength, rightLength, leftIndex) <= MaxBound(leftLength, rightLength, leftIndex);
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static bool InBounds(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex,
        [NonNegativeValue] int rightIndex
    ) =>
        MinBound(leftLength, rightLength, leftIndex) <= rightIndex &&
        rightIndex <= MaxBound(leftLength, rightLength, leftIndex);
    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    static int MaxBound(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex
    ) =>
        Math.Min(SearchRange(leftLength, rightLength) + leftIndex, rightLength - 1);
    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    static int MinBound(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] int leftIndex
    ) =>
        SearchRange(leftLength, rightLength) < leftIndex
            ? Math.Max(0, leftIndex - SearchRange(leftLength, rightLength))
            : 0;
    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
    static int SearchRange(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength
    ) =>
        Math.Max(leftLength, rightLength) / 2 - 1;
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(0, 1)]
    static double JaroDistance(
        [ValueRange(2, int.MaxValue)] int leftLength,
        [ValueRange(2, int.MaxValue)] int rightLength,
        [NonNegativeValue] double matchCount,
        [NonNegativeValue] int transpositionCount
    ) =>
        1 / 3.0 * (matchCount / leftLength + matchCount / rightLength + (matchCount - transpositionCount) / matchCount);
    [MustUseReturnValue, ValueRange(0, 1)]
    static double Grade([NonNegativeValue] int leftLength, [NonNegativeValue] int rightLength) =>
        1 - 1.0 / Math.Min(leftLength + 1, rightLength + 1);
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(0, 1)]
    static double JaroWinklerDistance([ValueRange(0, 1)] double jaroDistance, [NonNegativeValue] int prefixLength) =>
        jaroDistance + 0.1 * prefixLength * (1.0 - jaroDistance);
    /// <summary>Represents a pointer with a length.</summary>
    [StructLayout(LayoutKind.Auto)]
#if !NO_READONLY_STRUCTS
    readonly
#endif
        unsafe partial struct Fat<T>(void* pointer, [NonNegativeValue] int length)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        /// <summary>Takes the element corresponding to the passed in index. A bounds check is performed.</summary>
        /// <param name="i">The index to take.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// The parameter <paramref name="i"/> is outside the range.
        /// </exception>
        public T this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
            get => (uint)i < (uint)Length ? ((T*)pointer)[i] : throw new ArgumentOutOfRangeException(nameof(i), i, E);
        }
        /// <summary>Gets the length.</summary>
        public int Length => length;
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Provides the deconstruction to extract the head and tail of a collection.</summary>
    /// <summary>Represents a list with no head.</summary>
    /// <typeparam name="T">The type of list to encapsulate.</typeparam>
    public sealed partial class HeadlessList<T>([ProvidesContext] IList<T> list) : IList<T>
    {
        /// <inheritdoc cref="IList{T}.this" />
        [CollectionAccess(Read), Pure]
        public T this[int index]
        {
            get => index is not -1 ? list[index + 1] : throw new ArgumentOutOfRangeException(nameof(index));
            set => list[index + 1] = index is not -1 ? value : throw new ArgumentOutOfRangeException(nameof(index));
        }
        /// <inheritdoc />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
        public bool IsReadOnly => list.IsReadOnly;
        /// <inheritdoc cref="ICollection{T}.Count" />
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
        public int Count => list.Count - 1;
        /// <inheritdoc />
        [CollectionAccess(UpdatedContent)]
        public void Add(T item) => list.Add(item);
        /// <inheritdoc />
        [CollectionAccess(ModifyExistingContent)]
        public void Clear() => list.Clear();
        /// <inheritdoc />
        [CollectionAccess(Read)]
        public void CopyTo(T[] array, int arrayIndex)
        {
            for (var i = 0; i < Count && arrayIndex + i < array.Length; i++)
                array[arrayIndex + i] = this[i];
        }
        /// <inheritdoc />
        [CollectionAccess(UpdatedContent)]
        public void Insert(int index, T item) =>
            list.Insert(index is not -1 ? index + 1 : throw new ArgumentOutOfRangeException(nameof(index)), item);
        /// <inheritdoc />
        [CollectionAccess(ModifyExistingContent)]
        public void RemoveAt(int index) =>
            list.RemoveAt(index is not -1 ? index + 1 : throw new ArgumentOutOfRangeException(nameof(index)));
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public bool Contains(T item) => list.Contains(item);
        /// <inheritdoc />
        [CollectionAccess(Read | ModifyExistingContent), Pure]
        public bool Remove(T item) => list.Remove(item);
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public int IndexOf(T item) =>
            list.IndexOf(item) switch
            {
                0 => Find(item),
                -1 => -1,
                var x => x - 1,
            };
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        IEnumerator IEnumerable.GetEnumerator()
        {
            var ret = ((IEnumerable)list).GetEnumerator();
            ret.MoveNext();
            return ret;
        }
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public IEnumerator<T> GetEnumerator()
        {
            var ret = list.GetEnumerator();
            ret.MoveNext();
            return ret;
        }
        /// <inheritdoc />
        [CollectionAccess(Read), Pure]
        public override string? ToString() => list.ToString();
        [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(-1, int.MaxValue)]
        int Find(T item)
        {
            var count = list.Count - 1;
            for (var i = 0; i < count; i++)
                if (EqualityComparer<T>.Default.Equals(list[i + 1], item))
                    return i;
            return -1;
        }
    }
#endif
    /// <summary>Separates the head from the tail of an <see cref="ICollection{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="collection">The enumerable to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="collection"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="collection"/>.</param>
    public static void Deconstruct<T>(
        this IList<T>? collection,
        out T? head,
        [NotNullIfNotNull(nameof(collection))] out HeadlessList<T>? tail
    )
    {
        head = collection is null ? default : collection.FirstOrDefault();
        tail = collection.Tail();
    }
    /// <summary>Gets the tail of the <see cref="ICollection{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="collection">The collection to extract the tail from.</param>
    /// <returns>
    /// The encapsulation of the parameter <paramref name="collection"/> that prevents the head from being accessed.
    /// </returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(collection))]
    public static HeadlessList<T>? Tail<T>(this IList<T>? collection) => collection is null ? null : new(collection);
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable NullableWarningSuppressionIsUsed RedundantExtendsListEntry RedundantNameQualifier RedundantUnsafeContext UseSymbolAlias
// ReSharper disable once CheckNamespace EmptyNamespace
// ReSharper disable RedundantNameQualifier RedundantUsingDirective
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
/// <summary>Provides the method needed for collection expressions in <see cref="PooledSmallList{T}"/>.</summary>
static class PooledSmallListBuilder
{
    /// <summary>Converts the buffer into an expandable buffer.</summary>
    /// <typeparam name="T">The type of span.</typeparam>
    /// <param name="span">The span.</param>
    /// <returns>The <see cref="PooledSmallList{T}"/> that encapsulates the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static PooledSmallList<T> From<T>(ReadOnlySpan<T> span) => default(PooledSmallList<T>).Append(span);
}
/// <summary>Inlines elements before falling back on the heap using <see cref="ArrayPool{T}"/>.</summary>
/// <typeparam name="T">The type of the collection.</typeparam>
[CollectionBuilder(typeof(PooledSmallListBuilder), nameof(PooledSmallListBuilder.From))]
#if !NO_REF_STRUCTS
public ref
#endif
    partial struct PooledSmallList<T>
#if !NO_ALLOWS_REF_STRUCT
    : IDisposable
#endif
#if UNMANAGED_SPAN
    where T : unmanaged
#endif
{
    const int Inlined = 0, UnmanagedHeap = 1, ArrayPool = 2;
    [NonNegativeValue]
    int _length;
    Span<T> _view;
    T[]? _rental;
    /// <summary>Initializes a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList() { }
    /// <summary>Initializes a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    /// <param name="capacity">
    /// The initial allocation, which puts it on the heap immediately but can save future resizing.
    /// </param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList([NonNegativeValue] int capacity)
    {
        MakeRoom(capacity);
        _length = 0;
    }
    /// <summary>Initializes a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    /// <param name="view">The view to hold as the initial value.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList(Span<T> view) => _view = view;
    /// <inheritdoc cref="Span{T}.Empty"/>
    public static PooledSmallList<T> Empty
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => default;
    }
    /// <inheritdoc cref="Span{T}.IsEmpty"/>
    public readonly bool IsEmpty
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => View.IsEmpty;
    }
    /// <summary>Gets a value indicating whether the elements are inlined.</summary>
    [CLSCompliant(false)]
    public readonly bool IsInlined
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         MemberNotNullWhen(false, nameof(_rental), nameof(DangerouslyTransferOwnership)),
         Pure]
        get => _rental is null;
    }
    /// <summary>Gets a value indicating whether the elements are using the unmanaged heap.</summary>
    [CLSCompliant(false)]
    public readonly bool IsUnmanagedHeap
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         Pure]
        get => _rental.ToAddress() is UnmanagedHeap;
    }
    /// <summary>Gets a value indicating whether the elements are inlined.</summary>
    [CLSCompliant(false)]
    public readonly bool IsArrayPool
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         MemberNotNullWhen(true, nameof(_rental), nameof(DangerouslyTransferOwnership)),
         Pure]
        get => _rental.ToAddress() >= ArrayPool;
    }
    /// <inheritdoc cref="Span{T}.Length"/>
    public int Length
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure] readonly get => _length;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var newLength = Math.Max(value, 0);
            var relativeLength = newLength - _length;
            MakeRoom(relativeLength);
            _length = newLength;
        }
    }
    /// <summary>Gets and transfers responsibility of disposing the inner unmanaged array to the caller.</summary>
    public unsafe nint DangerouslyTransferOwnershipUnmanaged
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         MustUseReturnValue("Dispose unmanaged array with System.Runtime.InteropServices.Marshal.FreeHGlobal")]
        get
        {
            if (!IsUnmanagedHeap)
                return 0;
            var pointer = UnmanagedHeapPointer;
            _length = 0;
            _view = default;
            _rental = null;
            return pointer;
        }
    }
    /// <summary>Gets the buffer.</summary>
    public readonly Span<T> View
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _view[.._length];
    }
    /// <inheritdoc cref="ICollection{T}.Clear"/>
    public PooledSmallList<T> Reset
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            _length = 0;
            return this;
        }
    }
    /// <summary>Gets the entire exposed view.</summary>
    public PooledSmallList<T> Stretched
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            _length = _view.Length;
            return this;
        }
    }
    /// <summary>Gets the mutable reference to the <see cref="PooledSmallList{T}"/>.</summary>
    public unsafe ref PooledSmallList<T> AsRef
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
#pragma warning disable 8500
            fixed (PooledSmallList<T>* ptr = &this)
#pragma warning restore 8500
                return ref *ptr;
        }
    }
    /// <summary>Gets the inner heap array, or a copy of the inlined array.</summary>
    public readonly T[] ToArrayLazily
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => IsArrayPool ? _rental : _view.ToArray();
    }
    /// <summary>Gets and transfers responsibility of disposing the inner array to the caller.</summary>
    public T[]? DangerouslyTransferOwnership
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining),
         MustUseReturnValue("Dispose array with System.Memory.ArrayPool<T>.Shared.Return")]
        get
        {
            if (!IsArrayPool)
                return null;
            var rental = _rental;
            _length = 0;
            _view = default;
            _rental = null;
            return rental;
        }
    }
    readonly unsafe nint UnmanagedHeapPointer
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => (nint)Unsafe.AsPointer(ref MemoryMarshal.GetReference(_view));
    }
    /// <inheritdoc cref="Span{T}.Slice(int, int)"/>
    public readonly Span<T> this[[NonNegativeValue] int start, [NonNegativeValue] int length]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => View.Slice(start, length);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] set => value.CopyTo(View.Slice(start, length));
    }
    /// <inheritdoc cref="Span{T}.this"/>
    public readonly Span<T> this[Range range]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => View[range];
        [MethodImpl(MethodImplOptions.AggressiveInlining)] set => value.CopyTo(View[range]);
    }
    /// <inheritdoc cref="Span{T}.this"/>
    public readonly ref T this[[NonNegativeValue] int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => ref View[index];
    }
    /// <inheritdoc cref="Span{T}.this"/>
    public readonly ref T this[Index index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => ref View[index];
    }
    /// <inheritdoc cref="Span{T}.op_Equality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(PooledSmallList<T> left, PooledSmallList<T> right) => left.View == right.View;
    /// <inheritdoc cref="Span{T}.op_Inequality"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(PooledSmallList<T> left, PooledSmallList<T> right) => !(left == right);
    /// <summary>
    /// Implicitly converts the parameter by creating the new instance of <see cref="PooledSmallList{T}"/>
    /// by using the constructor <see cref="PooledSmallList{T}(int)"/>.
    /// </summary>
    /// <param name="capacity">The parameter to pass onto the constructor.</param>
    /// <returns>
    /// The new instance of <see cref="PooledSmallList{T}"/> by passing the parameter <paramref name="capacity"/>
    /// to the constructor <see cref="PooledSmallList{T}(int)"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator PooledSmallList<T>(int capacity) => new(capacity);
    /// <summary>Implicitly converts the buffer into an expandable buffer.</summary>
    /// <param name="span">The span.</param>
    /// <returns>The <see cref="PooledSmallList{T}"/> that encapsulates the parameter <paramref name="span"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator PooledSmallList<T>(Span<T> span) => new(span);
    /// <inheritdoc cref="AsSpan{TRef}"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static PooledSmallList<T> From<TRef>(ref TRef reference)
        where TRef : struct =>
        AsSpan(ref reference);
    /// <summary>Reinterprets the reference as the continuous buffer of <typeparamref name="T"/>.</summary>
    /// <typeparam name="TRef">The generic representing the continuous buffer of <typeparamref name="T"/>.</typeparam>
    /// <param name="reference">The reference.</param>
    /// <returns>The span.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Span<T> AsSpan<TRef>(ref TRef reference)
        where TRef : struct =>
        Validate<TRef>.AsSpan(ref reference);
    /// <inheritdoc cref="IDisposable.Dispose"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public unsafe void Dispose()
    {
        switch (_rental.ToAddress())
        {
            case Inlined: break;
            case UnmanagedHeap:
                Marshal.FreeHGlobal(DangerouslyTransferOwnershipUnmanaged);
                break;
            default:
                ArrayPool<T>.Shared.Return(DangerouslyTransferOwnership!);
                break;
        }
    }
    /// <inheritdoc />
    [DoesNotReturn, Obsolete("Will always throw", true)]
    public readonly override bool Equals(object? obj) => throw Unreachable;
    /// <inheritdoc />
    [DoesNotReturn, Obsolete("Will always throw", true)]
    public readonly override int GetHashCode() => throw Unreachable;
    /// <inheritdoc cref="Span{T}.ToString"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() =>
        typeof(T) == typeof(char) ? View.ToString() : View.ToArray().Conjoin();
    /// <inheritdoc cref="ICollection{T}.Add"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Append(T item)
    {
        if (HasRoom(1))
        {
            _view[_length++] = item;
            return this;
        }
        if (CanAllocateInUnmanagedHeap(1, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            _view.CopyTo(unmanaged);
            unmanaged[_length++] = item;
            Swap(unmanaged);
            return this;
        }
        var replacement = ArrayPool<T>.Shared.Rent(length);
        _view.CopyTo(replacement);
        replacement[_length++] = item;
        Swap(replacement);
        return this;
    }
    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Append(scoped ReadOnlySpan<T> collection)
    {
        if (HasRoom(collection.Length))
        {
            collection.CopyTo(_view[_length..]);
            _length += collection.Length;
            return this;
        }
        if (CanAllocateInUnmanagedHeap(collection.Length, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            _view.CopyTo(unmanaged);
            collection.CopyTo(unmanaged[_length..]);
            _length += collection.Length;
            Swap(unmanaged);
            return this;
        }
        var replacement = ArrayPool<T>.Shared.Rent(length);
        _view.CopyTo(replacement);
        collection.CopyTo(replacement.AsSpan()[_length..]);
        _length += collection.Length;
        Swap(replacement);
        return this;
    }
    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Append([InstantHandle] IEnumerable<T>? collection)
    {
        if (collection is null)
            return this;
        if (collection.TryGetNonEnumeratedCount(out var count))
            MakeRoom(count);
        foreach (var x in collection)
            Append(x);
        return this;
    }
    /// <inheritdoc cref="ICollection{T}.Add"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Prepend(T item)
    {
        if (HasRoom(1))
        {
            View.CopyTo(_view[1..]);
            _length++;
            _view[0] = item;
            return this;
        }
        if (CanAllocateInUnmanagedHeap(1, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            _view.CopyTo(unmanaged[1..]);
            unmanaged[0] = item;
            _length++;
            Swap(unmanaged);
            return this;
        }
        var replacement = ArrayPool<T>.Shared.Rent(length);
        _view.CopyTo(replacement.AsSpan()[1..]);
        replacement[0] = item;
        _length++;
        Swap(replacement);
        return this;
    }
    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Prepend(scoped ReadOnlySpan<T> collection)
    {
        if (HasRoom(collection.Length))
        {
            View.CopyTo(_view[collection.Length..]);
            _length += collection.Length;
            collection.CopyTo(_view);
            return this;
        }
        if (CanAllocateInUnmanagedHeap(collection.Length, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            _view.CopyTo(unmanaged[collection.Length..]);
            collection.CopyTo(unmanaged);
            _length += collection.Length;
            Swap(unmanaged);
            return this;
        }
        var replacement = ArrayPool<T>.Shared.Rent(length);
        _view.CopyTo(replacement.AsSpan()[collection.Length..]);
        collection.CopyTo(replacement);
        _length += collection.Length;
        Swap(replacement);
        return this;
    }
    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Prepend([InstantHandle] IEnumerable<T> collection) => Insert(0, collection);
    /// <inheritdoc cref="IList{T}.Insert"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Insert([NonNegativeValue] int offset, T item)
    {
        if (HasRoom(1))
        {
            Copy(offset, item, _view);
            return this;
        }
        if (CanAllocateInUnmanagedHeap(1, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            Copy(offset, item, unmanaged);
            Swap(unmanaged);
            return this;
        }
        var replacement = ArrayPool<T>.Shared.Rent(length);
        Copy(offset, item, replacement);
        Swap(replacement);
        return this;
    }
    /// <inheritdoc cref="IList{T}.Insert"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Insert([NonNegativeValue] int index, scoped ReadOnlySpan<T> collection)
    {
        if (HasRoom(collection.Length))
        {
            Copy(index, collection, _view);
            return this;
        }
        if (CanAllocateInUnmanagedHeap(collection.Length, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            Copy(index, collection, unmanaged);
            Swap(unmanaged);
            return this;
        }
        var replacement = ArrayPool<T>.Shared.Rent(length);
        Copy(index, collection, replacement);
        Swap(replacement);
        return this;
    }
    /// <inheritdoc cref="List{T}.AddRange"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Insert([NonNegativeValue] int index, [InstantHandle] IEnumerable<T> collection)
    {
        if (collection.TryCount() is { } count)
            MakeRoom(count);
        using var e = collection.GetEnumerator();
        for (var i = index; e.MoveNext(); i++)
            Insert(i, e.Current);
        return this;
    }
    /// <inheritdoc cref="IList{T}.RemoveAt"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt([NonNegativeValue] int index) => RemoveAt(index, 1);
    /// <summary>Removes the <see cref="PooledSmallList{T}"/> item at the specified offset and length.</summary>
    /// <param name="offset">The offset of the slice to remove.</param>
    /// <param name="length">The length of the slice to remove.</param>
    /// <returns>Itself.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt([NonNegativeValue] int offset, [NonNegativeValue] int length)
    {
        View[(offset + length)..].CopyTo(View[offset..]);
        _length -= length;
        return this;
    }
    /// <inheritdoc cref="IList{T}.RemoveAt"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt(Index index)
    {
        var offset = index.GetOffset(_length);
        RemoveAt(offset, 1);
        return this;
    }
    /// <summary>Removes the <see cref="PooledSmallList{T}"/> item at the specified range.</summary>
    /// <param name="range">The range of the slice to remove.</param>
    /// <returns>Itself.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> RemoveAt(Range range)
    {
        range.GetOffsetAndLength(_length, out var offset, out var length);
        RemoveAt(offset, length);
        return this;
    }
    /// <summary>Shrinks the collection.</summary>
    /// <param name="amount">The amount of elements to shrink.</param>
    /// <returns>Itself.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PooledSmallList<T> Shrink([NonNegativeValue] int amount)
    {
        Length -= amount;
        return this;
    }
    /// <inheritdoc cref="Span{T}.GetEnumerator"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly Span<T>.Enumerator GetEnumerator() => View.GetEnumerator();
    /// <summary>Gets the specific element, returning the default value when out-of-bounds.</summary>
    /// <param name="i">The index.</param>
    /// <returns>The element, or default.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ref T Nth([NonNegativeValue] int i) =>
        ref i >= 0 && i < _length ? ref _view[i] : ref Unsafe.NullRef<T>();
    /// <summary>Gets the specific element, returning the default value when out-of-bounds.</summary>
    /// <param name="i">The index.</param>
    /// <returns>The element, or default.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly ref T Nth(Index i) => ref Nth(i.GetOffset(_length));
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe Span<T> Rent([NonNegativeValue] int length, [NonNegativeValue] int bytes) =>
        new((void*)Marshal.AllocHGlobal(bytes), length);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void Copy([NonNegativeValue] int offset, T insertion, scoped Span<T> destination)
    {
        switch (offset)
        {
            case 0:
                View.CopyTo(destination[1..]);
                break;
            case var _ when offset == _length:
                View.CopyTo(destination);
                break;
            default:
                View[offset..].CopyTo(destination[(offset + 1)..]);
                View[..offset].CopyTo(destination);
                break;
        }
        destination[offset] = insertion;
        _length++;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void Copy([NonNegativeValue] int offset, scoped ReadOnlySpan<T> insertion, scoped Span<T> destination)
    {
        switch (offset)
        {
            case 0:
                View.CopyTo(destination[insertion.Length..]);
                insertion.CopyTo(destination);
                break;
            case var _ when offset == _length:
                insertion.CopyTo(destination[offset..]);
                View.CopyTo(destination);
                break;
            default:
                View[offset..].CopyTo(destination[(offset + insertion.Length)..]);
                insertion.CopyTo(destination[offset..]);
                View[..offset].CopyTo(destination);
                break;
        }
        _length += insertion.Length;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void Swap(T[] replacement)
    {
        if (IsArrayPool)
            ArrayPool<T>.Shared.Return(_rental);
        _view = _rental = replacement;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    unsafe void Swap(Span<T> replacement)
    {
        if (IsUnmanagedHeap)
            Marshal.FreeHGlobal((nint)Unsafe.AsPointer(ref MemoryMarshal.GetReference(_view)));
        UnsafelySetNullishTo(out _rental, 1);
        _view = replacement;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void MakeRoom([NonNegativeValue] int by)
    {
        if (HasRoom(by))
            return;
        if (CanAllocateInUnmanagedHeap(by, out var length, out var bytes))
        {
            var unmanaged = Rent(length, bytes);
            View.CopyTo(unmanaged);
            Swap(unmanaged);
        }
        else
        {
            var replacement = ArrayPool<T>.Shared.Rent(length);
            View.CopyTo(replacement);
            Swap(replacement);
        }
        _length += by;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly bool CanAllocateInUnmanagedHeap([NonNegativeValue] int by, out int length, out int bytes)
    {
        length = unchecked((int)((uint)(_view.Length + by)).RoundUpToPowerOf2());
        if (IsReferenceOrContainsReferences<T>())
        {
            Unsafe.SkipInit(out bytes);
            return false;
        }
        bytes = length * Unsafe.SizeOf<T>();
        if (length >= 0 && bytes >= 0)
            return true;
        Marshal.FreeHGlobal(UnmanagedHeapPointer);
        return false;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly bool HasRoom(int by) => _length + by <= _view.Length;
    /// <summary>Validator of generics representing the continuous buffer over the element type.</summary>
    /// <typeparam name="TRef">The generic representing the continuous buffer over the element type.</typeparam>
    public static class Validate<TRef>
        where TRef : struct
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static Validate() => Go(typeof(TRef));
        /// <summary>Gets the inlined length.</summary>
        [NonNegativeValue]
        public static int InlinedLength { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            Unsafe.SizeOf<TRef>() / Unsafe.SizeOf<T>();
        /// <summary>Reinterprets the reference as the continuous buffer over the element type.</summary>
        /// <param name="reference">The reference.</param>
        /// <returns>The span.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        public static Span<T> AsSpan(ref TRef reference) =>
            MemoryMarshal.CreateSpan(ref Unsafe.As<TRef, T>(ref reference), InlinedLength);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool Go(Type type) =>
            type
               .GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
               .Where(x => x.FieldType is var y && y != typeof(T) && (!y.IsValueType || y != x.DeclaringType && Go(y)))
               .Select(Throw)
               .Any();
        [DoesNotReturn, MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool Throw(FieldInfo _) =>
            throw new TypeLoadException(
                $"\"{typeof(TRef).UnfoldedName()}\" contains fields other than {typeof(T).UnfoldedName()}."
            );
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable NullableWarningSuppressionIsUsed RedundantUnsafeContext
// ReSharper disable once CheckNamespace
// ReSharper disable once RedundantNameQualifier
/// <summary>Extension methods that act as factories for <see cref="SmallList{T}"/>.</summary>
#if NETCOREAPP3_1_OR_GREATER
    /// <inheritdoc cref="System.MemoryExtensions.Contains"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool Contains<T>(this scoped PooledSmallList<T> span, T item)
        where T : IEquatable<T>? =>
        span.View.Contains(item);
#endif
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <summary>Removes the first occurence of a specific object from the <see cref="PooledSmallList{T}"/>.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="span">The <see cref="PooledSmallList{T}"/> to remove an element from.</param>
    /// <param name="item">The item to remove from the <see cref="PooledSmallList{T}"/>.</param>
    /// <returns>
    /// Whether or not it found the parameter <paramref name="item"/> within the bounds of the
    /// parameter <paramref name="span"/>, and substantially removed it from the collection.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Remove<T>(this scoped PooledSmallList<T> span, T item)
        where T : IEquatable<T>?
    {
        var i = span.IndexOf(item);
        if (i is -1)
            return false;
        span.RemoveAt(i);
        return true;
    }
    /// <inheritdoc cref="System.MemoryExtensions.IndexOf"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int IndexOf<T>(this scoped PooledSmallList<T> span, T item)
        where T : IEquatable<T>? =>
        span.View.IndexOf(item);
    /// <summary>Allocates the buffer on the stack or heap, and gives it to the caller.</summary>
    /// <remarks><para>See <see cref="Span.MaxStackalloc"/> for details about stack- and heap-allocation.</para></remarks>
    /// <typeparam name="T">The type of buffer.</typeparam>
    /// <param name="it">The length of the buffer.</param>
    /// <returns>The allocated buffer.</returns>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource, Pure]
    public static PooledSmallList<T> Alloc<T>(this in int it)
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        return it switch
        {
            <= 0 => default,
#if !CSHARPREPL
            _ when !IsReferenceOrContainsReferences<T>() && IsStack<T>(it) => Stackalloc<T>(it),
#endif
            _ => it,
        };
    }
#endif
    /// <summary>Creates a new instance of the <see cref="PooledSmallList{T}"/> struct.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="capacity">
    /// The initial allocation, which puts it on the heap immediately but can save future resizing.
    /// </param>
    /// <returns>The created instance of <see cref="PooledSmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static PooledSmallList<T> ToPooledSmallList<T>(this int capacity)
#if UNMANAGED_SPAN
    where T : unmanaged
#endif
        =>
            new(capacity);
    /// <inheritdoc cref="PooledSmallList{T}(Span{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource, Pure]
    public static PooledSmallList<T> ToPooledSmallList<T>(this Span<T> span)
#if UNMANAGED_SPAN
    where T : unmanaged
#endif
        =>
            new(span);
    /// <inheritdoc cref="PooledSmallList{T}(Span{T})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource, Pure]
    public static PooledSmallList<T> ToPooledSmallList<T>(this IEnumerable<T>? enumerable)
#if UNMANAGED_SPAN
    where T : unmanaged
#endif
        =>
            (enumerable?.TryCount() is { } count ? count.ToPooledSmallList<T>() : default).Append(enumerable);
    /// <summary>Collects the enumerable; allocating the heaped list lazily.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterable">The collection to turn into a <see cref="SmallList{T}"/>.</param>
    /// <returns>A <see cref="SmallList{T}"/> of <paramref name="iterable"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> ToSmallList<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null ? default : [..iterable];
    /// <summary>Mutates the enumerator; allocating the heaped list lazily.</summary>
    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
    /// <param name="iterator">The collection to turn into a <see cref="SmallList{T}"/>.</param>
    /// <returns>A <see cref="SmallList{T}"/> of <paramref name="iterator"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> ToSmallList<T>(this IEnumerator<T>? iterator) => new(iterator);
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable RedundantUnsafeContext RedundantUsingDirective
// ReSharper disable once CheckNamespace
/// <summary>Factory methods for creating inlined <see cref="SmallList{T}"/> instances.</summary>
    /// <summary>Number of items to keep inline for <see cref="SmallList{T}"/>.</summary>
    /// <remarks><para>
    /// And Saint Attila raised the <see cref="SmallList{T}"/> up on high, saying, "O Lord, bless this Thy
    /// <see cref="SmallList{T}"/> that, with it, Thou mayest blow Thine allocation costs to tiny bits in Thy mercy.".
    /// </para><para>
    /// And the Lord did grin, and the people did feast upon the lambs and sloths and carp and anchovies and orangutans
    /// and breakfast cereals and fruit bats and large chu...
    /// </para><para>
    /// And the Lord spake, saying, "First shalt thou recreate the
    /// <a href="https://crates.io/crates/smallvec"><c>smallvec</c></a> crate. Then, shalt thou keep three inline. No
    /// more. No less. Three shalt be the number thou shalt keep inline, and the number to keep inline shalt be three.
    /// Four shalt thou not keep inline, nor either keep inline thou two, excepting that thou then proceed to three.
    /// Five is right out. Once the number three,  being the third number, be reached, then, lobbest thou thy
    /// <see cref="SmallList{T}"/> towards thy heap, who, being slow and cache-naughty in My sight, shall snuff it.".
    /// </para><para>
    /// <a href="https://github.com/rhaiscript/rhai/blob/ca18cdd7f47f8ae8bd6e2b7a950ad4815d62f026/src/lib.rs#L373">
    /// (Adapted from Rhai)
    /// </a></para></remarks>
    public const int InlinedLength = 3;
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with no elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>() => [];
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 1 element.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first) => first;
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 2 elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first, T second) => new(first, second);
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 3 elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first, T second, T third) => new(first, second, third);
    /// <summary>Creates a new instance of the <see cref="SmallList{T}"/> struct with arbitrary elements.</summary>
    /// <typeparam name="T">The type of element in the <see cref="SmallList{T}"/>.</typeparam>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The rest of the elements.</param>
    /// <returns>The created <see cref="SmallList{T}"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Create<T>(T first, T second, T third, params T[] rest) =>
        new(first, second, third, rest);
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable NullableWarningSuppressionIsUsed
// ReSharper disable once CheckNamespace
/// <summary>Inlines 3 elements before falling back on the heap with an expandable <see cref="IList{T}"/>.</summary>
/// <typeparam name="T">The element type.</typeparam>
[StructLayout(LayoutKind.Sequential)]
public partial struct SmallList<T> :
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
    IConvertible,
#endif
    IEquatable<SmallList<T>>,
    IList<T>,
    IReadOnlyList<T>
{
    //
    [ProvidesContext]
    IList<T>? _rest;
    T? _first, _second, _third;
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with no elements.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList() { }
    /// <summary>
    /// Initializes a new instance of the <see cref="SmallList{T}"/> struct.
    /// Collects the enumerable; allocating the heaped list lazily.
    /// </summary>
    /// <param name="enumerable">The enumerable to collect.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList([InstantHandle] IEnumerable<T>? enumerable)
        : this(enumerable?.GetEnumerator()) { }
    /// <summary>
    /// Initializes a new instance of the <see cref="SmallList{T}"/> struct.
    /// Mutates the enumerator; allocating the heaped list lazily.
    /// </summary>
    /// <param name="enumerator">The enumerator to mutate.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(IEnumerator<T>? enumerator)
    {
        if (enumerator?.MoveNext() is not true)
            return;
        _first = enumerator.Current;
        if (!enumerator.MoveNext())
        {
            UnsafelySetNullishTo(out _rest, 1);
            return;
        }
        _second = enumerator.Current;
        if (!enumerator.MoveNext())
        {
            UnsafelySetNullishTo(out _rest, 2);
            return;
        }
        _third = enumerator.Current;
        if (!enumerator.MoveNext())
        {
            _rest = [];
            return;
        }
        List<T> list = [];
        do
            list.Add(enumerator.Current);
        while (enumerator.MoveNext());
        _rest = list;
    }
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 1 element.</summary>
    /// <param name="first">The first element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first)
    {
        _first = first;
        UnsafelySetNullishTo(out _rest, 1);
    }
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 2 elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second)
    {
        _first = first;
        _second = second;
        UnsafelySetNullishTo(out _rest, 2);
    }
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with 3 elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second, T third)
        : this(first, second, third, []) { }
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with arbitrary elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The rest of the elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second, T third, IList<T> rest)
    {
        _first = first;
        _second = second;
        _third = third;
        _rest = rest;
    }
    /// <summary>Initializes a new instance of the <see cref="SmallList{T}"/> struct with arbitrary elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The rest of the elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SmallList(T first, T second, T third, params T[] rest)
        : this(first, second, third, (IList<T>)rest) { }
    /// <summary>Gets the empty list.</summary>
    public static SmallList<T> Empty
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] get => default;
    }
    /// <summary>Gets a value indicating whether determines whether the collection is empty.</summary>
    public readonly bool IsEmpty
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _rest is null;
    }
    /// <inheritdoc />
    public readonly bool IsReadOnly
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => false;
    }
    /// <inheritdoc cref="ICollection{T}.Count" />
    public readonly int Count
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get => _rest.ToAddress() < InlinedLength ? (int)_rest.ToAddress() : _rest!.Count + InlinedLength;
    }
    /// <summary>Gets the number of head elements used.</summary>
    public readonly int HeadCount
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Math.Min(Count, 3);
    }
    /// <summary>Gets the deep clone of this instance.</summary>
    public readonly SmallList<T> Cloned
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        get
        {
            var clone = Uninit(Count);
            CopyTo(ref clone);
            return clone;
        }
    }
    /// <inheritdoc cref="IList{T}.this" />
    public T this[int index]
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        readonly get
        {
            BoundsCheck(index, out _);
            return index switch
            {
                0 => _first!,
                1 => _second!,
                2 => _third!,
                _ => _rest![index - InlinedLength],
            };
        }
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            BoundsCheck(index, out _);
            _ = index switch
            {
                0 => _first = value,
                1 => _second = value,
                2 => _third = value,
                _ => _rest![index - InlinedLength] = value,
            };
        }
    }
    /// <summary>Gets or sets the first element.</summary>
    public T First
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] readonly get => this[0];
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable MA0102
        set => this[0] = value;
    }
    /// <summary>Gets or sets the second element.</summary>
    [CollectionAccess(Read), Pure]
    public T Second
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] readonly get => this[1];
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => this[1] = value;
    }
    /// <summary>Gets or sets the third element.</summary>
    [CollectionAccess(Read), Pure]
    public T Third
    {
        [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure] readonly get => this[2];
        [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => this[2] = value;
#pragma warning restore MA0102
    }
    /// <summary>Gets the rest of the elements.</summary>
    public readonly IList<T>? Rest
    {
        [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), ProvidesContext, Pure]
        get => _rest.ToAddress() < InlinedLength ? null : _rest;
    }
    /// <summary>Determines whether both sequence are equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both sequences are equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator ==(SmallList<T> left, SmallList<T> right) => left.Equals(right);
    /// <summary>Determines whether both sequence are not equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether both sequences are not equal.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool operator !=(SmallList<T> left, SmallList<T> right) => !left.Equals(right);
    /// <summary>Creates the collection with 1 item in it.</summary>
    /// <param name="value">The single item to use.</param>
    /// <returns>The collection with 1 item.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>(T value) => new(value);
    /// <summary>Creates the collection with 2 items in it.</summary>
    /// <param name="tuple">The tuple containing 2 items to destructure and use.</param>
    /// <returns>The collection with 2 items.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second) tuple) => new(tuple.First, tuple.Second);
    /// <summary>Creates the collection with 3 items in it.</summary>
    /// <param name="tuple">The tuple containing 3 items to destructure and use.</param>
    /// <returns>The collection with 3 items.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second, T Third) tuple) =>
        new(tuple.First, tuple.Second, tuple.Third);
    /// <summary>Creates the collection with 3 or more items in it.</summary>
    /// <param name="tuple">The tuple containing 3 or more items to destructure and use.</param>
    /// <returns>The collection with 3 or more items.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second, T Third, IList<T> List) tuple) =>
        new(tuple.First, tuple.Second, tuple.Third, tuple.List);
    /// <summary>
    /// Implicitly converts the parameter by creating the new instance of <see cref="SmallList{T}"/>
    /// by using the constructor <see cref="SmallList{T}(T, T, T, T[])"/>.
    /// </summary>
    /// <param name="tuple">The parameter to pass onto the constructor.</param>
    /// <returns>
    /// The new instance of <see cref="SmallList{T}"/> by passing the parameter <paramref name="tuple"/>
    /// to the constructor <see cref="SmallList{T}(T, T, T, T[])"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static implicit operator SmallList<T>((T First, T Second, T Third, T[] TheRest) tuple) =>
        new(tuple.First, tuple.Second, tuple.Third, tuple.TheRest);
    /// <summary>Skips initialization of inlined elements.</summary>
    /// <param name="length">The length of the <see cref="SmallList{T}"/>.</param>
    /// <returns>The <see cref="SmallList{T}"/> of length <paramref name="length"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Uninit(int length)
    {
        Unsafe.SkipInit(out SmallList<T> output);
        RestFromLength(length, out output._rest);
        return output;
    }
    /// <summary>Skips initialization of unreachable inlined elements.</summary>
    /// <param name="length">The length of the <see cref="SmallList{T}"/>.</param>
    /// <returns>The <see cref="SmallList{T}"/> of length <paramref name="length"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static SmallList<T> Zeroed(int length)
    {
        var output = Uninit(length);
        switch (length)
        {
            case >= 3:
                output._third = default;
                goto case 2;
            case 2:
                output._second = default;
                goto case 1;
            case 1:
                output._first = default;
                break;
        }
        return output;
    }
    /// <inheritdoc />
    [CollectionAccess(UpdatedContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Add(T item)
    {
        switch (Count)
        {
            case 0:
                _first = item;
                UnsafelySetNullishTo(out _rest, 1);
                break;
            case 1:
                _second = item;
                UnsafelySetNullishTo(out _rest, 2);
                break;
            case 2:
                (_third, _rest) = (item, []);
                break;
            default:
                EnsureMutability().Add(item);
                break;
        }
    }
    /// <summary>Adds the elements of the specified collection to the end of the <see cref="SmallList{T}"/>.</summary>
    /// <param name="collection">
    /// The collection whose elements should be added to the end of the <see cref="SmallList{T}"/>.
    /// </param>
    [CollectionAccess(UpdatedContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void AddRange(IEnumerable<T>? collection)
    {
        if (collection?.ToICollection() is not { Count: var count and not 0 } c)
            return;
        if (InlinedLength - HeadCount is var stackExpand && stackExpand is not 0)
        {
            using var e = c.GetEnumerator();
            for (var i = 0; i < stackExpand; i++)
                if (e.MoveNext())
                    Add(e.Current);
                else
                    return;
        }
        if (count <= stackExpand)
            return;
        var rest = _rest as List<T> ?? [.. _rest!];
        rest.AddRange(stackExpand is 0 ? c : c.Skip(stackExpand).ToICollection());
        _rest = rest;
    }
    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear() => _rest = null;
    /// <summary>Copies all values onto the destination.</summary>
    /// <param name="list">The destination.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="list"/> has fewer elements than itself.
    /// </exception>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void CopyTo(ref SmallList<T> list)
    {
        if (Count is var count && count is 0)
            return;
        list.BoundsCheck(count - 1, out _);
        switch (count)
        {
            case > InlinedLength:
                IList<T>
                    from = _rest!,
                    to = list._rest!;
                for (var i = 0; i < from.Count; i++)
                    to[i] = from[i];
                goto case 3;
            case 3:
                list._third = _third;
                goto case 2;
            case 2:
                list._second = _second;
                goto case 1;
            case 1:
                list._first = _first;
                break;
        }
    }
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
    {
        switch (Count)
        {
            case > InlinedLength:
                _rest!.CopyTo(array, arrayIndex + InlinedLength);
                goto case 3;
            case 3:
                array[arrayIndex + 2] = _third!;
                goto case 2;
            case 2:
                array[arrayIndex + 1] = _second!;
                goto case 1;
            case 1:
                array[arrayIndex] = _first!;
                break;
        }
    }
    /// <summary>Deconstructs this instance with its properties.</summary>
    /// <param name="head">The first three elements.</param>
    /// <param name="tail">The remaining elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out (T? First, T? Second, T? Third) head, out IList<T> tail) =>
        (head, tail) = ((_first, _second, _third), Rest ?? []);
    /// <summary>Deconstructs this instance with the 3 first elements.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out T? first, out T? second, out T? third) =>
        (first, second, third) = (_first, _second, _third);
    /// <summary>Deconstructs this instance with its properties.</summary>
    /// <param name="first">The first element.</param>
    /// <param name="second">The second element.</param>
    /// <param name="third">The third element.</param>
    /// <param name="rest">The remaining elements.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly void Deconstruct(out T? first, out T? second, out T? third, out IList<T> rest) =>
        (first, second, third, rest) = (_first, _second, _third, Rest ?? []);
    /// <inheritdoc />
    [CollectionAccess(UpdatedContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Insert(int index, T item)
    {
        BoundsCheck(index, out var count);
        switch (count)
        {
            case 0:
                UnsafelySetNullishTo(out _rest, 1);
                break;
            case 1:
                UnsafelySetNullishTo(out _rest, 2);
                break;
            case 2:
                _rest = [];
                break;
            case >= InlinedLength:
                EnsureMutability().Insert(0, _third!);
                break;
        }
        switch (index)
        {
            case 0:
                _third = _second;
                _second = _first;
                _first = item;
                break;
            case 1:
                _third = _second;
                _second = item;
                break;
            case 2:
                _third = item;
                break;
        }
    }
    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void RemoveAt(int index)
    {
        BoundsCheck(index, out var count);
        if (index is 0)
            _first = _second;
        if (index is 0 or 1)
            _second = _third;
        if (index < InlinedLength && _rest is [var head, ..])
            _third = head;
        if (count > InlinedLength)
            EnsureMutability().RemoveAt(Math.Max(index - InlinedLength, 0));
        else
            UnsafelySetNullishTo(out _rest, (byte)count);
    }
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Reverse()
    {
#pragma warning disable IDE0180
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void SwapByRef(ref T left, ref T right)
        {
            var temp = left;
            left = right;
            right = temp;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void Swap(ref T left, in IList<T> right, int index)
        {
            var temp = left;
            left = right[index];
            right[index] = temp;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static void SwapItself(in IList<T> list, int index, int count)
        {
            var temp = list[index];
            list[count - index - 4] = list[index];
            list[count - index - 4] = temp;
        }
#pragma warning restore IDE0180
        switch (Count)
        {
            case 2:
                SwapByRef(ref _first!, ref _second!);
                break;
            case 3:
                SwapByRef(ref _first!, ref _third!);
                break;
            case 4:
                Swap(ref _first!, EnsureMutability(), 0);
                SwapByRef(ref _second!, ref _third!);
                break;
            case 5:
                Swap(ref _first!, EnsureMutability(), 1);
                Swap(ref _second!, _rest!, 0);
                break;
            case >= 6 and var count:
                Swap(ref _first!, EnsureMutability(), count - 4);
                Swap(ref _second!, _rest!, count - 5);
                Swap(ref _third!, _rest!, count - 6);
                if (_rest is List<T> rest)
                    rest.Reverse(0, count - 6);
                else
                    for (var i = 0; i < count / 2 - 3; i++)
                        SwapItself(_rest!, i, count);
                break;
        }
    }
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Contains(T item) =>
        Count switch
        {
            0 => Eq(_first, item),
            1 => Eq(_first, item) || Eq(_second, item),
            2 => Eq(_first, item) || Eq(_second, item) || Eq(_third, item),
            _ => Eq(_first, item) || Eq(_second, item) || Eq(_third, item) || _rest!.Contains(item),
        };
    /// <summary>Determines whether the item exists in the collection.</summary>
    /// <param name="item">The item to check.</param>
    /// <param name="comparer">The comparer to use.</param>
    /// <returns>The value determining whether the parameter <paramref name="item"/> exists in the collection.</returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Contains(T item, IEqualityComparer<T> comparer) =>
        Count switch
        {
            0 => comparer.Equals(_first!, item),
            1 => comparer.Equals(_first!, item) || comparer.Equals(_second!, item),
            2 => comparer.Equals(_first!, item) || comparer.Equals(_second!, item) || comparer.Equals(_third!, item),
            _ => comparer.Equals(_first!, item) ||
                comparer.Equals(_second!, item) ||
                comparer.Equals(_third!, item) ||
                _rest!.Contains(item, comparer),
        };
    /// <inheritdoc cref="object.Equals(object)"/>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override bool Equals([NotNullWhen(true)] object? obj) => obj is SmallList<T> other && Equals(other);
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly bool Equals(SmallList<T> other) =>
        Count == other.Count &&
        Eq(_first, other._first) &&
        Eq(_second, other._second) &&
        Eq(_third, other._third) &&
        (other.Rest is [_, ..] rest ? Rest?.SequenceEqual(rest) ?? false : other.Rest is null);
    /// <inheritdoc />
    [CollectionAccess(ModifyExistingContent), MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Remove(T item)
    {
        switch (Count)
        {
            case 0: return false;
            case 1: return Eq(_first, item) && (_rest = null) is var _;
            case 2:
                if (Eq(_first, item))
                {
                    UnsafelySetNullishTo(out _rest, 1);
                    return (_first = _second) is var _;
                }
                if (!Eq(_second, item))
                    return false;
                UnsafelySetNullishTo(out _rest, 1);
                return true;
            default:
                return Eq(_first, item) ? RemoveHead(_first = _second) :
                    Eq(_second, item) ? RemoveHead(_second = _third) :
                    Eq(_third, item) ? RemoveHead() : EnsureMutability().Remove(item);
        }
    }
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override int GetHashCode()
    {
        unchecked
        {
            const int Prime = 397;
            var hashCode = Prime;
            switch (Count)
            {
                case > InlinedLength:
                    hashCode = _rest!.GetHashCode();
                    goto case 3;
                case 3:
                    hashCode = hashCode * Prime ^ EqualityComparer<T?>.Default.GetHashCode(_third!);
                    goto case 2;
                case 2:
                    hashCode = hashCode * Prime ^ EqualityComparer<T?>.Default.GetHashCode(_second!);
                    goto case 1;
                case 1:
                    hashCode = hashCode * Prime ^ EqualityComparer<T?>.Default.GetHashCode(_first!);
                    break;
            }
            return hashCode;
        }
    }
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly int IndexOf(T item) =>
        Count switch
        {
            0 => Eq(_first, item) ? 0 : -1,
            1 => Eq(_first, item) ? 0 :
                Eq(_second, item) ? 1 : -1,
            2 => Eq(_first, item) ? 0 :
                Eq(_second, item) ? 1 :
                Eq(_third, item) ? 2 : -1,
            _ => Eq(_first, item) ? 0 :
                Eq(_second, item) ? 1 :
                Eq(_third, item) ? 2 :
                _rest!.IndexOf(item) is var i && i is -1 ? i : i + 3,
        };
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly override string ToString() =>
        Count switch
        {
            0 => "[]",
            1 => $"[{_first}]",
            2 => $"[{_first}, {_second}]",
            3 => $"[{_first}, {_second}, {_third}]",
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            _ => $"[{_first}, {_second}, {_third}, {_rest!.Conjoin()}]",
#else
            _ => $"[{_first}, {_second}, {_third}, {_rest}]",
#endif
        };
    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator" />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    public readonly Enumerator GetEnumerator() => new(this);
    /// <summary>Gets the enumeration object that returns the values in reversed order.</summary>
    /// <returns>The backwards enumerator.</returns>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    public readonly Enumerator GetReversedEnumerator() => new(this, true);
    /// <summary>Forms a slice out of the current list that begins at a specified index.</summary>
    /// <param name="start">The index at which to begin the slice.</param>
    /// <returns>
    /// A list that consists of all elements of the current list from <paramref name="start"/> to the end of the span.
    /// </returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
#pragma warning disable IDE0057
    public readonly SmallList<T> Slice(int start) => Slice(start, Count - start);
#pragma warning restore IDE0057
    /// <summary>Forms a slice out of the current list starting at a specified index for a specified length.</summary>
    /// <param name="start">The index at which to begin this slice.</param>
    /// <param name="length">The desired length for the slice.</param>
    /// <returns>
    /// A span that consists of <paramref name="length"/> elements from
    /// the current span starting at <paramref name="start"/>.
    /// </returns>
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public readonly SmallList<T> Slice(int start, int length)
    {
        var count = Count;
        start = Math.Max(start, 0);
        length = Math.Min(length, count - start);
        if (length <= 0)
            return default;
        if (start is 0 && length == count)
            return Cloned;
        Unsafe.SkipInit(out SmallList<T> output);
        if (length >= InlinedLength && _rest?.Skip(start).Take(length - InlinedLength).ToList() is { } list)
            output._rest = list;
        else
            RestFromLength(length, out output._rest);
        switch (length)
        {
            case >= 3:
                output._third = start is 0 ? _third : _rest![start - 1];
                goto case 2;
            case 2:
                output._second = start switch
                {
                    0 => _second,
                    1 => _third,
                    _ => _rest![start - 2],
                };
                goto case 1;
            case 1:
                output._first = start switch
                {
                    0 => _first,
                    1 => _second,
                    2 => _third,
                    _ => _rest![start - 3],
                };
                break;
        }
        return output;
    }
    /// <summary>Gets the first element of the list that optionally matches the <see cref="Predicate{T}"/>.</summary>
    /// <param name="predicate">The predicate to use as a filter.</param>
    /// <returns>The first element of the list that matches the parameter <paramref name="predicate"/>.</returns>
    public readonly T? FirstOrDefault(Predicate<T>? predicate)
    {
        if (predicate is null)
            return IsEmpty ? default : First;
        foreach (var next in this)
            if (predicate(next))
                return next;
        return default;
    }
    /// <summary>Gets the last element of the list that optionally matches the <see cref="Predicate{T}"/>.</summary>
    /// <param name="predicate">The predicate to use as a filter.</param>
    /// <returns>The last element of the list that matches the parameter <paramref name="predicate"/>.</returns>
    public readonly T? LastOrDefault(Predicate<T>? predicate = null)
    {
        if (predicate is null)
            return Count switch
            {
                0 => default,
                1 => First,
                2 => Second,
                3 => Third,
                _ => Rest![Rest.Count - 1],
            };
        using var e = GetReversedEnumerator();
        while (e.MoveNext())
            if (predicate(e.Current))
                return e.Current;
        return default;
    }
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly TypeCode IConvertible.GetTypeCode() => TypeCode.Object;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly bool IConvertible.ToBoolean(IFormatProvider? provider) => !IsEmpty;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly byte IConvertible.ToByte(IFormatProvider? provider) => unchecked((byte)Count);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly char IConvertible.ToChar(IFormatProvider? provider) => unchecked((char)Count);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly DateTime IConvertible.ToDateTime(IFormatProvider? provider) => new(Count, DateTimeKind.Utc);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly decimal IConvertible.ToDecimal(IFormatProvider? provider) => Count;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly double IConvertible.ToDouble(IFormatProvider? provider) => Count;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly short IConvertible.ToInt16(IFormatProvider? provider) => unchecked((short)Count);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly int IConvertible.ToInt32(IFormatProvider? provider) => Count;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly long IConvertible.ToInt64(IFormatProvider? provider) => Count;
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly sbyte IConvertible.ToSByte(IFormatProvider? provider) => unchecked((sbyte)Count);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly float IConvertible.ToSingle(IFormatProvider? provider) => Count;
    /// <inheritdoc />
    [CollectionAccess(Read), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly string IConvertible.ToString(IFormatProvider? provider) => ToString();
    /// <inheritdoc />
    [DoesNotReturn, MethodImpl(MethodImplOptions.AggressiveInlining)]
    readonly object IConvertible.ToType(Type conversionType, IFormatProvider? provider) =>
        throw new InvalidOperationException();
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly ushort IConvertible.ToUInt16(IFormatProvider? provider) => unchecked((ushort)Count);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly uint IConvertible.ToUInt32(IFormatProvider? provider) => unchecked((uint)Count);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    readonly ulong IConvertible.ToUInt64(IFormatProvider? provider) => unchecked((ulong)Count);
#endif
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), MethodImpl(MethodImplOptions.AggressiveInlining), MustDisposeResource(false), Pure]
    readonly IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void RestFromLength(int length, out IList<T>? rest)
    {
        if (length is 0 or 1 or 2 or 3)
            RestFromLengthWithoutAllocations(length, out rest);
        else
            rest = new T[length - InlinedLength];
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void RestFromLengthWithoutAllocations(int length, out IList<T>? rest)
    {
        switch (length)
        {
            case <= 0:
                rest = null;
                break;
            case 1:
                UnsafelySetNullishTo(out rest, 1);
                break;
            case 2:
                UnsafelySetNullishTo(out rest, 2);
                break;
            case 3:
                rest = [];
                break;
            default:
                Unsafe.SkipInit(out rest);
                break;
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static bool Eq(T? x, T? y) => x is null ? y is null : y is not null && EqualityComparer<T>.Default.Equals(x, y);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    readonly void BoundsCheck(int index, [ValueRange(1, int.MaxValue)] out int count)
    {
        count = Count;
        if (unchecked((uint)index >= count))
            throw new ArgumentOutOfRangeException(nameof(index), index, $"Must be between 0 and {count - 1}");
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    bool RemoveHead(in T? _ = default)
    {
        if (_rest is [var head, ..])
        {
            _third = head;
            EnsureMutability().RemoveAt(0);
        }
        else
            UnsafelySetNullishTo(out _rest, 2);
        return true;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
    IList<T> EnsureMutability() =>
        _rest = _rest switch
        {
            { IsReadOnly: false, Count: not 0 } x => x,
            { Count: not 0 } x => [.. x],
            _ => [],
        };
    /// <summary>An enumerator over <see cref="SmallList{T}"/>.</summary>
    [StructLayout(LayoutKind.Auto)]
    public struct Enumerator : IEnumerator<T>
    {
        readonly bool _isReversed;
        readonly int _count;
        readonly SmallList<T> _list;
        int _state = -1;
        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
        /// <param name="list">The <see cref="SmallList{T}"/> to enumerate over.</param>
        /// <param name="isReversed">Determines whether to go backwards.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Enumerator(SmallList<T> list, bool isReversed = false)
        {
            _list = list;
            _isReversed = isReversed;
            _count = list.Count;
        }
        /// <inheritdoc />
        public T Current { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; private set; } = default!;
        /// <inheritdoc />
        readonly object? IEnumerator.Current
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Current;
        }
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void Dispose() { }
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Reset() => _state = -1;
        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool MoveNext() =>
            ++_state < _count &&
            (Current = (_isReversed ? _count - _state - 1 : _state) switch
            {
                0 => _list._first!,
                1 => _list._second!,
                2 => _list._third!,
                var x => _list._rest![x - InlinedLength],
            }) is var _;
    }
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
#if !NET20 && !NET30
/// <summary>Extension methods that act as factories for <see cref="Split{T}"/>.</summary>
    /// <summary>Gets all booleans, in the order defined by <see cref="Split{T}"/>.</summary>
    public static bool[] Booleans { get; } = [true, false];
    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a number.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="count">The number of elements in the first half.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 enumerables containing the two halves of the underlying
    /// collection. The first half is as long as the parameter <paramref name="count"/> or shorter.
    /// </returns>
    [Pure]
    public static Split<IEnumerable<T>> SplitAt<T>(this ICollection<T> source, [NonNegativeValue] int count) =>
        new(source.Take(count), source.Skip(count));
    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="predicate">The method that decides where the item ends up.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 enumerables containing the two halves of the underlying
    /// collection. The first half lasts until the first element that returned <see langword="true"/>.
    /// </returns>
    [Pure]
    public static Split<IEnumerable<T>> SplitWhen<T>(
        [InstantHandle] this ICollection<T> source,
        [InstantHandle] Func<T, bool> predicate
    )
    {
        var index = source.TakeWhile(x => !predicate(x)).Count();
        return source.SplitAt(index);
    }
    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="predicate">The method that decides where the item ends up.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 lists containing the elements that returned
    /// <see langword="true"/> and <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static Split<List<T>> SplitBy<T>(
        [InstantHandle] this IEnumerable<T> source,
        [InstantHandle] Predicate<T> predicate
    )
    {
        List<T> t = [], f = [];
        foreach (var item in source)
            (predicate(item) ? t : f).Add(item);
        return new(t, f);
    }
    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
    /// <typeparam name="T">The type of the collection.</typeparam>
    /// <param name="source">The collection to split.</param>
    /// <param name="predicate">The method that decides where the item ends up.</param>
    /// <returns>
    /// A <see cref="Split{T}"/> instance that contains 2 lists containing the elements that returned
    /// <see langword="true"/> and <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static Split<SmallList<T>> SmallSplitBy<T>(
        [InstantHandle] this IEnumerable<T> source,
        [InstantHandle] Predicate<T> predicate
    )
    {
        SmallList<T> t = [], f = [];
        foreach (var item in source)
            (predicate(item) ? t : f).Add(item);
        return new(t, f);
    }
#endif
/// <summary>Represents a fixed collection of 2 items.</summary>
/// <typeparam name="T">The type of item in the collection.</typeparam>
/// <param name="truthy">The value representing a <see langword="true"/> value.</param>
/// <param name="falsy">The value representing a <see langword="false"/> value.</param>
public sealed partial class Split<T>(T truthy, T falsy) : ICollection<T>,
    IDictionary<bool, T>,
    IReadOnlyCollection<T>,
    IReadOnlyDictionary<bool, T>
{
    /// <summary>Initializes a new instance of the <see cref="Split{T}"/> class.</summary>
    /// <param name="value">The value representing both values.</param>
    public Split(T value)
        : this(value, value) { }
    /// <summary>Gets <see cref="Truthy"/> and <see cref="Falsy"/> within an array, in that order.</summary>
    [Pure]
    public T[] Array => [truthy, falsy];
    /// <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
    [Pure]
    public T Falsy
    {
        get => falsy;
        set => falsy = value;
    }
    /// <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
    [Pure]
    public T Truthy
    {
        get => truthy;
        set => truthy = value;
    }
    /// <inheritdoc cref="ICollection{T}.IsReadOnly" />
    [Pure]
    bool ICollection<T>.IsReadOnly => false;
    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int ICollection<T>.Count => 2;
    /// <inheritdoc />
    [Pure]
    public ICollection<T> Values => this;
    /// <inheritdoc cref="ICollection{T}.IsReadOnly" />
    [Pure]
    bool ICollection<KeyValuePair<bool, T>>.IsReadOnly => false;
    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int ICollection<KeyValuePair<bool, T>>.Count => 2;
    /// <inheritdoc />
    [Pure]
    ICollection<bool> IDictionary<bool, T>.Keys => Booleans;
    /// <inheritdoc cref="Array"/>
    [Pure]
    public KeyValuePair<bool, T>[] ArrayPair => [new(true, truthy), new(false, falsy)];
    /// <inheritdoc cref="IDictionary{TKey, TValue}.this" />
    [Pure]
    public T this[bool key]
    {
        get => key ? truthy : falsy;
        set => _ = key ? truthy = value : falsy = value;
    }
    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int IReadOnlyCollection<T>.Count => 2;
    /// <inheritdoc cref="ICollection{T}.Count" />
    [Pure, ValueRange(2)]
    int IReadOnlyCollection<KeyValuePair<bool, T>>.Count => 2;
    /// <inheritdoc />
    [Pure]
    IEnumerable<bool> IReadOnlyDictionary<bool, T>.Keys => Booleans;
    /// <inheritdoc />
    [Pure]
    IEnumerable<T> IReadOnlyDictionary<bool, T>.Values => Values;
    /// <summary>
    /// Implicitly converts the parameter by creating the new instance of <see cref="Split{T}"/>
    /// by using the constructor <see cref="Split{T}(T, T)"/>.
    /// </summary>
    /// <param name="tuple">The parameter to pass onto the constructor.</param>
    /// <returns>
    /// The new instance of <see cref="Split{T}"/> by passing the parameter <paramref name="tuple"/>
    /// to the constructor <see cref="Split{T}(T, T)"/>.
    /// </returns>
    [Pure]
    public static implicit operator Split<T>((T Truthy, T Falsy) tuple) => new(tuple.Truthy, tuple.Falsy);
    /// <inheritdoc />
    public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
    {
        array[arrayIndex] = truthy;
        array[arrayIndex + 1] = falsy;
    }
    /// <inheritdoc />
    [Pure]
    public bool Contains(T item) =>
        EqualityComparer<T>.Default.Equals(truthy, item) || EqualityComparer<T>.Default.Equals(falsy, item);
    /// <inheritdoc />
    [Pure]
    public IEnumerator<T> GetEnumerator() => ((IEnumerable<T>)Array).GetEnumerator();
    /// <inheritdoc />
    void ICollection<T>.Add(T item) { }
    /// <inheritdoc cref="ICollection{T}.Clear" />
    void ICollection<T>.Clear() { }
    /// <inheritdoc />
    [Pure]
    bool ICollection<T>.Remove(T item) => false;
    /// <inheritdoc />
    [Pure]
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    public void Add(bool key, T value) => _ = key ? truthy = value : falsy = value;
    /// <inheritdoc />
    public void Add(KeyValuePair<bool, T> item) => _ = item.Key ? truthy = item.Value : falsy = item.Value;
    /// <inheritdoc />
    public void CopyTo(KeyValuePair<bool, T>[] array, [NonNegativeValue] int arrayIndex)
    {
        array[arrayIndex] = new(true, truthy);
        array[arrayIndex + 1] = new(false, falsy);
    }
    /// <inheritdoc />
    [Pure]
    public bool Contains(KeyValuePair<bool, T> item) =>
        item.Key
            ? EqualityComparer<T>.Default.Equals(truthy, item.Value)
            : EqualityComparer<T>.Default.Equals(falsy, item.Value);
    /// <inheritdoc cref="IDictionary{TKey, TValue}.TryGetValue" />
    [Pure]
    public bool TryGetValue(bool key, out T value)
    {
        value = key ? truthy : falsy;
        return true;
    }
    /// <inheritdoc cref="ICollection{T}.Clear" />
    void ICollection<KeyValuePair<bool, T>>.Clear() { }
    /// <inheritdoc />
    [Pure]
    bool ICollection<KeyValuePair<bool, T>>.Remove(KeyValuePair<bool, T> item) => false;
    /// <inheritdoc />
    [Pure]
    bool IDictionary<bool, T>.Remove(bool key) => false;
    /// <inheritdoc cref="IDictionary{TKey, TValue}.ContainsKey" />
    [Pure]
    bool IDictionary<bool, T>.ContainsKey(bool key) => true;
    /// <inheritdoc />
    [Pure]
    IEnumerator<KeyValuePair<bool, T>> IEnumerable<KeyValuePair<bool, T>>.GetEnumerator() =>
        ((IEnumerable<KeyValuePair<bool, T>>)ArrayPair).GetEnumerator();
    /// <inheritdoc cref="IReadOnlyDictionary{TKey, TValue}.ContainsKey" />
    [Pure]
    bool IReadOnlyDictionary<bool, T>.ContainsKey(bool key) => true;
    /// <summary>Deconstructs a <see cref="Split{T}"/> into its components.</summary>
    /// <param name="t">The value to get assigned as <see cref="Truthy"/>.</param>
    /// <param name="f">The value to get assigned as <see cref="Falsy"/>.</param>
    public void Deconstruct(out T t, out T f)
    {
        t = truthy;
        f = falsy;
    }
    /// <inheritdoc />
    [Pure]
    public override string ToString() => $"Split({truthy}, {falsy})";
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Extension methods for nullable types and booleans.</summary>
#if NET7_0_OR_GREATER
    /// <summary>Converts <see cref="bool"/> to <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of number to convert to.</typeparam>
    /// <param name="that">Whether or not to return the one value, or zero.</param>
    /// <returns>
    /// The value <see cref="INumberBase{T}.One"/> or <see cref="INumberBase{T}.Zero"/>,
    /// based on the value of <paramref name="that"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T As<T>(this bool that)
        where T : INumberBase<T> =>
        that ? T.One : T.Zero;
#endif
#if NETCOREAPP || ROSLYN
    /// <summary>Determines whether two sequences are equal.</summary>
    /// <typeparam name="TDerived">The type of element in the compared array.</typeparam>
    /// <typeparam name="TBase">The type of element contained by the collection.</typeparam>
    /// <param name="first">The first <see cref="ImmutableArray{TBase}"/> to compare.</param>
    /// <param name="second">The second <see cref="ImmutableArray{TDerived}"/> to compare.</param>
    /// <returns>
    /// The value <see langword="true"/> if both sequences have the same
    /// values, or are both default; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool GuardedSequenceEqual<TDerived, TBase>(
        this ImmutableArray<TBase> first,
        ImmutableArray<TDerived> second
    )
        where TDerived : TBase =>
        first.IsDefault || second.IsDefault ? first.IsDefault && second.IsDefault : first.SequenceEqual(second);
    /// <summary>Determines whether two sequences are equal according to an equality comparer.</summary>
    /// <typeparam name="TDerived">The type of element in the compared array.</typeparam>
    /// <typeparam name="TBase">The type of element contained by the collection.</typeparam>
    /// <param name="first">The first <see cref="ImmutableArray{TBase}"/> to compare.</param>
    /// <param name="second">The second <see cref="ImmutableArray{TDerived}"/> to compare.</param>
    /// <param name="comparer">The comparer to use to check for equality.</param>
    /// <returns>
    /// The value <see langword="true"/> if both sequences have the same
    /// values, or are both default; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool GuardedSequenceEqual<TDerived, TBase>(
        this ImmutableArray<TBase> first,
        ImmutableArray<TDerived> second,
        Func<TBase, TBase, bool>? comparer
    )
        where TDerived : TBase =>
        first.IsDefault || second.IsDefault ? first.IsDefault && second.IsDefault :
        comparer is null ? first.SequenceEqual(second) : first.SequenceEqual(second, comparer);
    /// <summary>Determines whether two sequences are equal according to an equality comparer.</summary>
    /// <typeparam name="TDerived">The type of element in the compared array.</typeparam>
    /// <typeparam name="TBase">The type of element contained by the collection.</typeparam>
    /// <param name="first">The first <see cref="ImmutableArray{TBase}"/> to compare.</param>
    /// <param name="second">The second <see cref="ImmutableArray{TDerived}"/> to compare.</param>
    /// <param name="comparer">The comparer to use to check for equality.</param>
    /// <returns>
    /// The value <see langword="true"/> if both sequences have the same
    /// values, or are both default; otherwise, <see langword="false"/>.
    /// </returns>
    [MustUseReturnValue]
    public static bool GuardedSequenceEqual<TDerived, TBase>(
        this ImmutableArray<TBase> first,
        ImmutableArray<TDerived> second,
        IEqualityComparer<TBase>? comparer
    )
        where TDerived : TBase =>
        first.IsDefault || second.IsDefault ? first.IsDefault && second.IsDefault :
        comparer is null ? first.SequenceEqual(second) : first.SequenceEqual(second, comparer);
#endif
#if !NET20 && !NET30
    /// <summary>Filters an <see cref="IEnumerable{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IEnumerable{T}"/> with strictly non-null values.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Filter<T>([NoEnumeration] this IEnumerable<T?>? iterable) =>
#pragma warning disable 8619
        iterable?.Where(x => x is not null) ?? [];
#pragma warning restore 8619
    /// <summary>Filters an <see cref="IEnumerable{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IEnumerable{T}"/> with strictly non-null values.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Filter<T>([NoEnumeration] this IEnumerable<T?>? iterable)
        where T : struct =>
#pragma warning disable 8629
        iterable?.Where(x => x.HasValue).Select(x => x.Value) ?? [];
#pragma warning restore 8629
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>Represents the way an assertion be formatted.</summary>
    /// <param name="template">The template that is formatted and shown when the declaring member fails.</param>
    [AttributeUsage(AttributeTargets.Method)]
    public sealed partial class FormatAttribute(string template) : Attribute
    {
        /// <summary>The value that is substituted for the function body of the assertion.</summary>
        public const string Assertion = "!!";
        /// <summary>The value that is substituted for the function body of the first parameter's factory.</summary>
        public const string XFactory = "@x";
        /// <summary>The value that is substituted for first parameter.</summary>
        public const string XValue = "#x";
        /// <summary>The value that is substituted for the function body of the second parameter's factory.</summary>
        public const string YFactory = "@y";
        /// <summary>The value that is substituted for second parameter.</summary>
        public const string YValue = "#y";
        /// <summary>Gets the default formatter.</summary>
        [Pure]
        public static FormatAttribute Default { get; } = new($"Expected {Assertion} to be true.");
        /// <summary>Returns the formatted <see cref="Template"/> by inserting the parameter.</summary>
        /// <param name="assertion">The value to replace <see cref="Assertion"/> with.</param>
        [Pure]
        public string this[string assertion] => Template.Replace(Assertion, assertion.Collapse());
        /// <summary>Returns the formatted <see cref="Template"/> by inserting the parameters.</summary>
        /// <param name="assertion">The value to replace <see cref="Assertion"/> with.</param>
        /// <param name="xFactory">The value to replace <see cref="XFactory"/> with.</param>
        /// <param name="xValue">The value to replace <see cref="XValue"/> with.</param>
        [Pure]
        public string this[string assertion, string xFactory, object? xValue] =>
            xFactory.Collapse() is var factory && xValue.Stringify() is var value
                ? this[assertion, factory, value, factory, value]
                : throw Unreachable;
        /// <summary>Returns the formatted <see cref="Template"/> by inserting the parameters.</summary>
        /// <param name="assertion">The value to replace <see cref="Assertion"/> with.</param>
        /// <param name="xFactory">The value to replace <see cref="XFactory"/> with.</param>
        /// <param name="xValue">The value to replace <see cref="XValue"/> with.</param>
        /// <param name="yFactory">The value to replace <see cref="YFactory"/> with.</param>
        /// <param name="yValue">The value to replace <see cref="YValue"/> with.</param>
        [Pure]
        public string this[string assertion, string xFactory, object? xValue, string yFactory, object? yValue] =>
            new StringBuilder(Template)
               .Replace(Assertion, assertion.Collapse())
               .Replace(XFactory, xFactory.Collapse())
               .Replace(XValue, xValue.Stringify())
               .Replace(YFactory, yFactory.Collapse())
               .Replace(YValue, yValue.Stringify())
               .ToString();
        /// <summary>Gets the template, before any substitution occurs.</summary>
        [Pure]
        public string Template => template;
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="FormatAttribute"/>
        /// by using the constructor <see cref="FormatAttribute(string)"/>.
        /// </summary>
        /// <param name="template">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="FormatAttribute"/> by passing the parameter
        /// <paramref name="template"/> to the constructor <see cref="FormatAttribute(string)"/>.
        /// </returns>
        [Pure]
        public static implicit operator FormatAttribute(string template) => new(template);
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <summary>
/// Methods that provide functions for enumerations of <see cref="Assert.Result"/> instances.
/// </summary>
    /// <summary>Eagerly executes all asserts of the passed in enumerator.</summary>
    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to execute.</param>
    /// <returns>The collected result of all assertions.</returns>
    [Pure]
    public static IList<Assert.Result> RunAll(this IEnumerator<Assert.Result> enumerator)
    {
        SmallList<Assert.Result> collected = [];
        while (enumerator.MoveNext())
            collected.Add(enumerator.Current.Run());
        return collected;
    }
    /// <summary>Eagerly executes all asserts of the passed in enumerable.</summary>
    /// <param name="enumerable">The <see cref="IEnumerable{T}"/> to execute.</param>
    /// <returns>The collected result of all assertions.</returns>
    [Pure]
    public static IList<Assert.Result> RunAll([InstantHandle] this IEnumerable<Assert.Result> enumerable) =>
        enumerable.Select(x => x.Run()).ToIList();
/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>Represents the result of running an assertion.</summary>
    public readonly partial struct Result
    {
        /// <summary>Initializes a new instance of the <see cref="Result"/> struct.</summary>
        /// <param name="setup">The setup to store.</param>
        public Result(Type? setup = null) => Setup = setup;
        /// <summary>Initializes a new instance of the <see cref="Result"/> struct.</summary>
        /// <param name="assertion">The assertion to store.</param>
        /// <param name="setup">The setup to store.</param>
        public Result(Assert? assertion, Type? setup = null)
        {
            Assertion = assertion;
            Setup = setup ?? assertion?.GetType();
        }
        /// <summary>Initializes a new instance of the <see cref="Result"/> struct.</summary>
        /// <param name="error">The error to store.</param>
        /// <param name="setup">The setup to store.</param>
        public Result(Exception? error, Type? setup)
        {
            Error = error;
            Setup = setup;
        }
        /// <summary>Gets a value indicating whether <see cref="Assertion"/> has failed.</summary>
        [MemberNotNullWhen(false, nameof(Assertion)), Pure]
        public bool Failed => !Succeeded;
        /// <summary>Gets a value indicating whether <see cref="Error"/> is set.</summary>
        [MemberNotNullWhen(true, nameof(Error)), Pure]
        public bool HasError => Error is not null;
        /// <summary>Gets a value indicating whether this <see cref="Result"/> has executed.</summary>
        [Pure]
        public bool HasExecuted => !IsDefault;
        /// <summary>Gets a value indicating whether <see cref="Assertion"/> was successfully instantiated.</summary>
        [MemberNotNullWhen(true, nameof(Assertion)), Pure]
        public bool Instantiated => Assertion is not null;
        /// <summary>Gets a value indicating whether this <see cref="Result"/> is the default instance.</summary>
        [Pure]
        public bool IsDefault => Assertion is null && Error is null && Setup is null;
        /// <summary>Gets a value indicating whether <see cref="Assertion"/> has succeeded.</summary>
        [MemberNotNullWhen(true, nameof(Assertion)), Pure]
        public bool Succeeded => Instantiated && Assertion.Message is null;
        /// <summary>Gets the message of the assertion.</summary>
        [Pure]
        public string? Message => Instantiated ? Assertion.Message : null;
        /// <summary>Gets the name of the assertion type.</summary>
        [Pure]
        public string Name => Setup.UnfoldedFullName();
        /// <summary>Gets the assertion that ran.</summary>
        [Pure]
        public Assert? Assertion { get; }
        /// <summary>Gets the error that was thrown while instantiating <see cref="Assertion"/>.</summary>
        [Pure]
        public Exception? Error { get; }
        /// <summary>Gets the default instance.</summary>
        [Pure]
        public Result Default => default;
        /// <summary>Gets the type that was attempted to be instantiated.</summary>
        [Pure]
        public Type? Setup { get; }
        /// <summary>Gets the fail message.</summary>
        /// <returns>The fail message.</returns>
        [Pure]
        string Fail => Setup is null ? "Assertion failed! " : $"Assertion {Setup.Name} failed! ";
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of
        /// <see cref="Result"/> by using the constructor
        /// <see cref="Assert.Result(Type)"/>.
        /// </summary>
        /// <param name="setup">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Result"/>
        /// by passing the parameter <paramref name="setup"/> to the constructor
        /// <see cref="Assert.Result(Type)"/>.
        /// </returns>
        [Pure]
        public static implicit operator Result(Type setup) => new(setup);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of
        /// <see cref="Result"/> by using the constructor
        /// <see cref="global::Assert.Result(global::Assert, global::System.Type)"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Result"/>
        /// by passing the parameter <paramref name="tuple"/> to the constructor
        /// <see cref="global::Assert.Result(global::Assert, global::System.Type)"/>.
        /// </returns>
        [Pure]
        public static implicit operator Result((Assert Assertion, Type Setup) tuple) =>
            new(tuple.Assertion, tuple.Setup);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of
        /// <see cref="Result"/> by using the constructor
        /// <see cref="global::Assert.Result(global::System.Exception, global::System.Type)"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Result"/>
        /// by passing the parameter <paramref name="tuple"/> to the constructor
        /// <see cref="global::Assert.Result(global::System.Exception, global::System.Type)"/>.
        /// </returns>
        [Pure]
        public static implicit operator Result((Exception Error, Type Setup) tuple) => new(tuple.Error, tuple.Setup);
        /// <inheritdoc />
        [Pure]
        public override string ToString() =>
            IsDefault ? "N/A" :
            Instantiated ? Succeeded ? "OK" : $"{Fail}{Assertion.Message}" :
            HasError ? $"{Fail}Unexpectedly threw {Error.GetType().UnfoldedFullName()}: {Error}" :
            "Yet to be determined";
        /// <summary>Executes the assertion and returns the new <see cref="Result"/>.</summary>
        /// <returns>The new instance of <see cref="Result"/> that contains the assertion results.</returns>
        [MustUseReturnValue]
        public Result Run()
        {
            if (Setup is null)
                return default;
            try
            {
                return new(Activator.CreateInstance(Setup, true) as Assert, Setup);
            }
            catch (Exception ex)
            {
                return new(ex, Setup);
            }
        }
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>Defines the base class for an assertion, where the type must throw.</summary>
    protected abstract partial class Throws : Throws<Exception>
    {
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, message, thatEx) { }
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="Assert"/>
abstract partial class Assert
{
    /// <summary>
    /// Defines the base class for an assertion, where the type must throw <typeparamref name="TException"/>.
    /// </summary>
    /// <typeparam name="TException">The type of exception to expect to be thrown.</typeparam>
    public abstract partial class Throws<TException> : Assert
        where TException : Exception
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Assert.Throws{TException}"/> class.
        /// </summary>
        /// <param name="that">The condition that must throw <typeparamref name="TException"/>.</param>
        /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
        /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        protected Throws(
            [InstantHandle] Action that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(Try(that, ref message, thatEx), message, thatEx) { }
        /// <inheritdoc cref="Assert.Throws{TException}(Action, string, string)"/>
        protected Throws(
            [InstantHandle] Func<object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(Try(() => that(), ref message, thatEx), message, thatEx) { }
        /// <summary>Invokes the callback, expecting <typeparamref name="TException"/> to be thrown.</summary>
        /// <param name="that">The condition that must throw <typeparamref name="TException"/>.</param>
        /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
        /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
        /// <returns>
        /// Whether <typeparamref name="TException"/> is thrown by the parameter <paramref name="that"/>.
        /// </returns>
        static bool Try(Action that, [NotNullWhen(false)] ref string? message, string thatEx)
        {
            try
            {
                that();
                return (message ??= Format(thatEx)) is var _ && false;
            }
            catch (TException)
            {
                return true;
            }
            catch (Exception e)
            {
                return (message ??= Format(thatEx, e)) is var _ && false;
            }
        }
        /// <summary>Creates the formatted error message.</summary>
        /// <param name="thatEx">The context of where the error came from.</param>
        /// <param name="e">The caught exception, if one exists.</param>
        /// <returns>The formatted error message.</returns>
        static string Format(string thatEx, Exception? e = null) =>
            $"Expected {thatEx.Collapse()} to throw {typeof(TException).UnfoldedName()}, instead received {Format(e)}.";
        /// <summary>Formats the exception.</summary>
        /// <param name="e">The caught exception, if one exists.</param>
        /// <returns>The formatted exception.</returns>
        static string Format(Exception? e) =>
            e is null
                ? "no exception"
#if NET6_0_OR_GREATER
                : $"{e.GetType().UnfoldedName()}: {e.Message}. {e.StackTrace?.ReplaceLineEndings(" ")}";
#else
                : $"{e.GetType().UnfoldedName()}: {e.Message}. {e.StackTrace?.Replace('\n', ' ')}";
#endif
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <summary>Defines the base class for an assertion, where a function is expected to return true.</summary>
/// <param name="that">The condition that must be true.</param>
/// <param name="message">The message to display when <paramref name="that"/> is false.</param>
/// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
#if CSHARPREPL
public
#endif
abstract partial class Assert(
    bool that,
    string? message = null,
    [CallerArgumentExpression(nameof(that))] string thatEx = ""
)
{
#if !CSHARPREPL
    static readonly IList<Type> s_assertions = typeof(Assert).Assembly.TryGetTypes().Where(IsAssertable).ToIList();
#endif
    /// <summary>Initializes a new instance of the <see cref="Assert"/> class.</summary>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
    /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
    protected Assert(
        [InstantHandle] Func<bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(Update(that, that, ref message, f => f?[thatEx]), message, thatEx) { }
    /// <summary>Gets the amount of available assertions.</summary>
    [Pure]
    public static int Length =>
#if CSHARPREPL
        Runner.Count();
#else
        s_assertions.Count;
#endif
    /// <summary>
    /// Gets the enumeration responsible for running every <see cref="Assert"/> instance
    /// defined in the current <see cref="Assembly"/>, and returning every instance of a failed assert.
    /// </summary>
    [Pure]
    public static IEnumerable<Result> Runner =>
#if CSHARPREPL
        AppDomain
           .CurrentDomain
           .GetAssemblies()
           .SelectMany(ManyQueries.TryGetTypes)
           .Where(IsAssertable)
#else
        s_assertions
#endif
           .Select(x => new Result(x));
    /// <summary>Gets the message of the assertion if it failed, or null.</summary>
    [Pure]
    public string? Message { get; } = that ? null : message ?? FormatAttribute.Default[thatEx];
    /// <summary>Gets the name of the assertion.</summary>
    [Pure]
    public string Name => GetType().UnfoldedFullName();
    /// <summary>Assertion that the enumerable must contain an item.</summary>
    /// <param name="x">The enumerable that must contain an item.</param>
    /// <returns>Whether the parameter <paramref name="x"/> contains an item.</returns>
    [Format("Expected @x to have any items, received an empty collection."), Pure]
    public static bool Any([InstantHandle] IEnumerable x)
    {
        var e = x.GetEnumerator();
        try
        {
            return e.MoveNext();
        }
        finally
        {
            (e as IDisposable)?.Dispose();
        }
    }
    /// <summary>Assertion that the enumerable must be empty.</summary>
    /// <param name="x">The enumerable that must be empty.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is empty.</returns>
    [Format("Expected @x to be an empty collection, received #x."), Pure]
    public static bool Empty([InstantHandle] IEnumerable x) => !Any(x);
    /// <summary>Assertion that the enumerable must be null or empty.</summary>
    /// <param name="x">The enumerable that must be null or empty.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is null or empty.</returns>
    [Format("Expected @x to be null or empty, received #x."), Pure]
    public static bool EmptyOrNull([InstantHandle, NotNullWhen(false)] IEnumerable? x) => x is null || !Any(x);
    /// <summary>Updates the value of the referenced parameter if the provided assertion fails.</summary>
    /// <param name="exposure">The exposed <see cref="Delegate"/> used to get metadata from.</param>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to update.</param>
    /// <param name="formatter">The factory of the message.</param>
    /// <returns>The returned value when calling the parameter <paramref name="that"/>.</returns>
    [MustUseReturnValue]
    public static bool Update(
        [InstantHandle] Delegate exposure,
        [InstantHandle] Func<bool> that,
        ref string? message,
        [InstantHandle] Converter<FormatAttribute?, string?> formatter
    ) =>
        that() || (message ??= formatter(exposure.Method.GetCustomAttribute<FormatAttribute>())) is var _ && false;
    /// <summary>Assertion that both parameters must contain the same items.</summary>
    /// <typeparam name="T">The type of items to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> have the same items.</returns>
    [Format("Expected @x to have the same items as @y, received #x and #y."), Pure]
    public static bool SequenceEqualTo<T>([InstantHandle] IEnumerable<T> x, [InstantHandle] IEnumerable<T> y) =>
        x.SequenceEqual(y);
    /// <summary>Assertion that both parameters must be equal.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> are the same.</returns>
    [Format("Expected @x to be equal to @y, received #x and #y."), Pure]
    public static bool EqualTo<T>(T x, T y) => EqualityComparer<T>.Default.Equals(x, y);
    /// <summary>Assertion that the left-hand side must be greater than the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is greater than <paramref name="y"/>.</returns>
    [Format("Expected @x to be strictly greater than @y, received #x which is less than or equal to #y."), Pure]
    public static bool GreaterThan<T>(T x, T y) => Compare(x, y) > 0;
    /// <summary>Assertion that the left-hand side must be greater than or equal to the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is greater than or equal to <paramref name="y"/>.</returns>
    [Format("Expected @x to be greater than or equal to @y, received #x which is strictly less than #y."), Pure]
    public static bool GreaterThanOrEqualTo<T>(T x, T y) => Compare(x, y) >= 0;
    /// <summary>Assertion that the left-hand side must be less than the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is less than <paramref name="y"/>.</returns>
    [Format("Expected @x to be strictly less than @y, received #x which is greater than or equal to #y."), Pure]
    public static bool LessThan<T>(T x, T y) => Compare(x, y) < 0;
    /// <summary>Assertion that the left-hand side must be less than or equal to the right-hand side.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is less than or equal to <paramref name="y"/>.</returns>
    [Format("Expected @x to be less than or equal to @y, received #x which is strictly greater than #y."), Pure]
    public static bool LessThanOrEqualTo<T>(T x, T y) => Compare(x, y) <= 0;
    /// <summary>Assertion that the enumerable must not be null.</summary>
    /// <param name="x">The value that must not be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is not null.</returns>
    [Format("Expected @x to be not null, received null."), Pure]
    public static bool NotNull([NotNullWhen(true)] object? x) => x is not null;
    /// <summary>Assertion that the enumerable must not be null.</summary>
    /// <typeparam name="T">The type of value to do the null check on.</typeparam>
    /// <param name="x">The value that must not be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is not null.</returns>
    [Format("Expected @x to be not null, received null."), Pure]
    public static bool NotNull<T>([NotNullWhen(true)] T x) => x is not null;
    /// <summary>Assertion that the enumerable must be null.</summary>
    /// <param name="x">The value that must be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is null.</returns>
    [Format("Expected @x to be null, received #x."), Pure]
    public static bool Null([NotNullWhen(false)] object? x) => x is null;
    /// <summary>Assertion that the enumerable must be null.</summary>
    /// <typeparam name="T">The type of value to do the null check on.</typeparam>
    /// <param name="x">The value that must be null.</param>
    /// <returns>Whether the parameter <paramref name="x"/> is null.</returns>
    [Format("Expected @x to be null, received #x."), Pure]
    public static bool Null<T>([NotNullWhen(false)] T x) => x is null;
    /// <summary>Assertion that both parameters must not be equal.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>Whether the parameters <paramref name="x"/> and <paramref name="y"/> are not the same.</returns>
    [Format("Expected @x to not be equal to @y, received #x."), Pure]
    public static bool UnequalTo<T>(T x, T y) => !EqualTo(x, y);
    /// <summary>Compares the two instances. This method is used for any comparing assertion methods.</summary>
    /// <typeparam name="T">The type of values to compare.</typeparam>
    /// <param name="x">The left-hand side.</param>
    /// <param name="y">The right-hand side.</param>
    /// <returns>The resulting value from comparing parameters <paramref name="x"/> and <paramref name="y"/>.</returns>
    [Pure]
    public static int Compare<T>(T x, T y) => Comparer<T>.Default.Compare(x, y);
#if NET7_0_OR_GREATER
    /// <summary>Creates the assertion that two values must be equal to each other within an error of margin.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="margin">The lossy value to which both instances are considered equal.</param>
    /// <returns>The assertion that determines equality of two values within a margin of error.</returns>
    [Pure]
    public static Func<T, T, bool> RoughlyEqualTo<T>(T margin)
        where T : INumber<T> =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            T.Abs(x - y) <= T.Abs(margin);
#else
    /// <summary>Creates the assertion that two items must be equal to each other within an error of margin.</summary>
    /// <param name="margin">The lossy value to which both instances are considered equal.</param>
    /// <returns>The assertion that determines equality of two items within a margin of error.</returns>
    [Pure]
    public static Func<float, float, bool> RoughlyEqualTo(float margin) =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            Math.Abs(x - y) <= Math.Abs(margin);
    /// <inheritdoc cref="RoughlyEqualTo(float)"/>
    [Pure]
    public static Func<double, double, bool> RoughlyEqualTo(double margin) =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            Math.Abs(x - y) <= Math.Abs(margin);
    /// <inheritdoc cref="RoughlyEqualTo(float)"/>
    [Pure]
    public static Func<decimal, decimal, bool> RoughlyEqualTo(decimal margin) =>
        [Format("Expected @x to be approximately equal to @y, received #x and #y.")](x, y) =>
            Math.Abs(x - y) <= Math.Abs(margin);
#endif
    /// <summary>Executes every assertion and gets all of the assertions that failed.</summary>
    /// <returns>All assertions that failed.</returns>
    [Pure]
    public static IEnumerable<string> AllMessages() => Runner.RunAll().Where(x => x.Failed).Select(x => $"{x}");
    /// <summary>Creates the assertion that the value must be within a certain range.</summary>
    /// <param name="range">The range of values to accept. The range is considered to be inclusive on both ends.</param>
    /// <returns>The assertion that determines whether a value is within the specific range.</returns>
    [Pure]
    public static Predicate<int> InRangeOf(Range range) =>
        [Format("Expected @x to be approximately within the range, received #x.")](x) =>
            x >= range.Start.Value && x <= range.End.Value;
#if NET7_0_OR_GREATER
    /// <summary>Creates the assertion that the value must be within a certain range.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="range">The range of values to accept. The range is considered to be inclusive on both ends.</param>
    /// <returns>The assertion that determines whether a value is within the specific range.</returns>
    [Pure]
    public static Predicate<T> InRangeOf<T>(Range range)
        where T : INumberBase<T> =>
        [Format("Expected @x to be approximately within the range, received #x.")](x) =>
            int.CreateSaturating(x) is var i && i >= range.Start.Value && i <= range.End.Value;
#endif
    /// <summary>Creates the assertion that the value must be within a certain range.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="low">The inclusive lower boundary.</param>
    /// <param name="high">The inclusive higher boundary.</param>
    /// <returns>The assertion that determines whether a value is within the specific range.</returns>
    [Pure]
    public static Predicate<T> InRangeOf<T>(T low, T high) =>
        [Format("Expected @x to be approximately within the range, received #x.")](x) =>
            GreaterThanOrEqualTo(x, low) && LessThanOrEqualTo(x, high);
    /// <summary>Creates the assertion that the parameter must contain specific items.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="items">The items that will be eventually compared to.</param>
    /// <returns>The assertion that determines whether a value contains the pre-determined items.</returns>
    [Pure]
    public static Predicate<IEnumerable<T>> Structured<T>(params T[] items) =>
        [Format("Expected @x to have fixed specific items, received #x.")](x) => SequenceEqualTo(x, items);
    /// <summary>Returns the parameter.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="items">The items that will be returned directly.</param>
    /// <returns>The parameter <paramref name="items"/>.</returns>
    [Pure]
    public static T[] Params<T>(params T[] items) => items;
    /// <inheritdoc />
    [Pure]
    public override string ToString() => new Result(this, GetType()).ToString();
    /// <summary>
    /// Determines whether the type implements <see cref="Assert"/> and can be instantiated.
    /// </summary>
    /// <param name="type">The type to check.</param>
    /// <returns>Whether the type implements <see cref="Assert"/> and can be instantiated.</returns>
    [Pure]
    static bool IsAssertable([NotNullWhen(true)] Type? type) =>
        type is { IsAbstract: false, IsClass: true, IsGenericType: false } &&
        ParameterlessConstructor(type) is not null &&
        type.FindPathToNull(x => x.BaseType).Contains(typeof(Assert));
    /// <summary>Gets the parameterless constructor, ignoring possible exceptions thrown.</summary>
    /// <param name="type">The type to get the parameterless exception from.</param>
    /// <returns>
    /// The <see cref="ConstructorInfo"/> containing no parameters from the parameter <paramref name="type"/>,
    /// if one exists.
    /// </returns>
    [Pure]
    static ConstructorInfo? ParameterlessConstructor(Type type)
    {
        try
        {
            return type.GetConstructor(Type.EmptyTypes);
        }
        catch (FileNotFoundException)
        {
            return null;
        }
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="Assert{T}"/>
abstract partial class Assert<T>
{
    /// <summary>Initializes a new instance of the <see cref="Assert{T}"/> class.</summary>
    /// <param name="it">The context value.</param>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
    /// <param name="itEx">The context of where <paramref name="it"/> came from.</param>
    /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
    protected Assert(
        T it,
        [InstantHandle] Predicate<T> that,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : base(Update(that, () => that(it), ref message, f => f?[thatEx, itEx, it]), message, thatEx) { }
    /// <summary>Initializes a new instance of the <see cref="Assert{T}"/> class.</summary>
    /// <param name="x">The first context value.</param>
    /// <param name="y">The second context value.</param>
    /// <param name="that">The condition that must be true.</param>
    /// <param name="message">The message to display when <paramref name="that"/> is false.</param>
    /// <param name="xEx">The context of where <paramref name="x"/> came from.</param>
    /// <param name="yEx">The context of where <paramref name="y"/> came from.</param>
    /// <param name="thatEx">The context of where <paramref name="that"/> came from.</param>
    protected Assert(
        T x,
        T y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : base(Update(that, () => that(x, y), ref message, f => f?[thatEx, xEx, x, yEx, y]), message, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, Predicate{T}, string, string, string)"/>
    protected Assert(
        [InstantHandle] Predicate<T> that,
        T it,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(it, that, message, itEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, Predicate{T}, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> it,
        [InstantHandle] Predicate<T> that,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(it(), that, message, itEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, Predicate{T}, string, string, string)"/>
    protected Assert(
        [InstantHandle] Predicate<T> that,
        [InstantHandle] Func<T> it,
        string? message = null,
        [CallerArgumentExpression(nameof(it))] string itEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(it(), that, message, itEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        T x,
        [InstantHandle] Func<T, T, bool> that,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y, that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        T x,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y, that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        T x,
        [InstantHandle] Func<T> y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y(), that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        T y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y, that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T> y,
        [InstantHandle] Func<T, T, bool> that,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y(), that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y(), that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T, T, bool> that,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y, that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        T x,
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y(), that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> x,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y(), that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        [InstantHandle] Func<T> x,
        T y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x(), y, that, message, xEx, yEx, thatEx) { }
    /// <inheritdoc cref="Assert{T}(T, T, Func{T, T, bool}, string, string, string, string)"/>
    protected Assert(
        [InstantHandle] Func<T, T, bool> that,
        T x,
        [InstantHandle] Func<T> y,
        string? message = null,
        [CallerArgumentExpression(nameof(x))] string xEx = "",
        [CallerArgumentExpression(nameof(y))] string yEx = "",
        [CallerArgumentExpression(nameof(that))] string thatEx = ""
    )
        : this(x, y(), that, message, xEx, yEx, thatEx) { }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="Assert{T}"/>
abstract partial class Assert<T>
{
    /// <summary>Defines the base class for an assertion, where the type must throw.</summary>
    protected new abstract partial class Throws : Throws<Exception>
    {
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(that, x, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(x, that, message, thatEx) { }
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <inheritdoc cref="Assert{T}"/>
abstract partial class Assert<T>
{
    /// <inheritdoc cref="Assert.Throws{TException}"/>
    public new abstract partial class Throws<TException> : Assert.Throws<TException>
        where TException : Exception
    {
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            T x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            T x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Action<T> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Converter<T, object> that,
            [InstantHandle] Func<T> x,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Action<T> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }
        /// <inheritdoc />
        protected Throws(
            [InstantHandle] Func<T> x,
            [InstantHandle] Converter<T, object> that,
            string? message = null,
            [CallerArgumentExpression(nameof(that))] string thatEx = ""
        )
            : base(() => that(x()), message, thatEx) { }
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <summary>Defines the base class for an assertion, where a value is expected to return true.</summary>
/// <typeparam name="T">The type of value to assert with.</typeparam>
abstract partial class Assert<T> : Assert
{
    /// <inheritdoc cref="Assert.EqualTo{T}"/>
    [Format("Expected @x to be equal to @y, received #x and #y.")]
    public static bool EqualTo(T x, T y) => EqualTo<T>(x, y);
    /// <inheritdoc cref="Assert.GreaterThan{T}"/>
    [Format("Expected @x to be strictly greater than @y, received #x which is less than or equal to #y.")]
    public static bool GreaterThan(T x, T y) => GreaterThan<T>(x, y);
    /// <inheritdoc cref="Assert.GreaterThanOrEqualTo{T}"/>
    [Format("Expected @x to be greater than or equal to @y, received #x which is strictly less than #y.")]
    public static bool GreaterThanOrEqualTo(T x, T y) => GreaterThanOrEqualTo<T>(x, y);
    /// <inheritdoc cref="Assert.LessThan{T}"/>
    [Format("Expected @x to be strictly less than @y, received #x which is greater than or equal to #y.")]
    public static bool LessThan(T x, T y) => LessThan<T>(x, y);
    /// <inheritdoc cref="Assert.LessThanOrEqualTo{T}"/>
    [Format("Expected @x to be less than or equal to @y, received #x which is strictly greater than #y.")]
    public static bool LessThanOrEqualTo(T x, T y) => LessThanOrEqualTo<T>(x, y);
    /// <inheritdoc cref="Assert.NotNull{T}"/>
    [Format("Expected @x to be not null, received null.")]
    public static bool NotNull(T x) => NotNull<T>(x);
    /// <inheritdoc cref="Assert.Null{T}"/>
    [Format("Expected @x to be null, received #x.")]
    public static bool Null(T x) => Null<T>(x);
    /// <inheritdoc cref="Assert.SequenceEqualTo{T}"/>
    [Format("Expected @x to have the same items as @y, received #x and #y.")]
    public static bool SequenceEqualTo([InstantHandle] IEnumerable<T> x, [InstantHandle] IEnumerable<T> y) =>
        SequenceEqualTo<T>(x, y);
    /// <inheritdoc cref="Assert.UnequalTo{T}"/>
    [Format("Expected @x to not be equal to @y, received #x.")]
    public static bool UnequalTo(T x, T y) => UnequalTo<T>(x, y);
    /// <inheritdoc cref="Assert.Compare{T}"/>
    [Pure]
    public static int Compare(T x, T y) => Compare<T>(x, y);
    /// <inheritdoc cref="Assert.InRangeOf{T}(T, T)"/>
    [Pure]
    public static Predicate<T> InRangeOf(T low, T high) => InRangeOf<T>(low, high);
    /// <inheritdoc cref="Assert.Structured{T}"/>
    [Pure]
    public static Predicate<IEnumerable<T>> Structured(params T[] expected) => Structured<T>(expected);
    /// <inheritdoc cref="Assert.Params{T}"/>
    [Pure]
    public static T[] Params(params T[] items) => Params<T>(items);
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
#endif
// ReSharper disable once CheckNamespace
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
#endif
/// <summary>Provides methods for exiting the program.</summary>
    /// <remarks><para>This method represents the exit code 0, indicating success.</para></remarks>
    /// <inheritdoc cref="With{T}"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static Exception Success(string? message = null) => With<Exception>(message, 0);
    /// <remarks><para>This method represents the exit code 1, indicating failure.</para></remarks>
    /// <inheritdoc cref="With{T}"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static Exception Failure(string? message = null) => With<Exception>(message, 1);
    /// <remarks><para>This method represents the exit code 2, indicating invalid parameters.</para></remarks>
    /// <inheritdoc cref="With{T}"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static Exception Usage(string? message = null) => With<Exception>(message, 2);
    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <inheritdoc cref="Success"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static T Success<T>(string? message = null) => With<T>(message, 0);
    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <inheritdoc cref="Failure"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static T Failure<T>(string? message = null) => With<T>(message, 1);
    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <inheritdoc cref="Usage"/>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    public static T Usage<T>(string? message = null) => With<T>(message, 2);
    /// <summary>Terminates this process and returns the exit code to the operating system.</summary>
    /// <typeparam name="T">Only used for type coercion.</typeparam>
    /// <param name="message">The message to print into the standard output/error, if specified.</param>
    /// <param name="exitCode">The exit code.</param>
    /// <exception cref="SecurityException">
    /// The caller does not have sufficient security permission to perform this function.
    /// </exception>
    /// <returns>This method does not return. Specified to allow <see langword="throw"/> expressions.</returns>
    [ContractAnnotation("=> halt"),
     DoesNotReturn,
     SecuritySafeCritical,
#if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
     SecurityPermission(Demand, Flags = UnmanagedCode),
#endif
    ]
    static T With<T>(string? message, byte exitCode)
    {
        if (message is not null)
            (exitCode is 0 ? Console.Out : Console.Error).WriteLine(message);
        Environment.Exit(exitCode);
        throw Unreachable;
    }
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides methods to use callbacks within a statement.</summary>
#if FORCE_SERILOG || !RELEASE
#if ROSLYN
    /// <summary>The Serilog sink that creates <see cref="Diagnostic"/> instances.</summary>
    public sealed partial class DiagnosticSink : ILogEventSink
    {
        /// <summary>Contains the state of the <see cref="Accumulator"/>.</summary>
        public sealed class Accumulator
        {
            /// <summary>The maximum number of arguments when called from <see cref="Peeks.Do{T}"/>.</summary>
            const int UsualMaxCapacity = 5;
            readonly List<string> _list = new(UsualMaxCapacity);
            readonly StringBuilder _builder = new();
            int _index;
            /// <summary>Gets the message template.</summary>
            public string Template => $"{_builder}";
            /// <summary>Gets the list of property names.</summary>
            public IReadOnlyList<string> Names => _list;
            /// <summary>Steps the <see cref="Accumulator"/> forward.</summary>
            /// <param name="accumulator">The accumulator.</param>
            /// <param name="token">The token to process.</param>
            /// <returns>The parameter <paramref name="accumulator"/>.</returns>
            public static Accumulator Next(Accumulator accumulator, MessageTemplateToken token) =>
                accumulator.Next(token);
            /// <summary>Deconstructs the <see cref="Accumulator"/>.</summary>
            /// <param name="template">The message template.</param>
            /// <param name="names">The list of property names. </param>
            public void Deconstruct(out string template, out IReadOnlyList<string> names) =>
                (template, names) = (Template, Names);
            /// <summary>Steps the <see cref="Accumulator"/> forward.</summary>
            /// <param name="token">The token to process.</param>
            /// <returns>Itself.</returns>
            public Accumulator Next(MessageTemplateToken token)
            {
                if (token is TextToken { Text: var text })
                {
                    _builder.Append(text);
                    return this;
                }
                if (token is not PropertyToken property)
                    throw Unreachable;
                _builder.Append('{').Append(_index++).Append('}');
                _list.Add(property.PropertyName);
                return this;
            }
        }
        /// <summary>Gets the logged diagnostics.</summary>
        [Pure]
        public ConcurrentQueue<Diagnostic> UnreportedDiagnostics { get; } = [];
        /// <summary>Gets or sets the additional locations.</summary>
        [Pure]
        public IEnumerable<Location>? AdditionalLocations { get; set; }
        /// <summary>Gets or sets the location.</summary>
        [Pure]
        public Location Location { get; set; } = Location.None;
        /// <inheritdoc />
        public void Emit(LogEvent logEvent)
        {
            var (template, list) = logEvent.MessageTemplate.Tokens.Aggregate(new Accumulator(), Accumulator.Next);
            var level = ToDiagnosticSeverity(logEvent.Level);
            DiagnosticDescriptor descriptor = new(Name, $"{s_guid}", template, Name, level, true);
            var args = list.Select(object? (x) => logEvent.Properties[x]).ToArray();
            var diagnostic = Diagnostic.Create(descriptor, Location, AdditionalLocations, args);
            UnreportedDiagnostics.Enqueue(diagnostic);
        }
        static DiagnosticSeverity ToDiagnosticSeverity(LogEventLevel level) =>
            level switch
            {
                LogEventLevel.Debug => DiagnosticSeverity.Info,
                LogEventLevel.Error => DiagnosticSeverity.Error,
                LogEventLevel.Fatal => DiagnosticSeverity.Error,
                LogEventLevel.Information => DiagnosticSeverity.Info,
                LogEventLevel.Verbose => DiagnosticSeverity.Info,
                LogEventLevel.Warning => DiagnosticSeverity.Warning,
                _ => throw Unreachable,
            };
    }
#endif
    /// <summary>The character often used to identify scripted assemblies.</summary>
    public const char R = '\u211b';
    /// <summary>The escape sequence to clear the screen.</summary>
    public const string Clear = "\x1b\x5b\x48\x1b\x5b\x32\x4a\x1b\x5b\x33\x4a";
#if ROSLYN
    const string Name = nameof(DiagnosticSink);
    static readonly DiagnosticSink s_diagnosticSink = new();
    static readonly Guid s_guid = Guid.NewGuid();
#endif
#if NET462_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    static readonly string s_path = Path.Combine(
        Path.GetTempPath(),
        typeof(Assert).Assembly.GetName().Name is [not R, ..] name ? name : $"{R}"
    );
    static readonly ITextFormatter s_json =
#if CSHARPREPL
        new JsonFormatter();
#else
        new CompactJsonFormatter();
#endif
    static readonly Serilog.Core.Logger
        s_clef = new LoggerConfiguration().MinimumLevel.Verbose().WriteTo.File(s_json, $"{s_path}.clef").CreateLogger(),
#if ROSLYN
        s_roslyn = new LoggerConfiguration().MinimumLevel.Verbose().WriteTo.Sink(s_diagnosticSink).CreateLogger();
#else
        s_console = new LoggerConfiguration().MinimumLevel.Verbose().WriteTo.Console().CreateLogger();
#endif
#endif
#endif
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
    static readonly string s_debugFile = Path.Combine(Path.GetTempPath(), "morsels.log");
#if !RELEASE && !CSHARPREPL
    static Peeks() => File.Create(s_debugFile).Dispose();
#endif
#endif
    /// <summary>An event that is invoked every time <see cref="Write"/> is called.</summary>
    public static event Action<string> OnWrite =
#if NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2
        Shout;
#else
        (Action<string>)Shout +
#if KTANE
        UnityEngine.Debug.Log +
#endif
        Console.WriteLine;
#endif
#if NETFRAMEWORK || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <summary>Gets all the types currently loaded.</summary>
    [Pure]
    public static IEnumerable<Type> AllTypes =>
        AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.TryGetTypes());
#endif
#if !RELEASE && ROSLYN
    /// <inheritdoc cref="DiagnosticSink.UnreportedDiagnostics"/>
    [Pure]
    public static ConcurrentQueue<Diagnostic> Diagnostics => s_diagnosticSink.UnreportedDiagnostics;
    /// <summary>Gets the placeholder diagnostic.</summary>
    [Pure]
    public static DiagnosticDescriptor Bare { get; } = new(Name, $"{s_guid}", "", Name, DiagnosticSeverity.Error, true);
#endif
#pragma warning disable CS1574
    /// <summary>
    /// Invokes <see cref="System.Diagnostics.Debug.WriteLine(string)"/>, and <see cref="Trace.WriteLine(string)"/>.
    /// </summary>
    /// <remarks><para>
    /// This method exists to be able to hook both conditional methods in <see cref="OnWrite"/>,
    /// and to allow the consumer to be able to remove this method to the same <see cref="OnWrite"/>.
    /// </para></remarks>
    /// <param name="message">The value to send a message.</param>
#pragma warning restore CS1574
    public static void Shout(string message)
    {
        System.Diagnostics.Debug.WriteLine(message);
#if !(NETSTANDARD && !NETSTANDARD2_0_OR_GREATER)
#pragma warning disable S6670
        Trace.WriteLine(message);
#pragma warning restore S6670
#endif
#if !NETSTANDARD || NETSTANDARD1_3_OR_GREATER
        if (File.Exists(s_debugFile))
            File.AppendAllText(s_debugFile, $"[{DateTime.Now.ToLongTimeString()}]: {message}\n");
#endif
    }
    /// <summary>Quick and dirty debugging function, invokes <see cref="OnWrite"/>.</summary>
    /// <param name="message">The value to send a message.</param>
    /// <exception cref="InvalidOperationException">
    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
    /// every callback has been manually removed as it is always valid by default.
    /// </exception>
    public static void Write(this string message) => (OnWrite ?? throw new InvalidOperationException(message))(message);
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <summary>Quick and dirty debugging function, invokes <see cref="OnWrite"/>.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to stringify.</param>
    /// <exception cref="InvalidOperationException">
    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
    /// every callback has been manually removed as it is always valid by default.
    /// </exception>
#pragma warning disable RCS1196
    public static void Write<T>(T value) => Write(Stringifier.Stringify(value));
#pragma warning restore RCS1196
#if NET462_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
#if !FORCE_SERILOG && RELEASE && !CSHARPREPL
#if ROSLYN
    /// <inheritdoc cref="Mark(Location, IEnumerable{Location})"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Location Mark(this Location location, [UsedImplicitly] params Location[]? additionalLocations) =>
        location;
    /// <summary>Marks the location in the next set of lints.</summary>
    /// <param name="location">The primary location.</param>
    /// <param name="additionalLocations">Additional locations.</param>
    /// <returns>The parameter <paramref name="location"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Location Mark(this Location location, [UsedImplicitly] IEnumerable<Location>? additionalLocations) =>
        location;
#endif
    /// <summary>Write a log event with the <see cref="LogEventLevel.Debug"/> level.</summary>
    /// <typeparam name="T">The type of the value to write.</typeparam>
    /// <param name="x">The value to write.</param>
    /// <param name="map">When specified, overrides the value that is logged.</param>
    /// <param name="visit">The maximum number of times to recurse through an enumeration.</param>
    /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
    /// <param name="recurse">The maximum number of times to recurse a nested object or dictionary.</param>
    /// <returns>The parameter <paramref name="x"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Debug<T>(
        this T x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurse = DeconstructionCollection.DefaultRecurseLength
    ) =>
        x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Debug<T>(
        this Span<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurse = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static PooledSmallList<T> Debug<T>(
        this PooledSmallList<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurse = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SplitSpan<TBody, TSeparator, TStrategy> Debug<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> x,
        [InstantHandle, UsedImplicitly] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurse = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> Debug<T>(
        this ReadOnlySpan<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurse = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Error"/> level.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Error<T>(
        this T x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    ) =>
        x;
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Error<T>(
        this Span<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static PooledSmallList<T> Error<T>(
        this PooledSmallList<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SplitSpan<TBody, TSeparator, TStrategy> Error<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> x,
        [InstantHandle, UsedImplicitly] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            x;
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> Error<T>(
        this ReadOnlySpan<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Fatal"/> level.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Fatal<T>(
        this T x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    ) =>
        x;
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Fatal<T>(
        this Span<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static PooledSmallList<T> Fatal<T>(
        this PooledSmallList<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SplitSpan<TBody, TSeparator, TStrategy> Fatal<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> x,
        [InstantHandle, UsedImplicitly] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            x;
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> Fatal<T>(
        this ReadOnlySpan<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Information"/> level.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Info<T>(
        this T x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    ) =>
        x;
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Info<T>(
        this Span<T> x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static PooledSmallList<T> Info<T>(
        this PooledSmallList<T> x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SplitSpan<TBody, TSeparator, TStrategy> Info<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> x,
        [InstantHandle, UsedImplicitly] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            x;
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> Info<T>(
        this ReadOnlySpan<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Verbose"/> level.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Verbose<T>(
        this T x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    ) =>
        x;
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Verbose<T>(
        this Span<T> x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static PooledSmallList<T> Verbose<T>(
        this PooledSmallList<T> x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SplitSpan<TBody, TSeparator, TStrategy> Verbose<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> x,
        [InstantHandle, UsedImplicitly] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            x;
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> Verbose<T>(
        this ReadOnlySpan<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Warning"/> level.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Warn<T>(
        this T x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    ) =>
        x;
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Span<T> Warn<T>(
        this Span<T> x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static PooledSmallList<T> Warn<T>(
        this PooledSmallList<T> x,
        [InstantHandle, UsedImplicitly] Converter<T, object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static SplitSpan<TBody, TSeparator, TStrategy> Warn<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> x,
        [InstantHandle, UsedImplicitly] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
        =>
            x;
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan<T> Warn<T>(
        this ReadOnlySpan<T> x,
        [InstantHandle, UsedImplicitly] Converter<T[], object?>? map = null,
        [NonNegativeValue, UsedImplicitly] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue, UsedImplicitly] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue, UsedImplicitly] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
        =>
            x;
#else
#if ROSLYN
    /// <inheritdoc cref="Mark(Location, IEnumerable{Location})"/>
    public static Location Mark(this Location location, params Location[]? additionalLocations) =>
        Mark(location, (IEnumerable<Location>?)additionalLocations);
    /// <summary>Marks the location in the next set of lints.</summary>
    /// <param name="location">The primary location.</param>
    /// <param name="additionalLocations">Additional locations.</param>
    /// <returns>The parameter <paramref name="location"/>.</returns>
    public static Location Mark(this Location location, IEnumerable<Location>? additionalLocations)
    {
        s_diagnosticSink.Location = location;
        s_diagnosticSink.AdditionalLocations = additionalLocations;
        return location;
    }
    /// <summary>Marks the locations in the next set of lints.</summary>
    /// <param name="locations">The locations.</param>
    /// <returns>The first location within the parameter <paramref name="locations"/>.</returns>
    public static Location Mark(this IEnumerable<Location>? locations)
    {
        var (first, rest) = locations;
        try
        {
            return Mark(first, rest);
        }
        finally
        {
            (rest as IDisposable)?.Dispose();
        }
    }
#endif
    /// <summary>Write a log event with the <see cref="LogEventLevel.Debug"/> level.</summary>
    /// <typeparam name="T">The type of the value to write.</typeparam>
    /// <param name="x">The value to write.</param>
    /// <param name="map">When specified, overrides the value that is logged.</param>
    /// <param name="visitLength">The maximum number of times to recurse through an enumeration.</param>
    /// <param name="stringLength">The maximum length of any given <see cref="string"/>.</param>
    /// <param name="recurseLength">The maximum number of times to recurse a nested object or dictionary.</param>
    /// <param name="expression">Automatically filled by compilers; the source code of <paramref name="x"/>.</param>
    /// <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
    /// <param name="name">Automatically filled by compilers; the member's name where this method was called.</param>
    /// <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
    /// <returns>The parameter <paramref name="x"/>.</returns>
    public static T Debug<T>(
        this T x,
        [InstantHandle] Converter<T, object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(x))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    ) =>
        Do(x, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Debug);
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static Span<T> Debug<T>(
        this Span<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Debug);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static PooledSmallList<T> Debug<T>(
        this PooledSmallList<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArrayLazily, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Debug);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Debug<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> value,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        Do(value.ToArrays(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Debug);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static ReadOnlySpan<T> Debug<T>(
        this ReadOnlySpan<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Debug);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Error"/> level.</summary>
    public static T Error<T>(
        this T value,
        [InstantHandle] Converter<T, object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    ) =>
        Do(value, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Error);
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static Span<T> Error<T>(
        this Span<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Error);
        return value;
    }
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static PooledSmallList<T> Error<T>(
        this PooledSmallList<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArrayLazily, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Error);
        return value;
    }
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Error<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> value,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        Do(value.ToArrays(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Error);
        return value;
    }
    /// <inheritdoc cref="Error{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static ReadOnlySpan<T> Error<T>(
        this ReadOnlySpan<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Error);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Fatal"/> level.</summary>
    public static T Fatal<T>(
        this T value,
        [InstantHandle] Converter<T, object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    ) =>
        Do(value, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Fatal);
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static Span<T> Fatal<T>(
        this Span<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Fatal);
        return value;
    }
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static PooledSmallList<T> Fatal<T>(
        this PooledSmallList<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArrayLazily, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Fatal);
        return value;
    }
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Fatal<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> value,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        Do(value.ToArrays(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Fatal);
        return value;
    }
    /// <inheritdoc cref="Fatal{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static ReadOnlySpan<T> Fatal<T>(
        this ReadOnlySpan<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Fatal);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Information"/> level.</summary>
    public static T Info<T>(
        this T value,
        [InstantHandle] Converter<T, object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    ) =>
        Do(value, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Information);
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static Span<T> Info<T>(
        this Span<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Information);
        return value;
    }
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static PooledSmallList<T> Info<T>(
        this PooledSmallList<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArrayLazily, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Information);
        return value;
    }
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Info<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> value,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        Do(value.ToArrays(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Information);
        return value;
    }
    /// <inheritdoc cref="Info{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static ReadOnlySpan<T> Info<T>(
        this ReadOnlySpan<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Information);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Verbose"/> level.</summary>
    public static T Verbose<T>(
        this T value,
        [InstantHandle] Converter<T, object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    ) =>
        Do(value, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Verbose);
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static Span<T> Verbose<T>(
        this Span<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Verbose);
        return value;
    }
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static PooledSmallList<T> Verbose<T>(
        this PooledSmallList<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArrayLazily, map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Verbose);
        return value;
    }
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Verbose<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> value,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        Do(value.ToArrays(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Verbose);
        return value;
    }
    /// <inheritdoc cref="Verbose{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static ReadOnlySpan<T> Verbose<T>(
        this ReadOnlySpan<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visitLength, stringLength, recurseLength, expression, path, name, line, LogEventLevel.Verbose);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    /// <summary>Write a log event with the <see cref="LogEventLevel.Warning"/> level.</summary>
    public static T Warn<T>(
        this T value,
        [InstantHandle] Converter<T, object?>? map = null,
        [NonNegativeValue] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurse = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    ) =>
        Do(value, map, visit, str, recurse, expression, path, name, line, LogEventLevel.Warning);
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static Span<T> Warn<T>(
        this Span<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurse = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visit, str, recurse, expression, path, name, line, LogEventLevel.Warning);
        return value;
    }
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static PooledSmallList<T> Warn<T>(
        this PooledSmallList<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurse = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArrayLazily, map, visit, str, recurse, expression, path, name, line, LogEventLevel.Warning);
        return value;
    }
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Warn<TBody, TSeparator, TStrategy>(
        this SplitSpan<TBody, TSeparator, TStrategy> value,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [NonNegativeValue] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurse = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        Do(value.ToArrays(), map, visit, str, recurse, expression, path, name, line, LogEventLevel.Warning);
        return value;
    }
    /// <inheritdoc cref="Warn{T}(T, Converter{T, object}, int, int, int, string, string, string, int)"/>
    public static ReadOnlySpan<T> Warn<T>(
        this ReadOnlySpan<T> value,
        [InstantHandle] Converter<T[], object?>? map = null,
        [NonNegativeValue] int visit = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int str = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurse = DeconstructionCollection.DefaultRecurseLength,
        [CallerArgumentExpression(nameof(value))] string? expression = "",
        [CallerFilePath] string? path = null,
        [CallerMemberName] string? name = null,
        [CallerLineNumber] int line = default
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        Do(value.ToArray(), map, visit, str, recurse, expression, path, name, line, LogEventLevel.Warning);
        return value;
    }
    static T Do<T>(
        T value,
        [InstantHandle] Converter<T, object?>? map,
        [NonNegativeValue] int visitLength,
        [NonNegativeValue] int stringLength,
        [NonNegativeValue] int recurseLength,
        string? expression,
        string? path,
        string? name,
        int line,
        LogEventLevel level
    )
    {
        static object? Memory(T value) =>
            value switch
            {
                null => null,
#if ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
                Memory<char> m => m.ToString(),
                ReadOnlyMemory<char> m => m.ToString(),
                _ when value.GetType().GetMethod(nameof(Memory<int>.ToArray), []) is
                    {
                        IsStatic: false, ReturnParameter.ParameterType: var ret, IsGenericMethod: false,
                    } method &&
                    ret != typeof(void) => method.Invoke(value, null),
#endif
                _ => value,
            };
        var x = (map ?? Memory)(value).ToDeconstructed(visitLength, stringLength, recurseLength) is var deconstructed &&
            deconstructed is DeconstructionCollection { Serialized: var serialized }
                ? serialized
                : deconstructed;
#if ROSLYN
        var y = (x as DeconstructionCollection)?.ToStringWithoutNewLines() ?? x;
#endif
        if (expression.CollapseToSingleLine() is var ex && path.FileName() is not { Length: not 0 } file)
        {
            s_clef.Write(level, "[{@Member}:{@Line} ({@Expression})] {@Value}", name, line, ex, x);
#if ROSLYN
            s_roslyn.Write(level, "[{@Member}:{@Line} ({@Expression})] {@Value}", name, line, ex, y);
#else
            s_console.Write(level, "[{@Member}:{@Line} ({@Expression})] {@Value}", name, line, ex, x);
#endif
            return value;
        }
        s_clef.Write(level, "[{$File}.{@Member}:{@Line} ({@Expression})] {@Value}", file, name, line, ex, x);
#if ROSLYN
        s_roslyn.Write(level, "[{$File}.{@Member}:{@Line} ({@Expression})] {@Value}", file, name, line, ex, y);
#else
        s_console.Write(level, "[{$File}.{@Member}:{@Line} ({@Expression})] {@Value}", file, name, line, ex, x);
#endif
        return value;
    }
#endif
#else
    /// <summary>Quick and dirty debugging function.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The value to stringify and return.</param>
    /// <param name="shouldPrettify">Determines whether to prettify the resulting <see cref="string"/>.</param>
    /// <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
    /// <param name="map">The map callback.</param>
    /// <param name="filter">The filter callback.</param>
    /// <param name="logger">The logging callback.</param>
    /// <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
    /// <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
    /// <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
    /// <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
    /// <exception cref="InvalidOperationException">
    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
    /// every callback has been manually removed as it is always valid by default.
    /// </exception>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    [return: NotNullIfNotNull(nameof(value))]
    public static T Debug<T>(
        this T value,
        bool shouldPrettify = true,
        bool shouldLogExpression = true,
        [InstantHandle] Converter<T, object?>? map = null,
        [InstantHandle] Predicate<T>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
    {
        const string
            Indent = "\n        ",
            Of = $"{Indent}of ";
        if (!(filter ?? (_ => true))(value))
            return value;
        logger ??= Write;
        var stringified = (map ?? (x => x))(value) switch
        {
            var x when typeof(T) == typeof(string) && !(shouldLogExpression = false) => x,
            string x => x,
            var x when shouldPrettify => Stringifier.Stringify(x).Prettify(),
            var x => Stringifier.Stringify(x),
        };
        var logExpression = shouldLogExpression ? expression.CollapseToSingleLine(Of) : "";
        var log = $"{stringified}{logExpression}{Indent}at {member} in {path.FileName()}:line {line}";
        logger(log);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    [return: NotNullIfNotNull(nameof(value))]
    public static T Debug<T, TAs>(
        this T value,
        bool shouldPrettify = true,
        bool shouldLogExpression = true,
        [InstantHandle] Converter<T, TAs?>? map = null,
        [InstantHandle] Predicate<T>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
    {
        if (!(filter ?? (_ => true))(value))
            return value;
        var stringified = (map ?? (x => x is TAs t ? t : default))(value) switch
        {
            var x when typeof(T) == typeof(string) && !(shouldLogExpression = false) => x as object,
            string x => x,
            var x when shouldPrettify => Stringifier.Stringify(x).Prettify(),
            var x => Stringifier.Stringify(x),
        };
        Debug(
            stringified,
            false,
            shouldLogExpression,
            logger: logger,
            expression: expression,
            path: path,
            line: line,
            member: member
        );
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static Span<T> Debug<T>(
        this in Span<T> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<T[], object?>? map = null,
        [InstantHandle] Predicate<T[]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        _ = value
           .ToArray()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);
        return value;
    }
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static PooledSmallList<T> Debug<T>(
        this in PooledSmallList<T> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<T[], object?>? map = null,
        [InstantHandle] Predicate<T[]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        _ = value
           .View
           .ToArray()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);
        return value;
    }
#endif
    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static SplitSpan<TBody, TSeparator, TStrategy> Debug<TBody, TSeparator, TStrategy>(
        this in SplitSpan<TBody, TSeparator, TStrategy> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<TBody[][], object?>? map = null,
        [InstantHandle] Predicate<TBody[][]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where TBody : unmanaged, IEquatable<TBody>
#else
        where TBody : IEquatable<TBody>?
#endif
#if !NET7_0_OR_GREATER
        where TSeparator : IEquatable<TSeparator>?
#endif
    {
        _ = value
           .ToArrays()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);
        return value;
    }
    /// <inheritdoc cref="Debug{T}(T, bool, bool, Converter{T, object?}?, Predicate{T}?, Action{string}?, string?, string?, int, string?)"/>
    public static ReadOnlySpan<T> Debug<T>(
        this ReadOnlySpan<T> value,
        bool shouldPrettify = true,
        bool shouldLogExpression = false,
        [InstantHandle] Converter<T[], object?>? map = null,
        [InstantHandle] Predicate<T[]>? filter = null,
        [InstantHandle] Action<string>? logger = null,
        [CallerArgumentExpression(nameof(value))] string? expression = null,
        [CallerFilePath] string? path = null,
        [CallerLineNumber] int line = default,
        [CallerMemberName] string? member = null
    )
#if UNMANAGED_SPAN
        where T : unmanaged
#endif
    {
        _ = value
           .ToArray()
           .Debug(shouldPrettify, shouldLogExpression, map, filter, logger, expression, path, line, member);
        return value;
    }
#endif
#endif
    /// <summary>Executes an <see cref="Action{T}"/>, and returns the argument.</summary>
    /// <typeparam name="T">The type of value and action parameter.</typeparam>
    /// <param name="value">The value to pass into the callback.</param>
    /// <param name="action">The callback to perform.</param>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    public static T Peek<T>(this T value, [InstantHandle] Action<T> action)
    {
        action(value);
        return value;
    }
#if !NETFRAMEWORK
    /// <summary>Executes a <see langword="delegate"/> pointer, and returns the argument.</summary>
    /// <typeparam name="T">The type of value and delegate pointer parameter.</typeparam>
    /// <param name="value">The value to pass into the callback.</param>
    /// <param name="call">The callback to perform.</param>
    /// <exception cref="ArgumentNullException">
    /// The value <paramref name="call"/> points to <see langword="null"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="value"/>.</returns>
    public static unsafe T Peek<T>(this T value, [InstantHandle] delegate*<T, void> call)
    {
        if (call is not null)
            call(value);
        return value;
    }
#endif
    /// <summary>Executes the function, and returns the result.</summary>
    /// <typeparam name="T">The type of value and input parameter.</typeparam>
    /// <typeparam name="TResult">The type of output and return value.</typeparam>
    /// <param name="value">The value to pass into the callback.</param>
    /// <param name="converter">The callback to perform.</param>
    /// <returns>The return value of <paramref name="converter"/> after passing in <paramref name="value"/>.</returns>
    public static TResult Then<T, TResult>(this T value, [InstantHandle] Converter<T, TResult> converter) =>
        converter(value);
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer
#pragma warning restore GlobalUsingsAnalyzer
// ReSharper disable once CheckNamespace
/// <summary>Provides methods to wrap delegates around try-catch blocks.</summary>
    /// <summary>Attempts to execute the <paramref name="action"/>.</summary>
    /// <param name="action">The action to execute.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <returns>The value indicating whether <paramref name="action"/> threw an <see cref="Exception"/>.</returns>
    public static bool Go([InstantHandle] Action action, [NotNullWhen(true)] out Exception? err)
    {
        try
        {
            action();
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="action"/>.</summary>
    /// <typeparam name="T">The type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <param name="action">The action to execute.</param>
    /// <param name="param">The parameter to pass to <paramref name="action"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <returns>The value indicating whether <paramref name="action"/> threw an <see cref="Exception"/>.</returns>
    public static bool Go<T>([InstantHandle] Action<T> action, in T param, [NotNullWhen(true)] out Exception? err)
    {
        try
        {
            action(param);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="action"/>.</summary>
    /// <typeparam name="T1">The first type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <typeparam name="T2">The second type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <param name="action">The action to execute.</param>
    /// <param name="first">The first parameter to pass to <paramref name="action"/>.</param>
    /// <param name="second">The second parameter to pass to <paramref name="action"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <returns>The value indicating whether <paramref name="action"/> threw an <see cref="Exception"/>.</returns>
    public static bool Go<T1, T2>(
        [InstantHandle] Action<T1, T2> action,
        in T1 first,
        in T2 second,
        [NotNullWhen(true)] out Exception? err
    )
    {
        try
        {
            action(first, second);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="action"/>.</summary>
    /// <typeparam name="T1">The first type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <typeparam name="T2">The second type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <typeparam name="T3">The third type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <param name="action">The action to execute.</param>
    /// <param name="first">The first parameter to pass to <paramref name="action"/>.</param>
    /// <param name="second">The second parameter to pass to <paramref name="action"/>.</param>
    /// <param name="third">The third parameter to pass to <paramref name="action"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <returns>The value indicating whether <paramref name="action"/> threw an <see cref="Exception"/>.</returns>
    public static bool Go<T1, T2, T3>(
        [InstantHandle] Action<T1, T2, T3> action,
        in T1 first,
        in T2 second,
        in T3 third,
        [NotNullWhen(true)] out Exception? err
    )
    {
        try
        {
            action(first, second, third);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="action"/>.</summary>
    /// <typeparam name="T1">The first type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <typeparam name="T2">The second type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <typeparam name="T3">The third type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <typeparam name="T4">The fourth type of parameter to pass to <paramref name="action"/>.</typeparam>
    /// <param name="action">The action to execute.</param>
    /// <param name="first">The first parameter to pass to <paramref name="action"/>.</param>
    /// <param name="second">The second parameter to pass to <paramref name="action"/>.</param>
    /// <param name="third">The third parameter to pass to <paramref name="action"/>.</param>
    /// <param name="fourth">The fourth parameter to pass to <paramref name="action"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <returns>The value indicating whether <paramref name="action"/> threw an <see cref="Exception"/>.</returns>
    public static bool Go<T1, T2, T3, T4>(
        [InstantHandle] Action<T1, T2, T3, T4> action,
        in T1 first,
        in T2 second,
        in T3 third,
        in T4 fourth,
        [NotNullWhen(true)] out Exception? err
    )
    {
        try
        {
            action(first, second, third, fourth);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="func"/>.</summary>
    /// <typeparam name="T">The return type of <paramref name="func"/>.</typeparam>
    /// <param name="func">The function to execute.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <param name="ok">
    /// When this method returns <see langword="false"/>, contains the <typeparamref name="T"/> that was returned.
    /// </param>
    /// <returns>
    /// The value indicating whether <paramref name="func"/> threw an
    /// <see cref="Exception"/> or returned a <typeparamref name="T"/>.
    /// </returns>
    public static bool Go<T>(
        [InstantHandle] Func<T> func,
        [NotNullWhen(true)] out Exception? err,
        [NotNullWhen(false)] out T? ok
    )
        where T : notnull
    {
        try
        {
            ok = func();
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            ok = default;
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="func"/>.</summary>
    /// <typeparam name="T">The type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="TResult">The return type of <paramref name="func"/>.</typeparam>
    /// <param name="func">The function to execute.</param>
    /// <param name="param">The parameter to pass to <paramref name="func"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <param name="ok">
    /// When this method returns <see langword="false"/>, contains the <typeparamref name="TResult"/> that was returned.
    /// </param>
    /// <returns>
    /// The value indicating whether <paramref name="func"/> threw an
    /// <see cref="Exception"/> or returned a <typeparamref name="TResult"/>.
    /// </returns>
    public static bool Go<T, TResult>(
        [InstantHandle] Func<T, TResult> func,
        in T param,
        [NotNullWhen(true)] out Exception? err,
        [NotNullWhen(false)] out TResult? ok
    )
        where TResult : notnull
    {
        try
        {
            ok = func(param);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            ok = default;
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="func"/>.</summary>
    /// <typeparam name="T1">The first type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="T2">The second type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="TResult">The return type of <paramref name="func"/>.</typeparam>
    /// <param name="func">The function to execute.</param>
    /// <param name="first">The first parameter to pass to <paramref name="func"/>.</param>
    /// <param name="second">The second parameter to pass to <paramref name="func"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <param name="ok">
    /// When this method returns <see langword="false"/>, contains the <typeparamref name="TResult"/> that was returned.
    /// </param>
    /// <returns>
    /// The value indicating whether <paramref name="func"/> threw an
    /// <see cref="Exception"/> or returned a <typeparamref name="TResult"/>.
    /// </returns>
    public static bool Go<T1, T2, TResult>(
        [InstantHandle] Func<T1, T2, TResult> func,
        in T1 first,
        in T2 second,
        [NotNullWhen(true)] out Exception? err,
        [NotNullWhen(false)] out TResult? ok
    )
        where TResult : notnull
    {
        try
        {
            ok = func(first, second);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            ok = default;
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="func"/>.</summary>
    /// <typeparam name="T1">The first type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="T2">The second type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="T3">The third type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="TResult">The return type of <paramref name="func"/>.</typeparam>
    /// <param name="func">The function to execute.</param>
    /// <param name="first">The first parameter to pass to <paramref name="func"/>.</param>
    /// <param name="second">The second parameter to pass to <paramref name="func"/>.</param>
    /// <param name="third">The third parameter to pass to <paramref name="func"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <param name="ok">
    /// When this method returns <see langword="false"/>, contains the <typeparamref name="TResult"/> that was returned.
    /// </param>
    /// <returns>
    /// The value indicating whether <paramref name="func"/> threw an
    /// <see cref="Exception"/> or returned a <typeparamref name="TResult"/>.
    /// </returns>
    public static bool Go<T1, T2, T3, TResult>(
        [InstantHandle] Func<T1, T2, T3, TResult> func,
        in T1 first,
        in T2 second,
        in T3 third,
        [NotNullWhen(true)] out Exception? err,
        [NotNullWhen(false)] out TResult? ok
    )
        where TResult : notnull
    {
        try
        {
            ok = func(first, second, third);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            ok = default;
            err = ex;
            return true;
        }
    }
    /// <summary>Attempts to execute the <paramref name="func"/>.</summary>
    /// <typeparam name="T1">The first type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="T2">The second type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="T3">The third type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="T4">The fourth type of parameter to pass to <paramref name="func"/>.</typeparam>
    /// <typeparam name="TResult">The return type of <paramref name="func"/>.</typeparam>
    /// <param name="func">The function to execute.</param>
    /// <param name="first">The first parameter to pass to <paramref name="func"/>.</param>
    /// <param name="second">The second parameter to pass to <paramref name="func"/>.</param>
    /// <param name="third">The third parameter to pass to <paramref name="func"/>.</param>
    /// <param name="fourth">The fourth parameter to pass to <paramref name="func"/>.</param>
    /// <param name="err">
    /// When this method returns <see langword="true"/>, contains the <see cref="Exception"/> that was thrown.
    /// </param>
    /// <param name="ok">
    /// When this method returns <see langword="false"/>, contains the <typeparamref name="TResult"/> that was returned.
    /// </param>
    /// <returns>
    /// The value indicating whether <paramref name="func"/> threw an
    /// <see cref="Exception"/> or returned a <typeparamref name="TResult"/>.
    /// </returns>
    public static bool Go<T1, T2, T3, T4, TResult>(
        [InstantHandle] Func<T1, T2, T3, T4, TResult> func,
        in T1 first,
        in T2 second,
        in T3 third,
        in T4 fourth,
        [NotNullWhen(true)] out Exception? err,
        [NotNullWhen(false)] out TResult? ok
    )
        where TResult : notnull
    {
        try
        {
            ok = func(first, second, third, fourth);
            err = null;
            return false;
        }
        catch (Exception ex)
        {
            ok = default;
            err = ex;
            return true;
        }
    }
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer
// ReSharper disable once CheckNamespace RedundantUsingDirective.Global
/// <summary>Provides a reference for an <see cref="UnreachableException"/>.</summary>
    /// <summary>Gets the <see cref="Exception"/> that a collection cannot be empty.</summary>
    public static InvalidOperationException CannotBeEmpty { get; } = new("Buffer is empty.");
    /// <summary>Gets the <see cref="Exception"/> that represents an unreachable state.</summary>
    public static UnreachableException Unreachable { get; } = new();
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace EmptyNamespace
#if !NET20 && !NET30 && !NET471_OR_GREATER && !NETSTANDARD1_6_OR_GREATER && !NETCOREAPP
/// <summary>Adds support for Append and Prepend in lower frameworks.</summary>
    /// <summary>Appends a value to the end of the sequence.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <param name="source">A sequence of values.</param>
    /// <param name="element">The value to append to <paramref name="source"/>.</param>
    /// <returns>A new sequence that ends with <paramref name="element"/>.</returns>
    public static IEnumerable<TSource> Append<TSource>(this IEnumerable<TSource> source, TSource element) =>
        source.Concat(element.Yield());
    /// <summary>Prepends a value to the end of the sequence.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <param name="source">A sequence of values.</param>
    /// <param name="element">The value to prepend to <paramref name="source"/>.</param>
    /// <returns>A new sequence that starts with <paramref name="element"/>.</returns>
    public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element) =>
        element.Yield().Concat(source);
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Extension methods to create cartesian products.</summary>
    /// <summary>Creates a cartesian product from two collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T1">The type of item in the first set.</typeparam>
    /// <typeparam name="T2">The type of item in the second set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="second">The second set to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/> and <paramref name="second"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T1 First, T2 Second)> CartesianProduct<T1, T2>(
        this IEnumerable<T1> first,
        IEnumerable<T2> second
    ) =>
        first.SelectMany(_ => second, (x, y) => (x, y)) is var e &&
        first.TryCount() is { } f &&
        second.TryCount() is { } s
            ? e.WithCount(f * s)
            : e;
    /// <summary>Creates a cartesian product from three collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T1">The type of item in the first set.</typeparam>
    /// <typeparam name="T2">The type of item in the second set.</typeparam>
    /// <typeparam name="T3">The type of item in the third set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="second">The second set to create a cartesian product of.</param>
    /// <param name="third">The third set to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/>,
    /// <paramref name="second"/>, and <paramref name="third"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T1 First, T2 Second, T3 Third)> CartesianProduct<T1, T2, T3>(
        this IEnumerable<T1> first,
        IEnumerable<T2> second,
        IEnumerable<T3> third
    ) =>
        first
           .SelectMany(_ => second, (x, y) => (x, y))
           .SelectMany(_ => third, (xy, z) => (xy.x, xy.y, z)) is var e &&
        first.TryCount() is { } f &&
        second.TryCount() is { } s &&
        third.TryCount() is { } t
            ? e.WithCount(f * s * t)
            : e;
    /// <summary>Creates a cartesian product from four collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T1">The type of item in the first set.</typeparam>
    /// <typeparam name="T2">The type of item in the second set.</typeparam>
    /// <typeparam name="T3">The type of item in the third set.</typeparam>
    /// <typeparam name="T4">The type of item in the fourth set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="second">The second set to create a cartesian product of.</param>
    /// <param name="third">The third set to create a cartesian product of.</param>
    /// <param name="fourth">The fourth set to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/>, <paramref name="second"/>,
    /// <paramref name="third"/>, and <paramref name="fourth"/>.
    /// </returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T1 First, T2 Second, T3 Third, T4 Fourth)> CartesianProduct<T1, T2, T3, T4>(
        this IEnumerable<T1> first,
        IEnumerable<T2> second,
        IEnumerable<T3> third,
        IEnumerable<T4> fourth
    ) =>
        first
           .SelectMany(_ => second, (x, y) => (x, y))
           .SelectMany(_ => third, (xy, z) => (xy, z))
           .SelectMany(_ => fourth, (xyz, w) => (xyz.xy.x, xyz.xy.y, xyz.z, w)) is var e &&
        first.TryCount() is { } f &&
        second.TryCount() is { } s &&
        third.TryCount() is { } t &&
        fourth.TryCount() is { } u
            ? e.WithCount(f * s * t * u)
            : e;
    /// <summary>Creates a cartesian product from n-collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T">The type of item in the set.</typeparam>
    /// <param name="first">The first set to create a cartesian product of.</param>
    /// <param name="rest">The rest of the sets to create a cartesian product of.</param>
    /// <returns>
    /// The cartesian product of the parameter <paramref name="first"/>, and all of <paramref name="rest"/>.
    /// </returns>
    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(
        this IEnumerable<T> first,
        params IEnumerable<T>[] rest
    ) =>
        Enumerable.Repeat(first, 1).Concat(rest).CartesianProduct();
    /// <summary>Creates a cartesian product from n-collections.</summary>
    /// <remarks><para>The cartesian product is defined as the set of ordered pairs.</para></remarks>
    /// <typeparam name="T">The type of item in the set.</typeparam>
    /// <param name="iterable">The sets to create a cartesian product of.</param>
    /// <returns>The cartesian product of all of the parameter <paramref name="iterable"/>.</returns>
    public static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> iterable) =>
        iterable.Aggregate(
            Enumerable.Repeat((IEnumerable<T>)[], 1),
            (sum, next) => sum.SelectMany(_ => next, (s, n) => s.Concat(Enumerable.Repeat(n, 1)))
        );
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
// ReSharper disable RedundantReadonlyModifier StructCanBeMadeReadOnly
/// <summary>Provides methods to calculate various binomial coefficients.</summary>
#if NET8_0_OR_GREATER
    /// <summary>Calculates the binomial coefficient (nCk) (N items, choose k).</summary>
    /// <remarks><para>
    /// Implementation based on <a href="https://stackoverflow.com/a/19125294/18052726">Moop's solution</a>.
    /// </para></remarks>
    /// <typeparam name="T">The type of the number.</typeparam>
    /// <param name="n">The number of items.</param>
    /// <param name="k">The number to choose.</param>
    /// <returns>
    /// <math><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow></math>
    /// </returns>
    [NonNegativeValue, Pure]
    public static T Choose<T>(this T n, T k)
        where T : INumberBase<T>
    {
        if (T.IsNegative(n))
            return checked(T.IsEvenInteger(k) ? Choose(-n + T.One, k) : -Choose(-n + T.One + T.One, k));
        if (T.IsZero(k) || T.IsNegative(k) || T.IsNegative(n - k))
            return T.Zero;
        if (n == k)
            return T.One;
        var c = T.One;
        for (var i = T.One; T.IsPositive(k - i); i++)
            c = checked(c * n-- / i);
        return c;
    }
#else
    /// <summary>Calculates the binomial coefficient (nCk) (N items, choose k).</summary>
    /// <remarks><para>
    /// Implementation based on <a href="https://stackoverflow.com/a/19125294/18052726">Moop's solution</a>.
    /// </para></remarks>
    /// <param name="n">The number of items.</param>
    /// <param name="k">The number to choose.</param>
    /// <returns>
    /// <math><mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow></math>
    /// </returns>
    [NonNegativeValue, Pure]
    public static int Choose(this int n, int k)
    {
        if (n < 0)
            return checked((k & 1) is 0 ? Choose(-n + 1, k) : -Choose(-n + 2, k));
        if (n < k || k <= 0)
            return 0;
        if (n == k)
            return 1;
        var c = 1;
        for (var i = 1; i <= k; i++)
            c = checked(c * n-- / i);
        return c;
    }
    /// <inheritdoc cref="Choose(int, int)"/>
    [NonNegativeValue, Pure]
    public static long Choose(this long n, long k)
    {
        if (n < 0)
            return checked((k & 1) is 0 ? Choose(-n + 1, k) : -Choose(-n + 2, k));
        if (n < k || k <= 0)
            return 0;
        if (n == k)
            return 1;
        long c = 1;
        for (long i = 1; i <= k; i++)
            c = checked(c * n-- / i);
        return c;
    }
#endif
    /// <summary>Calculates the binomial coefficient (nCk) (N items, choose k).</summary>
    /// <typeparam name="T">The type of items to choose from.</typeparam>
    /// <param name="n">The items to choose from.</param>
    /// <param name="k">The amount of items to choose.</param>
    /// <returns>
    /// The <see cref="ICollection{T}"/> of <see cref="IList{T}"/> containing the binomial coefficients.
    /// </returns>
    [Pure]
    public static Choices<T> Choose<T>(this IEnumerable<T>? n, int k) => new(n.ToIList(), k);
/// <summary>Provides methods to calculate various binomial coefficients.</summary>
/// <typeparam name="T">The type of element.</typeparam>
/// <param name="n">The collection to choose from.</param>
/// <param name="k">The number to choose.</param>
[StructLayout(LayoutKind.Auto)]
#if CSHARPREPL
public
#endif
#if !NO_READONLY_STRUCTS
readonly
#endif
    struct Choices<T>(IList<T>? n, int k) : ICollection<IList<T>>, IEquatable<Choices<T>>
{
    /// <summary>Provides the enumerator for the <see cref="Choices{T}"/> struct.</summary>
    /// <param name="n">The collection to choose from.</param>
    /// <param name="k">The number to choose.</param>
    [StructLayout(LayoutKind.Auto)]
    public struct Enumerator(IList<T>? n, int k) : IEnumerator<IList<T>>
    {
        bool
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
            _hasDisposed,
#endif
            _hasMoved;
        int[] _values = Rent(n, k);
        /// <inheritdoc cref="Choices{T}.K"/>
        [NonNegativeValue, Pure]
        public int K { get; } = Math.Max(k, 0);
        /// <inheritdoc/>
        [Pure]
        public IList<T> Current { get; private set; } = [];
        /// <inheritdoc cref="Choices{T}.N"/>
        [Pure]
        public readonly IList<T> N { get; } = n ?? [];
        /// <inheritdoc />
        [Pure]
        readonly object IEnumerator.Current => Current;
        /// <summary>Resets the provided array to the initial state.</summary>
        /// <param name="values">The array to fill.</param>
        /// <param name="k">
        /// The length of the area to fill, assumed to be at least
        /// the length of the parameter <paramref name="values"/>.
        /// </param>
        /// <returns>The parameter <paramref name="values"/>.</returns>
        public static int[] Reset(int[] values, int k)
        {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
            values.AsSpan()[..k].Range();
#else
            for (var i = 0; i < k; i++)
                values[i] = i;
#endif
            return values;
        }
        /// <inheritdoc />
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        public void Dispose()
        {
            if (_hasDisposed || _values is null or [])
                return;
            ArrayPool<int>.Shared.Return(_values);
            _hasDisposed = true;
            _values = [];
        }
#else
        public readonly void Dispose() { }
#endif
        /// <inheritdoc />
        public void Reset()
        {
            _hasMoved = false;
            Reset(_values ??= new int[K], K);
        }
        /// <inheritdoc />
        public bool MoveNext()
        {
            if (EarlyReturn() is { } next)
                return next;
            for (var i = K - 1; i >= 0; i--)
                if (Found(i))
                    return true;
            return false;
        }
        [Pure]
        static int[] Rent(IList<T>? n, int k) =>
            n is not { Count: not 0 and var count } || count <= k
                ? []
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
                : Reset(ArrayPool<int>.Shared.Rent(k), k);
#else
                : Reset(new int[k], k);
#endif
        void Copy()
        {
            Current = new T[K];
            for (var i = 0; i < K; i++)
                Current[i] = N[_values[i]];
        }
        [MustUseReturnValue]
        bool Found(int found)
        {
            if (_values[found] + 1 is var next && next >= N.Count - (K - found - 1))
                return false;
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
            _values.AsSpan()[found..].Range(next);
#else
            for (var i = found; i < K; i++)
                _values[i] = next + i - found;
#endif
            Copy();
            return true;
        }
        [MustUseReturnValue]
        bool? EarlyReturn()
        {
            if (K is 0 || N is not { Count: not 0 and var count } || count < K)
                return false;
            if (K == count)
                return (Current = N) is var _ && !_hasMoved && (_hasMoved = true);
            if (_hasMoved)
                return null;
            Copy();
            _hasMoved = true;
            return true;
        }
    }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    readonly bool ICollection<IList<T>>.IsReadOnly => true;
    /// <inheritdoc cref="ICollection{T}.Count"/>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), NonNegativeValue, Pure]
    public readonly int Count => N.Count.Choose(K);
    /// <summary>Gets the number of choices.</summary>
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), NonNegativeValue, Pure]
    public int K { get; } = Math.Max(k, 0);
    /// <summary>Gets the list of choices.</summary>
    [CollectionAccess(Read), Pure]
    public IList<T> N { get; } = n ?? [];
    /// <summary>Gets the first <see cref="K"/> choices.</summary>
    [CollectionAccess(Read), Pure]
    public readonly IEnumerable<T> First =>
        N.Count is var count && count < K ? [] :
        count == K ? N : N.Take(K);
    /// <summary>Gets the last <see cref="K"/> choices.</summary>
    [CollectionAccess(Read), Pure]
    public readonly IEnumerable<T> Last =>
        N.Count is var count && count < K ? [] :
        count == K ? N : N.Skip(N.Count - K);
    /// <summary>Determines whether the specified objects are equal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the specified objects are equal.</returns>
    public static bool operator ==(Choices<T> left, Choices<T> right) => left.Equals(right);
    /// <summary>Determines whether the specified objects are unequal.</summary>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>Whether the specified objects are unequal.</returns>
    public static bool operator !=(Choices<T> left, Choices<T> right) => !(left == right);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    readonly void ICollection<IList<T>>.Add(IList<T> item) { }
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)]
    readonly void ICollection<IList<T>>.Clear() { }
    /// <inheritdoc />
    [CollectionAccess(Read)]
    public readonly void CopyTo(IList<T>[] array, int arrayIndex)
    {
        foreach (var next in this)
            array[arrayIndex++] = next;
    }
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    public readonly bool Contains(IList<T> item) => IndexOf(item) is not -1;
    /// <inheritdoc />
    public readonly override bool Equals(object? obj) => obj is Choices<T> other && Equals(other);
    /// <inheritdoc />
    public readonly bool Equals(Choices<T> other) => K == other.K && N.Equals(other.N);
    /// <inheritdoc />
    [CollectionAccess(JetBrains.Annotations.CollectionAccessType.None), Pure]
    readonly bool ICollection<IList<T>>.Remove(IList<T> item) => false;
    /// <inheritdoc cref="IList{T}.IndexOf"/>
    [CollectionAccess(Read), Pure]
    public readonly int IndexOf(IList<T> item)
    {
        if (N.Count == K)
            return N.Equals(item) ? 0 : -1;
        var i = 0;
        foreach (var next in this)
            if (next.Equals(item))
                return i;
            else
                i++;
        return -1;
    }
    /// <inheritdoc />
    public readonly override int GetHashCode() => unchecked(K * 397 ^ N.GetHashCode());
    /// <inheritdoc />
    public readonly override string ToString()
    {
#if NET6_0_OR_GREATER
        var count = Count;
        DefaultInterpolatedStringHandler str = new(count is 0 ? 2 : count * 4, count);
        str.AppendLiteral("[");
#else
        StringBuilder str = new("[");
#endif
        using var e = GetEnumerator();
        if (!e.MoveNext())
            goto Done;
#if NET6_0_OR_GREATER
        str.AppendLiteral("[");
#else
        str.Append('[');
#endif
        str.AppendMany(e.Current);
#if NET6_0_OR_GREATER
        str.AppendLiteral("]");
#else
        str.Append(']');
#endif
        while (e.MoveNext())
        {
#if NET6_0_OR_GREATER
            str.AppendLiteral(", [");
#else
            str.Append(", [");
#endif
            str.AppendMany(e.Current);
#if NET6_0_OR_GREATER
            str.AppendLiteral("]");
#else
            str.Append(']');
#endif
        }
    Done:
#if NET6_0_OR_GREATER
        str.AppendLiteral("]");
        return str.ToStringAndClear();
#else
        return $"{str.Append(']')}";
#endif
    }
    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator"/>
    [CollectionAccess(Read), Pure]
    public readonly Enumerator GetEnumerator() => new(N, K);
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    readonly IEnumerator<IList<T>> IEnumerable<IList<T>>.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    [CollectionAccess(Read), Pure]
    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
#if !NETFRAMEWORK || NET35_OR_GREATER
    /// <summary>Upcasts or creates an <see cref="IList{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="IList{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static T[]? ToArrayLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as T[] ?? iterable.ToArray();
#endif
    /// <summary>Wraps the <see cref="IEnumerable{T}"/> in a known-size collection type.</summary>
    /// <remarks><para>The parameter <paramref name="count"/> is assumed to be correct.</para></remarks>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to encapsulate.</param>
    /// <param name="count">The number of elements in the parameter <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/> as a <see cref="Collection{T}"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static Collection<T>? WithCount<T>(this IEnumerable<T>? iterable, [NonNegativeValue] int count) =>
        iterable is null ? null : new(iterable, count);
    /// <summary>Upcasts or creates an <see cref="ICollection{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="ICollection{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ICollection<T>? ToICollection<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null
            ? null
            : iterable as ICollection<T> ??
            (iterable.TryCount() is { } count
                ? new Collection<T>(iterable, count)
#if NETFRAMEWORK && NET40_OR_GREATER
                : new List<T>(iterable));
#else
                : iterable.ToIList());
#endif
    /// <summary>Returns a fallback enumeration if the collection given is null or empty.</summary>
    /// <typeparam name="T">The type of item within the enumeration.</typeparam>
    /// <param name="iterable">The potentially empty collection.</param>
    /// <param name="fallback">The fallback value.</param>
    /// <returns>
    /// The parameter <paramref name="iterable"/> when non-empty, otherwise; <paramref name="fallback"/>.
    /// </returns>
    [Pure]
    public static IEnumerable<T> DefaultIfEmpty<T>(this IEnumerable<T>? iterable, IEnumerable<T> fallback)
    {
        using var a = iterable?.GetEnumerator();
        if (a?.MoveNext() ?? false)
            do
                yield return a.Current;
            while (a.MoveNext());
        else
            foreach (var b in fallback)
                yield return b;
    }
    /// <summary>Upcasts or creates an <see cref="IList{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="IList{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static IList<T>? ToIList<T>([InstantHandle] this IEnumerable<T>? iterable) =>
#if !NET40_OR_GREATER && NETFRAMEWORK
        iterable is null ? null : iterable as IList<T> ?? new List<T>(iterable);
#else
        iterable is null ? null : iterable as IList<T> ?? iterable.ToList();
#endif
#if !NETFRAMEWORK || NET40_OR_GREATER
    /// <summary>Creates a <see cref="HashSet{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to encapsulate.</param>
    /// <param name="comparer">The comparer to use.</param>
    /// <returns>Itself as <see cref="ISet{T}"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static HashSet<T>? ToSet<T>(
        [InstantHandle] this IEnumerable<T>? iterable,
        IEqualityComparer<T>? comparer = null
    ) =>
        iterable is null ? null : new HashSet<T>(iterable, comparer);
    /// <summary>Upcasts or creates an <see cref="ISet{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <returns>Itself as <see cref="IList{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ISet<T>? ToSetLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
        iterable is null ? null : iterable as ISet<T> ?? new HashSet<T>(iterable);
    /// <summary>Upcasts or creates an <see cref="ISet{T}"/>.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
    /// <param name="comparer">The comparer to use if one needs to be generated.</param>
    /// <returns>Itself as <see cref="ISet{T}"/>, or collected.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(iterable))]
    public static ISet<T>? ToSetLazily<T>(
        [InstantHandle] this IEnumerable<T>? iterable,
        IEqualityComparer<T> comparer
    ) =>
        iterable is null ? null : iterable as ISet<T> ?? new HashSet<T>(iterable, comparer);
#endif
    /// <summary>Provides a wrapper to an <see cref="IEnumerable{T}"/> with a known count.</summary>
    /// <param name="enumerable">The enumerable to encapsulate.</param>
    /// <param name="count">The pre-computed count.</param>
    /// <typeparam name="T">The type of element in the <see cref="IEnumerable{T}"/>.</typeparam>
    internal sealed class Collection<T>([ProvidesContext] IEnumerable<T> enumerable, [NonNegativeValue] int count) :
        ICollection,
        ICollection<T>,
        IReadOnlyCollection<T>
    {
        /// <inheritdoc />
        [Pure]
        bool ICollection.IsSynchronized => true;
        /// <inheritdoc />
        [Pure]
        bool ICollection<T>.IsReadOnly => true;
        /// <inheritdoc cref="ICollection{T}.Count" />
        [NonNegativeValue, Pure]
        public int Count => count;
        /// <inheritdoc />
        [Pure]
        public object SyncRoot => enumerable;
        /// <inheritdoc />
        public void CopyTo(Array array, [NonNegativeValue] int index)
        {
            var i = index;
            foreach (var next in enumerable)
            {
                array.SetValue(next, i);
                _ = checked(i++);
            }
        }
        /// <inheritdoc />
        public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
        {
            var i = arrayIndex;
            foreach (var next in enumerable)
            {
                array[i] = next;
                _ = checked(i++);
            }
        }
        /// <inheritdoc />
        void ICollection<T>.Add(T? item) { }
        /// <inheritdoc />
        void ICollection<T>.Clear() { }
        /// <inheritdoc />
        [Pure]
        public bool Contains(T item) => enumerable.Contains(item);
        /// <inheritdoc />
        [Pure]
        bool ICollection<T>.Remove(T? item) => false;
        /// <inheritdoc />
        [Pure]
        IEnumerator IEnumerable.GetEnumerator() => enumerable.GetEnumerator();
        /// <inheritdoc />
        [Pure]
        public IEnumerator<T> GetEnumerator() => enumerable.GetEnumerator();
    }
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable NullableWarningSuppressionIsUsed
// ReSharper disable once CheckNamespace
/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For([NonNegativeValue] this int upper, [InstantHandle] Action action)
    {
        for (var i = 0; i < upper; i++)
            action();
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For([NonNegativeValue] this int upper, [InstantHandle] Action<int> action)
    {
        for (var i = 0; i < upper; i++)
            action(i);
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Action<TExternal> action
    )
    {
        for (var i = 0; i < upper; i++)
            action(external);
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int For<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Action<int, TExternal> action
    )
    {
        for (var i = 0; i < upper; i++)
            action(i, external);
        return upper;
    }
#if !NET20 && !NET30
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Action<T> action
    )
    {
        var list = iterable.ToICollection();
        foreach (var item in list)
            action(item);
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Action<T, TExternal> action
    )
    {
        var list = iterable.ToICollection();
        foreach (var item in list)
            action(item, external);
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Action<T, int> action
    )
    {
        var list = iterable.ToICollection();
        var i = 0;
        foreach (var item in list)
            action(item, checked(i++));
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> For<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Action<T, int, TExternal> action
    )
    {
        var list = iterable.ToICollection();
        var i = 0;
        foreach (var item in list)
            action(item, checked(i++), external);
        return list;
    }
#endif
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Action<TKey, TValue> action
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value);
        return dictionary;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Action<TKey, TValue, TExternal> action
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value, external);
        return dictionary;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Action<TKey, TValue, int> action
    )
        where TKey : notnull
    {
        var i = 0;
        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value, checked(i++));
        return dictionary;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> For<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Action<TKey, TValue, int, TExternal> action
    )
        where TKey : notnull
    {
        var i = 0;
        foreach (var kvp in dictionary)
            action(kvp.Key, kvp.Value, checked(i++), external);
        return dictionary;
    }
#if !NET20 && !NET30
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<int> For(this int num) =>
        num >= 0 ? Enumerable.Range(0, num) : Enumerable.Repeat(-num, -num).Select((x, i) => x - i - 1);
    /// <summary>Gets an enumeration of a number.</summary>
    /// <param name="num">The index to count up or down to.</param>
    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<int> GetEnumerator(this int num) => num.For().GetEnumerator();
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="int"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TExternal> For<TExternal>([NonNegativeValue] this int upper, TExternal external) =>
        Enumerable.Repeat(external, upper);
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<TResult>(
        [NonNegativeValue] this int upper,
        [InstantHandle] Func<TResult> func
    ) =>
        Enumerable.Repeat(func, upper).Select(x => x());
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<TResult>(
        [NonNegativeValue] this int upper,
        [InstantHandle] Converter<int, TResult> func
    ) =>
        Enumerable.Repeat(func, upper).Select((x, i) => x(i));
#endif
#if NET7_0_OR_GREATER
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> For<T>(this T upper)
        where T : IComparisonOperators<T?, T?, bool>,
        ISubtractionOperators<T, T, T>,
        IIncrementOperators<T>
    {
        var isNegative = upper < default(T);
        var abs = isNegative ? default(T)! - upper : upper;
        for (T? i = default; i < abs; i++)
            yield return isNegative ? upper - i : i;
    }
    /// <summary>Gets an enumeration of a number.</summary>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="num">The index to count up or down to.</param>
    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<T> GetEnumerator<T>(this T num)
        where T : IComparisonOperators<T?, T?, bool>,
        ISubtractionOperators<T, T, T>,
        IIncrementOperators<T> =>
        num.For().GetEnumerator();
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="int"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TExternal> For<T, TExternal>([NonNegativeValue] this T upper, TExternal external)
        where T : IComparisonOperators<T?, T?, bool>, ISubtractionOperators<T, T, T>, IIncrementOperators<T>
    {
        var abs = upper < default(T) ? default(T)! - upper : upper;
        for (T? i = default; i < abs; i++)
            yield return external;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<T, TResult>(
        [NonNegativeValue] this T upper,
        [InstantHandle] Func<TResult> func
    )
        where T : IComparisonOperators<T?, T?, bool>, ISubtractionOperators<T, T, T>, IIncrementOperators<T>
    {
        var abs = upper < default(T) ? default(T)! - upper : upper;
        for (T? i = default; i < abs; i++)
            yield return func();
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TResult">The type of iterator.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The function for each loop.</param>
    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> For<T, TResult>(
        [NonNegativeValue] this T upper,
        [InstantHandle] Converter<T, TResult> func
    )
        where T : IComparisonOperators<T?, T?, bool>, ISubtractionOperators<T, T, T>, IIncrementOperators<T>
    {
        var isNegative = upper < default(T);
        var abs = isNegative ? default(T)! - upper : upper;
        for (T? i = default; i < abs; i++)
            yield return func(isNegative ? upper - i : i);
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T>([NonNegativeValue] this T upper, [InstantHandle] Action action)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action();
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T>([NonNegativeValue] this T upper, [InstantHandle] Action<T> action)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action(i);
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Action<TExternal> action
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action(external);
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T For<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Action<T, TExternal> action
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            action(i, external);
        return upper;
    }
#endif
    /// <inheritdoc cref="Array.FindAll{T}"/>
    public static T[] FindAll<T>(this T[] array, [InstantHandle] Predicate<T> match) => Array.FindAll(array, match);
    /// <inheritdoc cref="Array.ConvertAll{TInput, TOutput}"/>
    public static TOutput[] ConvertAll<TInput, TOutput>(
        this TInput[] array,
        [InstantHandle] Converter<TInput, TOutput> converter
    ) =>
        Array.ConvertAll(array, converter);
    /// <inheritdoc cref="Array.AsReadOnly{T}"/>
    public static ReadOnlyCollection<T> AsReadOnly<T>(this T[]? array) => Array.AsReadOnly(array ?? []);
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
    /// <summary>
    /// Defines an <see cref="IEnumerable{T}"/> with a <see cref="Delegate"/> that is invoked on iteration.
    /// </summary>
    /// <typeparam name="T">The type of item in the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <typeparam name="TExternal">The context element to pass into the <see cref="Delegate"/>.</typeparam>
    sealed partial class Enumerable<T, TExternal> : IEnumerable<T>
    {
        readonly Delegate _action;
        readonly IEnumerable<T> _enumerable;
        readonly TExternal _external;
        /// <inheritdoc />
        public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T> action)
            : this(enumerable, external, (Delegate)action) { }
        /// <inheritdoc />
        public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T, int> action)
            : this(enumerable, external, (Delegate)action) { }
        /// <inheritdoc />
        public Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Action<T, TExternal> action)
            : this(enumerable, external, (Delegate)action) { }
        /// <inheritdoc />
        public Enumerable(
            [ProvidesContext] IEnumerable<T> enumerable,
            TExternal external,
            Action<T, int, TExternal> action
        )
            : this(enumerable, external, (Delegate)action) { }
        /// <summary>Initializes a new instance of the <see cref="Enumerable{T, TExternal}"/> class.</summary>
        /// <param name="enumerable">
        /// The <see cref="IEnumerable{T}"/> to create an <see cref="IEnumerator{T}"/> from.
        /// </param>
        /// <param name="external">The context element.</param>
        /// <param name="action">The <see cref="Delegate"/> to invoke on iteration.</param>
        Enumerable([ProvidesContext] IEnumerable<T> enumerable, TExternal external, Delegate action)
        {
            _enumerable = enumerable;
            _external = external;
            _action = action;
        }
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Enumerable{T, TExternal}"/>
        /// by using the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerable{T, TExternal}"/> by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T})"/>.
        /// </returns>
        [Pure]
        public static implicit operator Enumerable<T, TExternal>(
            (IEnumerable<T> Enumerable, TExternal External, Action<T> Action) tuple
        ) =>
            new(tuple.Enumerable, tuple.External, tuple.Action);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Enumerable{T, TExternal}"/>
        /// by using the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T, int})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of Enumerable{T, TExternal} by passing the parameter <paramref name="tuple"/> to
        /// the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T, int})"/>.
        /// </returns>
        [Pure]
        public static implicit operator Enumerable<T, TExternal>(
            (IEnumerable<T> Enumerable, TExternal External, Action<T, int> Action) tuple
        ) =>
            new(tuple.Enumerable, tuple.External, tuple.Action);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of <see cref="Enumerable{T, TExternal}"/>
        /// by using the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T, TExternal})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerable{T, TExternal}"/> by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T, TExternal})"/>.
        /// </returns>
        [Pure]
        public static implicit operator Enumerable<T, TExternal>(
            (IEnumerable<T> Enumerable, TExternal External, Action<T, TExternal> Action) tuple
        ) =>
            new(tuple.Enumerable, tuple.External, tuple.Action);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of Enumerable{T, TExternal} by using the
        /// constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T, int, TExternal})"/>.
        /// </summary>
        /// <param name="tuple">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="Enumerable{T, TExternal}"/> by passing the parameter <paramref name="tuple"/>
        /// to the constructor <see cref="Enumerable{T, TExternal}(IEnumerable{T}, TExternal, Action{T, int, TExternal})"/>.
        /// </returns>
        [Pure]
        public static implicit operator Enumerable<T, TExternal>(
            (IEnumerable<T> Enumerable, TExternal External, Action<T, int, TExternal> Action) tuple
        ) =>
            new(tuple.Enumerable, tuple.External, tuple.Action);
        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.Read), MustDisposeResource, Pure]
        public IEnumerator<T> GetEnumerator() => new Enumerator(_enumerable.GetEnumerator(), _external, _action);
        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.Read), MustDisposeResource, Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
        sealed class Enumerator(
            [HandlesResourceDisposal, ProvidesContext] IEnumerator<T> enumerator,
            TExternal external,
            Delegate action
        ) : IEnumerator<T>
        {
            int _index;
            /// <inheritdoc />
            public T Current => enumerator.Current;
            /// <inheritdoc />
            object? IEnumerator.Current => ((IEnumerator)enumerator).Current;
            /// <inheritdoc />
            public void Reset()
            {
                enumerator.Reset();
                _index = 0;
            }
            /// <inheritdoc />
            public void Dispose() => enumerator.Dispose();
            /// <inheritdoc />
            public bool MoveNext()
            {
                if (!enumerator.MoveNext())
                    return false;
                var current = Current;
                switch (action)
                {
                    case Action<T> a:
                        a(current);
                        break;
                    case Action<T, int> a:
                        a(current, _index);
                        break;
                    case Action<T, TExternal> a:
                        a(current, external);
                        break;
                    case Action<T, int, TExternal> a:
                        a(current, _index, external);
                        break;
                }
                _index++;
                return true;
            }
        }
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T>([NoEnumeration] this IEnumerable<T> iterable, Action<T> action) =>
        new Enumerable<T, object?>(iterable, null, action);
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T, TExternal>(
        [NoEnumeration] this IEnumerable<T> iterable,
        TExternal external,
        Action<T, TExternal> action
    ) =>
        new Enumerable<T, TExternal>(iterable, external, action);
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T>([NoEnumeration] this IEnumerable<T> iterable, Action<T, int> action) =>
        new Enumerable<T, object?>(iterable, null, action);
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Lazily<T, TExternal>(
        [NoEnumeration] this IEnumerable<T> iterable,
        TExternal external,
        Action<T, int, TExternal> action
    ) =>
        new Enumerable<T, TExternal>(iterable, external, action);
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Similar to <see cref="Each"/>, but with control flow, using <see cref="ControlFlow"/>.</summary>
// ReSharper disable LoopCanBePartlyConvertedToQuery
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor([NonNegativeValue] this int upper, [InstantHandle] Func<ControlFlow> func)
    {
        for (var i = 0; i < upper; i++)
            if (func() is ControlFlow.Break)
                break;
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor([NonNegativeValue] this int upper, [InstantHandle] Func<int, ControlFlow> func)
    {
        for (var i = 0; i < upper; i++)
            if (func(i) is ControlFlow.Break)
                break;
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Func<TExternal, ControlFlow> func
    )
    {
        for (var i = 0; i < upper; i++)
            if (func(external) is ControlFlow.Break)
                break;
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static int BreakableFor<TExternal>(
        [NonNegativeValue] this int upper,
        TExternal external,
        [InstantHandle] Func<int, TExternal, ControlFlow> func
    )
    {
        for (var i = 0; i < upper; i++)
            if (func(i, external) is ControlFlow.Break)
                break;
        return upper;
    }
#if !NET20 && !NET30
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<T, ControlFlow> func
    )
    {
        var list = iterable.ToICollection();
        foreach (var item in list)
            if (func(item) is ControlFlow.Break)
                break;
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Func<T, TExternal, ControlFlow> func
    )
    {
        var list = iterable.ToICollection();
        foreach (var item in list)
            if (func(item, external) is ControlFlow.Break)
                break;
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T>(
        [InstantHandle] this IEnumerable<T> iterable,
        [InstantHandle] Func<T, int, ControlFlow> func
    )
    {
        var list = iterable.ToICollection();
        var i = 0;
        foreach (var item in list)
            if (func(item, checked(i++)) is ControlFlow.Break)
                break;
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
    /// <returns>The parameter <paramref name="iterable"/>.</returns>
    public static ICollection<T> BreakableFor<T, TExternal>(
        [InstantHandle] this IEnumerable<T> iterable,
        TExternal external,
        [InstantHandle] Func<T, int, TExternal, ControlFlow> func
    )
    {
        var list = iterable.ToICollection();
        var i = 0;
        foreach (var item in list)
            if (func(item, checked(i++), external) is ControlFlow.Break)
                break;
        return list;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Func<TKey, TValue, ControlFlow> func
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value) is ControlFlow.Break)
                break;
        return dictionary;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Func<TKey, TValue, TExternal, ControlFlow> func
    )
        where TKey : notnull
    {
        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value, external) is ControlFlow.Break)
                break;
        return dictionary;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        [InstantHandle] Func<TKey, TValue, int, ControlFlow> func
    )
        where TKey : notnull
    {
        var i = 0;
        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value, checked(i++)) is ControlFlow.Break)
                break;
        return dictionary;
    }
    /// <summary>
    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
    /// instance of the type that implements the <see cref="IEnumerable{T}"/> interface.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue, TExternal>(
        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
        TExternal external,
        [InstantHandle] Func<TKey, TValue, int, TExternal, ControlFlow> func
    )
        where TKey : notnull
    {
        var i = 0;
        foreach (var kvp in dictionary)
            if (func(kvp.Key, kvp.Value, checked(i++), external) is ControlFlow.Break)
                break;
        return dictionary;
    }
#endif
#if NET7_0_OR_GREATER
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T>([NonNegativeValue] this T upper, [InstantHandle] Func<ControlFlow> func)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func() is ControlFlow.Break)
                break;
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T>([NonNegativeValue] this T upper, [InstantHandle] Func<T, ControlFlow> func)
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func(i) is ControlFlow.Break)
                break;
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Func<TExternal, ControlFlow> func
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func(external) is ControlFlow.Break)
                break;
        return upper;
    }
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <typeparam name="T">The type of number for the loop.</typeparam>
    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
    /// <param name="upper">The length to reach to in the for loop.</param>
    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
    /// <param name="func">The action for each loop.</param>
    /// <returns>The parameter <paramref name="upper"/>.</returns>
    [NonNegativeValue]
    public static T BreakableFor<T, TExternal>(
        [NonNegativeValue] this T upper,
        TExternal external,
        [InstantHandle] Func<T, TExternal, ControlFlow> func
    )
        where T : IComparisonOperators<T?, T, bool>, IIncrementOperators<T>
    {
        for (T? i = default; i < upper; i++)
            if (func(i, external) is ControlFlow.Break)
                break;
        return upper;
    }
#endif
/// <summary>Determines control flow for loops in <see cref="Each"/>.</summary>
public enum ControlFlow : byte
{
    /// <summary>The value indicating that the loop should continue.</summary>
    Continue,
    /// <summary>The value indicating that the loop should break.</summary>
    Break,
}
// SPDX-License-Identifier: MPL-2.0
// NOTE: This file should be moved to ./Source/References/System/Linq/EnumerableAggregate.cs when .NET 9 is released
// and CSharpRepl is updated to use it, as anything in ./Compile/Source/References/System/ is not included in REPL.csx.
#if !CSHARPREPL
// ReSharper disable once CheckNamespace EmptyNamespace
namespace System.Linq;
#endif
#if !NET9_0_OR_GREATER
/// <summary>The backport of the AggregateBy method for <see cref="IEnumerable{T}"/>.</summary>
    /// <summary>Performs a specified accumulator function over a sequence.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
    /// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
    /// <param name="source">The sequence to accumulate over.</param>
    /// <param name="keySelector">The key selector function.</param>
    /// <param name="seed">The initial accumulator value.</param>
    /// <param name="func">The accumulator function.</param>
    /// <param name="keyComparer">The key comparer.</param>
    /// <returns>The accumulated value.</returns>
    public static IEnumerable<KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(
        this IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector,
        TAccumulate seed,
        Func<TAccumulate, TSource, TAccumulate> func,
        IEqualityComparer<TKey>? keyComparer = null
    )
        where TKey : notnull =>
        source.TryCount() is 0 ? [] : AggregateByIterator(source, keySelector, seed, func, keyComparer);
    /// <summary>Performs a specified accumulator function over a sequence.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
    /// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
    /// <param name="source">The sequence to accumulate over.</param>
    /// <param name="keySelector">The key selector function.</param>
    /// <param name="seedSelector">The seed selector function.</param>
    /// <param name="func">The accumulator function.</param>
    /// <param name="keyComparer">The key comparer.</param>
    /// <returns>The accumulated value.</returns>
    public static IEnumerable<KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(
        this IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector,
        Func<TKey, TAccumulate> seedSelector,
        Func<TAccumulate, TSource, TAccumulate> func,
        IEqualityComparer<TKey>? keyComparer = null
    )
        where TKey : notnull =>
        source.TryCount() is 0 ? [] : AggregateByIterator(source, keySelector, seedSelector, func, keyComparer);
    static IEnumerable<KeyValuePair<TKey, TAccumulate>> AggregateByIterator<TSource, TKey, TAccumulate>(
        IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector,
        TAccumulate seed,
        Func<TAccumulate, TSource, TAccumulate> func,
        IEqualityComparer<TKey>? keyComparer
    )
        where TKey : notnull
    {
        using var enumerator = source.GetEnumerator();
        if (!enumerator.MoveNext())
            yield break;
        foreach (var countBy in PopulateDictionary(enumerator, keySelector, seed, func, keyComparer))
            yield return countBy;
        static Dictionary<TKey, TAccumulate> PopulateDictionary(
            IEnumerator<TSource> enumerator,
            Func<TSource, TKey> keySelector,
            TAccumulate seed,
            Func<TAccumulate, TSource, TAccumulate> func,
            IEqualityComparer<TKey>? keyComparer
        )
        {
            Dictionary<TKey, TAccumulate> dict = new(keyComparer);
            do
            {
                var value = enumerator.Current;
                var key = keySelector(value);
                dict[key] = func(dict.GetValueOrDefault(key, seed), value);
            } while (enumerator.MoveNext());
            return dict;
        }
    }
    static IEnumerable<KeyValuePair<TKey, TAccumulate>> AggregateByIterator<TSource, TKey, TAccumulate>(
        IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector,
        Func<TKey, TAccumulate> seedSelector,
        Func<TAccumulate, TSource, TAccumulate> func,
        IEqualityComparer<TKey>? keyComparer
    )
        where TKey : notnull
    {
        using var enumerator = source.GetEnumerator();
        if (!enumerator.MoveNext())
            yield break;
        foreach (var countBy in PopulateDictionary(enumerator, keySelector, seedSelector, func, keyComparer))
            yield return countBy;
        static Dictionary<TKey, TAccumulate> PopulateDictionary(
            IEnumerator<TSource> enumerator,
            Func<TSource, TKey> keySelector,
            Func<TKey, TAccumulate> seedSelector,
            Func<TAccumulate, TSource, TAccumulate> func,
            IEqualityComparer<TKey>? keyComparer
        )
        {
            Dictionary<TKey, TAccumulate> dict = new(keyComparer);
            do
            {
                var value = enumerator.Current;
                var key = keySelector(value);
                dict[key] = func(dict.GetValueOrDefault(key, seedSelector(key)), value);
            } while (enumerator.MoveNext());
            return dict;
        }
    }
#endif
// SPDX-License-Identifier: MPL-2.0
// NOTE: This file should be moved to ./Source/References/System/Linq/EnumerableCount.cs when .NET 9 is released
// and CSharpRepl is updated to use it, as anything in ./Compile/Source/References/System/ is not included in REPL.csx.
#if !CSHARPREPL
// ReSharper disable once CheckNamespace EmptyNamespace
namespace System.Linq;
#endif
#if !NET9_0_OR_GREATER
/// <summary>The backport of the CountBy method for <see cref="IEnumerable{T}"/>.</summary>
    /// <summary>Performs a count by operation.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
    /// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector"/>.</typeparam>
    /// <param name="source">The sequence to count by.</param>
    /// <param name="keySelector">The key selector function.</param>
    /// <param name="keyComparer">The key comparer.</param>
    /// <returns>The count by operation.</returns>
    public static IEnumerable<KeyValuePair<TKey, int>> CountBy<TSource, TKey>(
        this IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector,
        IEqualityComparer<TKey>? keyComparer = null
    )
        where TKey : notnull =>
        source.TryCount() is 0 ? [] : CountByIterator(source, keySelector, keyComparer);
    static IEnumerable<KeyValuePair<TKey, int>> CountByIterator<TSource, TKey>(
        IEnumerable<TSource> source,
        Func<TSource, TKey> keySelector,
        IEqualityComparer<TKey>? keyComparer
    )
        where TKey : notnull
    {
        using var enumerator = source.GetEnumerator();
        if (!enumerator.MoveNext())
            yield break;
        foreach (var countBy in BuildCountDictionary(enumerator, keySelector, keyComparer))
            yield return countBy;
        static Dictionary<TKey, int> BuildCountDictionary(
            IEnumerator<TSource> enumerator,
            Func<TSource, TKey> keySelector,
            IEqualityComparer<TKey>? keyComparer
        )
        {
            Dictionary<TKey, int> countsBy = new(keyComparer);
            do
            {
                var key = keySelector(enumerator.Current);
                countsBy[key] = checked(countsBy.GetValueOrDefault(key) + 1);
            } while (enumerator.MoveNext());
            return countsBy;
        }
    }
#endif
// SPDX-License-Identifier: MPL-2.0
// NOTE: This file should be moved to ./Source/References/System/Linq/EnumerableIndex.cs when .NET 9 is released
// and CSharpRepl is updated to use it, as anything in ./Compile/Source/References/System/ is not included in REPL.csx.
#if !CSHARPREPL
// ReSharper disable once CheckNamespace EmptyNamespace
namespace System.Linq;
#endif
#if !NET9_0_OR_GREATER
/// <summary>The backport of the Index method for <see cref="IEnumerable{T}"/>.</summary>
    /// <summary>Returns an enumerable that incorporates the element's index into a tuple.</summary>
    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
    /// <param name="source">The source enumerable providing the elements.</param>
    /// <returns>The enumerable that incorporates the element's index into a tuple.</returns>
    public static IEnumerable<(int Index, TSource Item)> Index<TSource>(this IEnumerable<TSource> source) =>
        source is TSource[] { Length: 0 } ? [] : source.Select((x, i) => (i, x));
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides methods to convert <see cref="IEnumerator{T}"/> to <see cref="IEnumerable{T}"/>.</summary>
    /// <summary>Collects <see cref="IComparer"/> and <see cref="IEqualityComparer"/> instances.</summary>
    sealed class ComparerCollector : IComparer, IEqualityComparer
    {
        /// <summary>The most common usage is with tuples, in which the maximum capacity is 8.</summary>
        const int Capacity = 8;
        public List<object?> List { get; } = new(Capacity);
        /// <inheritdoc />
        bool IEqualityComparer.Equals(object? x, object? y) => Append(x, true);
        /// <inheritdoc />
        int IComparer.Compare(object? x, object? y) => Append(x, 0);
        /// <inheritdoc />
        int IEqualityComparer.GetHashCode(object? obj) => Append(obj, 0);
        T Append<T>(object? obj, T ret)
        {
            List.Add(obj);
            return ret;
        }
    }
    /// <summary>
    /// Wraps an <see cref="IEnumerator{T}"/> and exposes it from an <see cref="IEnumerable{T}"/> context.
    /// </summary>
    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to encapsulate.</param>
    /// <typeparam name="T">The type of item to enumerate.</typeparam>
    public sealed partial class Enumerable<T>([HandlesResourceDisposal, ProvidesContext] IEnumerator<T> enumerator)
        : IDisposable, IEnumerable<T>
    {
        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.None)]
        public void Dispose() => enumerator.Dispose();
        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.Read), Pure]
        public IEnumerator<T> GetEnumerator() => enumerator;
        /// <inheritdoc />
        [CollectionAccess(CollectionAccessType.Read), Pure]
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }
    /// <summary>
    /// Wraps an <see cref="IEnumerator{T}"/> and exposes it from an <see cref="IEnumerable{T}"/> context.
    /// </summary>
    /// <param name="enumerator">The enumerator to encapsulate.</param>
    sealed partial class Enumerator([HandlesResourceDisposal, ProvidesContext] IEnumerator enumerator)
        : IEnumerator<object?>
    {
        /// <inheritdoc cref="IEnumerator{T}.Current" />
        [Pure]
        public object? Current => enumerator.Current;
        /// <inheritdoc />
        public void Dispose() => (enumerator as IDisposable)?.Dispose();
        /// <inheritdoc />
        public void Reset() => enumerator.Reset();
        /// <inheritdoc />
        public bool MoveNext() => enumerator.MoveNext();
    }
    /// <summary>Wraps the enumerator inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <param name="enumerator">The enumerator to encapsulate.</param>
    /// <returns>
    /// The <see cref="IEnumerator{T}"/> instance that returns the parameter <paramref name="enumerator"/>.
    /// </returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<object?> AsGeneric([HandlesResourceDisposal] this IEnumerator enumerator) =>
        new Enumerator(enumerator);
    /// <summary>Wraps the enumerator inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <param name="enumerator">The enumerator to encapsulate.</param>
    /// <returns>The <see cref="IEnumerator{T}"/> instance that wraps <paramref name="enumerator"/>.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerable<object?> AsEnumerable([HandlesResourceDisposal] this IEnumerator enumerator) =>
        AsEnumerable(AsGeneric(enumerator));
    /// <summary>Wraps the array inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <param name="array">The array to encapsulate.</param>
    /// <returns>The <see cref="IEnumerator{T}"/> instance that wraps <paramref name="array"/>.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerable<object?> AsGenericEnumerable(this Array array) => AsEnumerable(array.GetEnumerator());
    /// <summary>Wraps the <see cref="IEnumerator{T}"/> inside an <see cref="IEnumerable{T}"/>.</summary>
    /// <typeparam name="T">The type of item to enumerate.</typeparam>
    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to encapsulate.</param>
    /// <returns>The <see cref="IEnumerator{T}"/> instance that wraps <paramref name="enumerator"/>.</returns>
    [MustDisposeResource, Pure]
    public static Enumerable<T> AsEnumerable<T>([HandlesResourceDisposal] this IEnumerator<T> enumerator) =>
        new(enumerator);
#if !NET20 && !NET30 && !NET35
    /// <summary>Converts an <see cref="IStructuralComparable"/> to a <see cref="List{T}"/>.</summary>
    /// <param name="structure">The <see cref="IStructuralComparable"/> to convert.</param>
    /// <returns>The <see cref="List{T}"/> that contains elements from <paramref name="structure"/>.</returns>
    [Pure]
    public static List<object?> ToList(this IStructuralComparable structure)
    {
        ComparerCollector collector = new();
        _ = structure.CompareTo(structure, collector);
        return collector.List;
    }
    /// <summary>Converts an <see cref="IStructuralEquatable"/> to a <see cref="List{T}"/>.</summary>
    /// <param name="structure">The <see cref="IStructuralEquatable"/> to convert.</param>
    /// <returns>The <see cref="List{T}"/> that contains elements from <paramref name="structure"/>.</returns>
    [Pure]
    public static List<object?> ToList(this IStructuralEquatable structure)
    {
        ComparerCollector collector = new();
        _ = structure.Equals(structure, collector);
        return collector.List;
    }
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable InvertIf
// ReSharper disable once CheckNamespace
/// <summary>Extension methods to force full enumerations.</summary>
    /// <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    public static void Enumerate([InstantHandle] this IEnumerable? iterable)
    {
        if (iterable is not null)
            foreach (var _ in iterable) { }
    }
    /// <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    public static void Enumerate<T>([InstantHandle] this IEnumerable<T>? iterable)
    {
        if (iterable is not null)
            foreach (var _ in iterable) { }
    }
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable CheckNamespace RedundantNameQualifier
/// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<int> For(this Index index) => (index.IsFromEnd ? -index.Value : index.Value).For();
    /// <summary>
    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
    /// Boolean expression evaluates to <see langword="true"/>.
    /// </summary>
    /// <remarks><para><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement">
    /// See here for more information.
    /// </a></para></remarks>
    /// <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
    /// <returns>An enumeration from a range's start to end.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<int> For(this Range range) =>
        (range.Start.IsFromEnd ? -range.Start.Value : range.Start.Value) is var start &&
        (range.End.IsFromEnd ? -range.End.Value : range.End.Value) is var end &&
        start == end ? [] :
        start < end ? Enumerable.Range(start, end - start) :
        Enumerable.Repeat(start, start - end).Select((x, i) => x - i);
    /// <summary>Separates the head from the tail of an <see cref="IEnumerable{T}"/>.</summary>
    /// <remarks><para>
    /// The tail is not guaranteed to be able to be enumerated over multiple times.
    /// As such, use a method like <see cref="Collected.ToICollection{T}"/> if multiple enumerations are needed.
    /// </para></remarks>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="enumerable">The enumerable to split.</param>
    /// <param name="head">The first element of the parameter <paramref name="enumerable"/>.</param>
    /// <param name="tail">The rest of the parameter <paramref name="enumerable"/>.</param>
    public static void Deconstruct<T>(
        this IEnumerable<T>? enumerable,
        out T? head,
        [MustDisposeResource] out IEnumerable<T> tail
    )
    {
        using var e = enumerable?.GetEnumerator();
        if (e is null)
        {
            head = default;
            tail = [];
            return;
        }
        head = e.MoveNext() ? e.Current : default;
        tail = e.AsEnumerable();
    }
    /// <summary>Gets a specific item from a collection.</summary>
    /// <param name="str">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="str"/>, or <see langword="default"/>.</returns>
    [Pure]
    public static char? Nth(this string str, Index index) =>
        index.IsFromEnd ? str.NthLast(index.Value - 1) : str.Nth(index.Value);
    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static T? Nth<T>([InstantHandle] this IEnumerable<T> iterable, Index index) =>
        index.IsFromEnd ? iterable.NthLast(index.Value - 1) : iterable.Nth(index.Value);
    /// <summary>Gets a specific item from a collection.</summary>
    /// <param name="str">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="range">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="str"/>, or <see langword="default"/>.</returns>
    [Pure]
    public static string? Nth(this string str, Range range) =>
        range.TryGetOffsetAndLength(str.Length, out var offset, out var length)
            ? str.Substring(offset, length)
            : default;
    /// <summary>Gets a range of items from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get a range of items from.</param>
    /// <param name="range">The ranges to get.</param>
    /// <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Nth<T>([InstantHandle] this IEnumerable<T> iterable, Range range)
    {
        [LinqTunnel, Pure]
        static IEnumerable<TT> Sub<TT>([InstantHandle] IEnumerable<TT> iterable, Range range) =>
            iterable.Skip(range.Start.Value).Take(range.End.Value - range.Start.Value);
        if (!range.Start.IsFromEnd && !range.End.IsFromEnd)
            return Sub(iterable, range);
        if (iterable.TryGetNonEnumeratedCount(out var count) && RangeStart(range, count) is var startRange)
            return Sub(iterable, startRange);
        var arr = iterable.ToIList();
        var arrRange = RangeStart(range, arr.Count);
        return Sub(arr, arrRange);
    }
    /// <summary>Gets an enumeration of an index.</summary>
    /// <param name="index">The index to count up or down to.</param>
    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<int> GetEnumerator(this Index index) => index.For().GetEnumerator();
    /// <summary>Gets an enumeration of a range.</summary>
    /// <param name="range">The range to iterate over.</param>
    /// <returns>An enumeration from the range's start to end.</returns>
    [MustDisposeResource, Pure]
    public static IEnumerator<int> GetEnumerator(this Range range) => range.For().GetEnumerator();
    [Pure]
    static Index IndexStart(Index index, int length) => index.IsFromEnd ? length - index.Value - 1 : index;
    [Pure]
    static Range RangeStart(Range range, int length) =>
        new(IndexStart(range.Start, length), IndexStart(range.End, length));
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Extension methods that negate functions from <see cref="Enumerable"/>.</summary>
    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
    /// <remarks><para>
    /// Filters out unique elements within an <see cref="IEnumerable{T}"/>.
    /// Each duplicate appears exactly once within the returned value.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
    /// <param name="source">The source to filter.</param>
    /// <param name="comparer">The comparer to assess distinctiveness.</param>
    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> DistinctDuplicates<T>(
        [NoEnumeration] this IEnumerable<T> source,
        IEqualityComparer<T>? comparer = null
    ) =>
        source.GroupDuplicates(comparer).Select(x => x.Key);
    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
    /// <remarks><para>
    /// Filters out unique elements within an <see cref="IEnumerable{T}"/>.
    /// Each duplicate appears two or more times within the returned value.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
    /// <param name="source">The source to filter.</param>
    /// <param name="comparer">The comparer to assess distinctiveness.</param>
    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Duplicates<T>(
        [NoEnumeration] this IEnumerable<T> source,
        IEqualityComparer<T>? comparer = null
    ) =>
        source.GroupDuplicates(comparer).SelectMany(x => x);
    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
    /// <remarks><para>Filters out unique elements within an <see cref="IEnumerable{T}"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
    /// <param name="source">The source to filter.</param>
    /// <param name="comparer">The comparer to assess distinctiveness.</param>
    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<IGrouping<T, T>> GroupDuplicates<T>(
        [NoEnumeration] this IEnumerable<T> source,
        IEqualityComparer<T>? comparer = null
    ) =>
        source.GroupBy(x => x, comparer).Where(x => x.Skip(1).Any());
    /// <summary>Negated <see cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains the elements from the input sequence starting at
    /// the first element in the linear series that does pass the test specified by the predicate.
    /// </returns>
    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> SkipUntil<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
        source.SkipWhile(x => !predicate(x));
    /// <summary>
    /// Negated
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>.
    /// </summary>
    /// <remarks><para>
    /// Splits the <see cref="IEnumerable{T}"/> into multiple <see cref="IEnumerable{T}"/>
    /// instances in at most the specified length.
    /// </para></remarks>
    /// <typeparam name="T">The type of the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <param name="source">The <see cref="IEnumerable{T}"/> to chop into slices.</param>
    /// <param name="count">The maximum length of any given returned <see cref="IEnumerable{T}"/> instances.</param>
    /// <returns>The wrapper of the parameter <paramref name="source"/> that returns slices of it.</returns>
    [Pure]
    public static IEnumerable<IEnumerable<T>> SplitEvery<T>(
        [InstantHandle] this IEnumerable<T> source,
        [ValueRange(1, int.MaxValue)] int count
    )
    {
        if (count <= 0)
            yield break;
        using var e = source.GetEnumerator();
        while (e.MoveNext())
            yield return e.SplitEvery(count);
    }
    /// <summary>Negated <see cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains the elements from the input
    /// sequence that occur before the element at which the test no longer fails.
    /// </returns>
    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> TakeUntil<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
        source.TakeWhile(x => !predicate(x));
    /// <summary>Negated <see cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains elements from
    /// the input sequence that do not satisfy the condition.
    /// </returns>
    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> TakeUntil<T>(
        [NoEnumeration] this IEnumerable<T> source,
        Func<T, int, bool> predicate
    ) =>
        source.TakeWhile((x, y) => !predicate(x, y));
    /// <summary>Negated <see cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains elements from
    /// the input sequence that do not satisfy the condition.
    /// </returns>
    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Omit<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
        source.Where(x => !predicate(x));
    /// <summary>Negated <see cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
    /// <returns>
    /// An <see cref="IEnumerable{T}" /> that contains elements from
    /// the input sequence that do not satisfy the condition.
    /// </returns>
    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, int, bool})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Omit<T>(
        [NoEnumeration] this IEnumerable<T> source,
        Func<T, int, bool> predicate
    ) =>
        source.Where((x, y) => !predicate(x, y));
    static IEnumerable<T> SplitEvery<T>(this IEnumerator<T> e, [ValueRange(1, int.MaxValue)] int count)
    {
        do
            yield return e.Current;
        while (--count > 0 && e.MoveNext());
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Provides methods to flatten <see cref="IEnumerable{T}"/> instances.</summary>
    /// <summary>Flattens the nested collection.</summary>
    /// <typeparam name="T">The type of collection.</typeparam>
    /// <param name="enumerable">The collection to flatten.</param>
    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten<T>(this IEnumerable<IEnumerable<T>> enumerable) =>
        enumerable.SelectMany(Enumerable.AsEnumerable);
    /// <inheritdoc cref="Flatten{T}"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten2<T>(this IEnumerable<IEnumerable<IEnumerable<T>>> enumerable) =>
        enumerable.Flatten().Flatten();
    /// <inheritdoc cref="Flatten{T}"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten3<T>(this IEnumerable<IEnumerable<IEnumerable<IEnumerable<T>>>> enumerable) =>
        enumerable.Flatten2().Flatten();
    /// <inheritdoc cref="Flatten{T}"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten4<T>(
        this IEnumerable<IEnumerable<IEnumerable<IEnumerable<IEnumerable<T>>>>> enumerable
    ) =>
        enumerable.Flatten2().Flatten2();
    /// <inheritdoc cref="Flatten{T}"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten5<T>(
        this IEnumerable<IEnumerable<IEnumerable<IEnumerable<IEnumerable<IEnumerable<T>>>>>> enumerable
    ) =>
        enumerable.Flatten4().Flatten();
    /// <inheritdoc cref="Flatten{T}"/>
    [LinqTunnel, Pure]
    public static IEnumerable<T> Flatten6<T>(
        this IEnumerable<IEnumerable<IEnumerable<IEnumerable<IEnumerable<IEnumerable<IEnumerable<T>>>>>>> enumerable
    ) =>
        enumerable.Flatten4().Flatten2();
    /// <summary>
    /// Flattens the nested collection by taking all the first elements of the enumerations,
    /// then all the second elements of the enumerations, the third, and so on.
    /// When any enumeration runs out, it simply moves onto the next enumeration until all enumerations are finished.
    /// </summary>
    /// <typeparam name="T">The type of collection.</typeparam>
    /// <param name="enumerable">The collection to flatten.</param>
    /// <returns>
    /// The flattened collection by taking items in order of appearance of each individual enumerable,
    /// and only then by the outer enumerable.
    /// </returns>
    [Pure]
    public static IEnumerable<List<T>> Transpose<T>(this IEnumerable<IEnumerable<T>> enumerable)
    {
        var (truthy, falsy) = enumerable
           .Select([MustDisposeResource](x) => x.GetEnumerator())
           .SplitBy(x => x.MoveNext());
        falsy.For(x => x.Dispose());
        try
        {
            while (truthy is not [])
            {
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
                yield return truthy.ConvertAll(x => x.Current);
#else
                yield return new(truthy.Select(x => x.Current));
#endif
                (truthy, falsy) = truthy.SplitBy(x => x.MoveNext());
                falsy.For(x => x.Dispose());
            }
        }
        finally
        {
            truthy.For(x => x.Dispose());
        }
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Provides methods for creating combinations of items.</summary>
    /// <summary>Generates all combinations of the nested enumerable.</summary>
    /// <typeparam name="T">The type of nested enumerable.</typeparam>
    /// <param name="iterator">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="iterator"/>.</returns>
    [Pure]
#if NETFRAMEWORK && !NET45_OR_GREATER
    public static IEnumerable<IList<T>> Combinations<T>(
#else
    public static IEnumerable<IReadOnlyList<T>> Combinations<T>(
#endif
        [InstantHandle] this IEnumerable<IEnumerable<T>> iterator
    ) =>
#if NETFRAMEWORK && !NET45_OR_GREATER
        iterator.Select(x => x.ToIList()).ToIList().Combinations();
#else
        iterator.Select(x => x.ReadOnly()).ReadOnly().Combinations();
#endif
    /// <summary>Generates all combinations of the nested list.</summary>
    /// <typeparam name="T">The type of nested list.</typeparam>
    /// <param name="lists">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="lists"/>.</returns>
    [Pure]
#if NETFRAMEWORK && !NET45_OR_GREATER
    public static IEnumerable<IList<T>> Combinations<T>(this IList<IList<T>> lists)
#else
    public static IEnumerable<IReadOnlyList<T>> Combinations<T>(this IReadOnlyList<IReadOnlyList<T>> lists)
#endif
    {
        if (lists.Any(x => x is []))
            yield break;
        int count = lists.Count, index = 0, pos = 0;
        var indices = new int[count];
        var accumulator = new T[count];
        while (true)
        {
            while (pos < accumulator.Length)
            {
                indices[pos] = index;
                accumulator[pos] = lists[pos][index];
                index = 0;
                pos++;
            }
            var result = new T[count];
            Array.Copy(accumulator, result, count);
            yield return result;
            do
            {
                if (pos is 0)
                    yield break;
                index = indices[--pos] + 1;
            } while (index >= lists[pos].Count);
        }
    }
    /// <summary>Generates all combinations of the nested list.</summary>
    /// <typeparam name="T">The type of nested list.</typeparam>
    /// <param name="lists">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="lists"/>.</returns>
    [Pure]
    public static IEnumerable<SmallList<T>> Combinations<T>(this SmallList<SmallList<T>> lists)
    {
        foreach (var list in lists)
            if (list is [])
                return [];
        return lists.CombinationsIterator();
    }
    /// <summary>Generates all combinations of the nested enumerable.</summary>
    /// <typeparam name="T">The type of nested enumerable.</typeparam>
    /// <param name="iterator">The input to generate combinations of.</param>
    /// <returns>Every combination of the items in <paramref name="iterator"/>.</returns>
    [Pure]
    public static IEnumerable<SmallList<T>> SmallListCombinations<T>(
        [InstantHandle] this IEnumerable<IEnumerable<T>> iterator
    ) =>
        iterator.Select(x => x.ToSmallList()).ToSmallList().Combinations();
    static IEnumerable<SmallList<T>> CombinationsIterator<T>(this SmallList<SmallList<T>> lists)
    {
        int count = lists.Count, index = 0, pos = 0;
        var indices = SmallList<int>.Uninit(count);
        var accumulator = SmallList<T>.Uninit(count);
        while (true)
        {
            while (pos < accumulator.Count)
            {
                indices[pos] = index;
                accumulator[pos] = lists[pos][index];
                index = 0;
                pos++;
            }
            yield return accumulator.Cloned;
            do
            {
                if (pos is 0)
                    yield break;
                index = indices[--pos] + 1;
            } while (index >= lists[pos].Count);
        }
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Extension methods to create power sets.</summary>
    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<object>> PowerSet(this ICollection collection) =>
        collection.Cast<object>().PowerSetInner(collection.Count);
    /// <summary>Creates a power set from a collection.</summary>
    /// <remarks><para>
    /// The power set is defined as the set of all subsets, including the empty set and the set itself.
    /// </para></remarks>
    /// <typeparam name="T">The type of item in the set.</typeparam>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The argument <paramref name="collection"/> has 32 or more elements.
    /// </exception>
    /// <param name="collection">The set to create a power set.</param>
    /// <returns>The power set of the parameter <paramref name="collection"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this ICollection<T> collection) =>
        collection.PowerSetInner(collection.Count);
    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this IReadOnlyCollection<T> collection) =>
        collection.PowerSetInner(collection.Count);
    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
    [LinqTunnel, Pure]
    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this T[] collection) =>
        ((ICollection<T>)collection).PowerSet();
    [LinqTunnel, Pure]
    static IEnumerable<IEnumerable<T>> PowerSetInner<T>(this IEnumerable<T> iterable, [ValueRange(0, 31)] int count) =>
        count < 32
            ? Enumerable.Range(0, 1 << count).Select(mask => iterable.Where((_, j) => (1 << j & mask) is not 0))
            : throw new ArgumentOutOfRangeException(nameof(count), count, $"Cannot exceed bits in {nameof(Int32)}.");
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace RedundantUsingDirective
/// <summary>Extension methods to attempt to grab the length from enumerables.</summary>
    /// <summary>Tries to count the elements in the enumerable.</summary>
    /// <typeparam name="T">The type of element in the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <param name="enumerable">The enumerable to count.</param>
    /// <returns>
    /// If relatively cheap to compute, the number of elements in the parameter
    /// <paramref name="enumerable"/>; otherwise, <see langword="null"/>.</returns>
    [NonNegativeValue]
    public static int? TryCount<T>([NoEnumeration] this IEnumerable<T>? enumerable) =>
        enumerable switch
        {
            null => null,
            string { Length: var length } => length,
            IReadOnlyCollection<T> { Count: var count } => count,
            _ => enumerable.TryGetNonEnumeratedCount(out var count) ? count : null,
        };
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace RedundantUsingDirective
#if NETCOREAPP_3_0_OR_GREATER
#endif
/// <summary>Extension methods to attempt to grab the span from enumerables.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP || ROSLYN
    /// <summary>Tries to extract a span from the source.</summary>
    /// <typeparam name="T">The type of element in the <see cref="IEnumerable{T}"/>.</typeparam>
    /// <param name="source">The source to extract the span from.</param>
    /// <param name="span">The resulting span.</param>
    /// <returns>Whether the span can be extracted from the parameter <paramref name="source"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryGetSpan<T>(
        [NoEnumeration, NotNullWhen(true)] this IEnumerable<T>? source,
        out ReadOnlySpan<T> span
    ) =>
        source switch
        {
            T[] provider => (span = provider) is var _,
            ArraySegment<T> provider => (span = provider.AsSpan()) is var _,
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> provider => (span = provider.AsSpan()) is var _,
#endif
#if NET5_0_OR_GREATER
            List<T> provider => (span = CollectionsMarshal.AsSpan(provider)) is var _,
#endif
#if NETCOREAPP_3_0_OR_GREATER
            string provider => (span = MemoryMarshal.CreateReadOnlySpan(
                ref Unsafe.As<char, T>(ref AsRef(provider.GetPinnableReference())),
                provider.Length
            )) is var _,
#endif
            _ => !((span = default) is var _),
        };
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace ConditionIsAlwaysTrueOrFalse RedundantNameQualifier ReturnTypeCanBeEnumerable.Global UseIndexFromEndExpression
/// <summary>Extension methods to attempt to grab ranges from enumerables.</summary>
    /// <summary>Takes the last item lazily, or a fallback value.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
    [Pure]
    public static T EnumerateOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback)
    {
#if NETCOREAPP || ROSLYN
        if (iterable is ImmutableArray<T> { IsDefaultOrEmpty: true })
            return fallback;
#endif
        using var iterator = iterable.GetEnumerator();
        if (!iterator.MoveNext())
            return fallback;
        var last = iterator.Current;
        while (iterator.MoveNext())
            last = iterator.Current;
        return last;
    }
#if !(NET20 || NET30)
    /// <summary>Takes the first item, or a fallback value.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
    [MustUseReturnValue]
    public static T FirstOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback)
    {
        switch (iterable)
        {
            case string str:
                return str.Length is 0 ? fallback : Reinterpret<T>(str[0]);
#if NETCOREAPP || ROSLYN
            case ImmutableArray<T> array:
                return array.IsDefaultOrEmpty ? fallback : array[0];
#endif
            case IList<T> list:
                return list.Count is 0 ? fallback : list[0];
            case IReadOnlyList<T> list:
                return list.Count is 0 ? fallback : list[0];
            case var _ when iterable.TryGetNonEnumeratedCount(out var count):
                return count is 0 ? fallback : iterable.First();
            default:
            {
                using var iterator = iterable.GetEnumerator();
                return iterator.MoveNext() ? iterator.Current : fallback;
            }
        }
    }
    /// <summary>Takes the last item, or a fallback value.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The collection of items to go through one-by-one.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
    [MustUseReturnValue]
    public static T LastOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback) =>
        iterable switch
        {
            string str => str is [.., var last] ? Reinterpret<T>(last) : fallback,
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> array => array is [.., var last] ? last : fallback,
#endif
            IReadOnlyList<T> list => list is [.., var last] ? last : fallback,
            IList<T> list => list is [.., var last] ? last : fallback,
            _ when iterable.TryCount() is { } count => count is 0 ? fallback : iterable.Last(),
            _ => iterable.EnumerateOr(fallback),
        };
#endif
    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="TKey">The key item in the collection.</typeparam>
    /// <typeparam name="TValue">The value item in the collection.</typeparam>
    /// <param name="dictionary">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="key">The key to use to get the value.</param>
    /// <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static TValue? Nth<TKey, TValue>([InstantHandle] this IDictionary<TKey, TValue> dictionary, TKey key)
        where TKey : notnull =>
        dictionary.TryGetValue(key, out var value) ? value : default;
#if !NET20 && !NET30
    /// <summary>Returns the item, or a fallback.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="self">The item to potentially return.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
    [Pure]
    public static T Or<T>(this T? self, T fallback)
        where T : class =>
        self ?? fallback;
    /// <summary>Returns the item, or a fallback.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="self">The item to potentially return.</param>
    /// <param name="fallback">The fallback item.</param>
    /// <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
    [Pure]
    public static T Or<T>(this T? self, T fallback)
        where T : struct =>
        self ?? fallback;
    /// <summary>Returns the item, or a fallback.</summary>
    /// <typeparam name="T">The type of item.</typeparam>
    /// <param name="self">The item to potentially return.</param>
    /// <returns>The parameter <paramref name="self"/>, or a new instance.</returns>
    [Pure]
    public static T OrNew<T>(this T? self)
        where T : class, new() =>
        self ?? new();
    /// <summary>Returns the string, or an empty string.</summary>
    /// <param name="str">The string to potentially return.</param>
    /// <returns>The parameter <paramref name="str"/>, or <see cref="string.Empty"/>.</returns>
    [Pure]
    public static string OrEmpty(this string? str) => str ?? "";
    /// <summary>Returns the enumeration, or an empty enumeration.</summary>
    /// <typeparam name="T">The type of iterator.</typeparam>
    /// <param name="iterable">The enumeration to potentially return.</param>
    /// <returns>The parameter <paramref name="iterable"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T> OrEmpty<T>([NoEnumeration] this IEnumerable<T>? iterable) => iterable ?? [];
#if NETCOREAPP || ROSLYN
    /// <summary>Returns the array, or an empty array.</summary>
    /// <typeparam name="T">The type of array.</typeparam>
    /// <param name="array">The array to potentially return.</param>
    /// <returns>The parameter <paramref name="array"/>, or <see cref="ImmutableArray{T}.Empty"/>.</returns>
    [Pure]
    public static ImmutableArray<T> OrEmpty<T>(this ImmutableArray<T> array) =>
        array.IsDefault ? ImmutableArray<T>.Empty : array;
#endif
    /// <summary>Gets a specific character from a string.</summary>
    /// <param name="str">The string to get the character from.</param>
    /// <param name="index">The index to use.</param>
    /// <returns>The character based on the parameters <paramref name="str"/> and <paramref name="index"/>.</returns>
    [Pure]
    public static char? Nth(this string str, [NonNegativeValue] int index) =>
        index >= 0 && index < str.Length ? str[index] : null;
    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static T? Nth<T>([InstantHandle] this IEnumerable<T> iterable, [NonNegativeValue] int index)
    {
        if (index < 0)
            return default;
        return iterable switch
        {
            string str => index < str.Length ? Reinterpret<T>(str[index]) : default,
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> array => !array.IsDefault && index < array.Length ? array[index] : default,
#endif
            IReadOnlyList<T> list => index < list.Count ? list[index] : default,
            IList<T> list => index < list.Count ? list[index] : default,
            _ => iterable.Skip(index).FirstOrDefault(),
        };
    }
    /// <summary>Gets a specific character from a string.</summary>
    /// <param name="str">The string to get the character from.</param>
    /// <param name="index">The index to use.</param>
    /// <returns>The character based on the parameters <paramref name="str"/> and <paramref name="index"/>.</returns>
    [Pure]
    public static char? NthLast(this string str, [NonNegativeValue] int index) =>
        index >= 0 && index < str.Length ? str[str.Length - index - 1] : null;
    /// <summary>Gets a specific item from a collection.</summary>
    /// <typeparam name="T">The item in the collection.</typeparam>
    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
    /// <param name="index">The index to get.</param>
    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
    [MustUseReturnValue]
    public static T? NthLast<T>([InstantHandle] this IEnumerable<T> iterable, [NonNegativeValue] int index)
    {
        if (index < 0)
            return default;
        return iterable switch
        {
            string str => index < str.Length ? Reinterpret<T>(str[str.Length - index - 1]) : default,
#if NETCOREAPP || ROSLYN
            ImmutableArray<T> array =>
                !array.IsDefault && index < array.Length ? array[array.Length - index - 1] : default,
#endif
            IReadOnlyList<T> list => index < list.Count ? list[list.Count - index - 1] : default,
            IList<T> list => index < list.Count ? list[list.Count - index - 1] : default,
            _ when iterable.TryGetNonEnumeratedCount(out var count) =>
                index < count ? iterable.Skip(count - index - 1).FirstOrDefault() : default,
            _ => iterable.Reverse().Skip(index).FirstOrDefault(),
        };
    }
#endif
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static unsafe T Reinterpret<T>(char c)
    {
        System.Diagnostics.Debug.Assert(typeof(T) == typeof(char), "T must be char");
#if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
#pragma warning disable 8500
        return *(T*)&c;
#pragma warning restore 8500
#else
        return Unsafe.As<char, T>(ref c);
#endif
    }
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides methods to create views of <see cref="IEnumerable{T}"/> instances.</summary>
    /// <summary>
    /// Transforms the <see cref="IEnumerable{T}"/> into views of the current and next items.
    /// </summary>
    /// <typeparam name="T">The type of items in the collection.</typeparam>
    /// <param name="source">The collection to iterate over.</param>
    /// <returns>The <see cref="IEnumerable{T}"/> containing the current and next items.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<(T Left, T Right)> Pairs<T>(this IEnumerable<T> source) =>
        source.TryCount() is { } x ? Iterator(source).WithCount(x - 1) : Iterator(source);
    /// <summary>
    /// Transforms the <see cref="IEnumerable{T}"/> into views of the specified length.
    /// </summary>
    /// <typeparam name="T">The type of items in the collection.</typeparam>
    /// <param name="source">The collection to iterate over.</param>
    /// <param name="size">The size of the window.</param>
    /// <returns>An <see cref="IEnumerable{T}"/> of windows.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<T[]> Window<T>(this IEnumerable<T> source, int size) =>
        size <= 0
            ? []
            : source.TryCount() switch
            {
                0 => [],
                { } x when x < size => [],
                1 => source.Select(x => new[] { x }),
                { } x => Iterator(source, size).WithCount(x - size + 1),
                null => Iterator(source, size),
            };
    [Pure]
    static IEnumerable<(T Left, T Right)> Iterator<T>(IEnumerable<T> source)
    {
        using var e = source.GetEnumerator();
        if (!e.MoveNext())
            yield break;
        var previous = e.Current;
        while (e.MoveNext())
            yield return (previous, previous = e.Current);
    }
    [Pure]
    static IEnumerable<T[]> Iterator<T>(IEnumerable<T> source, int size)
    {
        using var e = source.GetEnumerator();
        var window = new T[size];
        for (var i = 0; i < size; i++)
            if (e.MoveNext())
                window[i] = e.Current;
            else
                yield break;
        yield return (T[])window.Clone();
        while (e.MoveNext())
        {
            for (var i = 1; i < window.Length; i++)
                window[i - 1] = window[i];
            window[^1] = e.Current;
            yield return (T[])window.Clone();
        }
    }
// SPDX-License-Identifier: MPL-2.0
#if !NET20 && !NET30
// ReSharper disable once CheckNamespace
/// <summary>Methods that creates enumerations from individual items.</summary>
#if !NETSTANDARD || NETSTANDARD1_5_OR_GREATER
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(this Assembly? assembly)
    {
        try
        {
            return assembly?.GetTypes() ?? [];
        }
        catch (ReflectionTypeLoadException ex)
        {
            return ex.Types.Filter();
        }
    }
#endif
    /// <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="item">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, MustUseReturnValue]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        this T? item,
        [InstantHandle] Converter<T, IEnumerable<TResult>?> map
    ) =>
        item is not null && map(item) is { } iterable ? iterable : [];
    /// <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="item">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, MustUseReturnValue]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        this T? item,
        [InstantHandle] Converter<T, IEnumerable<TResult>?> map
    )
        where T : struct =>
        item.HasValue && map(item.Value) is { } iterable ? iterable : [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    ) =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    )
        where T : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    )
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, IEnumerable<TResult?>?> map
    )
        where T : struct
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    ) =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    )
        where T : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    )
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
    /// <summary>
    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
    /// but with exhaustive null guards that fall back to empty enumerables.
    /// </summary>
    /// <typeparam name="T">The source of the item.</typeparam>
    /// <typeparam name="TResult">The resulting type.</typeparam>
    /// <param name="iterator">The item to check.</param>
    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
    [LinqTunnel, Pure]
    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
        [NoEnumeration] this IEnumerable<T?>? iterator,
        Func<T, int, IEnumerable<TResult?>?> map
    )
        where T : struct
        where TResult : struct =>
        iterator?.Filter().Select(map).SelectMany(x => x ?? []).Filter() ?? [];
#endif
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer
// ReSharper disable once RedundantUsingDirective.Global
// ReSharper disable once CheckNamespace
/// <summary>Methods to create methods.</summary>
    sealed class Compared<T>(Comparison<T?> comparer) : IComparer<T>
    {
        /// <inheritdoc />
        public int Compare(T? x, T? y) => comparer(x, y);
    }
    sealed class Compared<T, TResult>(Converter<T?, TResult> converter, IComparer<TResult> comparer) : IComparer<T>
    {
        /// <inheritdoc />
        public int Compare(T? x, T? y) => comparer.Compare(converter(x), converter(y));
    }
    sealed class Equated<T>(Func<T?, T?, bool> comparer, Func<T, int> hashCode) : IEqualityComparer<T>
    {
        /// <summary>Initializes a new instance of the <see cref="Equated{T}"/> class.</summary>
        /// <param name="comparer">The comparer to convert.</param>
        public Equated(IComparer<T> comparer)
            : this(FromIComparer(comparer), Default) { }
        /// <summary>Returns 0.</summary>
        /// <param name="_">The discard.</param>
        /// <returns>The value 0.</returns>
        public static int Default(T? _) => 0;
        /// <inheritdoc />
        public bool Equals(T? x, T? y) => comparer(x, y);
        /// <inheritdoc />
        public int GetHashCode(T obj) => hashCode(obj);
        /// <summary>Returns the equality function based on the <see cref="IComparer{T}"/>.</summary>
        /// <param name="comparer">The comparer to evaluate equality.</param>
        /// <returns>The equality function that wraps <paramref name="comparer"/>.</returns>
        static Func<T?, T?, bool> FromIComparer(IComparer<T> comparer) => (x, y) => comparer.Compare(x!, y!) is 0;
    }
    sealed class Equated<T, TResult>(Converter<T?, TResult> converter, IEqualityComparer<TResult> equalityComparer)
        : IEqualityComparer<T>
    {
        /// <inheritdoc />
        public bool Equals(T? x, T? y) => equalityComparer.Equals(converter(x), converter(y));
        /// <inheritdoc />
        public int GetHashCode(T obj) => equalityComparer.GetHashCode(converter(obj)!);
    }
    /// <summary>The number of bits in a byte.</summary>
    public const int BitsInByte = 8;
    /// <summary>Disposes of the <paramref name="disposable"/> and sets it to <see langword="default"/>.</summary>
    /// <typeparam name="T">The type of <paramref name="disposable"/>.</typeparam>
    /// <param name="disposable">The disposable to dispose.</param>
    public static void DisposeOf<T>(ref T? disposable)
#if NET9_0_OR_GREATER
        where T : IDisposable, allows ref struct
#else
        where T : IDisposable
#endif
    {
        disposable?.Dispose();
        disposable = default;
    }
    /// <summary>Invokes a method.</summary>
    /// <param name="del">The method to invoke.</param>
    public static void Invoke([InstantHandle] Action del) => del();
    /// <summary>Performs nothing.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Noop()
    {
    }
    /// <summary>Performs nothing.</summary>
    /// <typeparam name="T">The type of discard.</typeparam>
    /// <param name="_">The discard.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Noop<T>(T _)
    {
    }
    /// <summary>Performs nothing.</summary>
    /// <typeparam name="T1">The first type of discard.</typeparam>
    /// <typeparam name="T2">The second type of discard.</typeparam>
    /// <param name="_">The first discard.</param>
    /// <param name="__">The second discard.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Noop<T1, T2>(T1 _, T2 __)
    {
    }
    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <param name="comparison">The <see cref="Comparison{T}"/> to use.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="comparison"/>.</returns>
    public static IComparer<T> Comparing<T>(Comparison<T?> comparison) => new Compared<T>(comparison);
    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
    /// <param name="converter">The converter to use.</param>
    /// <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="converter"/>.</returns>
    public static IComparer<T> Comparing<T, TResult>(
        Converter<T?, TResult> converter,
        IComparer<TResult>? comparer = null
    ) =>
        new Compared<T, TResult>(converter, comparer ?? Comparer<TResult>.Default);
    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <param name="comparison">The <see cref="Comparison{T}"/> to use.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="comparison"/>.</returns>
    public static IEqualityComparer<T> AsEquality<T>(this IComparer<T> comparison) => new Equated<T>(comparison);
    /// <summary>Creates the <see cref="IEqualityComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
    /// <param name="converter">The converter to use.</param>
    /// <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="converter"/>.</returns>
    public static IEqualityComparer<T> Equating<T, TResult>(
        Converter<T?, TResult> converter,
        IEqualityComparer<TResult>? comparer = null
    ) =>
        new Equated<T, TResult>(converter, comparer ?? EqualityComparer<TResult>.Default);
    /// <summary>Creates the <see cref="IEqualityComparer{T}"/> from the mapping.</summary>
    /// <typeparam name="T">The type to compare.</typeparam>
    /// <param name="comparer">The comparer to use.</param>
    /// <param name="hashCode">If specified, the hash code algorithm.</param>
    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="comparer"/>.</returns>
    public static IEqualityComparer<T> Equating<T>(Func<T?, T?, bool> comparer, Func<T, int>? hashCode = null) =>
        new Equated<T>(comparer, hashCode ?? Equated<T>.Default);
    /// <inheritdoc cref="Invoke"/>
    public static TResult Invoke<TResult>([InstantHandle] Func<TResult> del) => del();
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Extension methods to clamp numbers.</summary>
    /// <inheritdoc cref="IsPow2(IntPtr)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2(this int value) =>
#if NET6_0_OR_GREATER
        BitOperations.IsPow2(value);
#else
        (value & value - 1) is 0 && value > 0;
#endif
    /// <inheritdoc cref="IsPow2(IntPtr)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2(this uint value) =>
#if NET6_0_OR_GREATER
        BitOperations.IsPow2(value);
#else
        (value & value - 1) is 0 && value > 0;
#endif
    /// <inheritdoc cref="IsPow2(IntPtr)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2(this long value) =>
#if NET6_0_OR_GREATER
        BitOperations.IsPow2(value);
#else
        (value & value - 1) is 0 && value > 0;
#endif
    /// <inheritdoc cref="IsPow2(IntPtr)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2(this ulong value) =>
#if NET6_0_OR_GREATER
        BitOperations.IsPow2(value);
#else
        (value & value - 1) is 0 && value > 0;
#endif
    /// <summary>Evaluate whether a given integral value is a power of 2.</summary>
    /// <param name="value">The value.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="value"/>
    /// is a power of 2; otherwise, <see langword="false"/>.
    /// </returns>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2(this nint value) =>
#if NET7_0_OR_GREATER
        BitOperations.IsPow2(value);
#else
        (value & value - 1) is 0 && value > 0;
#endif
    /// <inheritdoc cref="IsPow2(IntPtr)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2(this nuint value) =>
#if NET7_0_OR_GREATER
        BitOperations.IsPow2(value);
#else
        (value & value - 1) is 0 && value > 0;
#endif
#if NET7_0_OR_GREATER
    /// <inheritdoc cref="IsPow2(IntPtr)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPow2<T>(this T value)
        where T : IBitwiseOperators<T, T, T>, IComparisonOperators<T, T, bool>, INumberBase<T> =>
        (value & value - T.One) == T.Zero && value > T.Zero;
#endif
    /// <inheritdoc cref="RoundUpToPowerOf2(uint)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe uint RoundUpToPowerOf2(this int value) => RoundUpToPowerOf2(unchecked((uint)value));
    /// <summary>Round the given integral value up to a power of 2.</summary>
    /// <remarks><para>
    /// The fallback implementation is based on
    /// <a href="https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2">
    /// Bit Twiddling Hacks by Sean Eron Anderson
    /// </a>.
    /// </para></remarks>
    /// <param name="value">The value.</param>
    /// <returns>
    /// The smallest power of 2 which is greater than or equal to <paramref name="value"/>.
    /// If <paramref name="value"/> is 0 or the result overflows, returns 0.
    /// </returns>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static uint RoundUpToPowerOf2(this uint value)
#if NET6_0_OR_GREATER
        =>
            BitOperations.RoundUpToPowerOf2(value);
#else
    {
        --value;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        return value + 1;
    }
#endif
    /// <inheritdoc cref="RoundUpToPowerOf2(uint)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe ulong RoundUpToPowerOf2(this long value) => RoundUpToPowerOf2(unchecked((ulong)value));
    /// <inheritdoc cref="RoundUpToPowerOf2(uint)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static ulong RoundUpToPowerOf2(this ulong value)
#if NET6_0_OR_GREATER
        =>
            BitOperations.RoundUpToPowerOf2(value);
#else
    {
        --value;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value |= value >> 32;
        return value + 1;
    }
#endif
    /// <inheritdoc cref="RoundUpToPowerOf2(uint)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe nuint RoundUpToPowerOf2(this nint value) => RoundUpToPowerOf2(unchecked((nuint)value));
    /// <inheritdoc cref="RoundUpToPowerOf2(uint)"/>
    [CLSCompliant(false), Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static unsafe nuint RoundUpToPowerOf2(this nuint value) =>
#if NET6_0_OR_GREATER
#pragma warning disable IDE0004
        (nuint)BitOperations.RoundUpToPowerOf2(value);
#pragma warning restore IDE0004
#else
        sizeof(nuint) is 4 ? RoundUpToPowerOf2((uint)value) : (nuint)RoundUpToPowerOf2((ulong)value);
#endif
#if NET7_0_OR_GREATER
    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
    /// <typeparam name="T">The type of numeric value for comparisons.</typeparam>
    /// <param name="number">The number to clip.</param>
    /// <param name="min">If specified, the smallest number to return.</param>
    /// <param name="max">If specified, the greatest number to return.</param>
    /// <returns>
    /// The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
    /// otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
    /// <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Clip<T>(this T number, T? min = null, T? max = null)
        where T : class, IComparisonOperators<T, T, bool> =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;
    /// <inheritdoc cref="Clip{T}(T,T?,T?)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Clip<T>(this T number, T? min = null, T? max = null)
        where T : struct, IComparisonOperators<T, T, bool> =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;
    /// <summary>
    /// Calculates the least nonnegative remainder of <paramref name="number"/> <c>%</c> <paramref name="radix"/>.
    /// </summary>
    /// <remarks><para>
    /// Implementation based on <a href="https://doc.rust-lang.org/src/core/num/int_macros.rs.html#2190">
    /// Rust standard library (core)'s rem_euclid function
    /// </a>.
    /// </para></remarks>
    /// <typeparam name="T">The type of numeric value.</typeparam>
    /// <param name="number">The number to calculate the remainder of.</param>
    /// <param name="radix">The radix to use.</param>
    /// <returns>The result of the Euclidean division algorithm.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Mod<T>(this T number, T radix)
        where T : IComparisonOperators<T, T, bool>, IModulusOperators<T, T, T>, INumberBase<T> =>
        number % radix is var r && r < T.Zero ? unchecked(r + radix) : r;
#else
    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
    /// <param name="number">The number to clip.</param>
    /// <param name="min">If specified, the smallest number to return.</param>
    /// <param name="max">If specified, the greatest number to return.</param>
    /// <returns>
    /// The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
    /// otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
    /// <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int Clamp(this int number, int? min = null, int? max = null) =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;
    /// <inheritdoc cref="Clamp(int, int?, int?)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static float Clamp(this float number, float? min = null, float? max = null) =>
        (min ?? number) is var small &&
        (max ?? number) is var big &&
        number <= small ? small :
        number >= big ? big : number;
    /// <summary>
    /// Calculates the least nonnegative remainder of <paramref name="number"/> <c>%</c> <paramref name="radix"/>.
    /// </summary>
    /// <remarks><para>
    /// Implementation based on <a href="https://doc.rust-lang.org/src/core/num/int_macros.rs.html#2190">
    /// Rust standard library (core)'s rem_euclid function
    /// </a>.
    /// </para></remarks>
    /// <param name="number">The number to calculate the remainder of.</param>
    /// <param name="radix">The radix to use.</param>
    /// <returns>The result of the Euclidean division algorithm.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int Mod(this int number, int radix) => number % radix is var r && r < 0 ? unchecked(r + radix) : r;
    /// <inheritdoc cref="Mod(int, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static float Mod(this float number, float radix) => number % radix is var r && r < 0 ? r + radix : r;
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Extension methods to count digits in numbers.</summary>
    /// <summary>Gets the amount of digits of the number.</summary>
    /// <param name="number">The number to count.</param>
    /// <returns>The amount of digits in the parameter <paramref name="number"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 3)]
    public static byte DigitCount(this byte number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            _ => 3,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 3)]
    public static byte DigitCount(this sbyte number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            _ => 3,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 5)]
    public static byte DigitCount(this ushort number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            < 1000 => 3,
            < 10000 => 4,
            _ => 5,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 5)]
    public static byte DigitCount(this short number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            < 1000 and > -1000 => 3,
            < 10000 and > -10000 => 4,
            _ => 5,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 10)]
    public static byte DigitCount(this uint number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            < 1000 => 3,
            < 10000 => 4,
            < 100000 => 5,
            < 1000000 => 6,
            < 10000000 => 7,
            < 100000000 => 8,
            < 1000000000 => 9,
            _ => 10,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 10)]
    public static byte DigitCount(this int number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            < 1000 and > -1000 => 3,
            < 10000 and > -10000 => 4,
            < 100000 and > -100000 => 5,
            < 1000000 and > -1000000 => 6,
            < 10000000 and > -10000000 => 7,
            < 100000000 and > -100000000 => 8,
            < 1000000000 and > -1000000000 => 9,
            _ => 10,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 20)]
    public static byte DigitCount(this ulong number) =>
        number switch
        {
            < 10 => 1,
            < 100 => 2,
            < 1000 => 3,
            < 10000 => 4,
            < 100000 => 5,
            < 1000000 => 6,
            < 10000000 => 7,
            < 100000000 => 8,
            < 1000000000 => 9,
            < 10000000000 => 10,
            < 100000000000 => 11,
            < 1000000000000 => 12,
            < 10000000000000 => 13,
            < 100000000000000 => 14,
            < 1000000000000000 => 15,
            < 10000000000000000 => 16,
            < 100000000000000000 => 17,
            < 1000000000000000000 => 18,
            < 10000000000000000000 => 19,
            _ => 20,
        };
    /// <inheritdoc cref="DigitCount(byte)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(1, 19)]
    public static byte DigitCount(this long number) =>
        number switch
        {
            < 10 and > -10 => 1,
            < 100 and > -100 => 2,
            < 1000 and > -1000 => 3,
            < 10000 and > -10000 => 4,
            < 100000 and > -100000 => 5,
            < 1000000 and > -1000000 => 6,
            < 10000000 and > -10000000 => 7,
            < 100000000 and > -100000000 => 8,
            < 1000000000 and > -1000000000 => 9,
            < 10000000000 and > -10000000000 => 10,
            < 100000000000 and > -100000000000 => 11,
            < 1000000000000 and > -1000000000000 => 12,
            < 10000000000000 and > -10000000000000 => 13,
            < 100000000000000 and > -100000000000000 => 14,
            < 1000000000000000 and > -1000000000000000 => 15,
            < 10000000000000000 and > -10000000000000000 => 16,
            < 100000000000000000 and > -100000000000000000 => 17,
            < 1000000000000000000 and > -1000000000000000000 => 18,
            _ => 19,
        };
// SPDX-License-Identifier: MPL-2.0
#if !NETFRAMEWORK || NET35_OR_GREATER
// ReSharper disable CheckNamespace RedundantNameQualifier
#if !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP3_0_OR_GREATER
#endif
/// <summary>Provides methods to do math on enums without overhead from boxing.</summary>
[UsedImplicitly]
    enum Unknowable;
    static readonly Dictionary<Type, IList> s_dictionary = [];
    /// <summary>Checks if the left-hand side implements the right-hand side.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="left"/> has the values
    /// of the parameter <paramref name="right"/>; otherwise, <see langword="false"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool Has<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() & right.AsInt()) == right.AsInt();
#else
        left.Op(right, static (x, y) => (x & y) == y);
#endif
    /// <summary>Performs a conversion operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The <see cref="int"/> cast of <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int AsInt<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (typeof(T) == typeof(Enum) ? value.GetType() : typeof(T)).GetEnumUnderlyingType() switch
        {
            var x when x == typeof(byte) => (byte)(object)value,
            var x when x == typeof(sbyte) => (sbyte)(object)value,
            var x when x == typeof(short) => (short)(object)value,
            var x when x == typeof(ushort) => (ushort)(object)value,
            var x when x == typeof(int) => (int)(object)value,
            var x when x == typeof(uint) => (int)(uint)(object)value,
            var x when x == typeof(long) => (int)(long)(object)value,
            var x when x == typeof(ulong) => (int)(ulong)(object)value,
            var x when x == typeof(nint) => (int)(nint)(object)value,
            var x when x == typeof(nuint) => (int)(nuint)(object)value,
            _ => throw Unreachable,
        };
#else
        typeof(T) == typeof(Enum)
            ? GetUnderlyingType(value.GetType()) switch
            {
                var x when x == typeof(byte) => (byte)(object)value,
                var x when x == typeof(sbyte) => (sbyte)(object)value,
                var x when x == typeof(short) => (short)(object)value,
                var x when x == typeof(ushort) => (ushort)(object)value,
                var x when x == typeof(int) => (int)(object)value,
                var x when x == typeof(uint) => (int)(uint)(object)value,
                var x when x == typeof(long) => (int)(long)(object)value,
                var x when x == typeof(ulong) => (int)(ulong)(object)value,
                var x when x == typeof(nint) => (int)(nint)(object)value,
                var x when x == typeof(nuint) => (int)(nuint)(object)value,
                _ => throw new NotSupportedException(),
            }
            : MathCaching<T>.From(value);
#endif
    /// <summary>Gets the values of an enum cached and strongly-typed.</summary>
    /// <typeparam name="T">The type of enum to get the values from.</typeparam>
    /// <returns>All values in the type parameter <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static IList<T> GetValues<T>()
        where T : Enum =>
        s_dictionary.TryGetValue(typeof(T), out var list)
            ? (IList<T>)list
            : (IList<T>)(s_dictionary[typeof(T)] = typeof(T) == typeof(Enum)
                ? []
                : (T[])Enum.GetValues(typeof(T)));
    /// <summary>Performs a conversion operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The <typeparamref name="T"/> cast of <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T As<T>(this int value)
        where T : Enum =>
        typeof(T) == typeof(Enum)
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
            ? (T)(Enum)(Unknowable)value
            : typeof(T).GetEnumUnderlyingType() switch
            {
                var x when x == typeof(byte) => (T)(object)(byte)value,
                var x when x == typeof(sbyte) => (T)(object)(sbyte)value,
                var x when x == typeof(short) => (T)(object)(short)value,
                var x when x == typeof(ushort) => (T)(object)(ushort)value,
                var x when x == typeof(int) => (T)(object)value,
                var x when x == typeof(uint) => (T)(object)(uint)value,
                var x when x == typeof(long) => (T)(object)(long)value,
                var x when x == typeof(ulong) => (T)(object)(ulong)value,
                var x when x == typeof(nint) => (T)(object)(nint)value,
                var x when x == typeof(nuint) => (T)(object)(nuint)value,
                _ => throw Unreachable,
            };
#else
            ? (T)(Enum)MathCaching<Unknowable>.To(value)
            : MathCaching<T>.To(value);
#endif
    /// <summary>Performs a negation operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Negate<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (-value.AsInt()).As<T>();
#else
        value.Op(static x => unchecked(-x));
#endif
    /// <summary>Performs an decrement operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately before it.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Predecessor<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (value.AsInt() - 1).As<T>();
#else
        value.Op(static x => unchecked(x - 1));
#endif
    /// <summary>Performs a increment operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately after it.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Successor<T>(this T value)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (value.AsInt() + 1).As<T>();
#else
        value.Op(static x => unchecked(x + 1));
#endif
    /// <summary>Performs an addition operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The sum of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Add<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() + right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => unchecked(x + y));
#endif
    /// <summary>Performs a subtraction operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The difference of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Subtract<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() - right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => unchecked(x - y));
#endif
    /// <summary>Performs a multiplication operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The product of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Multiply<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() * right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => unchecked(x * y));
#endif
    /// <summary>Performs a division operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The quotient of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Divide<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() / right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => x / y);
#endif
    /// <summary>Performs a modulo operation.</summary>
    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="left">The left-hand side.</param>
    /// <param name="right">The right-hand side.</param>
    /// <returns>The remainder of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Modulo<T>(this T left, T right)
        where T : Enum =>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        (left.AsInt() % right.AsInt()).As<T>();
#else
        left.Op(right, static (x, y) => x % y);
#endif
    /// <summary>Computes the product of a sequence of <typeparamref name="T"/> values.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="source">A sequence of <typeparamref name="T"/> values to calculate the product of.</param>
    /// <returns>The product of the values in the sequence.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Product<T>(this IEnumerable<T> source)
        where T : Enum =>
        source.Aggregate(Multiply);
    /// <summary>Computes the sum of a sequence of <typeparamref name="T"/> values.</summary>
    /// <typeparam name="T">The type of sequence.</typeparam>
    /// <param name="source">A sequence of <typeparamref name="T"/> values to calculate the sum of.</param>
    /// <returns>The sum of the values in the sequence.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Sum<T>(this IEnumerable<T> source)
        where T :
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_0_OR_GREATER
        unmanaged,
#endif
        Enum
#if NET5_0_OR_GREATER
        =>
            source.TryGetSpan(out var span) ? span.Sum() : source.Aggregate(Add);
#else
        =>
            source.Aggregate(Add);
#endif
#if !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP3_0_OR_GREATER
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T Op<T>(this T value, [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int> op)
        where T : Enum =>
        op(value.AsInt()).As<T>();
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static T Op<T>(this T left, T right, [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int, int> op)
        where T : Enum =>
        op(left.AsInt(), right.AsInt()).As<T>();
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    static TResult Op<T, TResult>(
        this T left,
        T right,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int, TResult> op
    )
        where T : Enum =>
        op(left.AsInt(), right.AsInt());
    static class MathCaching<T>
        where T : Enum
    {
        public static Converter<T, int> From { [Pure] get; } = Make<Converter<T, int>>(false);
        public static Converter<int, T> To { [Pure] get; } = Make<Converter<int, T>>(true);
        [MustUseReturnValue]
        static TFunc Make<TFunc>(bool isReverse)
            where TFunc : Delegate
        {
            var parameter = Parameter(isReverse ? typeof(int) : typeof(T), nameof(T));
            var underlying = GetUnderlyingType(typeof(T));
            Expression cast = isReverse ? parameter : Convert(parameter, underlying);
            cast = underlying != typeof(int) ? Convert(parameter, isReverse ? underlying : typeof(int)) : cast;
            cast = isReverse ? Convert(cast, typeof(T)) : cast;
            return Lambda<TFunc>(cast, parameter).Compile();
        }
    }
#endif
#endif
// SPDX-License-Identifier: MPL-2.0
#if NET7_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <summary>Extension methods for <see cref="INumber{TSelf}"/>.</summary>
    /// <inheritdoc cref="INumberBase{TSelf}.IsCanonical"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsCanonical<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsCanonical(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsComplexNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsComplexNumber<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsComplexNumber(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsEvenInteger"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsEvenInteger<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsEvenInteger(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsFinite"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsFinite<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsFinite(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsImaginaryNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsImaginaryNumber<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsImaginaryNumber(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsInfinity"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsInfinity<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsInfinity(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsInteger"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsInteger<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsInteger(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsNaN"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsNaN<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsNaN(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsNegative"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsNegative<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsNegative(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsNegativeInfinity"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsNegativeInfinity<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsNegativeInfinity(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsNormal"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsNormal<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsNormal(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsOddInteger"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsOddInteger<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsOddInteger(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsPositive"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPositive<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsPositive(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsPositiveInfinity"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsPositiveInfinity<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsPositiveInfinity(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsRealNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsRealNumber<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsRealNumber(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsSubnormal"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsSubnormal<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsSubnormal(value);
    /// <inheritdoc cref="INumberBase{TSelf}.IsZero"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsZero<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.IsZero(value);
    /// <inheritdoc cref="INumber{TSelf}.Sign"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static int Sign<TSelf>(this TSelf value)
        where TSelf : INumber<TSelf> =>
        TSelf.Sign(value);
    /// <inheritdoc cref="INumberBase{TSelf}.Abs"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf Abs<TSelf>(this TSelf value)
        where TSelf : INumberBase<TSelf> =>
        TSelf.Abs(value);
    /// <inheritdoc cref="INumber{TSelf}.Clamp"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf Clamp<TSelf>(this TSelf value, TSelf min, TSelf max)
        where TSelf : INumber<TSelf> =>
        TSelf.Clamp(value, min, max);
    /// <inheritdoc cref="INumberBase{TSelf}.Abs"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf CopySign<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumber<TSelf> =>
        TSelf.CopySign(value, sign);
#if NET9_0_OR_GREATER
    /// <inheritdoc cref="INumberBase{TSelf}.MultiplyAddEstimate"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MultiplyAddEstimate<TSelf>(this TSelf left, TSelf right, TSelf addend)
        where TSelf : INumberBase<TSelf> =>
        TSelf.MultiplyAddEstimate(left, right, addend);
#endif
    /// <inheritdoc cref="INumber{TSelf}.Min"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf Min<TSelf>(this TSelf x, TSelf y)
        where TSelf : INumber<TSelf> =>
        TSelf.Min(x, y);
    /// <inheritdoc cref="INumberBase{TSelf}.MinMagnitude"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MinMagnitude<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumberBase<TSelf> =>
        TSelf.MinMagnitude(value, sign);
    /// <inheritdoc cref="INumberBase{TSelf}.MinMagnitudeNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MinMagnitudeNumber<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumberBase<TSelf> =>
        TSelf.MinMagnitudeNumber(value, sign);
    /// <inheritdoc cref="INumber{TSelf}.MinNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MinNumber<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumber<TSelf> =>
        TSelf.MinNumber(value, sign);
    /// <inheritdoc cref="INumber{TSelf}.Max"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf Max<TSelf>(this TSelf x, TSelf y)
        where TSelf : INumber<TSelf> =>
        TSelf.Max(x, y);
    /// <inheritdoc cref="INumberBase{TSelf}.MaxMagnitude"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MaxMagnitude<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumberBase<TSelf> =>
        TSelf.MaxMagnitude(value, sign);
    /// <inheritdoc cref="INumberBase{TSelf}.MaxMagnitudeNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MaxMagnitudeNumber<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumberBase<TSelf> =>
        TSelf.MaxMagnitudeNumber(value, sign);
    /// <inheritdoc cref="INumber{TSelf}.MaxNumber"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TSelf MaxNumber<TSelf>(this TSelf value, TSelf sign)
        where TSelf : INumber<TSelf> =>
        TSelf.MaxNumber(value, sign);
    /// <inheritdoc cref="INumberBase{TSelf}.CreateChecked{TOther}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TOther CreateChecked<TSelf, TOther>(this TSelf value)
        where TSelf : INumberBase<TSelf>
        where TOther : INumberBase<TOther> =>
        TOther.CreateChecked(value);
    /// <inheritdoc cref="INumberBase{TSelf}.CreateSaturating{TOther}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TOther CreateSaturating<TSelf, TOther>(this TSelf value)
        where TSelf : INumberBase<TSelf>
        where TOther : INumberBase<TOther> =>
        TOther.CreateSaturating(value);
    /// <inheritdoc cref="INumberBase{TSelf}.CreateTruncating{TOther}"/>
    [Inline, MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static TOther CreateTruncating<TSelf, TOther>(this TSelf value)
        where TSelf : INumberBase<TSelf>
        where TOther : INumberBase<TOther> =>
        TOther.CreateTruncating(value);
#endif
// SPDX-License-Identifier: MPL-2.0
#if NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP
// ReSharper disable RedundantUsingDirective
// ReSharper disable CheckNamespace NullableWarningSuppressionIsUsed RedundantSuppressNullableWarningExpression
// ReSharper disable once RedundantNameQualifier
/// <summary>Methods that provide access to generic operators, for frameworks that do not support it.</summary>
    /// <summary>Increments the value.</summary>
    /// <typeparam name="T">The type of value to increment.</typeparam>
    /// <param name="t">The value to increment.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Increment<T>(ref T t)
    {
        if (typeof(T) == typeof(byte))
            Unsafe.As<T, byte>(ref t)++;
        else if (typeof(T) == typeof(double))
            Unsafe.As<T, double>(ref t)++;
        else if (typeof(T) == typeof(float))
            Unsafe.As<T, float>(ref t)++;
        else if (typeof(T) == typeof(int))
            Unsafe.As<T, int>(ref t)++;
        else if (typeof(T) == typeof(nint))
            Unsafe.As<T, nint>(ref t)++;
        else if (typeof(T) == typeof(nuint))
            Unsafe.As<T, nuint>(ref t)++;
        else if (typeof(T) == typeof(sbyte))
            Unsafe.As<T, sbyte>(ref t)++;
        else if (typeof(T) == typeof(short))
            Unsafe.As<T, short>(ref t)++;
        else if (typeof(T) == typeof(uint))
            Unsafe.As<T, uint>(ref t)++;
        else if (typeof(T) == typeof(ulong))
            Unsafe.As<T, ulong>(ref t)++;
        else if (typeof(T) == typeof(ushort))
            Unsafe.As<T, ushort>(ref t)++;
        else if (DirectOperators<T>.IsSupported)
            t = DirectOperators<T>.Increment(t);
        else
            Fail<T>();
    }
    /// <summary>Determines whether the current type <typeparamref name="T"/> is supported.</summary>
    /// <typeparam name="T">The type to check.</typeparam>
    /// <returns>Whether the current type <typeparamref name="T"/> is supported.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool IsSupported<T>() => DirectOperators<T>.IsSupported;
    /// <summary>Performs an addition operation to return the sum.</summary>
    /// <typeparam name="T">The type of value to add.</typeparam>
    /// <param name="l">The left-hand side.</param>
    /// <param name="r">The right-hand side.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The sum of the parameters <paramref name="l"/> and <paramref name="r"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Adder<T>(T l, T r) =>
        0 switch
        {
            _ when typeof(T) == typeof(byte) => (T)(object)(byte)((byte)(object)l! + (byte)(object)r!),
            _ when typeof(T) == typeof(double) => (T)(object)((double)(object)l! + (double)(object)r!),
            _ when typeof(T) == typeof(float) => (T)(object)((float)(object)l! + (float)(object)r!),
            _ when typeof(T) == typeof(int) => (T)(object)((int)(object)l! + (int)(object)r!),
            _ when typeof(T) == typeof(nint) => (T)(object)((nint)(object)l! + (nint)(object)r!),
            _ when typeof(T) == typeof(nuint) => (T)(object)((nuint)(object)l! + (nuint)(object)r!),
            _ when typeof(T) == typeof(sbyte) => (T)(object)(sbyte)((sbyte)(object)l! + (sbyte)(object)r!),
            _ when typeof(T) == typeof(short) => (T)(object)(short)((short)(object)l! + (short)(object)r!),
            _ when typeof(T) == typeof(uint) => (T)(object)((uint)(object)l! + (uint)(object)r!),
            _ when typeof(T) == typeof(ulong) => (T)(object)((ulong)(object)l! + (ulong)(object)r!),
            _ when typeof(T) == typeof(ushort) => (T)(object)(ushort)((ushort)(object)l! + (ushort)(object)r!),
            _ when DirectOperators<T>.IsSupported => DirectOperators<T>.Adder(l, r),
            _ => Fail<T>(),
        };
    /// <summary>Performs a dividing operation to return the quotient.</summary>
    /// <typeparam name="T">The type of value to divide.</typeparam>
    /// <param name="l">The left-hand side.</param>
    /// <param name="r">The right-hand side.</param>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>The quotient of the parameters <paramref name="l"/> and <paramref name="r"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T Divider<T>(T l, int r) =>
        0 switch
        {
            _ when typeof(T) == typeof(byte) => (T)(object)(byte)((byte)(object)l! / r),
            _ when typeof(T) == typeof(double) => (T)(object)((double)(object)l! / r),
            _ when typeof(T) == typeof(float) => (T)(object)((float)(object)l! / r),
            _ when typeof(T) == typeof(int) => (T)(object)((int)(object)l! / r),
            _ when typeof(T) == typeof(nint) => (T)(object)((nint)(object)l! / r),
            _ when typeof(T) == typeof(nuint) => (T)(object)((nuint)(object)l! / (nuint)r),
            _ when typeof(T) == typeof(sbyte) => (T)(object)(sbyte)((sbyte)(object)l! / r),
            _ when typeof(T) == typeof(short) => (T)(object)(short)((short)(object)l! / r),
            _ when typeof(T) == typeof(uint) => (T)(object)((uint)(object)l! / r),
            _ when typeof(T) == typeof(ulong) => (T)(object)((ulong)(object)l! / (ulong)r),
            _ when typeof(T) == typeof(ushort) => (T)(object)(ushort)((ushort)(object)l! / r),
            _ when DirectOperators<T>.IsSupported => DirectOperators<T>.Divider(l, r),
            _ => Fail<T>(),
        };
    /// <summary>Gets the maximum value.</summary>
    /// <typeparam name="T">The type of value to get the maximum value of.</typeparam>
    /// <returns>The maximum value of <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T MaxValue<T>() => DirectOperators<T>.MaxValue;
    /// <summary>Gets the minimum value.</summary>
    /// <typeparam name="T">The type of value to get the minimum value of.</typeparam>
    /// <returns>The minimum value of <typeparamref name="T"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T MinValue<T>() => DirectOperators<T>.MinValue;
    /// <summary>Throws the exception used by <see cref="OperatorCaching"/> to propagate errors.</summary>
    /// <typeparam name="T">The type that failed.</typeparam>
    /// <exception cref="MissingMethodException">The type <typeparamref name="T"/> is unsupported.</exception>
    /// <returns>This method does not return.</returns>
    [DoesNotReturn, MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Fail<T>() =>
        throw new MissingMethodException(typeof(T).UnfoldedFullName(), "op_Addition/op_Division/op_Increment");
    /// <summary>Caches operators.</summary>
    /// <typeparam name="T">The containing member of operators.</typeparam>
    public sealed partial class DirectOperators<T>
    {
        const BindingFlags Flags = BindingFlags.Public | BindingFlags.Static;
        static readonly Type[]
            s_binary = [typeof(T), typeof(T)],
            s_unary = [typeof(T)];
        static DirectOperators()
        {
            try
            {
                Increment = Make("op_Increment", Expression.Increment);
                Adder = Make<T>("op_Addition", Expression.AddChecked);
                Divider = Make<int>("op_Division", (x, y) => Expression.Divide(x, Expression.Convert(y, typeof(T))));
            }
            catch (InvalidOperationException)
            {
                IsSupported = false;
            }
        }
        /// <summary>
        /// Gets a value indicating whether the functions can be used.
        /// <see cref="MinValue"/> can be used regardless of its output.
        /// </summary>
        [CLSCompliant(false)]
#pragma warning disable RCS1158
        public static bool IsSupported
#pragma warning restore RCS1158
        {
            [MemberNotNullWhen(true, nameof(Adder), nameof(Divider), nameof(Increment)),
             MethodImpl(MethodImplOptions.AggressiveInlining),
             Pure]
            get;
        } = true;
        /// <summary>Gets the minimum value.</summary>
        public static T MaxValue { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            (typeof(T).IsEnum ? typeof(T).GetEnumUnderlyingType() : typeof(T)) switch
            {
                var x when x == typeof(byte) => (T)(object)byte.MaxValue,
                var x when x == typeof(double) => (T)(object)double.MaxValue,
                var x when x == typeof(float) => (T)(object)float.MaxValue,
                var x when x == typeof(int) => (T)(object)int.MaxValue,
#if NET5_0_OR_GREATER
                var x when x == typeof(nint) => (T)(object)nint.MaxValue,
                var x when x == typeof(nuint) => (T)(object)nuint.MaxValue,
#endif
                var x when x == typeof(sbyte) => (T)(object)sbyte.MaxValue,
                var x when x == typeof(short) => (T)(object)short.MaxValue,
                var x when x == typeof(uint) => (T)(object)uint.MaxValue,
                var x when x == typeof(ulong) => (T)(object)ulong.MaxValue,
                var x when x == typeof(ushort) => (T)(object)ushort.MaxValue,
                _ => typeof(T).GetField(nameof(MaxValue), Flags)?.GetValue(null) is T t ? t : default!,
            };
        /// <summary>Gets the minimum value.</summary>
        public static T MinValue { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            (typeof(T).IsEnum ? typeof(T).GetEnumUnderlyingType() : typeof(T)) switch
            {
                var x when x == typeof(byte) => (T)(object)byte.MinValue,
                var x when x == typeof(double) => (T)(object)double.MinValue,
                var x when x == typeof(float) => (T)(object)float.MinValue,
                var x when x == typeof(int) => (T)(object)int.MinValue,
#if NET5_0_OR_GREATER
                var x when x == typeof(nint) => (T)(object)nint.MinValue,
                var x when x == typeof(nuint) => (T)(object)nuint.MinValue,
#endif
                var x when x == typeof(sbyte) => (T)(object)sbyte.MinValue,
                var x when x == typeof(short) => (T)(object)short.MinValue,
                var x when x == typeof(uint) => (T)(object)uint.MinValue,
                var x when x == typeof(ulong) => (T)(object)ulong.MinValue,
                var x when x == typeof(ushort) => (T)(object)ushort.MinValue,
                _ => typeof(T).GetField(nameof(MinValue), Flags)?.GetValue(null) is T t ? t : default!,
            };
        /// <summary>Gets the function for dividing.</summary>
        public static Converter<T?, T>? Increment { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
        /// <summary>Gets the function for adding.</summary>
        public static Func<T?, T?, T>? Adder { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
        /// <summary>Gets the function for dividing.</summary>
        public static Func<T?, int, T>? Divider { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
        [Pure]
        static Converter<T?, T> Make(string name, [InstantHandle] Func<Expression, UnaryExpression> go) =>
            typeof(T).GetMethod(name, Flags, null, s_unary, null) is not { } method &&
            Expression.Parameter(typeof(T), "unit") is var unit
                ? Expression.Lambda<Converter<T?, T>>(go(unit), unit).Compile()
                : (Converter<T?, T>)Delegate.CreateDelegate(typeof(Converter<T?, T>), method);
        [Pure]
        static Func<T?, TRight?, T> Make<TRight>(
            string name,
            [InstantHandle] Func<Expression, Expression, BinaryExpression> go
        ) =>
            (typeof(T).GetMethod(name, Flags, null, s_binary, null) is not { } method ||
                (Func<T?, T?, T>)Delegate.CreateDelegate(typeof(Func<T?, T?, T>), method) is not { } func) &&
            Expression.Parameter(typeof(T), "left") is var left &&
            Expression.Parameter(typeof(TRight), "right") is var right
                ? Expression.Lambda<Func<T?, TRight?, T>>(go(left, right), left, right).Compile()
                : (x, y) => func(x, (T?)(object?)y);
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable SA1003, SA1114
// ReSharper disable BadParensLineBreaks BadPreprocessorIndent
// ReSharper disable once CheckNamespace
/// <summary>Provides prime numbers.</summary>
public static class Primes
{
    /// <summary>The smallest prime number.</summary>
    public const short Min = 2;
    /// <summary>The largest prime number for signed 16-bit numbers.</summary>
    public const short MaxInt16 = 32749;
    /// <summary>Gets all <see langword="short"/> prime numbers.</summary>
    public static
#if NETCOREAPP || ROSLYN
        ImmutableArray
#else
        ReadOnlyCollection
#endif
        <short> Int16 { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
#if NETCOREAPP || ROSLYN
        ImmutableCollectionsMarshal.AsImmutableArray<short>(
#else
        Array.AsReadOnly<short>(
#endif
            [
                2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,
                103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,
                223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337,
                347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,
                463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,
                607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
                743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881,
                883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,
                1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129,
                1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277,
                1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409,
                1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,
                1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621,
                1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759,
                1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901,
                1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029,
                2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153,
                2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297,
                2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417,
                2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579,
                2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699,
                2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819,
                2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963,
                2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119,
                3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259,
                3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391,
                3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539,
                3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671,
                3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803,
                3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931,
                3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091,
                4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231,
                4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373,
                4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519,
                4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663,
                4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813,
                4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969,
                4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101,
                5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273,
                5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419,
                5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557,
                5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693,
                5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843,
                5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007,
                6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143,
                6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287,
                6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421,
                6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581,
                6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737,
                6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883,
                6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019,
                7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207,
                7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351,
                7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529,
                7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649,
                7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817,
                7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951,
                7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123,
                8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287,
                8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443,
                8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623,
                8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741,
                8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887,
                8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043,
                9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203,
                9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349,
                9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479,
                9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649,
                9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803,
                9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941,
                9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103,
                10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247,
                10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357,
                10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513,
                10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663,
                10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831,
                10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957,
                10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113,
                11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257,
                11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399,
                11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549,
                11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717,
                11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839,
                11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971,
                11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113,
                12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263,
                12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409,
                12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527,
                12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647,
                12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799,
                12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941,
                12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063,
                13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217,
                13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367,
                13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513,
                13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681,
                13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789,
                13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921,
                13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083,
                14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249, 14251, 14281,
                14293, 14303, 14321, 14323, 14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423,
                14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551, 14557,
                14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 14713,
                14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821,
                14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 14951,
                14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 15077, 15083, 15091, 15101, 15107, 15121,
                15131, 15137, 15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263,
                15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349, 15359, 15361, 15373,
                15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 15511,
                15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649,
                15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 15787,
                15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919,
                15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 16073,
                16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187, 16189, 16193, 16217, 16223, 16229,
                16231, 16249, 16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411,
                16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529, 16547, 16553,
                16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 16693,
                16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879,
                16883, 16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 17011,
                17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159,
                17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321,
                17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401, 17417, 17419, 17431, 17443,
                17449, 17467, 17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579,
                17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729, 17737,
                17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 17903,
                17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041,
                18043, 18047, 18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 18149,
                18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 18251, 18253, 18257, 18269, 18287, 18289,
                18301, 18307, 18311, 18313, 18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433,
                18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539, 18541, 18553, 18583,
                18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 18757,
                18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959,
                18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 19139,
                19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273,
                19289, 19301, 19309, 19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 19427,
                19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483, 19489, 19501, 19507, 19531, 19541,
                19543, 19553, 19559, 19571, 19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709,
                19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841, 19843, 19853,
                19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 19993,
                19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123,
                20129, 20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 20269,
                20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 20359, 20369, 20389, 20393, 20399, 20407,
                20411, 20431, 20441, 20443, 20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563,
                20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717, 20719, 20731, 20743, 20747,
                20749, 20753, 20759, 20771, 20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899,
                20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019, 21023,
                21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 21179,
                21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341,
                21347, 21377, 21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 21493,
                21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 21569, 21577, 21587, 21589, 21599, 21601,
                21611, 21613, 21617, 21647, 21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757,
                21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863, 21871, 21881, 21893,
                21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 22051,
                22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159,
                22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307, 22343,
                22349, 22367, 22369, 22381, 22391, 22397, 22409, 22433, 22441, 22447, 22453, 22469, 22481, 22483, 22501,
                22511, 22531, 22541, 22543, 22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643, 22651,
                22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 22739, 22741, 22751, 22769, 22777, 22783,
                22787, 22807, 22811, 22817, 22853, 22859, 22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 22961,
                22963, 22973, 22993, 23003, 23011, 23017, 23021, 23027, 23029, 23039, 23041, 23053, 23057, 23059, 23063,
                23071, 23081, 23087, 23099, 23117, 23131, 23143, 23159, 23167, 23173, 23189, 23197, 23201, 23203, 23209,
                23227, 23251, 23269, 23279, 23291, 23293, 23297, 23311, 23321, 23327, 23333, 23339, 23357, 23369, 23371,
                23399, 23417, 23431, 23447, 23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549, 23557, 23561, 23563,
                23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627, 23629, 23633, 23663, 23669, 23671, 23677, 23687,
                23689, 23719, 23741, 23743, 23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 23831,
                23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 23911, 23917, 23929, 23957, 23971, 23977,
                23981, 23993, 24001, 24007, 24019, 24023, 24029, 24043, 24049, 24061, 24071, 24077, 24083, 24091, 24097,
                24103, 24107, 24109, 24113, 24121, 24133, 24137, 24151, 24169, 24179, 24181, 24197, 24203, 24223, 24229,
                24239, 24247, 24251, 24281, 24317, 24329, 24337, 24359, 24371, 24373, 24379, 24391, 24407, 24413, 24419,
                24421, 24439, 24443, 24469, 24473, 24481, 24499, 24509, 24517, 24527, 24533, 24547, 24551, 24571, 24593,
                24611, 24623, 24631, 24659, 24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763, 24767, 24781,
                24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877, 24889, 24907, 24917, 24919, 24923, 24943,
                24953, 24967, 24971, 24977, 24979, 24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 25111,
                25117, 25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 25189, 25219, 25229, 25237, 25243, 25247,
                25253, 25261, 25301, 25303, 25307, 25309, 25321, 25339, 25343, 25349, 25357, 25367, 25373, 25391, 25409,
                25411, 25423, 25439, 25447, 25453, 25457, 25463, 25469, 25471, 25523, 25537, 25541, 25561, 25577, 25579,
                25583, 25589, 25601, 25603, 25609, 25621, 25633, 25639, 25643, 25657, 25667, 25673, 25679, 25693, 25703,
                25717, 25733, 25741, 25747, 25759, 25763, 25771, 25793, 25799, 25801, 25819, 25841, 25847, 25849, 25867,
                25873, 25889, 25903, 25913, 25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999, 26003,
                26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 26113, 26119, 26141, 26153, 26161, 26171,
                26177, 26183, 26189, 26203, 26209, 26227, 26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 26309,
                26317, 26321, 26339, 26347, 26357, 26371, 26387, 26393, 26399, 26407, 26417, 26423, 26431, 26437, 26449,
                26459, 26479, 26489, 26497, 26501, 26513, 26539, 26557, 26561, 26573, 26591, 26597, 26627, 26633, 26641,
                26647, 26669, 26681, 26683, 26687, 26693, 26699, 26701, 26711, 26713, 26717, 26723, 26729, 26731, 26737,
                26759, 26777, 26783, 26801, 26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879, 26881, 26891, 26893,
                26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981, 26987, 26993, 27011, 27017, 27031, 27043, 27059,
                27061, 27067, 27073, 27077, 27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 27239,
                27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 27337, 27361, 27367, 27397, 27407, 27409,
                27427, 27431, 27437, 27449, 27457, 27479, 27481, 27487, 27509, 27527, 27529, 27539, 27541, 27551, 27581,
                27583, 27611, 27617, 27631, 27647, 27653, 27673, 27689, 27691, 27697, 27701, 27733, 27737, 27739, 27743,
                27749, 27751, 27763, 27767, 27773, 27779, 27791, 27793, 27799, 27803, 27809, 27817, 27823, 27827, 27847,
                27851, 27883, 27893, 27901, 27917, 27919, 27941, 27943, 27947, 27953, 27961, 27967, 27983, 27997, 28001,
                28019, 28027, 28031, 28051, 28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123, 28151, 28163,
                28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283, 28289, 28297, 28307, 28309, 28319, 28349,
                28351, 28387, 28393, 28403, 28409, 28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 28513,
                28517, 28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 28591, 28597, 28603, 28607, 28619, 28621,
                28627, 28631, 28643, 28649, 28657, 28661, 28663, 28669, 28687, 28697, 28703, 28711, 28723, 28729, 28751,
                28753, 28759, 28771, 28789, 28793, 28807, 28813, 28817, 28837, 28843, 28859, 28867, 28871, 28879, 28901,
                28909, 28921, 28927, 28933, 28949, 28961, 28979, 29009, 29017, 29021, 29023, 29027, 29033, 29059, 29063,
                29077, 29101, 29123, 29129, 29131, 29137, 29147, 29153, 29167, 29173, 29179, 29191, 29201, 29207, 29209,
                29221, 29231, 29243, 29251, 29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363, 29383,
                29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 29453, 29473, 29483, 29501, 29527, 29531,
                29537, 29567, 29569, 29573, 29581, 29587, 29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 29683,
                29717, 29723, 29741, 29753, 29759, 29761, 29789, 29803, 29819, 29833, 29837, 29851, 29863, 29867, 29873,
                29879, 29881, 29917, 29921, 29927, 29947, 29959, 29983, 29989, 30011, 30013, 30029, 30047, 30059, 30071,
                30089, 30091, 30097, 30103, 30109, 30113, 30119, 30133, 30137, 30139, 30161, 30169, 30181, 30187, 30197,
                30203, 30211, 30223, 30241, 30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319, 30323, 30341, 30347,
                30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467, 30469, 30491, 30493, 30497, 30509, 30517, 30529,
                30539, 30553, 30557, 30559, 30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 30697,
                30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 30809, 30817, 30829, 30839, 30841, 30851,
                30853, 30859, 30869, 30871, 30881, 30893, 30911, 30931, 30937, 30941, 30949, 30971, 30977, 30983, 31013,
                31019, 31033, 31039, 31051, 31063, 31069, 31079, 31081, 31091, 31121, 31123, 31139, 31147, 31151, 31153,
                31159, 31177, 31181, 31183, 31189, 31193, 31219, 31223, 31231, 31237, 31247, 31249, 31253, 31259, 31267,
                31271, 31277, 31307, 31319, 31321, 31327, 31333, 31337, 31357, 31379, 31387, 31391, 31393, 31397, 31469,
                31477, 31481, 31489, 31511, 31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583, 31601, 31607,
                31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721, 31723, 31727, 31729, 31741, 31751, 31769,
                31771, 31793, 31799, 31817, 31847, 31849, 31859, 31873, 31883, 31891, 31907, 31957, 31963, 31973, 31981,
                31991, 32003, 32009, 32027, 32029, 32051, 32057, 32059, 32063, 32069, 32077, 32083, 32089, 32099, 32117,
                32119, 32141, 32143, 32159, 32173, 32183, 32189, 32191, 32203, 32213, 32233, 32237, 32251, 32257, 32261,
                32297, 32299, 32303, 32309, 32321, 32323, 32327, 32341, 32353, 32359, 32363, 32369, 32371, 32377, 32381,
                32401, 32411, 32413, 32423, 32429, 32441, 32443, 32467, 32479, 32491, 32497, 32503, 32507, 32531, 32533,
                32537, 32561, 32563, 32569, 32573, 32579, 32587, 32603, 32609, 32611, 32621, 32633, 32647, 32653, 32687,
                32693, 32707, 32713, 32717, 32719, 32749,
            ]
        );
    /// <summary>Performs the index operation.</summary>
    /// <param name="index"></param>
    /// <returns></returns>
    [Pure, ValueRange(Min, MaxInt16)]
    public static short Index(int index) =>
#if NETCOREAPP || ROSLYN
        Int16[index.Mod(Int16.Length)];
#else
        Int16[index.Mod(Int16.Count)];
#endif
    [Pure, ValueRange(Min, MaxInt16)]
    internal static short Index(Index index) => Index(index.IsFromEnd ? -index.Value - 1 : index.Value);
}
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Extension methods to generate random numbers.</summary>
    /// <summary>Generates a random value of type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of the random value.</typeparam>
    /// <param name="random">The random number generator.</param>
    /// <returns>The random value.</returns>
    public static unsafe T Next<T>(this Func<int, int, int> random)
        where T : unmanaged
    {
        T output = default;
        if (sizeof(T) >= sizeof(int))
            for (var i = 0; i < sizeof(T) / sizeof(int); i++)
                *((int*)&output + i) = random(int.MinValue, int.MaxValue);
        if (sizeof(T) % sizeof(int) is 2 or 3)
            *((ushort*)((byte*)&output + sizeof(T)) - 1) = (ushort)random(ushort.MinValue, ushort.MinValue);
        if (sizeof(T) % sizeof(int) is 1 or 3)
            *((byte*)&output + sizeof(T) - sizeof(T) % 4) = (byte)random(byte.MinValue, byte.MinValue);
        return output;
    }
    /// <summary>Generates a random value of type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of the random value.</typeparam>
    /// <param name="random">The random number generator.</param>
    /// <returns>The random value.</returns>
    public static T Next<T>(this Random random)
        where T : unmanaged
    {
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        T output = default;
        random.NextBytes(MemoryMarshal.Cast<T, byte>(Ref(ref output)));
        return output;
#else
        return Next<T>(random.Next);
#endif
    }
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace RedundantNameQualifier
/// <summary>Implements a <see cref="GetOffsetAndLength"/> overload that doesn't rely on tuples.</summary>
    /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
    /// <remarks><para>
    /// For performance reasons, we don't validate the input length parameter against negative values.
    /// It is expected Range will be used with collections which always have non negative length/count.
    /// We validate the range is inside the length scope though.
    /// </para></remarks>
    /// <param name="range">The <see cref="Range"/> that contains the range of elements.</param>
    /// <param name="length">
    /// The length of the collection that the range will be used with.
    /// <paramref name="length"/> has to be a positive value.
    /// </param>
    /// <param name="outOffset">The resulting offset.</param>
    /// <param name="outLength">The resulting length.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void GetOffsetAndLength(this Range range, int length, out int outOffset, out int outLength)
    {
        if (!TryGetOffsetAndLength(range, length, out outOffset, out outLength))
            throw new ArgumentOutOfRangeException(nameof(length));
    }
    /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
    /// <param name="range">The <see cref="Range"/> that contains the range of elements.</param>
    /// <param name="length">
    /// The length of the collection that the range will be used with.
    /// <paramref name="length"/> has to be a positive value.
    /// </param>
    /// <param name="outOffset">The resulting offset.</param>
    /// <param name="outLength">The resulting length.</param>
    /// <returns>Whether the values are set.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static bool TryGetOffsetAndLength(this Range range, int length, out int outOffset, out int outLength)
    {
        var startIndex = range.Start;
        var start = startIndex.IsFromEnd ? length - startIndex.Value : startIndex.Value;
        var endIndex = range.End;
        var end = endIndex.IsFromEnd ? length - endIndex.Value : endIndex.Value;
        outOffset = start;
        outLength = end - start;
        return unchecked((uint)end <= (uint)length && (uint)start <= (uint)end);
    }
// SPDX-License-Identifier: MPL-2.0
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
// ReSharper disable once CheckNamespace
/// <summary>Allows you to get an attribute on an enum field value.</summary>
    /// <summary>Gets the <typeparamref name="T"/> applied to the field of the enum.</summary>
    /// <typeparam name="T">The type of <see cref="Attribute"/> to get.</typeparam>
    /// <param name="value">The enum containing the <typeparamref name="T"/> instance in metadata.</param>
    /// <returns>
    /// The <typeparamref name="T"/> instance attached to the parameter <paramref name="value"/>'s field metadata.
    /// </returns>
    public static T? GetCustomAttribute<T>(this Enum value)
        where T : Attribute =>
        value.GetType().GetMember($"{value}", BindingFlags.Static | BindingFlags.Public)[0].GetCustomAttribute<T>();
#endif
// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
// ReSharper disable once CheckNamespace
/// <summary>Contains syntactic operations and registrations.</summary>
    /// <summary>Gets the fully qualified name for a given symbol.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance.</param>
    /// <returns>The fully qualified name for <paramref name="symbol"/>.</returns>
    public static string GetFullyQualifiedName(this ISymbol symbol) =>
        symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    /// <summary>Gets the fully qualified name for a given symbol, including nullability annotations.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance.</param>
    /// <returns>The fully qualified name for <paramref name="symbol"/>.</returns>
    public static string GetFullyQualifiedNameWithNullabilityAnnotations(this ISymbol symbol) =>
        symbol.ToDisplayString(
            SymbolDisplayFormat.FullyQualifiedFormat.AddMiscellaneousOptions(
                SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
            )
        );
    /// <summary>Checks whether or not a given type symbol has a specified full name.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="name">The full name to check.</param>
    /// <returns>Whether <paramref name="symbol"/> has a full name equals to <paramref name="name"/>.</returns>
    public static bool HasFullyQualifiedName(this ISymbol symbol, string name) =>
        symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == name;
    /// <summary>
    /// Checks whether or not a given symbol has an attribute with the specified fully qualified metadata name.
    /// </summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="name">The attribute name to look for.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified name.</returns>
    public static bool HasAttributeWithFullyQualifiedMetadataName(this ISymbol symbol, string name)
    {
        foreach (var attribute in symbol.GetAttributes())
            if (attribute.AttributeClass is { } named && named.HasFullyQualifiedMetadataName(name))
                return true;
        return false;
    }
    /// <summary>Checks whether or not a given symbol has an attribute with the specified type.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="typeSymbol">The <see cref="ITypeSymbol"/> instance for the attribute type to look for.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified type.</returns>
    public static bool HasAttributeWithType(this ISymbol symbol, ITypeSymbol typeSymbol) =>
        TryGetAttributeWithType(symbol, typeSymbol, out _);
    /// <summary>Tries to get an attribute with the specified type.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="typeSymbol">The <see cref="ITypeSymbol"/> instance for the attribute type to look for.</param>
    /// <param name="attributeData">The resulting attribute, if it was found.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified type.</returns>
    [Pure]
    public static bool TryGetAttributeWithType(
        this ISymbol symbol,
        ITypeSymbol typeSymbol,
        [NotNullWhen(true)] out AttributeData? attributeData
    )
    {
        foreach (var attribute in symbol.GetAttributes())
            if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, typeSymbol))
            {
                attributeData = attribute;
                return true;
            }
        attributeData = null;
        return false;
    }
    /// <summary>Checks whether or not a given type symbol has a specified fully qualified metadata name.</summary>
    /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance to check.</param>
    /// <param name="name">The full name to check.</param>
    /// <returns>Whether <paramref name="symbol"/> has a full name equals to <paramref name="name"/>.</returns>
    public static bool HasFullyQualifiedMetadataName(this ITypeSymbol symbol, string name)
    {
        var builder = ImmutableArrayBuilder<char>.Rent();
        try
        {
            symbol.AppendFullyQualifiedMetadataName(builder);
            return builder.WrittenSpan.SequenceEqual(name.AsSpan());
        }
        finally
        {
            builder.Dispose();
        }
    }
    /// <summary>Gets the fully qualified metadata name for a given <see cref="ITypeSymbol"/> instance.</summary>
    /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance.</param>
    /// <returns>The fully qualified metadata name for <paramref name="symbol"/>.</returns>
    [Pure]
    public static string GetFullyQualifiedMetadataName(this ITypeSymbol symbol)
    {
        var builder = ImmutableArrayBuilder<char>.Rent();
        try
        {
            symbol.AppendFullyQualifiedMetadataName(builder);
            return builder.ToString();
        }
        finally
        {
            builder.Dispose();
        }
    }
    /// <summary>Tries to get an attribute with the specified fully qualified metadata name.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="name">The attribute name to look for.</param>
    /// <param name="attributeData">The resulting attribute, if it was found.</param>
    /// <returns>Whether or not <paramref name="symbol"/> has an attribute with the specified name.</returns>
    [Pure]
    public static bool TryGetAttributeWithFullyQualifiedMetadataName(
        this ISymbol symbol,
        string name,
        [NotNullWhen(true)] out AttributeData? attributeData
    )
    {
        foreach (var attribute in symbol.GetAttributes())
            if (attribute.AttributeClass is { } named && named.HasFullyQualifiedMetadataName(name))
            {
                attributeData = attribute;
                return true;
            }
        attributeData = null;
        return false;
    }
    /// <summary>Calculates the effective accessibility for a given symbol.</summary>
    /// <param name="symbol">The <see cref="ISymbol"/> instance to check.</param>
    /// <returns>The effective accessibility for <paramref name="symbol"/>.</returns>
    [Pure]
    public static Accessibility GetEffectiveAccessibility(this ISymbol symbol)
    {
        var visibility = Accessibility.Public;
        switch (symbol.Kind)
        {
            case SymbolKind.Alias: return Accessibility.Private;
            case SymbolKind.Parameter: return GetEffectiveAccessibility(symbol.ContainingSymbol);
            case SymbolKind.TypeParameter: return Accessibility.Private;
        }
        while (symbol is not null && symbol.Kind != SymbolKind.Namespace)
        {
            switch (symbol.DeclaredAccessibility)
            {
                case Accessibility.NotApplicable or Accessibility.Private: return Accessibility.Private;
                case Accessibility.Internal or Accessibility.ProtectedAndInternal:
                    visibility = Accessibility.Internal;
                    break;
            }
            symbol = symbol.ContainingSymbol;
        }
        return visibility;
    }
    /// <summary>Checks whether or not a given symbol can be accessed from a specified assembly.</summary>
    /// <param name="symbol">The input <see cref="ISymbol"/> instance to check.</param>
    /// <param name="assembly">The assembly to check the accessibility of <paramref name="symbol"/> for.</param>
    /// <returns>Whether <paramref name="assembly"/> can access <paramref name="symbol"/>.</returns>
    [Pure]
    public static bool CanBeAccessedFrom(this ISymbol symbol, IAssemblySymbol assembly) =>
        symbol.GetEffectiveAccessibility() is var accessibility &&
        accessibility == Accessibility.Public ||
        accessibility == Accessibility.Internal && symbol.ContainingAssembly.GivesAccessTo(assembly);
    /// <summary>Negated <see cref="SyntaxValueProvider.ForAttributeWithMetadataName"/>.</summary>
    /// <inheritdoc cref="SyntaxValueProvider.ForAttributeWithMetadataName"/>
    [Pure]
    public static IncrementalValuesProvider<T> AgainstAttributeWithMetadataName<T>(
        this SyntaxValueProvider syntaxValueProvider,
        string fullyQualifiedMetadataName,
        [InstantHandle] Func<SyntaxNode, CancellationToken, bool> predicate,
        [InstantHandle] Func<SyntaxNode, ISymbol, SemanticModel, CancellationToken, T> transform
    )
    {
        (bool HasValue, T Value) Extract(GeneratorSyntaxContext context, CancellationToken token) =>
            context.SemanticModel.GetDeclaredSymbol(context.Node, token) is { } symbol &&
            !symbol.TryGetAttributeWithFullyQualifiedMetadataName(fullyQualifiedMetadataName, out _)
                ? (true, transform(context.Node, symbol, context.SemanticModel, token))
                : default;
        return syntaxValueProvider
           .CreateSyntaxProvider(predicate, Extract)
           .Where(static x => x.HasValue)
           .Select(static (item, _) => item.Value);
    }
    /// <summary>Filters an <see cref="IncrementalValuesProvider{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="provider">The <see cref="IncrementalValuesProvider{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IncrementalValuesProvider{T}"/> with strictly non-null values.</returns>
    [Pure]
    public static IncrementalValuesProvider<T> Filter<T>(this IncrementalValuesProvider<T?> provider) =>
#pragma warning disable 8619
        provider.Where(x => x is not null);
#pragma warning restore 8619
    /// <summary>Filters an <see cref="IncrementalValuesProvider{T}"/> to only non-null values.</summary>
    /// <typeparam name="T">The type of value to filter.</typeparam>
    /// <param name="provider">The <see cref="IncrementalValuesProvider{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IncrementalValuesProvider{T}"/> with strictly non-null values.</returns>
    [Pure]
    public static IncrementalValuesProvider<T> Filter<T>(this IncrementalValuesProvider<T?> provider)
        where T : struct =>
#pragma warning disable 8629
        provider.Where(x => x.HasValue).Select((x, _) => x.Value);
#pragma warning restore 8629
    /// <summary>Filters an <see cref="IncrementalValuesProvider{T}"/> to the specified destination type.</summary>
    /// <typeparam name="TFrom">The initial type.</typeparam>
    /// <typeparam name="TTo">The target type.</typeparam>
    /// <param name="provider">The <see cref="IncrementalValuesProvider{T}"/> to filter.</param>
    /// <returns>A filtered <see cref="IncrementalValuesProvider{T}"/> with <typeparamref name="TTo"/> values.</returns>
    [Pure]
    public static IncrementalValuesProvider<TTo> OfType<TFrom, TTo>(this IncrementalValuesProvider<TFrom?> provider)
        where TTo : TFrom =>
        provider.Where(static x => x is TTo).Select(static (x, _) => (TTo)x!);
    /// <summary>Appends the fully qualified metadata name for a given symbol to a target builder.</summary>
    /// <param name="symbol">The input <see cref="ITypeSymbol"/> instance.</param>
    /// <param name="builder">The target <see cref="ImmutableArrayBuilder{T}"/> instance.</param>
    static void AppendFullyQualifiedMetadataName(this ISymbol symbol, in ImmutableArrayBuilder<char> builder)
    {
        static void BuildFrom(ISymbol? symbol, in ImmutableArrayBuilder<char> builder)
        {
            switch (symbol)
            {
                case INamespaceSymbol { ContainingNamespace.IsGlobalNamespace: false }:
                    BuildFrom(symbol.ContainingNamespace, builder);
                    builder.Add('.');
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;
                case INamespaceSymbol { IsGlobalNamespace: false }:
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;
                case ITypeSymbol { ContainingSymbol: INamespaceSymbol { IsGlobalNamespace: true } }:
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;
                case ITypeSymbol { ContainingSymbol: INamespaceSymbol namespaceSymbol }:
                    BuildFrom(namespaceSymbol, builder);
                    builder.Add('.');
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;
                case ITypeSymbol { ContainingSymbol: ITypeSymbol typeSymbol }:
                    BuildFrom(typeSymbol, builder);
                    builder.Add('+');
                    builder.AddRange(symbol.MetadataName.AsSpan());
                    break;
            }
        }
        BuildFrom(symbol, builder);
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
#pragma warning disable GlobalUsingsAnalyzer
// ReSharper disable once CheckNamespace
#pragma warning restore GlobalUsingsAnalyzer
/// <summary>Generates the attribute needed to use this analyzer.</summary>
/// <param name="hintName">The file name of the source.</param>
/// <param name="contents">The contents of the source.</param>
public abstract class FixedGenerator(
    [StringSyntax(StringSyntaxAttribute.Uri), UriString] string hintName,
    [StringSyntax("C#")] string contents
) : IIncrementalGenerator
{
    /// <summary>The header for generated files.</summary>
    [StringSyntax("C#")]
    public const string Header =
        """
        #nullable enable
        """;
    /// <summary>The extension of each generated file.</summary>
    const string Extension = ".g.cs";
    /// <summary>Gets the attribute that indicates source generation from this library.</summary>
    [Pure, StringSyntax("C#")]
    public static string Annotation { get; } =
#if DEBUG
        $"[global::System.CodeDom.Compiler.GeneratedCode(\"{
            typeof(FixedGenerator).Assembly.ManifestModule.FullyQualifiedName}\", \"{
                typeof(FixedGenerator).Assembly.ManifestModule.ModuleVersionId}\")]";
#else
        $"[global::System.CodeDom.Compiler.GeneratedCode(\"{
            typeof(FixedGenerator).Assembly.GetName().Name}\", \"{
                typeof(FixedGenerator).Assembly.GetName().Version}\")]";
#endif
    /// <summary>Gets the name of the generated attribute.</summary>
    [Pure]
    public string Name => hintName;
    /// <summary>Gets the name of the attribute generated specified by <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The kind of <see cref="FixedGenerator"/> to get the <see cref="Name"/> from.</typeparam>
    /// <returns>The <see cref="Name"/> of the <see cref="FixedGenerator"/> <typeparamref name="T"/>.</returns>
    [Pure]
    public static string Of<T>()
        where T : FixedGenerator, new() =>
        new T().Name;
    /// <inheritdoc />
#pragma warning disable CA1033
    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context) =>
        context.RegisterPostInitializationOutput(x => x.AddSource($"{hintName}{Extension}", $"{Header}{contents}\n"));
#pragma warning restore CA1033
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
// ReSharper disable NullableWarningSuppressionIsUsed
// ReSharper disable once CheckNamespace
/// <summary>A helper type to build sequences of values with pooled buffers.</summary>
/// <typeparam name="T">The type of items to create sequences for.</typeparam>
[StructLayout(LayoutKind.Auto)]
public ref partial struct ImmutableArrayBuilder<T>
{
    /// <summary>The rented <see cref="Writer"/> instance to use.</summary>
    Writer? _writer;
    /// <summary>
    /// Initializes a new instance of the <see cref="ImmutableArrayBuilder{T}"/> struct with the specified parameters.
    /// </summary>
    /// <param name="writer">The target data writer to use.</param>
    ImmutableArrayBuilder(Writer writer) => _writer = writer;
    /// <inheritdoc cref="ImmutableArray{T}.Builder.Count"/>
    public readonly int Count
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] get => _writer!.Count;
    }
    /// <summary>Gets the data written to the underlying buffer so far, as a <see cref="ReadOnlySpan{T}"/>.</summary>
    [UnscopedRef]
    public readonly ReadOnlySpan<T> WrittenSpan
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)] get => _writer!.WrittenSpan;
    }
    /// <summary>Creates a <see cref="ImmutableArrayBuilder{T}"/> value with a pooled underlying data writer.</summary>
    /// <returns>A <see cref="ImmutableArrayBuilder{T}"/> instance to write data to.</returns>
    public static ImmutableArrayBuilder<T> Rent() => new(new());
    /// <inheritdoc cref="ImmutableArray{T}.Builder.Add(T)"/>
    public readonly void Add(T item) => _writer!.Add(item);
    /// <summary>Adds the specified items to the end of the array.</summary>
    /// <param name="items">The items to add at the end of the array.</param>
    public readonly void AddRange(scoped ReadOnlySpan<T> items) => _writer!.AddRange(items);
    /// <inheritdoc cref="ImmutableArray{T}.Builder.ToImmutable"/>
    public readonly ImmutableArray<T> ToImmutable() => ImmutableCollectionsMarshal.AsImmutableArray(ToArray());
    /// <inheritdoc cref="ImmutableArray{T}.Builder.ToArray"/>
    public readonly T[] ToArray() => WrittenSpan.ToArray();
    /// <summary>Gets an <see cref="IEnumerable{T}"/> instance for the current builder.</summary>
    /// <remarks><para>The builder should not be mutated while an enumerator is in use.</para></remarks>
    /// <returns>An <see cref="IEnumerable{T}"/> instance for the current builder.</returns>
    public readonly IEnumerable<T> AsEnumerable() => _writer!;
    /// <inheritdoc/>
    public readonly override string ToString() => WrittenSpan.ToString();
    /// <inheritdoc cref="IDisposable.Dispose"/>
    public void Dispose()
    {
        var writer = _writer;
        _writer = null;
        writer?.Dispose();
    }
    /// <summary>A class handling the actual buffer writing.</summary>
    sealed class Writer : ICollection<T>, IDisposable
    {
        /// <summary>The underlying <typeparamref name="T"/> array.</summary>
        T?[]? _array = ArrayPool<T?>.Shared.Rent(typeof(T) == typeof(char) ? 1024 : 8);
        /// <inheritdoc/>
        bool ICollection<T>.IsReadOnly => true;
        /// <inheritdoc cref="ImmutableArrayBuilder{T}.Count"/>
        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get;
            [MethodImpl(MethodImplOptions.AggressiveInlining)] private set;
        }
        /// <inheritdoc cref="ImmutableArrayBuilder{T}.WrittenSpan"/>
        public ReadOnlySpan<T> WrittenSpan
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new(_array!, 0, Count);
        }
        /// <inheritdoc cref="ImmutableArrayBuilder{T}.Add"/>
        public void Add(T item)
        {
            EnsureCapacity(1);
            _array![Count++] = item;
        }
        /// <inheritdoc cref="ImmutableArrayBuilder{T}.AddRange"/>
        public void AddRange(ReadOnlySpan<T> items)
        {
            EnsureCapacity(items.Length);
            items.CopyTo(_array.AsSpan(Count)!);
            Count += items.Length;
        }
        /// <inheritdoc/>
        public void Dispose()
        {
            var array = _array;
            _array = null;
            if (array is not null)
                ArrayPool<T?>.Shared.Return(array, typeof(T) != typeof(char));
        }
        /// <inheritdoc/>
        void ICollection<T>.Clear() => throw new NotSupportedException();
        /// <inheritdoc/>
        void ICollection<T>.CopyTo(T[] array, int arrayIndex) => Array.Copy(_array!, 0, array, arrayIndex, Count);
        /// <summary>
        /// Ensures that <see cref="_array"/> has enough free space to contain a given number of new items.
        /// </summary>
        /// <param name="requestedSize">The minimum number of items to ensure space for in <see cref="_array"/>.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void EnsureCapacity(int requestedSize)
        {
            if (requestedSize > _array!.Length - Count)
                ResizeBuffer(requestedSize);
        }
        /// <summary>Resizes <see cref="_array"/> to ensure it can fit the specified number of new items.</summary>
        /// <param name="sizeHint">The minimum number of items to ensure space for in <see cref="_array"/>.</param>
        [MethodImpl(MethodImplOptions.NoInlining)]
        void ResizeBuffer(int sizeHint)
        {
            var minimumSize = Count + sizeHint;
            var oldArray = _array!;
            var newArray = ArrayPool<T?>.Shared.Rent(minimumSize);
            Array.Copy(oldArray, newArray, Count);
            _array = newArray;
            ArrayPool<T?>.Shared.Return(oldArray, typeof(T) != typeof(char));
        }
        /// <inheritdoc/>
        bool ICollection<T>.Contains(T item) => throw new NotSupportedException();
        /// <inheritdoc/>
        bool ICollection<T>.Remove(T item) => throw new NotSupportedException();
        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable<T>)this).GetEnumerator();
        /// <inheritdoc/>
        IEnumerator<T> IEnumerable<T>.GetEnumerator()
        {
            var array = _array!;
            var length = Count;
            for (var i = 0; i < length; i++)
                yield return array[i]!;
        }
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
#pragma warning disable GlobalUsingsAnalyzer, SA1216
// ReSharper disable once RedundantUsingDirective.Global
#pragma warning restore GlobalUsingsAnalyzer, RCS1175
// ReSharper disable once CheckNamespace
/// <summary>Contains syntactic operations and registrations.</summary>
    /// <summary>Adds the deconstruction of the tuples onto the <see cref="SourceProductionContext"/>.</summary>
    /// <param name="context">The context to use for source generation.</param>
    /// <param name="generated">The tuple containing the hint name and source.</param>
    public static void AddSource(SourceProductionContext context, GeneratedSource generated) =>
        context.AddSource(generated.HintName, generated.Source);
    /// <summary>Drains the <see cref="Peeks.Diagnostics"/> <see cref="ConcurrentQueue{T}"/>.</summary>
    /// <param name="context">The context that can be used to report <see cref="Diagnostic"/> instances.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#pragma warning disable RCS1175
    public static void Drain(this in SyntaxNodeAnalysisContext context)
#pragma warning restore RCS1175
    {
#if !RELEASE && ROSLYN
        while (Peeks.Diagnostics.TryDequeue(out var diagnostic))
            context.ReportDiagnostic(diagnostic);
#endif
    }
    /// <summary>
    /// Returns the <see cref="TypeDeclarationSyntax"/> annotated with the provided <see cref="AttributeSyntax"/>.
    /// </summary>
    /// <param name="syntax">The <see cref="AttributeSyntax"/> to extract from.</param>
    /// <returns>
    /// The <see cref="TypeDeclarationSyntax"/>, or <see langword="null"/> if the parameter <paramref name="syntax"/>
    /// is <see langword="null"/>, or annotated to something other than a <see cref="TypeDeclarationSyntax"/>.
    /// </returns>
    [Pure]
    public static TypeDeclarationSyntax? TypeDeclaration(this AttributeSyntax? syntax)
    {
        if (syntax is not { Parent: var parent })
            return null;
        while (parent is { Parent: var grandparent } and
            not BaseParameterSyntax and
            not MemberDeclarationSyntax and
            not TypeParameterSyntax)
            parent = grandparent;
        return parent as TypeDeclarationSyntax;
    }
    /// <summary>Returns whether the provided <see cref="SyntaxNode"/> is of type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of <see cref="SyntaxNode"/> to test the instance for.</typeparam>
    /// <param name="node">The passed in node to test.</param>
    /// <param name="_">The discarded token, existing purely for convenience.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="node"/> is
    /// an instance of <typeparamref name="T"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool AnnotatedAndIs<T>([NotNullWhen(true)] SyntaxNode? node, CancellationToken _ = default)
        where T : MemberDeclarationSyntax =>
        node is T { AttributeLists.Count: >= 1 };
    /// <summary>Determines whether the symbol can be passed in as a generic.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// can be placed as a generic parameter, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool CanBeGeneric([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is
            not null and
            not IDynamicTypeSymbol and
            not IPointerTypeSymbol and
            not { IsRefLikeType: true } and
            not { SpecialType: System_Void };
    /// <summary>Determines whether the symbol is declared with the attribute of the specific name.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <param name="name">The name to get.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// has the attribute <paramref name="name"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool HasAttribute([NotNullWhen(true)] this ISymbol? symbol, string? name)
    {
        [Pure]
        static ReadOnlySpan<char> WithoutAttributeSuffix(string name) =>
            name.AsSpan() is var span && span is [.. var x, 'A', 't', 't', 'r', 'i', 'b', 'u', 't', 'e'] ? x : span;
        if (symbol is null)
            return false;
        if (name is null)
            return symbol.GetAttributes() is not [];
        var against = WithoutAttributeSuffix(name);
        foreach (var attribute in symbol.GetAttributes())
            if (attribute.AttributeClass?.Name is { } match && WithoutAttributeSuffix(match).SequenceEqual(against))
                return true;
        return false;
    }
    /// <summary>Returns whether the provided <see cref="SyntaxNode"/> is of type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type of <see cref="SyntaxNode"/> to test the instance for.</typeparam>
    /// <param name="node">The passed in node to test.</param>
    /// <param name="_">The discarded token, existing purely for convenience.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="node"/> is
    /// an instance of <typeparamref name="T"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool Is<T>([NotNullWhen(true)] SyntaxNode? node, CancellationToken _ = default)
        where T : SyntaxNode =>
        node is T;
    /// <summary>Determines whether the symbol is accessible from an external assembly.</summary>
    /// <param name="accessibility">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="accessibility"/> is accessible externally.
    /// </returns>
    [Pure]
    public static bool IsAccessible(this Accessibility accessibility) =>
        accessibility is Accessibility.Protected or Accessibility.ProtectedOrInternal or Accessibility.Public;
    /// <summary>Determines whether the symbol is accessible from an external assembly.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/> is accessible externally.
    /// </returns>
    [Pure]
    public static bool IsAccessible([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol?.DeclaredAccessibility.IsAccessible() is true;
    /// <summary>
    /// Determines whether the symbol and all subsequent parent types
    /// are declared with the <see langword="partial"/> keyword.
    /// </summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/> and all its subsequent
    /// parent types are <see langword="partial"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsCompletelyPartial([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol?.FindPathToNull(x => x.ContainingType).All(IsPartial) is true;
    /// <summary>Returns whether the provided <see cref="SyntaxNode"/> is the first declaration.</summary>
    /// <param name="node">The passed in node to test.</param>
    /// <param name="symbol">The symbol to retrieve the declaring syntax references from.</param>
    /// <param name="token">The cancellation token.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="node"/> is the first
    /// to declare the parameter <paramref name="symbol"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsFirst(
        this SyntaxNode? node,
        [NotNullWhen(true)] ISymbol? symbol,
        CancellationToken token = default
    ) =>
        symbol is { DeclaringSyntaxReferences: var x } && (x is not [var first, ..] || first.GetSyntax(token) == node);
    /// <summary>Determines whether the symbol is from metadata.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is in metadata, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsInMetadata([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol is { Locations: [{ IsInMetadata: true }, ..] };
    /// <summary>Determines whether the symbol is from source code.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is from source code, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsInSource([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol is { Locations: [{ IsInSource: true }, ..] };
    /// <summary>Determines whether the symbol is an <see langword="interface"/>.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is an <see langword="interface"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsInterface([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is { BaseType: null, SpecialType: not System_Object };
    /// <summary>Returns whether the provided <see cref="ISymbol"/> is an interface implementation.</summary>
    /// <param name="symbol">The passed in symbol to test.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is an explicit interface implementation, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsInterfaceDeclaration([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol?.Name.Contains('.') ?? false;
    /// <summary>Determines whether the symbol is declared with the <see cref="ObsoleteAttribute"/> attribute.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is obsolete, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsObsolete([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol.HasAttribute(nameof(ObsoleteAttribute));
    /// <summary>Determines whether the symbol is declared with the <see langword="partial"/> keyword.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// is <see langword="partial"/>, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsPartial([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol
          ?.DeclaringSyntaxReferences
           .Select(x => x.GetSyntax())
           .OfType<TypeDeclarationSyntax>()
           .Any(x => x.Modifiers.Any(x => x.ValueText is "partial")) is true;
    /// <summary>Determines whether the symbol is an <see langword="unmanaged"/> primitive type.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/> is
    /// an <see langword="unmanaged"/> primitive, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool IsUnmanagedPrimitive([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is
        {
            SpecialType: System_Char or
            System_SByte or
            System_Byte or
            System_Int16 or
            System_UInt16 or
            System_Int32 or
            System_UInt32 or
            System_Int64 or
            System_UInt64 or
            System_Decimal or
            System_Single or
            System_Double or
            System_IntPtr or
            System_UIntPtr,
        };
    /// <summary>Determines whether the symbol has a default implementation.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>The value <see langword="true"/> if the symbol has a default implementation.</returns>
    [Pure]
    public static bool HasDefaultImplementation([NotNullWhen(true)] this ISymbol? symbol) =>
        symbol is IMethodSymbol { IsAbstract: false, IsVirtual: true };
    /// <summary>Determines whether the symbol has a parameterless constructor.</summary>
    /// <param name="symbol">The symbol to check.</param>
    /// <returns>
    /// The value <see langword="true"/> if the parameter <paramref name="symbol"/>
    /// has a parameterless constructor, otherwise; <see langword="false"/>.
    /// </returns>
    [Pure]
    public static bool HasParameterlessConstructor([NotNullWhen(true)] this ITypeSymbol? symbol) =>
        symbol is INamedTypeSymbol { InstanceConstructors: var x } && x.Any(x => x.Parameters is []);
    /// <summary>Gets the hint name of the <see cref="INamedTypeSymbol"/>.</summary>
    /// <param name="symbol">The symbol to use.</param>
    /// <param name="prefix">If specified, the prefix to contain within the hint name.</param>
    /// <returns>The hint name of the parameter <paramref name="symbol"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(symbol))]
    public static string? HintName(this INamedTypeSymbol? symbol, string? prefix = nameof(Emik))
    {
        if (symbol is null)
            return null;
        StringBuilder sb = new(symbol.Name);
        ISymbol? containing = symbol;
        if (symbol.TypeParameters.Length is not 0 and var length)
            sb.Append('`').Append(length);
        while ((containing = containing.ContainingWithoutGlobal()) is not null)
        {
            sb.Insert(0, '.').Insert(0, containing.Name);
            if (containing is INamedTypeSymbol { TypeParameters.Length: not 0 and var i })
                sb.Append('`').Append(i);
        }
        if (prefix is not null)
            sb.Insert(0, '.').Insert(0, prefix);
        return sb.Append(".g.cs").ToString();
    }
    /// <summary>Gets the keyword associated with the declaration of the <see cref="ITypeSymbol"/>.</summary>
    /// <param name="symbol">The symbol to get its keyword.</param>
    /// <returns>The keyword used to declare the parameter <paramref name="symbol"/>.</returns>
    [Pure]
    public static string Keyword(this ITypeSymbol symbol) =>
        symbol switch
        {
            { TypeKind: TypeKind.Enum } => "enum",
            { TypeKind: TypeKind.Delegate } => "delegate",
            { TypeKind: TypeKind.Interface } => "interface",
            { IsValueType: true, IsRecord: true } => "record struct",
            { IsRecord: true } => "record",
            { IsValueType: true } => "struct",
            { IsReferenceType: true } => "class",
            _ => "",
        };
    /// <summary>Gets the keyword associated with the declaration of the <see cref="RefKind"/>.</summary>
    /// <param name="kind">The symbol to get its keyword.</param>
    /// <returns>The keyword used to declare the parameter <paramref name="kind"/>.</returns>
    [Pure]
    public static string KeywordInParameter(this RefKind kind) =>
        kind switch
        {
            RefKind.In => "in ",
            RefKind.Out => "out ",
            RefKind.Ref => "ref ",
            _ => "",
        };
    /// <summary>Gets the keyword associated with the declaration of the <see cref="RefKind"/>.</summary>
    /// <param name="kind">The symbol to get its keyword.</param>
    /// <returns>The keyword used to declare the parameter <paramref name="kind"/>.</returns>
    [Pure]
    public static string KeywordInReturn(this RefKind kind) =>
        kind switch
        {
            RefKind.Ref => "ref ",
            RefKind.RefReadOnly => "ref readonly ",
            _ => "",
        };
    /// <inheritdoc cref="MemberPath.TryGetMemberName(ExpressionSyntax, out string)"/>
    [Pure]
    public static string? MemberName(this ExpressionSyntax syntax)
    {
        syntax.TryGetMemberName(out var result);
        return result;
    }
    /// <inheritdoc cref="AttributeArgumentSyntaxExt.TryGetStringValue(AttributeArgumentSyntax, SemanticModel, CancellationToken, out string)"/>
    [Pure]
    public static string? StringValue(this SyntaxNodeAnalysisContext context, AttributeArgumentSyntax syntax)
    {
        syntax.TryGetStringValue(context.SemanticModel, context.CancellationToken, out var result);
        return result;
    }
    /// <inheritdoc cref="AnalysisContext.RegisterSyntaxNodeAction{TLanguageKindEnum}(Action{SyntaxNodeAnalysisContext}, TLanguageKindEnum[])"/>
    public static AnalysisContext RegisterSyntaxNodeAction<TSyntaxNode>(
        this AnalysisContext context,
        Action<SyntaxNodeAnalysisContext, TSyntaxNode> action,
        params SyntaxKind[] syntaxKinds
    )
        where TSyntaxNode : SyntaxNode =>
        context.RegisterSyntaxNodeAction(action, ImmutableArray.Create(syntaxKinds));
    /// <inheritdoc cref="AnalysisContext.RegisterSyntaxNodeAction{TLanguageKindEnum}(Action{SyntaxNodeAnalysisContext}, ImmutableArray{TLanguageKindEnum})"/>
    public static AnalysisContext RegisterSyntaxNodeAction<TSyntaxNode>(
        this AnalysisContext context,
        Action<SyntaxNodeAnalysisContext, TSyntaxNode> action,
        ImmutableArray<SyntaxKind> syntaxKinds
    )
        where TSyntaxNode : SyntaxNode
    {
        context.RegisterSyntaxNodeAction(Filter(action), syntaxKinds);
        return context;
    }
    /// <summary>Adds information to a diagnostic.</summary>
    /// <typeparam name="T">The type of <paramref name="message"/>.</typeparam>
    /// <param name="diagnostic">The diagnostic to append.</param>
    /// <param name="message">The string to append.</param>
    /// <returns>The diagnostic with added information.</returns>
    [MustUseReturnValue]
    public static Diagnostic And<T>(this Diagnostic diagnostic, T message) =>
        Diagnostic.Create(
            new(
                diagnostic.Descriptor.Id,
                diagnostic.Descriptor.Title,
                $"{diagnostic.Descriptor.MessageFormat} {message.Stringify()}",
                diagnostic.Descriptor.Category,
                diagnostic.Descriptor.DefaultSeverity,
                diagnostic.Descriptor.IsEnabledByDefault,
                $"{diagnostic.Descriptor.Description} {message.Stringify()}",
                diagnostic.Descriptor.HelpLinkUri,
                diagnostic.Descriptor.CustomTags.ToArrayLazily()
            ),
            diagnostic.Location,
            diagnostic.Severity,
            diagnostic.AdditionalLocations,
            diagnostic.Properties
        );
    /// <summary>Gets all the members, including its base type members.</summary>
    /// <param name="symbol">The symbol to get all of the members of.</param>
    /// <returns>
    /// All of the symbols of the parameter <paramref name="symbol"/>, including the members that come from its
    /// interfaces and base types, and any subsequent interfaces and base types from those.
    /// </returns>
    [Pure]
    public static IEnumerable<ISymbol> GetAllMembers(this INamedTypeSymbol symbol) =>
        symbol
           .BaseType
           .FindPathToNull(x => x.BaseType)
           .SelectMany(GetAllMembers)
           .Concat(symbol.GetMembers());
    /// <summary>Gets the symbol from a lookup.</summary>
    /// <param name="context">The context to use.</param>
    /// <param name="syntax">The syntax to lookup.</param>
    /// <returns>The symbols that likely define it.</returns>
    [Pure]
    public static IEnumerable<ISymbol> Symbols(this in SyntaxNodeAnalysisContext context, ExpressionSyntax syntax) =>
        (syntax.MemberName() ?? $"{syntax}") is var name && syntax is PredefinedTypeSyntax
            ? context.Compilation.GetSymbolsWithName(
                x => x.Contains(name),
                cancellationToken: context.CancellationToken
            )
            : context.SemanticModel.LookupSymbols(syntax.SpanStart, name: name);
    /// <summary>Gets the containing <see cref="INamespaceOrTypeSymbol"/>.</summary>
    /// <param name="syntax">The syntax to lookup.</param>
    /// <returns>The containing type or namespace of the parameter <paramref name="syntax"/>.</returns>
    [Pure]
    public static INamespaceOrTypeSymbol ContainingSymbol(this ISymbol syntax) =>
        syntax.ContainingType ?? (INamespaceOrTypeSymbol)syntax.ContainingNamespace;
    /// <summary>Gets the containing symbol so long as it isn't the global namespace.</summary>
    /// <param name="symbol">The symbol to use.</param>
    /// <returns>The containing symbol, or <see langword="null"/> if it is the global namespace.</returns>
    [Pure]
    public static ISymbol? ContainingWithoutGlobal(this ISymbol? symbol) =>
        symbol?.ContainingSymbol is var x && x is INamespaceSymbol { IsGlobalNamespace: true } ? null : x;
    /// <inheritdoc cref="GetAllMembers(INamespaceSymbol)" />
    [Pure]
    public static IEnumerable<INamespaceOrTypeSymbol> GetAllMembers(this Compilation symbol) =>
        symbol.GlobalNamespace.GetAllMembers();
    /// <inheritdoc cref="GetAllMembers(INamespaceSymbol)" />
    [Pure]
    public static IEnumerable<INamespaceOrTypeSymbol> GetAllMembers(this IAssemblySymbol symbol) =>
        symbol.GlobalNamespace.GetAllMembers();
    /// <summary>Gets all of the types declared by this symbol.</summary>
    /// <param name="symbol">The symbol to get all of the type symbols of.</param>
    /// <returns>
    /// The <see cref="IEnumerable{T}"/> of all types defined in the parameter <paramref name="symbol"/>.
    /// </returns>
    [Pure]
    public static IEnumerable<INamespaceOrTypeSymbol> GetAllMembers(this INamespaceSymbol symbol) =>
        symbol.GetMembers().SelectMany(GetAllNamespaceOrTypeSymbolMembers).Prepend(symbol);
    /// <summary>Gets the underlying type symbol of another symbol.</summary>
    /// <param name="symbol">The symbol to get the underlying type from.</param>
    /// <returns>The underlying type symbol from <paramref name="symbol"/>, if applicable.</returns>
    [Pure]
    public static ITypeSymbol? ToUnderlying(this ISymbol? symbol) =>
        symbol switch
        {
            IEventSymbol x => x.Type,
            IFieldSymbol x => x.Type,
            ILocalSymbol x => x.Type,
            IDiscardSymbol x => x.Type,
            IPropertySymbol x => x.Type,
            IParameterSymbol x => x.Type,
            IMethodSymbol x => x.ReturnType,
            IArrayTypeSymbol x => x.ElementType,
            IPointerTypeSymbol x => x.PointedAtType,
            IFunctionPointerTypeSymbol x => x.Signature.ReturnType,
            _ => null,
        };
    /// <summary>Gets the underlying symbol if the provided parameter is the nullable type.</summary>
    /// <param name="symbol">The symbol to get the underlying type from.</param>
    /// <returns>The underlying type of <paramref name="symbol"/>, if it exists.</returns>
    [Pure]
    public static ITypeSymbol? UnderlyingNullable(this ISymbol? symbol) =>
        symbol is INamedTypeSymbol
        {
            ContainingNamespace: { ContainingNamespace.IsGlobalNamespace: true, Name: nameof(System) },
            Name: nameof(Nullable),
            IsValueType: true,
            TypeArguments:
            [
                { } underlying and not { Name: nameof(Nullable) },
            ],
        }
            ? underlying
            : null;
    /// <summary>Gets the <see cref="RefKind"/> of the parameter.</summary>
    /// <param name="argument">The argument to get the <see cref="RefKind"/> of.</param>
    /// <returns>The <see cref="RefKind"/> of the parameter <paramref name="argument"/>.</returns>
    public static RefKind GetRefKind(this ArgumentSyntax? argument) =>
        argument?.RefKindKeyword.Kind() switch
        {
            SyntaxKind.RefKeyword => RefKind.Ref,
            SyntaxKind.OutKeyword => RefKind.Out,
            SyntaxKind.InKeyword => RefKind.In,
            _ => RefKind.None,
        };
    /// <summary>Gets the specified symbol.</summary>
    /// <typeparam name="T">The type of symbol to get.</typeparam>
    /// <param name="context">The context.</param>
    /// <param name="token">The cancellation token.</param>
    /// <returns>The context node as <typeparamref name="T"/>.</returns>
    [Pure]
    public static T? Get<T>(this in GeneratorSyntaxContext context, CancellationToken token = default)
        where T : ISymbol =>
        context.SemanticModel.GetDeclaredSymbol(context.Node, token) is T symbol ? symbol : default;
    [Pure]
    static Action<SyntaxNodeAnalysisContext> Filter<TSyntaxNode>(Action<SyntaxNodeAnalysisContext, TSyntaxNode> action)
        where TSyntaxNode : SyntaxNode =>
        context =>
        {
            if (context.Node is not TSyntaxNode node || context.IsExcludedFromAnalysis())
                return;
#if !RELEASE
            node.GetLocation().Mark();
#endif
            action(context, node);
#if !RELEASE
            context.Drain();
#endif
        };
    [Pure]
    static IEnumerable<INamespaceOrTypeSymbol> GetAllNamespaceOrTypeSymbolMembers(INamespaceOrTypeSymbol x) =>
        ((x as INamespaceSymbol)?.GetAllMembers() ?? []).Prepend(x);
#endif
// SPDX-License-Identifier: MPL-2.0
#if ROSLYN
// ReSharper disable CheckNamespace InvocationIsSkipped RedundantNameQualifier UseSymbolAlias
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
/// <summary>
/// Helper type that allows signature help to make better decisions about which overload the user is likely choosing
/// when the compiler itself bails out and gives a generic list of options.
/// </summary>
/// <remarks><para>
/// This implementation is based on a modified version of
/// <a href="https://github.com/dotnet/roslyn/blob/main/src/Features/CSharp/Portable/SignatureHelp/LightweightOverloadResolution.cs">
/// Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution
/// </a>.
/// </para></remarks>
readonly struct LightweightOverloadResolution(
    SemanticModel semanticModel,
    int position,
    SeparatedSyntaxList<ArgumentSyntax> arguments
)
{
    /// <summary>Contains the resulting overload.</summary>
    /// <param name="Method">The <see cref="IMethodSymbol"/> to use.</param>
    /// <param name="ParameterIndex">The index of the parameter to highlight.</param>
    public record struct Overload(IMethodSymbol? Method, int ParameterIndex)
    {
        /// <summary>Gets the instance indicating that no overload was found.</summary>
        [Pure]
        public static Overload None => new(null, -1);
    }
    /// <summary>Performs the overload resolution.</summary>
    /// <param name="symbolInfo">The <see cref="SymbolInfo"/> to use.</param>
    /// <param name="candidates">The different overloads.</param>
    /// <returns>The overload to use.</returns>
    public Overload RefineOverloadAndPickParameter(SymbolInfo symbolInfo, ImmutableArray<IMethodSymbol> candidates) =>
        symbolInfo.Symbol is IMethodSymbol method
            ? TryFindParameterIndexIfCompatibleMethod(method)
            : GuessCurrentSymbolAndParameter(candidates);
    /// <summary>Finds the parameter index if the method is compatible.</summary>
    /// <param name="method">The <see cref="IMethodSymbol"/> to check.</param>
    /// <returns>The index of the parameter if the method is compatible, <c>-1</c> otherwise.</returns>
    public int FindParameterIndexIfCompatibleMethod(IMethodSymbol method) =>
        TryFindParameterIndexIfCompatibleMethod(method) is (not null, var parameterIndex) ? parameterIndex : -1;
    static bool IsEmptyArgument(SyntaxNode expression) => expression.Span.IsEmpty;
    /// <summary> Deals with a partial invocation and finds the respective overload.</summary>
    /// <param name="methodGroup">The different overloads.</param>
    /// <returns>The overload to use.</returns>
    Overload GuessCurrentSymbolAndParameter(ImmutableArray<IMethodSymbol> methodGroup)
    {
        if (arguments is [])
            return Overload.None;
        foreach (var method in methodGroup)
        {
            var (candidateMethod, parameterIndex) = TryFindParameterIndexIfCompatibleMethod(method);
            if (candidateMethod is not null)
                return new(candidateMethod, parameterIndex);
        }
        return Overload.None;
    }
    /// <summary>
    /// Simulates overload resolution with the arguments provided so far and determines if you might be calling this overload.
    /// Returns true if an overload is acceptable. In that case, we output the parameter that should be highlighted given the cursor's
    /// position in the partial invocation.
    /// </summary>
    Overload TryFindParameterIndexIfCompatibleMethod(IMethodSymbol method)
    {
        using var argumentToParameterMap = PooledSmallList<int>.Empty;
        for (var i = 0; i < arguments.Count; i++)
            argumentToParameterMap.Append(-1);
        if (!TryPrepareArgumentToParameterMap(method, ref argumentToParameterMap.AsRef))
            return Overload.None;
        var parameters = method.Parameters;
        for (var argumentIndex = 0; argumentIndex < arguments.Count; argumentIndex++)
        {
            var parameterIndex = argumentToParameterMap[argumentIndex];
            if (parameterIndex < 0)
                continue;
            var parameter = parameters[parameterIndex];
            var argument = arguments[argumentIndex];
            if (!IsCompatibleArgument(argument, parameter))
                return Overload.None;
        }
        var argumentIndexToSave = GetArgumentIndex();
        var foundParameterIndex = -1;
        if (argumentIndexToSave >= 0)
        {
            foundParameterIndex = argumentToParameterMap[argumentIndexToSave];
            if (foundParameterIndex < 0)
                foundParameterIndex = FirstUnspecifiedParameter(ref argumentToParameterMap.AsRef);
        }
        System.Diagnostics.Debug.Assert(
            foundParameterIndex < parameters.Length,
            "foundParameterIndex < parameters.Length"
        );
        return new(method, foundParameterIndex);
    }
    /// <summary>Determines if the given argument is compatible with the given parameter.</summary>
    /// <param name="argument">The argument to check.</param>
    /// <param name="parameter">The parameter to check.</param>
    /// <returns>
    /// <see langword="true"/> if the argument is compatible with the parameter, <see langword="false"/> otherwise.
    /// </returns>
    bool IsCompatibleArgument(ArgumentSyntax argument, IParameterSymbol parameter)
    {
        var parameterRefKind = parameter.RefKind;
        if (parameterRefKind == RefKind.None)
        {
            if (IsEmptyArgument(argument.Expression))
                return true;
            var type = parameter.Type;
            if (parameter.IsParams &&
                type is IArrayTypeSymbol arrayType &&
                semanticModel.ClassifyConversion(argument.Expression, arrayType.ElementType).IsImplicit)
                return true;
            return semanticModel.ClassifyConversion(argument.Expression, type).IsImplicit;
        }
        var argumentRefKind = argument.GetRefKind();
        if (parameterRefKind == argumentRefKind)
            return true;
        return parameterRefKind == RefKind.In && argumentRefKind == RefKind.None;
    }
    /// <summary>Highlights the first unspecified parameter.</summary>
    /// <param name="argumentToParameterMap">The input map.</param>
    /// <returns>The index of the first unspecified parameter.</returns>
    int FirstUnspecifiedParameter(ref PooledSmallList<int> argumentToParameterMap)
    {
        using var specified = PooledSmallList<bool>.Empty;
        for (var i = 0; i < arguments.Count; i++)
            specified.Append(false);
        for (var i = 0; i < arguments.Count; i++)
        {
            var parameterIndex = argumentToParameterMap[i];
            if (parameterIndex >= 0 && parameterIndex < arguments.Count)
                specified[parameterIndex] = true;
        }
        for (var i = 0; i < specified.Length; i++)
            if (!specified[i])
                return i;
        return 0;
    }
    /// <summary>Find the parameter index corresponding to each argument provided.</summary>
    /// <param name="method">The method to prepare.</param>
    /// <param name="argumentToParameterMap">The output map.</param>
    /// <returns>Whether or not the method could be prepared.</returns>
#pragma warning disable MA0051
    bool TryPrepareArgumentToParameterMap(IMethodSymbol method, ref PooledSmallList<int> argumentToParameterMap)
#pragma warning restore MA0051
    {
        System.Diagnostics.Debug.Assert(
            argumentToParameterMap.Length == arguments.Count,
            "argumentToParameterMap.Length == arguments.Count"
        );
        var currentParameterIndex = 0;
        var seenOutOfPositionArgument = false;
        var inParams = false;
        for (var argumentIndex = 0; argumentIndex < arguments.Count; argumentIndex++)
        {
            if (argumentIndex >= method.Parameters.Length && !inParams)
                return false;
            var argument = arguments[argumentIndex];
            if (argument is { NameColon.Name.Identifier.ValueText: var argumentName })
            {
                var namedParameterIndex = 0;
                for (;
                    namedParameterIndex < method.Parameters.Length &&
                    method.Parameters[namedParameterIndex].Name == argumentName;
                    namedParameterIndex++) { }
                if (namedParameterIndex == method.Parameters.Length)
                    return false;
                if (namedParameterIndex != currentParameterIndex)
                    seenOutOfPositionArgument = true;
                AddArgumentToParameterMapping(argumentIndex, namedParameterIndex, ref argumentToParameterMap);
            }
            else if (IsEmptyArgument(argument.Expression))
            {
                if (!seenOutOfPositionArgument)
                    AddArgumentToParameterMapping(argumentIndex, currentParameterIndex, ref argumentToParameterMap);
            }
            else if (seenOutOfPositionArgument)
                return false;
            else
                AddArgumentToParameterMapping(argumentIndex, currentParameterIndex, ref argumentToParameterMap);
        }
        return true;
        void AddArgumentToParameterMapping(
            int argumentIndex,
            int parameterIndex,
            ref PooledSmallList<int> argumentToParameterMap
        )
        {
            System.Diagnostics.Debug.Assert(parameterIndex >= 0, "parameterIndex >= 0");
            System.Diagnostics.Debug.Assert(
                parameterIndex < method.Parameters.Length,
                "parameterIndex < method.Parameters.Length"
            );
            inParams |= method.Parameters[parameterIndex].IsParams;
            argumentToParameterMap[argumentIndex] = parameterIndex;
            if (!seenOutOfPositionArgument && !inParams)
                currentParameterIndex++;
        }
    }
    /// <summary>
    /// Given the cursor position, find which argument is active.
    /// This will be useful to later find which parameter should be highlighted.
    /// </summary>
    int GetArgumentIndex()
    {
        for (var i = 0; i < arguments.Count - 1; i++)
            if (position <= arguments.GetSeparator(i).Span.Start)
                return i;
        return arguments.Count - 1;
    }
}
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides methods for heap-allocation analysis.</summary>
    /// <summary>
    /// A <see langword="string"/> to use in an <see cref="ObsoleteAttribute"/> to indicate that the API isn't meant
    /// for production, but not for deprecated reasons.
    /// </summary>
    const string NotForProduction = "NOT deprecated. While this can be used in Release builds to run this on " +
        "optimized code; This API exists for debugging builds and should be excluded from final production builds.";
    /// <summary>Swallows all exceptions from a callback; Use with caution.</summary>
    /// <param name="action">The dangerous callback.</param>
    /// <returns>An exception, if caught.</returns>
    [Inline, Obsolete(NotForProduction)]
    public static Exception? Swallow([InstantHandle] this Action action)
    {
        try
        {
            action();
            return null;
        }
        catch (Exception ex)
        {
            return ex;
        }
    }
    /// <summary>Swallows all exceptions from a callback; Use with caution.</summary>
    /// <typeparam name="T">The type of return.</typeparam>
    /// <param name="func">The dangerous callback.</param>
    /// <returns>The value returned from <paramref name="func"/>, or the exception caught.</returns>
    [Inline, Obsolete(NotForProduction)]
    public static (T?, Exception?) Swallow<T>([InstantHandle] this Func<T> func)
    {
        try
        {
            return (func(), null);
        }
        catch (Exception ex)
        {
            return (default, ex);
        }
    }
    /// <summary>Gets the amount of bytes a callback uses.</summary>
    /// <remarks><para>
    /// This method temporarily tunes the <see cref="GC"/> to <see cref="GCLatencyMode.LowLatency"/>
    /// for accurate results. As such, the parameter <paramref name="heap"/> should not cause
    /// substantial allocation such that collecting mid-way is required.
    /// </para></remarks>
    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
    /// <returns>The number of bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.</returns>
    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
    public static long CountAllocation([InstantHandle, RequireStaticDelegate] Action heap, bool willWarmup = true)
    {
        if (willWarmup)
            heap.Swallow();
#if !(NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER)
        var mode = GCSettings.LatencyMode;
#endif
        try
        {
#if NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            GC.TryStartNoGCRegion(ushort.MaxValue, ushort.MaxValue);
#else
            GCSettings.LatencyMode = GCLatencyMode.LowLatency;
#endif
#if NETCOREAPP3_0_OR_GREATER
            var before = GC.GetTotalAllocatedBytes(true);
#else
            var before = GC.GetTotalMemory(true);
#endif
            heap.Swallow();
#if NETCOREAPP3_0_OR_GREATER
            var after = GC.GetTotalAllocatedBytes(true);
#else
            var after = GC.GetTotalMemory(false);
#endif
            return after - before;
        }
        finally
        {
#if NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            if (GCSettings.LatencyMode is GCLatencyMode.NoGCRegion)
                GC.EndNoGCRegion();
#else
            GCSettings.LatencyMode = mode;
#endif
        }
    }
    /// <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
    /// <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
    /// <returns>
    /// An <see cref="Array"/> where each entry is a separate test of the number of
    /// bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.
    /// </returns>
    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
    public static long[] CountAllocations(
        [InstantHandle, RequireStaticDelegate] Action heap,
        [NonNegativeValue] int times = byte.MaxValue,
        bool willWarmup = true
    )
    {
        if (willWarmup)
            heap.Swallow();
        var all = new long[times];
        for (var i = 0; i < times; i++)
            all[i] += CountAllocation(heap, false);
        return all;
    }
    /// <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
    /// <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
    /// <returns>
    /// An <see cref="Array"/> where each entry is a separate test of the number of
    /// bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.
    /// </returns>
    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
    public static bool HasAllocations(
        [InstantHandle, RequireStaticDelegate] Action heap,
        [NonNegativeValue] int times = byte.MaxValue,
        bool willWarmup = true
    )
    {
        if (willWarmup)
            heap.Swallow();
        for (var i = 0; i < times; i++)
            if (CountAllocation(heap, false) is not 0)
                return true;
        return false;
    }
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Class for obtaining the underlying data for lists.</summary>
    /// <summary>Contains the cached method for obtaining the underlying array.</summary>
    /// <typeparam name="T">The element type within the collection.</typeparam>
    static class ListCache<T>
    {
        /// <summary>Gets the converter.</summary>
        public static Converter<List<T>, T[]> Converter { get; } =
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
            typeof(List<T>)
           .GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
           .FirstOrDefault(x => x.FieldType == typeof(T[])) is { } method
            ? CreateGetter(method)
            :
#endif
            x => [.. x];
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
        /// <summary>Creates the getter to the inner array.</summary>
        /// <param name="field">The field to the list's array.</param>
        /// <exception cref="InvalidOperationException">The field has no declaring type.</exception>
        /// <returns>The getter to the inner array.</returns>
        static Converter<List<T>, T[]> CreateGetter(FieldInfo field)
        {
            if (field.DeclaringType is not { } declaringType)
                throw new InvalidOperationException("Field has no declaring type.");
            var param = Expression.Parameter(declaringType, field.Name);
            var access = Expression.Field(param, field);
            return Expression.Lambda<Converter<List<T>, T[]>>(access, param).Compile();
#endif
        }
    }
    /// <summary>Gets the underlying <see cref="Array"/> of the <see cref="List{T}"/>.</summary>
    /// <remarks><para>
    /// While unlikely, it is theoretically possible that the framework's implementation of
    /// <see cref="List{T}"/> lacks any references to its underlying <see cref="Array"/>, or at
    /// least directly. In that case, a new array is made, holding no reference to the list.
    /// </para><para>
    /// If you want to ensure maximum compatibility, the implementation should not rely on whether
    /// mutations within the <see cref="Array"/> would affect the <see cref="List{T}"/>, and vice versa.
    /// </para><para>
    /// Regardless of framework, mutations within the array will not notify the list during its enumerations which can
    /// easily cause bugs to slip through.
    /// </para><para>
    /// The <see cref="Array"/> may contain uninitialized memory for all elements past <see cref="List{T}.Count"/>.
    /// </para><para>
    /// Uses of this method include obtaining a <see cref="ReadOnlySpan{T}"/> or <see cref="Span{T}"/> outside of
    /// .NET 5+ projects, as <c>CollectionsMarshal.AsSpan&lt;T&gt;</c> is not available there, or obtaining
    /// <see cref="ReadOnlyMemory{T}"/> or <see cref="Memory{T}"/> of a <see cref="List{T}"/>, normally impossible,
    /// or if growth of an <see cref="Array"/> is no longer needed but the contents are expected to be long-lasting.
    /// </para><para>
    /// Whatever your use case, remember this: "It's not a b&#x0075;g, it's an undocumented feature.".
    /// </para></remarks>
    /// <typeparam name="T">The type of list.</typeparam>
    /// <param name="list">The list to obtain the underlying array.</param>
    /// <returns>The <see cref="Array"/> of the parameter <paramref name="list"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T[] UnsafelyToArray<T>(this List<T> list) => ListCache<T>.Converter(list);
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides extension methods for <see cref="char"/>.</summary>
    /// <inheritdoc cref="char.IsControl(char)"/>
    [Pure]
    public static bool IsControl(this char c) => char.IsControl(c);
    /// <inheritdoc cref="char.IsDigit(char)"/>
    [Pure]
    public static bool IsDigit(this char c) => char.IsDigit(c);
    /// <inheritdoc cref="char.IsHighSurrogate(char)"/>
    [Pure]
    public static bool IsHighSurrogate(this char c) => char.IsHighSurrogate(c);
    /// <inheritdoc cref="char.IsLetter(char)"/>
    [Pure]
    public static bool IsLetter(this char c) => char.IsLetter(c);
    /// <inheritdoc cref="char.IsLetterOrDigit(char)"/>
    [Pure]
    public static bool IsLetterOrDigit(this char c) => char.IsLetterOrDigit(c);
    /// <inheritdoc cref="char.IsLower(char)"/>
    [Pure]
    public static bool IsLower(this char c) => char.IsLower(c);
    /// <inheritdoc cref="char.IsLowSurrogate(char)"/>
    [Pure]
    public static bool IsLowSurrogate(this char c) => char.IsLowSurrogate(c);
    /// <inheritdoc cref="string.IsNullOrEmpty(string)"/>
    [Pure]
    public static bool IsNullOrEmpty([NotNullWhen(false)] this string? value) => string.IsNullOrEmpty(value);
#if NET35
    /// <summary>
    /// Indicates whether a specified string is <see langword="null"/>,
    /// empty, or consists only of white-space characters.
    /// </summary>
    /// <param name="value">The string to test.</param>
    /// <returns>
    /// <see langword="true"/> if the <paramref name="value"/> parameter is <see langword="null"/>,
    /// or <see cref="string.Empty"/>, or if <paramref name="value"/> consists exclusively of white-space characters.
    /// </returns>
    [Pure]
    public static bool IsNullOrWhitespace([NotNullWhen(false)] this string? value) =>
        value?.All(char.IsWhiteSpace) != false;
#elif !NET20 && !NET30
    /// <inheritdoc cref="string.IsNullOrWhiteSpace(string)"/>
    [Pure]
    public static bool IsNullOrWhitespace([NotNullWhen(false)] this string? value) => string.IsNullOrWhiteSpace(value);
#endif
    /// <inheritdoc cref="char.IsNumber(char)"/>
    [Pure]
    public static bool IsNumber(this char c) => char.IsNumber(c);
    /// <inheritdoc cref="char.IsPunctuation(char)"/>
    [Pure]
    public static bool IsPunctuation(this char c) => char.IsPunctuation(c);
    /// <inheritdoc cref="char.IsSeparator(char)"/>
    [Pure]
    public static bool IsSeparator(this char c) => char.IsSeparator(c);
    /// <inheritdoc cref="char.IsSurrogate(char)"/>
    [Pure]
    public static bool IsSurrogate(this char c) => char.IsSurrogate(c);
    /// <inheritdoc cref="char.IsSymbol(char)"/>
    [Pure]
    public static bool IsSymbol(this char c) => char.IsSymbol(c);
    /// <inheritdoc cref="char.IsUpper(char)"/>
    public static bool IsUpper(this char c) => char.IsUpper(c);
    /// <inheritdoc cref="char.IsWhiteSpace(char)"/>
    [Pure]
    public static bool IsWhitespace(this char c) => char.IsWhiteSpace(c);
    /// <summary>Converts the character to the byte-equivalent, 0-9.</summary>
    /// <param name="c">The character to convert.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="c"/> isn't between '0' and '9', inclusively on both ends.
    /// </exception>
    /// <returns>The number 0-9 representing the character.</returns>
    [Pure]
    public static byte AsDigit(this char c) =>
        c is >= '0' and <= '9'
            ? (byte)(c - '0')
            : throw new ArgumentOutOfRangeException(nameof(c), c, "Character must be 0-9.");
    /// <summary>Attempts to convert the character to the byte-equivalent, 0-9.</summary>
    /// <param name="c">The character to convert.</param>
    /// <returns>The number 0-9 representing the character, or <see langword="null"/>.</returns>
    [Pure]
    public static byte? TryAsDigit(this char c) => c is >= '0' and <= '9' ? (byte)(c - '0') : null;
    /// <inheritdoc cref="char.ToLower(char)"/>
    [Pure]
    public static char ToLower(this char c) => char.ToLowerInvariant(c);
    /// <inheritdoc cref="char.ToUpper(char)"/>
    [Pure]
    public static char ToUpper(this char c) => char.ToUpperInvariant(c);
    /// <inheritdoc cref="char.GetNumericValue(char)"/>
    [Pure]
    public static double GetNumericValue(this char c) => char.GetNumericValue(c);
    /// <inheritdoc cref="string.Trim(char[])"/>
    [Pure]
    public static string Trim(this string s, string trim)
    {
        int start = 0, end = 1;
        for (; start < s.Length; start++)
            if (start >= trim.Length || s[start] != trim[start])
                break;
        for (; end <= s.Length; end++)
            if (end > trim.Length || s[^end] != trim[^end])
                return s[..^(end - 1)];
        return s[start..^end];
    }
    /// <inheritdoc cref="string.TrimEnd(char[])"/>
    [Pure]
    public static string TrimEnd(this string s, string trim)
    {
        for (var i = 1; i <= s.Length; i++)
            if (i > trim.Length || s[^i] != trim[^i])
                return s[..^(i - 1)];
        return "";
    }
    /// <inheritdoc cref="string.TrimStart(char[])"/>
    [Pure]
    public static string TrimStart(this string s, string trim)
    {
        for (var i = 0; i < s.Length; i++)
            if (i >= trim.Length || s[i] != trim[i])
                return s[i..];
        return "";
    }
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
    /// <inheritdoc cref="char.GetUnicodeCategory(char)"/>
    [Pure]
    public static UnicodeCategory GetUnicodeCategory(this char c) => char.GetUnicodeCategory(c);
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace EmptyNamespace InvalidXmlDocComment RedundantNameQualifier SuggestBaseTypeForParameter UseSymbolAlias
#if NET35_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
/// <summary>Contains methods for deconstructing objects.</summary>
#pragma warning disable 9107
    /// <summary>Takes the complex object and turns it into a structure that is serializable.</summary>
    /// <param name="value">The complex object to convert.</param>
    /// <param name="visitLength">The maximum number of times to recurse through an enumeration.</param>
    /// <param name="stringLength">The maximum length of any given <see cref="string"/>.</param>
    /// <param name="recurseLength">The maximum number of times to recurse a nested object or dictionary.</param>
    /// <returns>
    /// The serializable object: any of <see cref="IntPtr"/>, <see cref="UIntPtr"/>,
    /// <see cref="ISerializable"/>, or <see cref="DeconstructionCollection"/>.
    /// </returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(value))]
    public static object? ToDeconstructed(
        this object? value,
        [NonNegativeValue] int visitLength = DeconstructionCollection.DefaultVisitLength,
        [NonNegativeValue] int stringLength = DeconstructionCollection.DefaultStringLength,
        [NonNegativeValue] int recurseLength = DeconstructionCollection.DefaultRecurseLength
    )
    {
        if (value is DeconstructionCollection)
            return value;
        if (stringLength <= 0)
            return "";
        HashSet<object?> seen = new(DeconstructionCollection.Comparer) { value };
        var assertion = false;
        var next = DeconstructionCollection.CollectNext(value, stringLength, ref visitLength, ref assertion, seen);
        if (next is not DeconstructionCollection x)
        {
            System.Diagnostics.Debug.Assert(!assertion, "!assertion");
            return DeconstructionCollection.TryTruncate(next, stringLength, out var output) ? output : next;
        }
        System.Diagnostics.Debug.Assert(assertion, "assertion");
        for (var i = 0; recurseLength > 0 && i < recurseLength && x.TryRecurse(i, ref visitLength, seen); i++) { }
        return x.Simplify();
    }
/// <summary>Defines the collection responsible for deconstructing.</summary>
/// <param name="str">The maximum length of any given <see cref="string"/>.</param>
abstract partial class DeconstructionCollection([NonNegativeValue] int str) : ICollection
{
    /// <summary>Represents a comparer for <see cref="DeconstructionCollection"/> recursion checks.</summary>
    /// <remarks><para>
    /// All values considered to be scalar values are treated as being always unique even when the exact
    /// reference is the same. The point of the comparer is to avoid reference cycles, not for equality.
    /// </para></remarks>
    sealed partial class DeconstructionComparer : IEqualityComparer<object?>
    {
        int _unique = int.MaxValue;
        /// <inheritdoc />
        [Pure]
        public new bool Equals(object? x, object? y) => !IsScalar(x) && !IsScalar(y) && x == y;
        /// <inheritdoc />
        [Pure]
        public int GetHashCode(object? obj) =>
            IsScalar(obj)
                ? unchecked(_unique--)
#if NETFRAMEWORK && !NET35_OR_GREATER
                : RuntimeHelpers.GetHashCode(obj);
#else
                : 0;
#endif
        /// <summary>Determines whether the value is a scalar.</summary>
        /// <param name="value">The value to check.</param>
        /// <returns>
        /// The value <see langword="true"/> if the value is a scalar; otherwise, <see langword="false"/>.
        /// </returns>
        [Pure]
        static bool IsScalar([NotNullWhen(false)] object? value) =>
            value is nint or nuint or null or string or IConvertible or Pointer or Type or Version;
    }
    /// <summary>Represents a deep-cloned list.</summary>
    /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
    sealed partial class DeconstructionList([NonNegativeValue] int str) : DeconstructionCollection(str), IList
    {
        readonly List<object?> _list = [];
        /// <inheritdoc />
        [Pure]
        public override IList Inner => _list;
        /// <inheritdoc />
        [Pure]
        public object? this[int index]
        {
            get => ((IList)_list)[index];
            set => ((IList)_list)[index] = value;
        }
        /// <inheritdoc />
        [Pure]
        bool IList.IsFixedSize => false;
        /// <inheritdoc />
        [Pure]
        bool IList.IsReadOnly => false;
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of
        /// <see cref="DeconstructionCollection.DeconstructionList"/> by using the constructor
        /// <see cref="DeconstructionCollection.DeconstructionList(int)"/>.
        /// </summary>
        /// <param name="str">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="DeconstructionCollection.DeconstructionList"/>
        /// by passing the parameter <paramref name="str"/> to the constructor
        /// <see cref="DeconstructionCollection.DeconstructionList(int)"/>.
        /// </returns>
        [Pure]
        public static implicit operator DeconstructionList(int str) => new(str);
        /// <summary>Attempts to deconstruct an object by enumerating it.</summary>
        /// <param name="enumerator">The enumerator to collect. It will be disposed after the method halts.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="list">The resulting <see cref="DeconstructionCollection.DeconstructionList"/>.</param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="enumerator"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="list"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryCollect(
            [HandlesResourceDisposal] IEnumerator enumerator,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionList list,
            HashSet<object?>? seen = null
        )
        {
            using var _ = enumerator as IDisposable;
            var copy = visit;
            list = new(str);
            while (enumerator.MoveNext())
                if (seen?.Add(enumerator.Current) is false) { }
                else if (--copy > 0)
                    list.Add(enumerator.Current);
                else if (!enumerator.MoveNext())
                    break;
                else
                    return list.Fail();
            visit = copy;
            return true;
        }
        /// <summary>Attempts to deconstruct an object by enumerating it.</summary>
        /// <param name="enumerable">The enumerator to collect.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="list">The resulting <see cref="DeconstructionCollection.DeconstructionList"/>.</param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="enumerable"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="list"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryCollect(
            [InstantHandle] IEnumerable enumerable,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionList list,
            HashSet<object?>? seen = null
        ) =>
            TryCollect(enumerable.GetEnumerator(), str, ref visit, out list, seen);
#if !NET20 && !NET30 && !NET35
        /// <summary>Attempts to deconstruct an object by enumerating it.</summary>
        /// <param name="comparable">The comparable to collect.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="list">The resulting <see cref="DeconstructionCollection.DeconstructionList"/>.</param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="comparable"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="list"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryCollect(
            [InstantHandle] IStructuralComparable comparable,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionList list,
            HashSet<object?>? seen = null
        ) =>
            TryCollect(comparable.ToList(), str, ref visit, out list, seen);
        /// <summary>Attempts to deconstruct an object by enumerating it.</summary>
        /// <param name="equatable">The equatable to collect.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="list">The resulting <see cref="DeconstructionCollection.DeconstructionList"/>.</param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="equatable"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="list"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryCollect(
            [InstantHandle] IStructuralEquatable equatable,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionList list,
            HashSet<object?>? seen = null
        ) =>
            TryCollect(equatable.ToList(), str, ref visit, out list, seen);
#endif
        public override bool Fail()
        {
            Add('');
            return false;
        }
        /// <inheritdoc />
        public override bool TryRecurse(int layer, ref int visit, HashSet<object?>? seen = null)
        {
            if (layer < 0)
                return false;
            var any = false;
            if (layer is 0)
                for (var i = 0; i < Count; i++)
                    _list[i] = CollectNext(_list[i], str, ref visit, ref any, seen);
            else
                foreach (var next in _list)
                    RecurseNext(next, layer, ref visit, ref any, seen);
            return any;
        }
        /// <inheritdoc />
        [NonNegativeValue]
        public int Add(object? value) => ((IList)_list).Add(value);
        /// <inheritdoc />
        [Pure]
        public override string ToString() => $"[{_list.Select(ToString).Conjoin()}]";
        /// <inheritdoc />
        public override DeconstructionCollection Simplify()
        {
            for (var i = 0; i < Count; i++)
                _list[i] = SimplifyObject(_list[i]);
            return this;
        }
        /// <inheritdoc />
        void IList.Clear() => _list.Clear();
        /// <inheritdoc />
        void IList.Insert(int index, object? value) => _list.Insert(index, value);
        /// <inheritdoc />
        void IList.Remove(object? value) => _list.Remove(value);
        /// <inheritdoc />
        void IList.RemoveAt(int index) => _list.RemoveAt(index);
        /// <inheritdoc />
        [Pure]
        bool IList.Contains(object? value) => _list.Contains(value);
        /// <inheritdoc />
        [Pure]
        int IList.IndexOf(object? value) => _list.IndexOf(value);
        /// <inheritdoc />
        [Pure]
        public override IEnumerator GetEnumerator() => _list.GetEnumerator();
    }
    /// <summary>Represents either a complex object or a deep-cloned dictionary.</summary>
    /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
    sealed partial class DeconstructionDictionary([NonNegativeValue] int str)
        : DeconstructionCollection(str), IDictionary
    {
        /// <summary>Handles enumeration of the <see cref="DeconstructionDictionary"/>.</summary>
        /// <param name="dictionary">The <see cref="DeconstructionDictionary"/> to enumerate.</param>
        sealed class Enumerator(DeconstructionDictionary dictionary) : IDictionaryEnumerator
        {
            int _index = -1;
            /// <inheritdoc />
            [Pure]
            public DictionaryEntry Entry =>
                _index >= 0 && _index < dictionary.Count ? dictionary._list[_index] : default;
            /// <inheritdoc />
            [Pure]
            object IEnumerator.Current => Entry;
            /// <inheritdoc />
            [Pure]
            object IDictionaryEnumerator.Key => Entry.Key;
            /// <inheritdoc />
            [Pure]
            object? IDictionaryEnumerator.Value => Entry.Value;
            /// <inheritdoc />
            bool IEnumerator.MoveNext() => ++_index < dictionary.Count;
            /// <inheritdoc />
            void IEnumerator.Reset() => _index = -1;
        }
        readonly List<DictionaryEntry> _list = [];
        /// <inheritdoc />
        [Pure]
        object? IDictionary.this[object key]
        {
            get => _list.Find(Eq(key)).Value;
            set => _ = _list.FindIndex(Eq(key)) is not -1 and var i ? _list[i] = new(key, value) : default;
        }
        /// <inheritdoc />
        [Pure]
        bool IDictionary.IsFixedSize => false;
        /// <inheritdoc />
        [Pure]
        bool IDictionary.IsReadOnly => false;
        /// <inheritdoc />
        [Pure]
        ICollection IDictionary.Keys => _list.ConvertAll(x => x.Key);
        /// <inheritdoc />
        [Pure]
        ICollection IDictionary.Values => _list.ConvertAll(x => x.Value);
        /// <inheritdoc />
        [Pure]
        public override IList Inner => _list;
        /// <inheritdoc />
        [Pure]
        public override ICollection Serialized =>
            _list.Aggregate(new Dictionary<string, object?>(StringComparer.Ordinal), AddUnique);
        /// <summary>
        /// Implicitly converts the parameter by creating the new instance of
        /// <see cref="DeconstructionCollection.DeconstructionDictionary"/>
        /// by using the constructor <see cref="DeconstructionCollection.DeconstructionDictionary(int)"/>.
        /// </summary>
        /// <param name="str">The parameter to pass onto the constructor.</param>
        /// <returns>
        /// The new instance of <see cref="DeconstructionCollection.DeconstructionDictionary"/>
        /// by passing the parameter <paramref name="str"/> to the constructor
        /// <see cref="DeconstructionCollection.DeconstructionDictionary(int)"/>.
        /// </returns>
        [Pure]
        public static implicit operator DeconstructionDictionary(int str) => new(str);
        /// <summary>Attempts to deconstruct an object by enumerating it.</summary>
        /// <param name="enumerator">The enumerator to collect. It will be disposed after the method halts.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="dictionary">
        /// The resulting <see cref="DeconstructionCollection.DeconstructionDictionary"/>.
        /// </param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="enumerator"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="dictionary"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryCollect(
            [HandlesResourceDisposal] IDictionaryEnumerator enumerator,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionDictionary dictionary,
            HashSet<object?>? seen = null
        )
        {
            using var _ = enumerator as IDisposable;
            var copy = visit;
            dictionary = new(str);
            while (enumerator.MoveNext())
                if (seen?.Contains(enumerator.Key) is true ||
                    seen?.Add(enumerator.Value) is false ||
                    seen?.Add(enumerator.Key) is false) { }
                else if (--copy > 0)
                    dictionary.Add(enumerator.Key, enumerator.Value);
                else if (!enumerator.MoveNext())
                    break;
                else
                    return dictionary.Fail();
            visit = copy;
            return true;
        }
        /// <summary>Attempts to deconstruct an object by enumerating it.</summary>
        /// <param name="dict">The dictionary to collect.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="dictionary">
        /// The resulting <see cref="DeconstructionCollection.DeconstructionDictionary"/>.
        /// </param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="dict"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="dictionary"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryCollect(
            IDictionary dict,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionDictionary dictionary,
            HashSet<object?>? seen = null
        ) =>
            TryCollect(dict.GetEnumerator(), str, ref visit, out dictionary, seen);
        /// <summary>Attempts to deconstruct an object by reflectively collecting its fields and properties.</summary>
        /// <param name="value">The complex object to convert.</param>
        /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
        /// <param name="visit">The maximum number of times to recurse.</param>
        /// <param name="dictionary">
        /// The resulting <see cref="DeconstructionCollection.DeconstructionDictionary"/>.
        /// </param>
        /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
        /// <returns>
        /// Whether the parameter <paramref name="value"/> was deconstructed fully and <paramref name="visit"/>
        /// altered. When this method returns <see langword="false"/>, the parameter <paramref name="dictionary"/>
        /// will still contain the elements that were able to be deconstructed, alongside an ellipsis.
        /// </returns>
        public static bool TryReflectivelyCollect(
            object value,
            [NonNegativeValue] int str,
            ref int visit,
            out DeconstructionDictionary dictionary,
            HashSet<object?>? seen = null
        )
        {
            var copy = visit;
            dictionary = new(str);
            var type = value.GetType();
            var fields = type.GetFields();
            var properties = type.GetProperties();
            foreach (var next in fields)
            {
                if (next.IsStatic)
                    continue;
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
                if (next.FieldType.IsByRefLike)
                    continue;
#endif
                if (next.GetValue(value) is var result && seen?.Add(result) is false)
                    continue;
                if (--copy <= 0)
                    return dictionary.Fail();
                var name = Name(next, fields, properties);
                dictionary.Add(name, result);
            }
            foreach (var next in properties)
            {
                if (next.GetGetMethod() is { } getter &&
                    (getter.IsStatic || next.GetGetMethod()?.GetParameters() is not []))
                    continue;
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
                if (next.PropertyType.IsByRefLike)
                    continue;
#endif
                if (GetValueOrException(value, next, str, ref visit, seen) is var result && seen?.Add(result) is false)
                    continue;
                if (--copy <= 0)
                    return dictionary.Fail();
                var name = Name(next, fields, properties);
                dictionary.Add(name, result);
            }
            visit = copy;
            return true;
        }
        /// <inheritdoc cref="IDictionary.Add"/>
        public void Add(object? key, object? value) => _list.Add(new(key!, value));
        /// <inheritdoc cref="IDictionary.Clear"/>
        public void Clear() => _list.Clear();
        /// <inheritdoc />
        public override bool Fail()
        {
            Add('', '');
            return false;
        }
        /// <inheritdoc />
        public override bool TryRecurse(int layer, ref int visit, HashSet<object?>? seen = null)
        {
            if (layer < 0)
                return false;
            var any = false;
            if (layer is 0)
                for (var i = 0; i < Count; i++)
                    _list[i] = new(
                        CollectNext(_list[i].Key, str, ref visit, ref any, seen)!,
                        CollectNext(_list[i].Value, str, ref visit, ref any, seen)
                    );
            else
                foreach (var next in _list)
                {
                    RecurseNext(next.Key, layer, ref visit, ref any, seen);
                    RecurseNext(next.Value, layer, ref visit, ref any, seen);
                }
            return any;
        }
        /// <inheritdoc />
        [Pure]
        public override string ToString() =>
            $"{{ {_list.Select(x => $"{ToString(x.Key)}: {ToString(x.Value)}").Conjoin()} }}";
        /// <inheritdoc />
        public override DeconstructionCollection Simplify()
        {
            for (var i = 0; i < Count; i++)
                _list[i] = new(SimplifyObject(_list[i].Key), SimplifyObject(_list[i].Value));
            return this;
        }
        /// <inheritdoc />
        [MustUseReturnValue]
        public override IEnumerator GetEnumerator() => ((IDictionary)this).GetEnumerator();
        /// <inheritdoc />
        void IDictionary.Remove(object key) => _list.Remove(_list.Find(Eq(key)));
        /// <inheritdoc />
        [Pure]
        bool IDictionary.Contains(object key) => _list.FindIndex(Eq(key)) is not -1;
        /// <inheritdoc />
        [MustUseReturnValue]
        IDictionaryEnumerator IDictionary.GetEnumerator()
        {
            _list.Sort(ByKeyString);
            return new Enumerator(this);
        }
        [Pure]
        static string Name(MemberInfo next, FieldInfo[] fields, PropertyInfo[] properties)
        {
            static string QualifyTypeName(MemberInfo next) => $"{next.DeclaringType?.Name}.{next.Name}";
            if (next.DeclaringType == next.ReflectedType)
                return next.Name;
            foreach (var x in fields)
                if (x != next && x.Name == next.Name)
                    return QualifyTypeName(next);
            foreach (var x in properties)
                if (x != next && x.Name == next.Name)
                    return QualifyTypeName(next);
            return next.Name;
        }
        [Pure]
        static object? GetValueOrException(
            object value,
            PropertyInfo next,
            [NonNegativeValue] int str,
            ref int visit,
            HashSet<object?>? seen = null
        )
        {
            try
            {
                return next.GetValue(value, null);
            }
            catch (Exception ex)
            {
                return value is not Exception && TryReflectivelyCollect(ex, str, ref visit, out var x, seen) ? x : ex;
            }
        }
        [Pure]
        static Predicate<DictionaryEntry> Eq(object? key) => x => x.Key.Equals(key);
        [Pure]
        int ByKeyString(DictionaryEntry x, DictionaryEntry y) =>
            StringComparer.Ordinal.Compare(ToString(x.Key), ToString(y.Key));
        Dictionary<string, object?> AddUnique(Dictionary<string, object?> accumulator, DictionaryEntry next)
        {
            var key = ToString(next.Key);
            while (accumulator.ContainsKey(key))
                key = $"{key}";
            accumulator[key] = next.Value is DeconstructionCollection { Serialized: var x } ? x : next.Value;
            return accumulator;
        }
    }
    /// <summary>The defaults used in <see cref="DeconstructionCollectionExtensions.ToDeconstructed"/>.</summary>
    public const int
        DefaultVisitLength = 80,
        DefaultStringLength = 40,
        DefaultRecurseLength = 20;
    /// <summary>Gets the comparer used in <see cref="DeconstructionCollectionExtensions.ToDeconstructed"/>.</summary>
    [Pure]
    public static IEqualityComparer<object?> Comparer { get; } = new DeconstructionComparer();
    /// <inheritdoc />
    [Pure]
    public bool IsSynchronized => false;
    /// <inheritdoc />
    [NonNegativeValue, Pure]
    public int Count =>
        Inner is var inner && ReferenceEquals(this, inner) ? throw new InvalidOperationException() : inner.Count;
    /// <summary>Gets the maximum length of any given <see cref="string"/>.</summary>
    [NonNegativeValue, Pure]
    public int MaxStringLength => str;
    /// <inheritdoc />
    [Pure]
    public object SyncRoot => this;
    /// <summary>Gets the underlying collection.</summary>
    [Pure]
    public abstract IList Inner { get; }
    /// <summary>Gets the collection to a serializable collection.</summary>
    [Pure]
    public virtual ICollection Serialized => this;
    /// <summary>Attempts to truncate the <paramref name="v"/>.</summary>
    /// <param name="v">The <see cref="object"/> to truncate.</param>
    /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
    /// <param name="o">The resulting truncation <see cref="string"/>.</param>
    /// <returns>Whether the <paramref name="v"/> was truncated.</returns>
    public static bool TryTruncate(object? v, [NonNegativeValue] int str, out string o) =>
        $"{v}" is var x &&
        (o = v is not DeconstructionCollection && str >= 1 && x.Length > str
            ? $"{x[..(str - 1)]}"
            : x) is not null;
    /// <summary>Collects the value however applicable, reverting on failure.</summary>
    /// <param name="value">The complex object to convert.</param>
    /// <param name="str">The maximum length of any given <see cref="string"/>.</param>
    /// <param name="visit">The maximum number of times to recurse.</param>
    /// <param name="any">Whether any value was collected.</param>
    /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
    /// <returns>The replacement value.</returns>
    public static object? CollectNext(
        object? value,
        [NonNegativeValue] int str,
        ref int visit,
        ref bool any,
        HashSet<object?>? seen = null
    )
    {
        static object? Ok(object? o, out bool any)
        {
            any = true;
            return o;
        }
        switch (value)
        {
            case nint or nuint or null or DictionaryEntry or DeconstructionCollection or IConvertible: return value;
            case Type x: return x.UnfoldedName();
            case Pointer x: return x.ToHexString();
            case Version x: return x.ToShortString();
            case IDictionary x when DeconstructionDictionary.TryCollect(x, str, ref visit, out var dictionary, seen):
                return Ok(dictionary, out any);
            case IDictionary: goto default;
            case IDictionaryEnumerator x
                when DeconstructionDictionary.TryCollect(x, str, ref visit, out var dictionaryEnumerator, seen):
                return Ok(dictionaryEnumerator, out any);
            case IDictionaryEnumerator: goto default;
            case IEnumerable x when DeconstructionList.TryCollect(x, str, ref visit, out var enumerable, seen):
                return Ok(enumerable, out any);
            case IEnumerable: goto default;
            case IEnumerator x when DeconstructionList.TryCollect(x, str, ref visit, out var enumerator, seen):
                return Ok(enumerator, out any);
            case IEnumerator: goto default;
#if !NET20 && !NET30 && !NET35
            case IStructuralComparable x when DeconstructionList.TryCollect(x, str, ref visit, out var comparable, seen):
                return Ok(comparable, out any);
            case IStructuralComparable: goto default;
            case IStructuralEquatable x when DeconstructionList.TryCollect(x, str, ref visit, out var equatable, seen):
                return Ok(equatable, out any);
            case IStructuralEquatable: goto default;
#endif
            default:
                return DeconstructionDictionary.TryReflectivelyCollect(value, str, ref visit, out var obj, seen)
                    ? Ok(obj, out any)
                    : value;
        }
    }
    /// <inheritdoc />
    public void CopyTo(Array array, int index) =>
        (Inner is var inner && ReferenceEquals(this, inner) ? throw new InvalidOperationException() : inner)
       .CopyTo(array, index);
    /// <summary>Adds a failure element, and returns <see langword="false"/>.</summary>
    /// <returns>The value <see langword="false"/>.</returns>
    public abstract bool Fail();
    /// <summary>Attempts to recurse into this instance's elements.</summary>
    /// <param name="layer">The amount of layers of recursion to apply.</param>
    /// <param name="visit">The maximum number of times to recurse.</param>
    /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
    /// <returns>Whether any mutation occured.</returns>
    public abstract bool TryRecurse(int layer, ref int visit, HashSet<object?>? seen = null);
    /// <inheritdoc />
    [Pure]
    public abstract override string ToString();
    /// <summary>Returns the <see cref="string"/> representation of this instance without newlines.</summary>
    /// <returns>The <see cref="string"/> representation of this instance.</returns>
    [Pure]
    public string ToStringWithoutNewLines() =>
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        ToString().SplitSpanLines().ToString();
#else
        $"{Breaking.Aggregate(new StringBuilder(ToString()), (acc, next) => acc.Replace($"{next}", ""))}";
#endif
    /// <summary>Recursively simplifies every value according to <see cref="Simplify"/>.</summary>
    /// <returns>Itself. The returned value is not a copy; mutation applies to the instance.</returns>
    public abstract DeconstructionCollection Simplify();
    /// <inheritdoc />
    [MustUseReturnValue]
    public abstract IEnumerator GetEnumerator();
    /// <summary>Starts recursion if the value is a collection.</summary>
    /// <param name="value">The complex object to convert.</param>
    /// <param name="layer">The amount of layers of recursion to apply.</param>
    /// <param name="visit">The maximum number of times to recurse.</param>
    /// <param name="any">Whether any value was collected.</param>
    /// <param name="seen">The set of seen values, which is used to avoid recursion.</param>
    protected static void RecurseNext(
        object? value,
        int layer,
        ref int visit,
        ref bool any,
        HashSet<object?>? seen = null
    )
    {
        if (value is DeconstructionCollection collection)
            any |= collection.TryRecurse(layer - 1, ref visit, seen);
    }
    /// <summary>Converts the <see cref="object"/> to a <see cref="string"/>.</summary>
    /// <param name="value">The <see cref="object"/> to convert.</param>
    /// <returns>The converted <see cref="string"/>.</returns>
    [Pure]
    protected string ToString(object? value)
    {
        TryTruncate(value, str, out var output);
        return output;
    }
    /// <summary>Simplifies the value to either a <see cref="IConvertible"/> or <see cref="string"/>.</summary>
    /// <param name="value">The value to simplify.</param>
    /// <returns>The simplified value.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(value))]
    protected object? SimplifyObject(object? value) =>
        value switch
        {
            DeconstructionCollection x => x.Simplify(),
            Version x => x.ToShortString(),
            Pointer x => x.ToHexString(),
            Type x => x.UnfoldedName(),
            nuint x => x.ToHexString(),
            nint x => x.ToHexString(),
            string x => ToString(x),
            null or IConvertible => value,
            _ => ToString(value),
        };
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if NET40_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable CheckNamespace RedundantNameQualifier
/// <summary>Provides methods to do math on enums without overhead from boxing.</summary>
[UsedImplicitly]
    const string ParameterName = "value";
    static readonly ConstantExpression s_parameterName = Constant(ParameterName, typeof(string));
    static readonly ConstructorInfo s_newArgument = typeof(ArgumentException).GetConstructor(
            BindingFlags.Instance | BindingFlags.Public,
            null,
            [typeof(string), typeof(string)],
            null
        ) ??
        throw Unreachable;
    static readonly ConstructorInfo s_newInvalidEnumArgument = typeof(InvalidEnumArgumentException).GetConstructor(
            BindingFlags.Instance | BindingFlags.Public,
            null,
            [typeof(string), typeof(int), typeof(Type)],
            null
        ) ??
        throw Unreachable;
    /// <summary>Converts the value to a constant <see cref="string"/>.</summary>
    /// <remarks><para>
    /// Combinations via <see cref="FlagsAttribute"/> are ignored. Only explicit fields count.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <exception cref="InvalidEnumArgumentException">The value doesn't represent an exact value.</exception>
    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
    [Pure]
    public static string AsString<T>(this T value)
        where T : Enum =>
        typeof(T) == typeof(Enum) ? value.ToString() : StringCaching<T>.From(value);
    /// <summary>Converts the <see cref="string"/> to a constant value.</summary>
    /// <remarks><para>
    /// Combinations via <see cref="FlagsAttribute"/> are ignored. Only explicit fields count.
    /// </para></remarks>
    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
    /// <param name="value">The value.</param>
    /// <exception cref="ArgumentException">The value doesn't represent an exact value.</exception>
    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
    [Pure]
    public static T As<T>(this string value)
        where T : Enum =>
        typeof(T) == typeof(Enum) ? (T)Enum.Parse(typeof(T), value) : StringCaching<T>.To(value);
    static class StringCaching<T>
        where T : Enum
    {
        public static Converter<T, string> From { get; } = Make<Converter<T, string>>(false);
        public static Converter<string, T> To { get; } = Make<Converter<string, T>>(true);
        static TFunc Make<TFunc>(bool isToT)
            where TFunc : Delegate
        {
            var parameter = Parameter(isToT ? typeof(string) : typeof(T), ParameterName);
            var cases = Cases(isToT);
            var thrower = Thrower(parameter, isToT);
            var ret = Switch(parameter, thrower, cases);
            return Lambda<TFunc>(ret, parameter).Compile();
        }
        static SwitchCase[] Cases(bool isToT) =>
            [..typeof(T).GetFields(BindingFlags.Static | BindingFlags.Public).Select(x => Case(x, isToT))];
        static SwitchCase Case(FieldInfo x, bool isToT)
        {
            var str = Constant(x.Name, typeof(string));
            var t = Constant(x.GetValue(null), typeof(T));
            var from = isToT ? str : t;
            var to = isToT ? t : str;
            return SwitchCase(to, from);
        }
        static UnaryExpression Thrower(Expression parameter, bool isToT) =>
            Throw(isToT ? Format(parameter) : InvalidEnumArgument(parameter), isToT ? typeof(T) : typeof(string));
        static NewExpression Format(Expression parameter) => New(s_newArgument, parameter, s_parameterName);
        static NewExpression InvalidEnumArgument(Expression parameter) =>
            New(
                s_newInvalidEnumArgument,
                s_parameterName,
                Convert(parameter, typeof(int)),
                Constant(typeof(T), typeof(Type))
            );
    }
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides extension methods to convert representations of text into destination types.</summary>
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Parse<T>(this string s) => Parse<T>(s, out _);
    /// <summary>Parses the <see cref="string"/> into a <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type to parse into.</typeparam>
    /// <param name="s">The buffer source.</param>
    /// <param name="success">Whether the parsing was successful.</param>
    /// <returns>The parsed value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Parse<T>(this string s, out bool success) => FindTryParseFor<T>.WithString(s, out success);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Parse<T>(this scoped in ReadOnlySpan<byte> s) => Parse<T>(s, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Parse<T>(this scoped in ReadOnlySpan<byte> s, out bool success) =>
        FindTryParseFor<T>.WithByteSpan(s, out success);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Parse<T>(this scoped in ReadOnlySpan<char> s) => Parse<T>(s, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Parse<T>(this scoped in ReadOnlySpan<char> s, out bool success) =>
        FindTryParseFor<T>.WithCharSpan(s, out success);
#if NET7_0_OR_GREATER
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this string s)
        where T : IParsable<T> =>
        Into<T>(s, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this string s, IFormatProvider? provider)
        where T : IParsable<T> =>
        Into<T>(s, provider, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this string s, out bool success)
        where T : IParsable<T> =>
        (success = T.TryParse(s, CultureInfo.InvariantCulture, out var result)) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this string s, IFormatProvider? provider, out bool success)
        where T : IParsable<T> =>
        (success = T.TryParse(s, provider, out var result)) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<byte> s)
        where T : IUtf8SpanParsable<T> =>
        Into<T>(s, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<byte> s, IFormatProvider? provider)
        where T : IUtf8SpanParsable<T> =>
        Into<T>(s, provider, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<byte> s, out bool success)
        where T : IUtf8SpanParsable<T> =>
        (success = T.TryParse(s, CultureInfo.InvariantCulture, out var result)) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<byte> s, IFormatProvider? provider, out bool success)
        where T : IUtf8SpanParsable<T> =>
        (success = T.TryParse(s, provider, out var result)) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<char> s)
        where T : ISpanParsable<T> =>
        Into<T>(s, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<char> s, IFormatProvider? provider)
        where T : ISpanParsable<T> =>
        Into<T>(s, provider, out _);
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<char> s, out bool success)
        where T : ISpanParsable<T> =>
        (success = T.TryParse(s, CultureInfo.InvariantCulture, out var result)) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? Into<T>(this scoped in ReadOnlySpan<char> s, IFormatProvider? provider, out bool success)
        where T : ISpanParsable<T> =>
        (success = T.TryParse(s, provider, out var result)) ? result : default;
#endif
#if NET40_OR_GREATER || NETSTANDARD || NETCOREAPP
    /// <summary>Parses the <see cref="string"/> into the <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type to parse into.</typeparam>
    /// <param name="s">The buffer source.</param>
    /// <param name="ignoreCase">Whether to ignore case.</param>
    /// <returns>The parsed value.</returns>
    public static T IntoEnum<T>(this string s, bool ignoreCase = true)
        where T : struct =>
        Enum.TryParse(s, ignoreCase, out T result) ? result : default;
    /// <summary>Parses the <see cref="string"/> into the <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type to parse into.</typeparam>
    /// <param name="s">The buffer source.</param>
    /// <param name="ignoreCase">Whether to ignore case.</param>
    /// <returns>The parsed value.</returns>
    public static T? TryIntoEnum<T>(this string s, bool ignoreCase = true)
        where T : struct =>
        Enum.TryParse(s, ignoreCase, out T result) ? result : null;
#endif
#if NET6_0_OR_GREATER
    /// <summary>Parses the <see cref="string"/> into the <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type to parse into.</typeparam>
    /// <param name="s">The buffer source.</param>
    /// <param name="ignoreCase">Whether to ignore case.</param>
    /// <returns>The parsed value.</returns>
    public static T IntoEnum<T>(this scoped in ReadOnlySpan<char> s, bool ignoreCase = true)
        where T : struct =>
        Enum.TryParse(s, ignoreCase, out T result) ? result : default;
    /// <summary>Parses the <see cref="string"/> into the <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">The type to parse into.</typeparam>
    /// <param name="s">The buffer source.</param>
    /// <param name="ignoreCase">Whether to ignore case.</param>
    /// <returns>The parsed value.</returns>
    public static T? TryIntoEnum<T>(this scoped in ReadOnlySpan<char> s, bool ignoreCase = true)
        where T : struct =>
        Enum.TryParse(s, ignoreCase, out T result) ? result : null;
#endif
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryParse<T>(this string s)
        where T : struct =>
        Parse<T>(s, out var success) is var value && success ? value : null;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryParse<T>(this scoped in ReadOnlySpan<byte> s)
        where T : struct =>
        Parse<T>(s, out var success) is var value && success ? value : null;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryParse<T>(this scoped in ReadOnlySpan<char> s)
        where T : struct =>
        Parse<T>(s, out var success) is var value && success ? value : null;
#if NET7_0_OR_GREATER
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryInto<T>(this string s)
        where T : struct, IParsable<T> =>
        T.TryParse(s, CultureInfo.InvariantCulture, out var result) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryInto<T>(this string s, IFormatProvider? provider)
        where T : struct, IParsable<T> =>
        T.TryParse(s, provider, out var result) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryInto<T>(this scoped in ReadOnlySpan<byte> s)
        where T : struct, IUtf8SpanParsable<T> =>
        T.TryParse(s, CultureInfo.InvariantCulture, out var result) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryInto<T>(this scoped in ReadOnlySpan<byte> s, IFormatProvider? provider)
        where T : struct, IUtf8SpanParsable<T> =>
        T.TryParse(s, provider, out var result) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryInto<T>(this scoped in ReadOnlySpan<char> s)
        where T : struct, ISpanParsable<T> =>
        T.TryParse(s, CultureInfo.InvariantCulture, out var result) ? result : default;
    /// <inheritdoc cref="Parse{T}(string, out bool)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static T? TryInto<T>(this scoped in ReadOnlySpan<char> s, IFormatProvider? provider)
        where T : struct, ISpanParsable<T> =>
        T.TryParse(s, provider, out var result) ? result : default;
#endif
    static class FindTryParseFor<T>
    {
        [Pure]
        public delegate T? ByteParser(in ReadOnlySpan<byte> s, out bool success);
        [Pure]
        public delegate T? CharParser(in ReadOnlySpan<char> s, out bool success);
        [Pure]
        public delegate T? Parser(in string? s, out bool success);
        [Pure]
        delegate bool InByteParser(ReadOnlySpan<byte> s, CultureInfo info, out T? result);
        [Pure]
        delegate bool InCharParser(ReadOnlySpan<char> s, CultureInfo info, out T? result);
        [Pure]
        delegate bool InEnumByteParser(ReadOnlySpan<byte> s, bool ignoreCase, out T? result);
        [Pure]
        delegate bool InEnumCharParser(ReadOnlySpan<char> s, bool ignoreCase, out T? result);
        [Pure]
        delegate bool InEnumParser(string? s, bool ignoreCase, out T? result);
        [Pure]
        delegate bool InNumberByteParser(ReadOnlySpan<byte> s, CultureInfo info, NumberStyles style, out T? result);
        [Pure]
        delegate bool InNumberCharParser(ReadOnlySpan<char> s, CultureInfo info, NumberStyles style, out T? result);
        [Pure]
        delegate bool InNumberParser(string? s, CultureInfo info, NumberStyles style, out T? result);
        [Pure]
        delegate bool InParser(string? s, CultureInfo info, out T? result);
        const BindingFlags Flags = BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy;
        static readonly InByteParser? s_byteParse = Make<InByteParser>();
        static readonly InCharParser? s_charParse = Make<InCharParser>();
        static readonly InEnumByteParser? s_byteParseEnum = Make<InEnumByteParser>();
        static readonly InEnumCharParser? s_charParseEnum = Make<InEnumCharParser>();
        static readonly InEnumParser? s_parseEnum = Make<InEnumParser>();
        static readonly InNumberByteParser? s_byteParseNumber = Make<InNumberByteParser>();
        static readonly InNumberCharParser? s_charParseNumber = Make<InNumberCharParser>();
        static readonly InNumberParser? s_parseNumber = Make<InNumberParser>();
        static readonly InParser? s_parse = Make<InParser>();
        public static Parser WithString { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            s_parseNumber is not null ? ParseNumberInvoker :
            s_parseEnum is not null ? ParseEnumInvoker :
            s_parse is not null ? ParseInvoker : FailedParseInvoker;
        public static ByteParser WithByteSpan { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            s_byteParseNumber is not null ? ByteParseNumberInvoker :
            s_byteParseEnum is not null ? ByteParseEnumInvoker :
            s_byteParse is not null ? ByteParseInvoker : ByteFailedParseInvoker;
        public static CharParser WithCharSpan { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; } =
            s_charParseNumber is not null ? CharParseNumberInvoker :
            s_charParseEnum is not null ? CharParseEnumInvoker :
            s_charParse is not null ? CharParseInvoker : CharFailedParseInvoker;
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ByteFailedParseInvoker(in ReadOnlySpan<byte> _, out bool b)
        {
            b = false;
            return default;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ByteParseInvoker(in ReadOnlySpan<byte> s, out bool b)
        {
            b = s_byteParse!(s, CultureInfo.InvariantCulture, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ByteParseEnumInvoker(in ReadOnlySpan<byte> s, out bool b)
        {
            b = s_byteParseEnum!(s, true, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ByteParseNumberInvoker(in ReadOnlySpan<byte> s, out bool b)
        {
            b = s_byteParseNumber!(s, CultureInfo.InvariantCulture, NumberStyles.Any, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? CharFailedParseInvoker(in ReadOnlySpan<char> _, out bool b)
        {
            b = false;
            return default;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? CharParseInvoker(in ReadOnlySpan<char> s, out bool b)
        {
            b = s_charParse!(s, CultureInfo.InvariantCulture, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? CharParseEnumInvoker(in ReadOnlySpan<char> s, out bool b)
        {
            b = s_charParseEnum!(s, true, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? CharParseNumberInvoker(in ReadOnlySpan<char> s, out bool b)
        {
            b = s_charParseNumber!(s, CultureInfo.InvariantCulture, NumberStyles.Any, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? FailedParseInvoker(in string? _, out bool b)
        {
            b = false;
            return default;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ParseInvoker(in string? s, out bool b)
        {
            b = s_parse!(s, CultureInfo.InvariantCulture, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ParseEnumInvoker(in string? s, out bool b)
        {
            b = s_parseEnum!(s, true, out var result);
            return result;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
        static T? ParseNumberInvoker(in string? s, out bool b)
        {
            b = s_parseNumber!(s, CultureInfo.InvariantCulture, NumberStyles.Any, out var result);
            return result;
        }
        [Pure]
        static TDelegate? Make<TDelegate>()
            where TDelegate : Delegate =>
            typeof(TDelegate).GetMethod(nameof(Invoke))!.GetParameters() is var parameters &&
            Array.ConvertAll(parameters, x => x.ParameterType) is var types &&
            typeof(T)
               .GetMethods(Flags)
               .Where(x => x.Name is nameof(int.TryParse))
               .Select(x => x.IsGenericMethodDefinition && x.GetGenericArguments() is { Length: 1 } ? TryCoerce(x) : x)
               .FirstOrDefault(x => x.GetParameters().Select(x => x.ParameterType).SequenceEqual(types)) is { } method
                ? Delegate.CreateDelegate(typeof(TDelegate), method) as TDelegate
                : null;
        [MustUseReturnValue]
        static MethodInfo TryCoerce(MethodInfo x)
        {
            try
            {
                return x.MakeGenericMethod(typeof(T));
            }
            catch (ArgumentException)
            {
                return x;
            }
        }
    }
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable CheckNamespace RedundantNameQualifier
/// <summary>Provides extension methods for <see cref="char"/>.</summary>
    /// <summary>Removes the single character based on the index from the langword="string"/>.</summary>
    /// <param name="str">The builder to take the character from.</param>
    /// <param name="index">The index to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <returns>The parameter <paramref name="str"/>.</returns>
    public static string Pop(this string str, int index, out char popped)
    {
        if (index >= 0 && index < str.Length)
        {
            popped = str[index];
            return str.Remove(index, 1);
        }
        popped = default;
        return str;
    }
    /// <inheritdoc cref="Pop(StringBuilder, int, out char)"/>
    public static string Pop(this string str, Index index, out char popped) =>
        str.Pop(index.GetOffset(str.Length), out popped);
    /// <summary>Removes the substring based on the range from the langword="string"/>.</summary>
    /// <param name="str">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="str"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="str"/>.</returns>
    public static string Pop(this string str, Range range, out string popped)
    {
        range.GetOffsetAndLength(str.Length, out var startIndex, out var length);
        popped = str[range];
        return str.Remove(startIndex, length);
    }
    /// <summary>Removes the substring based on the range from the <see langword="string"/>.</summary>
    /// <param name="str">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="str"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="str"/>.</returns>
    public static string Remove(this string str, Range range)
    {
        range.GetOffsetAndLength(str.Length, out var startIndex, out var length);
        return str.Remove(startIndex, length);
    }
    /// <summary>Removes the single character based on the index from the <see cref="StringBuilder"/>.</summary>
    /// <param name="builder">The builder to take the character from.</param>
    /// <param name="index">The index to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
    public static StringBuilder Pop(this StringBuilder builder, int index, out char popped)
    {
        if (index >= 0 && index < builder.Length)
        {
            popped = builder[index];
            return builder.Remove(index, 1);
        }
        popped = default;
        return builder;
    }
    /// <inheritdoc cref="Pop(StringBuilder, int, out char)"/>
    public static StringBuilder Pop(this StringBuilder builder, Index index, out char popped) =>
        builder.Pop(index.GetOffset(builder.Length), out popped);
    /// <summary>Removes the substring based on the range from the <see cref="StringBuilder"/>.</summary>
    /// <param name="builder">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <param name="popped">The resulting character that was removed, or <see langword="default"/>.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="builder"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
    public static StringBuilder Pop(this StringBuilder builder, Range range, out string popped)
    {
        range.GetOffsetAndLength(builder.Length, out var startIndex, out var length);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        popped = string.Create(
            length,
            (builder, startIndex),
            static (span, tuple) =>
            {
                var (builder, startIndex) = tuple;
                for (var i = 0; i < span.Length; i++)
                    span[i] = builder[i + startIndex];
            }
        );
#else
        StringBuilder poppedBuilder = new(length);
        for (var i = 0; i < length; i++)
            poppedBuilder[i] = builder[startIndex + i];
        popped = $"{poppedBuilder}";
#endif
        return builder.Remove(startIndex, length);
    }
    /// <summary>Removes the substring based on the range from the <see cref="StringBuilder"/>.</summary>
    /// <param name="builder">The builder to take the character from.</param>
    /// <param name="range">The range to remove.</param>
    /// <exception cref="ArgumentOutOfRangeException">
    /// The parameter <paramref name="range"/> is out of range when indexing the parameter <paramref name="builder"/>.
    /// </exception>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
    public static StringBuilder Remove(this StringBuilder builder, Range range)
    {
        range.GetOffsetAndLength(builder.Length, out var startIndex, out var length);
        return builder.Remove(startIndex, length);
    }
#if ROSLYN || NETSTANDARD2_1_OR_GREATER
    /// <inheritdoc cref="string.Trim()"/>
    public static Memory<char> Trim(this Memory<char> memory) => memory.TrimStart().TrimEnd();
    /// <inheritdoc cref="string.Trim()"/>
    public static ReadOnlyMemory<char> Trim(this ReadOnlyMemory<char> memory) => memory.TrimStart().TrimEnd();
    /// <inheritdoc cref="string.TrimStart(char[])"/>
    public static Memory<char> TrimStart(this Memory<char> memory)
    {
        var span = memory.Span;
        for (var i = 0; i < span.Length; i++)
            if (!char.IsWhiteSpace(span[i]))
                return memory[..i];
        return default;
    }
    /// <inheritdoc cref="string.TrimStart(char[])"/>
    public static ReadOnlyMemory<char> TrimStart(this ReadOnlyMemory<char> memory)
    {
        var span = memory.Span;
        for (var i = 0; i < span.Length; i++)
            if (!char.IsWhiteSpace(span[i]))
                return memory[..i];
        return default;
    }
    /// <inheritdoc cref="string.TrimEnd(char[])"/>
    public static Memory<char> TrimEnd(this Memory<char> memory)
    {
        var span = memory.Span;
        for (var i = span.Length - 1; i >= 0; i--)
            if (!char.IsWhiteSpace(span[i]))
                return memory[i..];
        return default;
    }
    /// <inheritdoc cref="string.TrimEnd(char[])"/>
    public static ReadOnlyMemory<char> TrimEnd(this ReadOnlyMemory<char> memory)
    {
        var span = memory.Span;
        for (var i = span.Length - 1; i >= 0; i--)
            if (!char.IsWhiteSpace(span[i]))
                return memory[i..];
        return default;
    }
#endif
    /// <inheritdoc cref="string.Trim()"/>
    public static StringBuilder Trim(this StringBuilder builder) => builder.TrimStart().TrimEnd();
    /// <inheritdoc cref="string.TrimEnd(char[])"/>
    public static StringBuilder TrimEnd(this StringBuilder builder)
    {
        for (var i = builder.Length - 1; i >= 0; i--)
            if (!char.IsWhiteSpace(builder[i]))
                return builder.Remove(i + 1, builder.Length - i - 1);
        return builder.Remove(0, builder.Length);
    }
    /// <inheritdoc cref="string.TrimStart(char[])"/>
    public static StringBuilder TrimStart(this StringBuilder builder)
    {
        for (var i = 0; i < builder.Length; i++)
            if (!char.IsWhiteSpace(builder[i]))
                return builder.Remove(0, i);
        return builder.Remove(0, builder.Length);
    }
// SPDX-License-Identifier: MPL-2.0
#if NETFRAMEWORK || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
// ReSharper disable ConditionalAccessQualifierIsNonNullableAccordingToAPIContract CheckNamespace RedundantNameQualifier RedundantUsingDirective UseSymbolAlias
#if WAWA
namespace Wawa.Modules;
#else
#endif
#if !(NET20 || NET30)
#endif
/// <summary>Provides stringification methods.</summary>
// ReSharper disable once BadPreprocessorIndent
#if WAWA
public
#endif
    const int MaxIteration = 32, MaxRecursion = 3;
    unsafe delegate nuint VoidPointer(void* v);
#if !WAWA
    const RegexOptions Options = RegexOptions.Multiline | RegexOptions.Compiled;
#endif
    const string
        Apology = "I am so sorry that you have to deal with double pointers, but this cannot be supported.",
        BitFlagSeparator = " | ",
        Else = "th",
        EqualityContract = nameof(EqualityContract),
        False = "false",
        FirstOrd = "st",
#if !NET461_OR_GREATER && !NETSTANDARD2_0_OR_GREATER && !NETCOREAPP2_0_OR_GREATER
        HexCharactersTable = "0123456789ABCDEF",
#endif
        Invalid = $"!<{nameof(InvalidOperationException)}>",
        KeyValueSeparator = ": ",
        Null = "null",
        SecondOrd = "nd",
        Separator = ", ",
        Slashes = @"/\",
        ThirdOrd = "rd",
        True = "true",
        Unsupported = $"!<{nameof(NotSupportedException)}>",
        UnsupportedPlatform = $"!<{nameof(PlatformNotSupportedException)}>";
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    static readonly Dictionary<Type, bool>
#if !WAWA
        s_fullyUnmanaged = [],
#endif
        s_hasMethods = [];
    static readonly Dictionary<Type, Delegate> s_stringifiers = [];
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    static readonly Dictionary<Type, string> s_unfoldedNames = new()
    {
        [typeof(bool)] = "bool",
        [typeof(byte)] = "byte",
        [typeof(char)] = "char",
        [typeof(decimal)] = "decimal",
        [typeof(double)] = "double",
        [typeof(float)] = "float",
        [typeof(int)] = "int",
        [typeof(long)] = "long",
        [typeof(nint)] = "nint",
        [typeof(nuint)] = "nuint",
        [typeof(object)] = "object",
        [typeof(sbyte)] = "sbyte",
        [typeof(short)] = "short",
        [typeof(string)] = "string",
        [typeof(uint)] = "uint",
        [typeof(ulong)] = "ulong",
        [typeof(ushort)] = "ushort",
        [typeof(void)] = "void",
    };
#endif
    static readonly ConstantExpression
        s_exEmpty = Constant(""),
#if !NETFRAMEWORK || NET40_OR_GREATER
        s_exInvalid = Constant(Invalid),
        s_exUnsupported = Constant(Unsupported),
        s_exUnsupportedPlatform = Constant(UnsupportedPlatform),
#endif
        s_exSeparator = Constant(Separator),
        s_exTrue = Constant(true);
    static readonly unsafe MethodInfo s_readVoidPointer = ((VoidPointer)ReadVoidPointer).Method;
    static readonly MethodInfo
        s_boolStringify = ((Func<bool, int, bool, string>)Stringify).Method,
        s_combine = ((Func<string, string, string>)string.Concat).Method,
        s_readPointer = s_boolStringify.DeclaringType!
           .GetMethod(nameof(ReadPointer), BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)!
           .GetGenericMethodDefinition(),
        s_stringify = s_boolStringify.GetGenericMethodDefinition();
#endif
#if !WAWA
#if NET8_0_OR_GREATER
    static readonly OnceMemoryManager<SearchValues<char>> s_slashes = new(SearchValues.Create(Slashes));
#endif
#pragma warning disable MA0110, SYSLIB1045
    static readonly Regex
        s_parentheses = new(@"\((?>(?:\((?<A>)|\)(?<-A>)|[^()]+){2,})\)", Options),
        s_brackets = new(@"\[(?>(?:\[(?<A>)|\](?<-A>)|[^\[\]]+){2,})\]", Options),
        s_curlies = new("{(?>(?:{(?<A>)|}(?<-A>)|[^{}]+){2,})}", Options),
        s_angles = new("<(?>(?:<(?<A>)|>(?<-A>)|[^<>]+){2,})>", Options),
        s_quotes = new(@"""(?>(?:{(?<A>)|}(?<-A>)|[^""]+){2,})""", Options);
#pragma warning restore MA0110, SYSLIB1045
#endif
    /// <summary>Gets the field count of the version.</summary>
    /// <param name="version">The <see cref="Version"/> to use.</param>
    /// <returns>The field count of the parameter <paramref name="version"/>.</returns>
    [Pure]
    public static int FieldCount(
#if !WAWA
        this
#endif
            Version? version
    ) =>
        version switch
        {
            (_, <= 0, <= 0, <= 0) => 1,
            (_, _, <= 0, <= 0) => 2,
            (_, _, _, <= 0) => 3,
            _ => 4,
        };
#if !WAWA
    /// <summary>Creates the collapsed form of the string.</summary>
    /// <param name="s">The string to collapse.</param>
    /// <returns>The collapsed string.</returns>
    public static string Collapse(this string s)
    {
        s = s_parentheses.Replace(s, "()");
        s = s_brackets.Replace(s, "[]");
        s = s_curlies.Replace(s, "{}");
        s = s_angles.Replace(s, "<>");
        return s_quotes.Replace(s, "\"\"");
    }
    /// <summary>Collapses the <see cref="string"/> to a single line.</summary>
    /// <param name="expression">The <see cref="string"/> to collapse.</param>
    /// <param name="prefix">The prefix to use.</param>
    /// <returns>The collapsed <see cref="string"/>.</returns>
    [Pure]
    [return: NotNullIfNotNull(nameof(expression))]
    public static string? CollapseToSingleLine(this string? expression, string? prefix = null)
    {
#if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
        static unsafe StringBuilder Accumulator(StringBuilder accumulator, scoped ReadOnlySpan<char> next)
        {
            var trimmed = next.Trim();
            fixed (char* ptr = &trimmed[0])
                accumulator.Append(ptr, trimmed.Length).Append(' ');
            return accumulator;
        }
        return expression?.Collapse()
           .SplitSpanLines()
           .Aggregate(new StringBuilder(prefix), Accumulator)
           .Trim()
           .ToString();
#else
        return expression
          ?.Collapse()
           .Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries)
           .Select(x => x.Trim())!
           .Prepend(prefix)
           .Conjoin("");
#endif
    }
    /// <summary>Converts a number to an ordinal.</summary>
    /// <param name="i">The number to convert.</param>
    /// <param name="one">The string for the value 1 or -1.</param>
    /// <param name="many">The string to concatenate. Use prefixed dashes to trim <paramref name="one"/>.</param>
    /// <returns>The conjugation of all the parameters.</returns>
    [Pure]
    public static string Conjugate(this int i, string one, string many = "s") =>
        i is not 1 and not -1 &&
#if NET7_0_OR_GREATER
        (many.AsSpan().IndexOfAnyExcept('-') is not -1 and var found ? found : 0)
#else
        Math.Min(many.TakeWhile(x => x is '-').Count(), one.Length)
#endif
        is var trim
            ? $"{i} {one[..^trim]}{many[trim..]}"
            : $"{i} {one}";
#if NET7_0_OR_GREATER
    /// <inheritdoc cref="Conjugate(int, string, string)"/>
    [Pure]
    public static string Conjugate<T>(this T i, string one, string many = "s")
        where T : INumberBase<T>, IComparisonOperators<T, T, bool> =>
        (T.IsZero(i) || T.Abs(i) > T.One) && (many.AsSpan().IndexOfAnyExcept('-') is not -1 and var f ? f : 0) is var tr
            ? $"{i} {one[..^tr]}{many[tr..]}"
            : $"{i} {one}";
#endif
    /// <summary>Extracts the file name from the path.</summary>
    /// <remarks><para>
    /// The return type depends on what framework is used. Ensure that the caller doesn't care about the return type.
    /// </para></remarks>
    /// <param name="path">The path to extract the file name from.</param>
    /// <returns>The file name.</returns>
    [Pure]
#if !ROSLYN && !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP2_1_OR_GREATER
    [return: NotNullIfNotNull(nameof(path))]
#endif
    public static
#if ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        ReadOnlyMemory<char>
#else
        string
#endif
        FileName(this string? path) =>
        path is null
#if NET8_0_OR_GREATER
            ? default
            : path.SplitOn(s_slashes).Last.Trim();
#elif ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
            ? default
            : path.SplitOnAny(Slashes.AsMemory()).Last.Trim();
#else
            ? ""
            : Path.GetFileName(path).Trim() ?? "";
#endif
    /// <summary>Extracts the file name from the path.</summary>
    /// <remarks><para>
    /// The return type depends on what framework is used. Ensure that the caller doesn't care about the return type.
    /// </para></remarks>
    /// <param name="path">The path to extract the file name from.</param>
    /// <returns>The file name.</returns>
    [Pure]
#if !ROSLYN && !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP2_1_OR_GREATER
    [return: NotNullIfNotNull(nameof(path))]
#endif
    public static
#if ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
        ReadOnlyMemory<char>
#else
        string
#endif
        UntrimmedFileName(this string? path) =>
        path is null
#if NET8_0_OR_GREATER
            ? default
            : path.SplitOn(s_slashes).Last;
#elif ROSLYN || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER
            ? default
            : path.SplitOnAny(Slashes.AsMemory()).Last;
#else
            ? ""
            : Path.GetFileName(path) ?? "";
#endif
    /// <summary>Creates the prettified form of the string.</summary>
    /// <param name="s">The string to prettify.</param>
    /// <returns>The prettified string.</returns>
    public static string Prettify(this string s) => Prettify(s, separator: ",;");
    /// <summary>Creates the prettified form of the string.</summary>
    /// <remarks><para>
    /// The functionality is based on
    /// <a href="https://gist.github.com/kodo-pp/89cefb17a8772cd9fd7b875d94fd29c7">this gist by kodo-pp</a>.
    /// </para></remarks>
    /// <param name="s">The string to prettify.</param>
    /// <param name="start">The characters considered to be starting blocks.</param>
    /// <param name="end">The characters considered to be ending blocks.</param>
    /// <param name="separator">The characters considered to be separators.</param>
    /// <param name="indent">The amount of spaces for indentation.</param>
    /// <returns>The prettified string.</returns>
    public static string Prettify(
        this string s,
        string start = "([{<",
        string end = ")]}>",
        string separator = ",;",
        string indent = "    "
    )
    {
        var seen = false;
        var nest = 0;
        StringBuilder sb = new();
        for (var i = 0; i < s.Length; i++)
            (seen, nest, sb) = s[i] switch
            {
                not ' ' when seen && sb.Indent(indent, nest) is var _ && (seen = false) => throw Unreachable,
                _ when start.Contains(s[i]) && (s.Nth(i + 1) is not { } next || !end.Contains(next)) =>
                    (seen, ++nest, sb.Append(s[i]).Indent(indent, nest)),
                _ when end.Contains(s[i]) && (s.Nth(i - 1) is not { } prev || !start.Contains(prev)) =>
                    (seen, --nest, sb.Indent(indent, nest).Append(s[i])),
                _ when separator.Contains(s[i]) => (true, nest, sb.Append(s[i])),
                ' ' when seen && nest > 0 ||
                    s.Nth(i - 1) is { } prev && start.Contains(prev) ||
                    s.Nth(i + 1) is { } next && end.Contains(next) => (seen, nest, sb),
                _ => (seen, nest, sb.Append(s[i])),
            };
        return $"{sb}";
    }
#endif
#if NET40_OR_GREATER || NETSTANDARD || NETCOREAPP
    /// <summary>Concatenates an enumeration of <see cref="char"/> into a <see cref="string"/>.</summary>
    /// <remarks><para>
    /// This method is more efficient than using <see cref="Conjoin{T}(IEnumerable{T}, string)"/>
    /// for <see cref="char"/> enumerations.
    /// </para></remarks>
    /// <param name="chars">The enumeration of characters.</param>
    /// <returns>A <see cref="string"/> built from concatenating <paramref name="chars"/>.</returns>
    [Pure]
    public static string Concat([InstantHandle] this IEnumerable<char> chars) => string.Concat(chars);
#endif
    /// <summary>Joins a set of values into one long <see cref="string"/>.</summary>
    /// <remarks><para>
    /// This method is more efficient than using
    /// <see cref="Conjoin{T}(IEnumerable{T}, string)"/> for <see cref="char"/> separators.
    /// </para></remarks>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>One long <see cref="string"/>.</returns>
    [Pure]
    public static string Conjoin<T>(
        [InstantHandle]
#if !WAWA
        this
#endif
            IEnumerable<T> values,
        char separator
    ) =>
        $"{new StringBuilder().AppendMany(values, separator)}";
    /// <summary>Joins a set of values into one long <see cref="string"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>One long <see cref="string"/>.</returns>
    [Pure]
    public static string Conjoin<T>(
        [InstantHandle]
#if !WAWA
        this
#endif
            IEnumerable<T> values,
        string separator = Separator
    ) =>
        $"{new StringBuilder().AppendMany(values, separator)}";
    /// <summary>Converts the <see cref="Stopwatch"/> to its concise <see cref="string"/> representation.</summary>
    /// <param name="stopwatch">The <see cref="Stopwatch"/> to convert.</param>
    /// <returns>The <see cref="string"/> representation of <paramref name="stopwatch"/>.</returns>
    [Pure]
    public static string ToConciseString(
        this
#if !WAWA
            Stopwatch? stopwatch
#endif
    ) =>
        stopwatch is null ? "0" : ToConciseString(stopwatch.Elapsed);
    /// <summary>Converts the <see cref="TimeSpan"/> to its concise <see cref="string"/> representation.</summary>
    /// <param name="time">The <see cref="TimeSpan"/> to convert.</param>
    /// <returns>The <see cref="string"/> representation of <paramref name="time"/>.</returns>
    [Pure]
    public static string ToConciseString(
#if !WAWA
        this
#endif
        TimeSpan time
    )
    {
        var sign = time.Ticks < 0 ? "-" : "";
        var ticks = Math.Abs(time.Ticks);
        return ticks switch
        {
            0 => "0",
            >= TimeSpan.TicksPerDay * 7 => $"{sign}{ticks / TimeSpan.TicksPerDay}d",
            >= TimeSpan.TicksPerDay => $"{sign}{ticks / TimeSpan.TicksPerDay
            }d{ticks % TimeSpan.TicksPerDay / TimeSpan.TicksPerHour
            }h",
            >= TimeSpan.TicksPerHour => $"{sign}{ticks / TimeSpan.TicksPerHour
            }h{ticks % TimeSpan.TicksPerHour / TimeSpan.TicksPerMinute
            }m{ticks % TimeSpan.TicksPerMinute / TimeSpan.TicksPerSecond}s",
            >= TimeSpan.TicksPerMinute => $"{sign}{ticks / TimeSpan.TicksPerMinute
            }m{ticks % TimeSpan.TicksPerMinute / TimeSpan.TicksPerSecond}s",
            >= TimeSpan.TicksPerSecond => $"{sign}{Math.Round(ticks / (double)TimeSpan.TicksPerSecond, 1)}s",
            >= TimeSpan.TicksPerMillisecond => $"{sign}{Math.Round(ticks / (double)TimeSpan.TicksPerMillisecond, 1)}ms",
            _ => $"{sign}{ticks / 10.0}s",
        };
    }
    /// <summary>Converts a <see cref="Pointer"/> to a <see cref="string"/>.</summary>
    /// <param name="value">The <see cref="Pointer"/> to convert.</param>
    /// <returns>The <see cref="string"/> representation of <paramref name="value"/>.</returns>
    [CLSCompliant(false), Pure]
    public static unsafe string ToHexString(
#if !WAWA
        this
#endif
            Pointer? value
    ) =>
        (value is null ? 0 : (nuint)Pointer.Unbox(value)).ToHexString();
    /// <summary>Gets the short display form of the version.</summary>
    /// <param name="version">The <see cref="Version"/> to convert.</param>
    /// <returns>The full name of the parameter <paramref name="version"/>.</returns>
    [Pure]
    public static string ToShortString(
#if !WAWA
        this
#endif
            Version? version
    )
    {
        if (version is not var (major, minor, build, revision) ||
            major <= 0 && minor <= 0 && build <= 0 && revision <= 0)
            return "v0";
        var length = Length(major, revision, minor, build);
        Span<char> span = stackalloc char[length];
        Format(span, version);
        return span.ToString();
    }
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
#if !WAWA
    /// <summary>Gets the full type name, with its generics extended.</summary>
    /// <param name="type">The <see cref="Type"/> to get the full name of.</param>
    /// <returns>The full name of the parameter <paramref name="type"/>.</returns>
    [Pure]
    public static string UnfoldedFullName(this Type? type) =>
        type is null ? Null :
        s_unfoldedNames.TryGetValue(type, out var val) ? val :
        s_unfoldedNames[type] = $"{type.UnfoldedName(new(), x => x.FullName)}";
#endif
    /// <summary>Gets the type name, with its generics extended.</summary>
    /// <param name="type">The <see cref="Type"/> to get the name of.</param>
    /// <returns>The name of the parameter <paramref name="type"/>.</returns>
    [Pure]
    public static string UnfoldedName(
#if !WAWA
        this
#endif
            Type? type
    ) =>
        type is null ? Null :
        s_unfoldedNames.TryGetValue(type, out var val) ? val :
        s_unfoldedNames[type] = $"{type.UnfoldedName(new(), x => x.Name)}";
#endif
    /// <summary>Converts a number to an ordinal.</summary>
    /// <param name="i">The number to convert.</param>
    /// <param name="indexByZero">Determines whether to index from zero or one.</param>
    /// <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
    [Pure]
    public static string Nth(
#if !WAWA
        this
#endif
            int i,
        bool indexByZero = false
    ) =>
        indexByZero ? (i + 1).ToOrdinal() : i.ToOrdinal();
    /// <inheritdoc cref="string.Split(string[], StringSplitOptions)"/>
    public static string[] Chop(
#if !WAWA
        this
#endif
            string source,
        string separator
    ) =>
        source.Split(separator.ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(
#if !WAWA
        this
#endif
            T? source
    ) =>
        Stringify(source, MaxRecursion);
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <param name="depth">Determines how deep the recursive function should go.</param>
    /// <param name="useQuotes">
    /// Determines whether <see cref="string"/> and <see cref="char"/> have a " and ' surrounding them.
    /// </param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(
#if !WAWA
        this
#endif
            T? source,
        int depth,
        bool useQuotes = false
    ) =>
        source switch
        {
            null => Null,
            true => True,
            false => False,
            nint x => $"{x}",
            nuint x => $"{x}",
            char x => useQuotes ? Escape(x) : $"{x}",
            string x => useQuotes ? @$"""{x}""" : x,
            Enum x when x.AsInt() is var i && x.GetType().IsDefined(typeof(FlagsAttribute), false) is var b =>
                $"{x.GetType().Name}({(b ? $"0x{i:x}" : i)}) = {(b
                    ? Conjoin(i.AsBits().Select(x.GetType().Into), BitFlagSeparator)
                    : x)}",
            TimeSpan x => ToConciseString(x),
            Type x => UnfoldedName(x),
            Pointer x => ToHexString(x),
            Version x => ToShortString(x),
#if KTANE
            Object x => x.name,
#endif
            IConvertible x => x.ToString(CultureInfo.InvariantCulture),
            ICustomFormatter x => x.Format("", x, CultureInfo.InvariantCulture),
            _ when depth <= 0 =>
#if NET20 || NET30 || !(!NETSTANDARD || NETSTANDARD2_0_OR_GREATER)
                source.ToString(),
#else
                source.StringifyObject(depth - 1),
#endif
#if NET40_OR_GREATER || NETSTANDARD || NETCOREAPP
            IEnumerable<char> x => useQuotes ? @$"""{x.Concat()}""" : x.Concat(),
#else
            IEnumerable<char> x => useQuotes ? @$"""{Conjoin(x, "")}""" : Conjoin(x, ""),
#endif
            IDictionary { Count: 0 } => "{ }",
            IDictionary x => $"{{ {x.DictionaryStringifier(depth - 1, useQuotes)} }}",
            ICollection { Count: var count } x => Count(x, depth - 1, useQuotes, count),
            IEnumerable x => $"[{EnumeratorStringifier(x.GetEnumerator(), depth - 1, useQuotes)}]",
#if NET471_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER
            ITuple x => $"({EnumeratorStringifier(x.AsEnumerable().GetEnumerator(), depth - 1, useQuotes)})",
#endif
#if !NETFRAMEWORK || NET40_OR_GREATER
            IStructuralComparable x when new FakeComparer(depth - 1) is var c && x.CompareTo(x, c) is var _ => $"{c}",
            IStructuralEquatable x when new FakeComparer(depth - 1) is var c && x.GetHashCode(c) is var _ => $"{c}",
#endif
#if ROSLYN
            ISymbol x => x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
#endif
#if NET20 || NET30 || !(!NETSTANDARD || NETSTANDARD2_0_OR_GREATER)
            _ => source.ToString(),
#else
            _ => source.StringifyObject(depth - 1),
#endif
        };
#if !NET461_OR_GREATER && !NETSTANDARD2_0_OR_GREATER && !NETCOREAPP2_0_OR_GREATER
    /// <summary>Converts the value to a hex <see cref="string"/>.</summary>
    /// <remarks><para>The implementation is based on
    /// <a href="https://github.com/CommunityToolkit/dotnet/blob/7b53ae23dfc6a7fb12d0fc058b89b6e948f48448/src/CommunityToolkit.Diagnostics/Extensions/ValueTypeExtensions.cs#L44">
    /// CommunityToolkit.Diagnostics.ValueTypeExtensions.ToHexString
    /// </a>.
    /// </para></remarks>
    /// <typeparam name="T">The type of the value.</typeparam>
    /// <param name="value">The value to convert.</param>
    /// <returns>The hex <see cref="string"/>.</returns>
    [Pure]
#if !WAWA
    public
#endif
        static unsafe string ToHexString<T>(this T value)
#if KTANE
        where T : struct
#else
        where T : unmanaged
#endif
#pragma warning disable 8500
    {
        var p = stackalloc char[sizeof(T) * 2];
        p[0] = '0';
        p[1] = 'x';
        fixed (char* rh = HexCharactersTable)
            for (int i = 0, j = sizeof(T) * 2; i < sizeof(T); i++, j -= 2)
            {
                var b = ((byte*)&value)[i];
                var low = b & 0x0f;
                var high = (b & 0xf0) >> 4;
                p[j + 1] = *(rh + low);
                p[j] = *(rh + high);
            }
        return new(p, 0, sizeof(T) * 2 + 2);
    }
#pragma warning restore 8500
#endif
    /// <summary>Forces the use of reflective stringification.</summary>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <param name="depth">The amount of nesting.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
#if !WAWA
    public
#endif
        static string UseStringifier<T>(this T source, int depth = MaxRecursion)
    {
        if (!typeof(T).IsValueType && source is null)
            return Null;
        if (!s_stringifiers.ContainsKey(typeof(T)))
            s_stringifiers[typeof(T)] = GenerateStringifier<T>();
        var name = source?.GetType() is { } type && type != typeof(T)
            ? $"{UnfoldedName(type)} as {UnfoldedName(typeof(T))}"
            : UnfoldedName(typeof(T));
        return ((Func<T, int, string>)s_stringifiers[typeof(T)])(source, depth) is not "" and var str
            ? $"{name} {{ {str} }}"
            : name;
    }
#if NET6_0_OR_GREATER
    /// <summary>Appends an enumeration onto the <see cref="DefaultInterpolatedStringHandler"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="dish">
    /// The <see cref="DefaultInterpolatedStringHandler"/> to mutate and <see langword="return"/>.
    /// </param>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>The parameter <paramref name="dish"/>.</returns>
    public static DefaultInterpolatedStringHandler AppendMany<T>(
        this ref DefaultInterpolatedStringHandler dish,
        [InstantHandle] IEnumerable<T> values,
        char separator
    )
    {
        using var enumerator = values.GetEnumerator();
        if (enumerator.MoveNext())
            dish.AppendFormatted(enumerator.Current);
        else
            return dish;
        while (enumerator.MoveNext())
        {
            dish.AppendFormatted(separator);
            dish.AppendFormatted(enumerator.Current);
        }
        return dish;
    }
    /// <summary>Appends an enumeration onto the <see cref="DefaultInterpolatedStringHandler"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="dish">
    /// The <see cref="DefaultInterpolatedStringHandler"/> to mutate and <see langword="return"/>.
    /// </param>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>The parameter <paramref name="dish"/>.</returns>
    public static DefaultInterpolatedStringHandler AppendMany<T>(
        this ref DefaultInterpolatedStringHandler dish,
        [InstantHandle] IEnumerable<T> values,
        string separator = Separator
    )
    {
        if (separator is "")
            switch (values)
            {
                case char[] x:
                    dish.AppendFormatted(x);
                    return dish;
                case string x:
                    dish.AppendFormatted(x);
                    return dish;
            }
        using var enumerator = values.GetEnumerator();
        if (enumerator.MoveNext())
            dish.AppendFormatted(enumerator.Current);
        else
            return dish;
        while (enumerator.MoveNext())
        {
            dish.AppendLiteral(separator);
            dish.AppendFormatted(enumerator.Current);
        }
        return dish;
    }
#endif
    /// <summary>Appends an enumeration onto the <see cref="StringBuilder"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="builder">The <see cref="StringBuilder"/> to mutate and <see langword="return"/>.</param>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
#if !WAWA
    public
#endif
        static StringBuilder AppendMany<T>(
            this StringBuilder builder,
            [InstantHandle] IEnumerable<T> values,
            char separator
        )
    {
        using var enumerator = values.GetEnumerator();
        if (enumerator.MoveNext())
            builder.Append(enumerator.Current);
        else
            return builder;
        while (enumerator.MoveNext())
            builder.Append(separator).Append(enumerator.Current);
        return builder;
    }
    /// <summary>Appends an enumeration onto the <see cref="StringBuilder"/>.</summary>
    /// <typeparam name="T">The type of each item in the collection.</typeparam>
    /// <param name="builder">The <see cref="StringBuilder"/> to mutate and <see langword="return"/>.</param>
    /// <param name="values">The values to join.</param>
    /// <param name="separator">The separator between each item.</param>
    /// <returns>The parameter <paramref name="builder"/>.</returns>
#if !WAWA
    public
#endif
        static StringBuilder AppendMany<T>(
            this StringBuilder builder,
            [InstantHandle] IEnumerable<T> values,
            string separator = Separator
        )
    {
        if (separator is "")
            switch (values)
            {
                case char[] x: return builder.Append(x);
                case string x: return builder.Append(x);
            }
        using var enumerator = values.GetEnumerator();
        if (enumerator.MoveNext())
            builder.Append(enumerator.Current);
        else
            return builder;
        while (enumerator.MoveNext())
            builder.Append(separator).Append(enumerator.Current);
        return builder;
    }
#if !WAWA
    /// <summary>Gets the type name, with its generics extended.</summary>
    /// <param name="type">The <see cref="Type"/> to get the name of.</param>
    /// <returns>The name of the parameter <paramref name="type"/>.</returns>
    [Pure]
    public static bool IsUnmanaged([NotNullWhen(true)] this Type? type) =>
        type is not null &&
        (s_fullyUnmanaged.TryGetValue(type, out var answer) ? answer :
            !type.IsValueType ? s_fullyUnmanaged[type] = false :
            type.IsEnum || type.IsPointer || type.IsPrimitive ? s_fullyUnmanaged[type] = true :
            s_fullyUnmanaged[type] = type.IsGenericTypeDefinition
                ? type
                   .GetCustomAttributes()
                   .Any(x => x?.GetType().FullName is "System.Runtime.CompilerServices.IsUnmanagedAttribute")
                : Array.TrueForAll(
                    type.GetFields(
                        BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic
                    ),
                    x => IsUnmanaged(x.FieldType)
                ));
#endif
    static void AppendKeyValuePair(this StringBuilder builder, string key, string value) =>
        builder.Append(key).Append(KeyValueSeparator).Append(value);
    static void Push(char c, scoped ref Span<char> span)
    {
        span[0] = c;
        span = span.UnsafelySkip(1);
    }
    static void Push([NonNegativeValue] int next, scoped ref Span<char> span)
    {
        var it = next.TryFormat(span, out var slice);
        System.Diagnostics.Debug.Assert(it, "TryFormat");
        span = span.UnsafelySkip(slice);
    }
    static void Push([NonNegativeValue] int next, char c, scoped ref Span<char> span)
    {
        Push(next, ref span);
        Push(c, ref span);
    }
    static void Format(scoped Span<char> span, Version version)
    {
        Push('v', ref span);
        switch (version)
        {
            case (var major, var minor, var build, > 0 and var revision):
                Push(major, '.', ref span);
                Push(minor, '.', ref span);
                Push(build, '.', ref span);
                Push(revision, ref span);
                break;
            case (var major, var minor, > 0 and var build):
                Push(major, '.', ref span);
                Push(minor, '.', ref span);
                Push(build, ref span);
                break;
            case (var major, > 0 and var minor):
                Push(major, '.', ref span);
                Push(minor, ref span);
                break;
            default:
                Push(version.Major, ref span);
                break;
        }
        System.Diagnostics.Debug.Assert(span.IsEmpty, "span is drained");
    }
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    [MustUseReturnValue]
    static bool CanUse(PropertyInfo p) =>
        p is { CanRead: true, PropertyType.Name: not "SyntaxTree" } &&
        p.GetIndexParameters().Length is 0 &&
        Array.TrueForAll(p.GetCustomAttributes(true), x => x?.GetType() != typeof(ObsoleteAttribute));
#endif
    [Pure]
    static bool IsEqualityContract(PropertyInfo x) =>
        x is { CanRead: true, CanWrite: false, Name: EqualityContract } &&
        x.PropertyType == typeof(Type) &&
        x.GetIndexParameters().Length is 0;
    [Pure]
    static bool IsRecord<T>() =>
        Array.Exists(
            typeof(T).GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic),
            IsEqualityContract
        );
    [Pure]
    static int Length(int major, int revision, int minor, int build) =>
        (major.DigitCount() + 1 is var length && revision > 0 ?
            minor.DigitCount() + build.DigitCount() + revision.DigitCount() + 3 :
            build > 0 ? minor.DigitCount() + build.DigitCount() + 2 :
                minor > 0 ? minor.DigitCount() + 1 : 0) +
        length;
    [Inline, Pure]
    static int Mod(this int i) => Math.Abs(i) / 10 % 10 is 1 ? 0 : Math.Abs(i) % 10;
    [MustUseReturnValue]
    static string Count(IEnumerable e, int depth, bool useQuotes, int count) =>
        count is 0
            ? "[Count: 0]"
            : $"[Count: {count}; {EnumeratorStringifier(e.GetEnumerator(), depth, useQuotes, count)}]";
    [Pure]
    static string Escape(char c) =>
        c switch
        {
            '\'' => "'\\''",
            '\"' => "'\\\"'",
            '\\' => @"'\\'",
            '\0' => "'\\0'",
            '\a' => "'\\a'",
            '\b' => "'\\b'",
            '\f' => "'\\f'",
            '\n' => "'\\n'",
            '\r' => "'\\r'",
            '\t' => "'\\t'",
            '\v' => "'\\v'",
            _ => $"{c}",
        };
    [Pure]
    static string Etcetera(this int? i) => i is null ? "" : $"{i} more";
    [Pure]
    static string ToOrdinal(this int i) =>
        $"{i}{Mod(i) switch
        {
            1 => FirstOrd,
            2 => SecondOrd,
            3 => ThirdOrd,
            _ => Else,
        }}";
    [Pure]
    static object Into(this Type type, int i) =>
#if !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
        Enum.ToObject(type, i);
#else
        Enum.Parse(type, $"{i}");
#endif
    [MustUseReturnValue]
    static StringBuilder EnumeratorStringifier(
        [HandlesResourceDisposal] this IEnumerator iterator,
        [NonNegativeValue] int depth,
        bool useQuotes,
        [NonNegativeValue] int? count = null
    )
    {
        try
        {
            StringBuilder builder = new();
            if (iterator.MoveNext())
                builder.Append(Stringify(iterator.Current, depth, useQuotes));
            var i = 0;
            while (iterator.MoveNext())
            {
                if (checked(++i) >= MaxIteration)
                {
                    builder.Append(Separator).Append(Etcetera(count - i));
                    break;
                }
                builder.Append(Separator).Append(Stringify(iterator.Current, depth, useQuotes));
            }
            return builder;
        }
        finally
        {
            (iterator as IDisposable)?.Dispose();
        }
    }
#if !WAWA
    [MustUseReturnValue]
    static StringBuilder Indent(this StringBuilder sb, string indent, int nest)
    {
        sb.AppendLine();
        for (var i = 0; i < nest && nest >= 0; i++)
            sb.Append(indent);
        return sb;
    }
#endif
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    [MustUseReturnValue]
    static string StringifyObject<T>(this T source, int depth)
    {
        if (source is null)
            return Null;
        if (!s_hasMethods.ContainsKey(typeof(T)))
            s_hasMethods[typeof(T)] =
                source.GetType().GetMethod(nameof(ToString), Type.EmptyTypes)?.DeclaringType != typeof(object) &&
                !IsRecord<T>();
        if (depth < 0)
            return s_hasMethods[typeof(T)] ? source.ToString() ?? Null : UnfoldedName(source.GetType());
        if (source.GetType() is var t && t != typeof(T))
            return (string)s_stringify.MakeGenericMethod(t).Invoke(null, [source, depth, false])!;
        return UseStringifier(source, depth);
    }
    [MustUseReturnValue]
    static Func<T, int, string> GenerateStringifier<T>()
    {
        static MethodCallExpression Combine(Expression prev, Expression curr)
        {
            var call = Call(s_combine, prev, s_exSeparator);
            return Call(s_combine, call, curr);
        }
        const BindingFlags Flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy;
        ParameterExpression
            exInstance = Parameter(typeof(T), nameof(T)),
            exDepth = Parameter(typeof(int), nameof(Int32));
        var deepProperties = typeof(T).IsInterface ? typeof(T).GetInterfaces().SelectMany(x => x.GetProperties()) : [];
        var deepFields = typeof(T).IsInterface ? typeof(T).GetInterfaces().SelectMany(x => x.GetFields()) : [];
        var properties = typeof(T)
           .GetProperties(Flags)
           .Concat(deepProperties)
           .Where(CanUse)
           .OrderBy(x => x.Name, StringComparer.Ordinal)
#if NETFRAMEWORK && !NET40_OR_GREATER
           .Select(p => GetMethodCaller<T, PropertyInfo>(p, exInstance, exDepth, static x => x.PropertyType));
#else
           .Select(p => GetMethodCaller(p, exInstance, exDepth, static x => x.PropertyType));
#endif
        var fields = typeof(T)
           .GetFields(Flags)
           .Concat(deepFields)
           .OrderBy(x => x.Name, StringComparer.Ordinal)
#if NETFRAMEWORK && !NET40_OR_GREATER
           .Select(f => GetMethodCaller<T, FieldInfo>(f, exInstance, exDepth, static x => x.FieldType));
#else
           .Select(f => GetMethodCaller(f, exInstance, exDepth, static x => x.FieldType));
#endif
        var all = fields
           .Concat(properties)
#if WAWA
           .ToList();
#else
           .ToICollection();
#endif
        var exResult = all.Count is 0 ? s_exEmpty : all.Aggregate(Combine);
        return Lambda<Func<T, int, string>>(exResult, exInstance, exDepth).Compile();
    }
    [MustUseReturnValue]
#pragma warning disable CA1859
#if NETFRAMEWORK && !NET40_OR_GREATER
    static Expression GetMethodCaller<T, TMember>(
#else
    static Expression GetMethodCaller<TMember>(
#endif
#pragma warning restore CA1859
        TMember info,
        ParameterExpression exInstance,
        ParameterExpression exDepth,
        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<TMember, Type> selector
    )
        where TMember : MemberInfo
    {
        var type = selector(info);
        var exConstant = Constant($"{info.Name}{KeyValueSeparator}");
        Expression exAcc = MakeMemberAccess(exInstance, info);
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
        if (type.IsByRef || type.IsByRefLike)
#else
        if (type.IsByRef)
#endif
            return Call(
                s_combine,
                exConstant,
                type.GetMethod(nameof(ToString), Type.EmptyTypes) is { } method
                    ? Expression.Call(exAcc, method)
                    : Expression.Constant(UnfoldedName(exAcc.Type))
            );
        while (type.IsPointer && (type = type.GetElementType()!) is var _)
            exAcc = type.IsPointer
                ? throw new NotSupportedException(Apology)
                : Call(type == typeof(void) ? s_readVoidPointer : s_readPointer.MakeGenericMethod(type), exAcc);
        Expression exCall =
            Call(s_stringify.MakeGenericMethod(type == typeof(void) ? typeof(nuint) : type), exAcc, exDepth, s_exTrue);
#if NETFRAMEWORK && !NET40_OR_GREATER
        var call = Lambda<Func<T, int, string>>(exCall, exInstance, exDepth).Compile();
        Expression<Func<T, int, string>> wrapped = (t, i) => TryStringify(t, i, call);
        exCall = Invoke(wrapped, exInstance, exDepth);
#else
        CatchBlock
            invalid = Catch(typeof(InvalidOperationException), s_exInvalid),
            unsupported = Catch(typeof(NotSupportedException), s_exUnsupported),
            unsupportedPlatform = Catch(typeof(PlatformNotSupportedException), s_exUnsupportedPlatform);
        exCall = TryCatch(exCall, unsupportedPlatform, unsupported, invalid);
#endif
        return Call(s_combine, exConstant, exCall);
    }
#endif
#if NETFRAMEWORK && !NET40_OR_GREATER
    static string TryStringify<T>(T instance, int depth, [InstantHandle] Func<T, int, string> stringify)
    {
        try
        {
            return stringify(instance, depth);
        }
        catch (PlatformNotSupportedException)
        {
            return UnsupportedPlatform;
        }
        catch (NotSupportedException)
        {
            return Unsupported;
        }
        catch (InvalidOperationException)
        {
            return Invalid;
        }
    }
#endif
    [Pure]
    static StringBuilder DictionaryStringifier(this IDictionary dictionary, int depth, bool useQuotes)
    {
        var iterator = dictionary.GetEnumerator();
        try
        {
            StringBuilder builder = new();
            if (iterator.MoveNext())
                builder.AppendKeyValuePair(
                    Stringify(iterator.Key, depth, useQuotes),
                    Stringify(iterator.Value, depth, useQuotes)
                );
            var i = 0;
            while (iterator.MoveNext())
            {
                if (checked(++i) >= MaxIteration)
                {
                    builder.Append(Separator).Append(Etcetera(dictionary.Count - i));
                    break;
                }
                builder
                   .Append(Separator)
                   .AppendKeyValuePair(
                        Stringify(iterator.Key, depth, useQuotes),
                        Stringify(iterator.Value, depth, useQuotes)
                    );
            }
            return builder;
        }
        finally
        {
            (iterator as IDisposable)?.Dispose();
        }
    }
#if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
    static StringBuilder UnfoldedName(this Type? type, StringBuilder builder, Converter<Type, string?> naming)
    {
        StringBuilder Append(Type x)
        {
            builder.Append(',').Append(' ');
            return x.UnfoldedName(builder, naming);
        }
        if (type is null)
            return builder;
        if (s_unfoldedNames.TryGetValue(type, out var val))
            return builder.Append(val);
        if (type.GetElementType() is { } underlying)
            return UnfoldedElementName(type, builder, naming, underlying);
        if ((naming(type) ?? "") is var name && !type.IsGenericType)
            return builder.Append(name);
        var length = name.IndexOf('`') is var i && i is -1 ? name.Length : i;
        var types = type.GetGenericArguments();
        types.FirstOrDefault()?.UnfoldedName(builder.Append(name, 0, length).Append('<'), naming);
        types.Skip(1).Select(Append).Enumerate();
        return builder.Append('>');
    }
    static StringBuilder UnfoldedElementName(
        Type type,
        StringBuilder builder,
        Converter<Type, string?> naming,
        Type underlying
    )
    {
        if (type.IsByRef)
            builder.Append("ref ");
        builder.Append(UnfoldedName(underlying, new(), naming));
        if (type.IsArray)
            builder.Append('[').Append(']');
        if (type.IsPointer)
            builder.Append('*');
        return builder;
    }
#endif
#if WAWA
    static IEnumerable<int> AsBits(this int i)
    {
        for (var j = 1; j is not 0; j <<= 1)
            if ((i & j) is not 0)
                yield return j;
    }
#endif
    static unsafe nuint ReadVoidPointer(void* ptr) => (nuint)ptr;
#pragma warning disable 8500
    static unsafe T? ReadPointer<T>(T* ptr) => (nuint)ptr >= 1 << 11 ? *ptr : default;
#pragma warning restore 8500
#if !NETFRAMEWORK || NET40_OR_GREATER
    sealed class FakeComparer(int depth) : IComparer, IEqualityComparer
    {
        StringBuilder? _builder;
        /// <inheritdoc />
        public override string ToString() =>
            _builder?.Remove(_builder.Length - Separator.Length, Separator.Length).Append(')').ToString() ?? "()";
        /// <inheritdoc />
        bool IEqualityComparer.Equals(object? x, object? y) => Append(x, true);
        /// <inheritdoc />
        int IComparer.Compare(object? x, object? y) => Append(x, 0);
        /// <inheritdoc />
        int IEqualityComparer.GetHashCode(object? obj) => Append(obj, 0);
        T Append<T>(object? obj, T ret)
        {
#pragma warning disable RCS1196
            (_builder ??= new("(")).Append(Stringify(obj, depth)).Append(Separator);
#pragma warning restore RCS1196
            return ret;
        }
    }
#endif
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Contains a myriad of strings that list all whitespace characters.</summary>
    /// <summary>All unicode characters where <c>White_Space=yes</c>, and are line breaks.</summary>
    public const string Breaking = "\n\v\f\r\u0085\u2028\u2029";
    /// <summary>All unicode characters where <c>White_Space=yes</c>, and are not a line break.</summary>
    public const string NonBreaking =
        "\t\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000";
    /// <summary>All unicode characters where <c>White_Space=no</c>, but appears to be whitespace.</summary>
    public const string Related = "\u180E\u200B\u200C\u200D\u2060\uFEFF";
    /// <summary>All unicode characters where <c>White_Space=yes</c>.</summary>
    public const string Unicode = $"{Breaking}{NonBreaking}";
    /// <summary>All unicode characters that appear to be whitespace.</summary>
    public const string Combined = $"{Unicode}{Related}";
#if NET8_0_OR_GREATER
    /// <inheritdoc cref="Breaking"/>
    public static OnceMemoryManager<SearchValues<char>> BreakingSearch
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new(SearchValues.Create(Breaking));
    /// <inheritdoc cref="NonBreaking"/>
    public static OnceMemoryManager<SearchValues<char>> NonBreakingSearch
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } = new(SearchValues.Create(NonBreaking));
    /// <inheritdoc cref="Related"/>
    public static OnceMemoryManager<SearchValues<char>> RelatedSearch
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new(SearchValues.Create(Related));
    /// <inheritdoc cref="Unicode"/>
    public static OnceMemoryManager<SearchValues<char>> UnicodeSearch
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new(SearchValues.Create(Unicode));
    /// <inheritdoc cref="Combined"/>
    public static OnceMemoryManager<SearchValues<char>> CombinedSearch
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get;
    } =
        new(SearchValues.Create(Combined));
#endif
// SPDX-License-Identifier: MPL-2.0
#pragma warning disable GlobalUsingsAnalyzer
// ReSharper disable once RedundantUsingDirective.Global
// ReSharper disable once CheckNamespace
/// <summary>Methods to get elements of a tuple.</summary>
    /// <summary>Gets the first item of the tuple.</summary>
    /// <typeparam name="T1">The first type of the tuple.</typeparam>
    /// <typeparam name="T2">The second type of the tuple.</typeparam>
    /// <param name="tuple">The tuple to get the value from.</param>
    /// <returns>The field <see cref="ValueTuple{T1, T2}.Item1"/> from the parameter <paramref name="tuple"/>.</returns>
    public static T1 First<T1, T2>((T1, T2) tuple) => tuple.Item1;
    /// <summary>Gets the second item of the tuple.</summary>
    /// <typeparam name="T1">The first type of the tuple.</typeparam>
    /// <typeparam name="T2">The second type of the tuple.</typeparam>
    /// <param name="tuple">The tuple to get the value from.</param>
    /// <returns>The field <see cref="ValueTuple{T1, T2}.Item2"/> from the parameter <paramref name="tuple"/>.</returns>
    public static T2 Second<T1, T2>((T1, T2) tuple) => tuple.Item2;
#if !NET20 && !NET30 && !NET47 && !NETSTANDARD2_0
    /// <summary>Gets the enumeration of the tuple.</summary>
    /// <param name="tuple">The tuple to enumerate.</param>
    /// <returns>The enumeration of the parameter <paramref name="tuple"/>.</returns>
    public static IEnumerable<object?> AsEnumerable(this ITuple tuple) => tuple.Length.For(i => tuple[i]);
    /// <summary>Gets the enumeration of the tuple.</summary>
    /// <typeparam name="T">The type of tuple.</typeparam>
    /// <param name="tuple">The tuple to enumerate.</param>
    /// <returns>The enumeration of the parameter <paramref name="tuple"/>.</returns>
    public static IEnumerable<object?> AsEnumerable<T>(this T tuple)
        where T : ITuple =>
        tuple.Length.For(i => tuple[i]);
#endif
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable once CheckNamespace
/// <summary>Provides methods for unfolding.</summary>
    /// <summary>Applies a selector and collects the returned items recursively until the value becomes null.</summary>
    /// <typeparam name="T">The type of value.</typeparam>
    /// <param name="value">The initial value.</param>
    /// <param name="converter">The converter to apply.</param>
    /// <returns>
    /// The parameter <paramref name="value"/>, followed by each non-null
    /// returned value from the parameter <paramref name="converter"/>.
    /// </returns>
    [Pure]
    public static IEnumerable<T> FindPathToNull<T>(this T? value, Converter<T, T?> converter)
        where T : class
    {
        while (value is not null)
        {
            yield return value;
            value = converter(value);
        }
    }
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T _, Converter<T, T> converter)
        where T : struct =>
        throw Unreachable;
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T value, Converter<T, T?> converter)
        where T : struct
    {
        T? maybe = value;
        while (maybe is { } yes)
        {
            yield return yes;
            maybe = converter(yes);
        }
    }
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T? _, Converter<T, T> converter)
        where T : struct =>
        throw Unreachable;
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static IEnumerable<T> FindPathToEmptyNullable<T>(this T? value, Converter<T, T?> converter)
        where T : struct =>
        value is { } t ? FindPathToEmptyNullable(t, converter) : [];
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static SmallList<T> FindSmallPathToNull<T>(this T? value, Converter<T, T?> converter)
        where T : class
    {
        SmallList<T> output = default;
        while (value is not null)
        {
            output.Add(value);
            value = converter(value);
        }
        return output;
    }
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T _, Converter<T, T> converter)
        where T : struct =>
        throw Unreachable;
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T value, Converter<T, T?> converter)
        where T : struct
    {
        SmallList<T> output = [];
        T? maybe = value;
        while (maybe is { } yes)
        {
            output.Add(yes);
            maybe = converter(yes);
        }
        return output;
    }
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [DoesNotReturn, EditorBrowsable(EditorBrowsableState.Never), Obsolete("The return value is always not null.", true)]
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T? _, Converter<T, T> converter)
        where T : struct =>
        throw Unreachable;
    /// <inheritdoc cref="FindPathToNull{T}"/>
    [Pure]
    public static SmallList<T> FindSmallPathToEmptyNullable<T>(this T? value, Converter<T, T?> converter)
        where T : struct =>
        value is { } t ? FindSmallPathToEmptyNullable(t, converter) : [];
// SPDX-License-Identifier: MPL-2.0
// ReSharper disable MissingIndent UsePositionalDeconstructionPattern
// ReSharper disable once CheckNamespace
/// <summary>Methods that deconstructs <see cref="Version"/> instances.</summary>
    /// <summary>Deconstructs this instance into the major version.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    public static void Deconstruct(this Version? version, [NonNegativeValue] out int major) =>
        major = version?.Major ?? 0;
    /// <summary>Deconstructs this instance into the major and minor versions.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor
    )
    {
        if (version is { Major: var maj, Minor: var min })
        {
            major = maj;
            minor = min;
            return;
        }
        major = 0;
        minor = 0;
    }
    /// <summary>Deconstructs this instance into the major, minor, and build versions.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    /// <param name="build">The resulting build version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor,
        [NonNegativeValue] out int build
    )
    {
        if (version is { Major: var maj, Minor: var min, Build: var bui })
        {
            major = maj;
            minor = min;
            build = bui;
            return;
        }
        major = 0;
        minor = 0;
        build = 0;
    }
    /// <summary>Deconstructs this instance into the major, minor, build, and revision versions.</summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    /// <param name="build">The resulting build version.</param>
    /// <param name="revision">The resulting revision version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor,
        [NonNegativeValue] out int build,
        [NonNegativeValue] out int revision
    )
    {
        if (version is { Major: var maj, Minor: var min, Build: var bui, Revision: var rev })
        {
            major = maj;
            minor = min;
            build = bui;
            revision = rev;
            return;
        }
        major = 0;
        minor = 0;
        build = 0;
        revision = 0;
    }
    /// <summary>
    /// Deconstructs this instance into the major, minor, build, major revision, and minor revision versions.
    /// </summary>
    /// <remarks><para>
    /// If the passed in value is <see langword="null"/>, all out parameters are zero-initialized.
    /// </para></remarks>
    /// <param name="version">The <see cref="Version"/> to deconstruct.</param>
    /// <param name="major">The resulting major version.</param>
    /// <param name="minor">The resulting minor version.</param>
    /// <param name="build">The resulting build version.</param>
    /// <param name="majorRevision">The resulting major revision version.</param>
    /// <param name="minorRevision">The resulting minor revision version.</param>
    public static void Deconstruct(
        this Version? version,
        [NonNegativeValue] out int major,
        [NonNegativeValue] out int minor,
        [NonNegativeValue] out int build,
        [NonNegativeValue] out int majorRevision,
        [NonNegativeValue] out int minorRevision
    )
    {
        if (version is
        {
            Major: var maj, Minor: var min, Build: var bui, MajorRevision: var majRev, MinorRevision: var minRev,
        })
        {
            major = maj;
            minor = min;
            build = bui;
            majorRevision = majRev;
            minorRevision = minRev;
            return;
        }
        major = 0;
        minor = 0;
        build = 0;
        majorRevision = 0;
        minorRevision = 0;
    }
// SPDX-License-Identifier: MPL-2.0
#if XNA
// ReSharper disable once CheckNamespace
/// <summary>Provides thread-safe access to keyboard input.</summary>
    /// <summary>Converts <see cref="GamePadButtons"/> to <see cref="Buttons"/>.</summary>
    /// <param name="state">The <see cref="GamePadButtons"/> to convert.</param>
    /// <returns>The <see cref="Buttons"/> equivalent.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static Buttons AsButtons(this GamePadButtons state) => Unsafe.As<GamePadButtons, Buttons>(ref state);
    /// <summary>Converts <see cref="MouseState"/> to <see cref="MouseButtons"/>.</summary>
    /// <param name="state">The <see cref="MouseState"/> to convert.</param>
    /// <returns>The <see cref="MouseButtons"/> equivalent.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static MouseButtons ToMouseButtons(this in MouseState state) =>
        (state.LeftButton is ButtonState.Pressed ? MouseButtons.Left : MouseButtons.None) |
        (state.MiddleButton is ButtonState.Pressed ? MouseButtons.Middle : MouseButtons.None) |
        (state.RightButton is ButtonState.Pressed ? MouseButtons.Right : MouseButtons.None) |
        (state.XButton1 is ButtonState.Pressed ? MouseButtons.X1 : MouseButtons.None) |
        (state.XButton2 is ButtonState.Pressed ? MouseButtons.X2 : MouseButtons.None);
#endif
// SPDX-License-Identifier: MPL-2.0
#if XNA
// ReSharper disable BitwiseOperatorOnEnumWithoutFlags InconsistentNaming NullableWarningSuppressionIsUsed
// ReSharper disable once CheckNamespace
/// <summary>Provides thread-safe access to keyboard input.</summary>
#pragma warning disable CA1810
    static ConcurrentKeyboard()
#pragma warning restore CA1810
    {
        Trace.Assert(Unsafe.SizeOf<Keys>() is sizeof(int), $"sizeof({nameof(Keys)}) is 4");
        Trace.Assert(Unsafe.SizeOf<KeyMods>() is sizeof(ushort), $"sizeof({nameof(KeyMods)}) is 2");
        Trace.Assert(Unsafe.SizeOf<KeyboardState>() >= sizeof(uint) * 8 + sizeof(byte), "Memory layout is known.");
        Trace.Assert(TryGetType(out var type), $"{nameof(type)} is not null");
        Trace.Assert(TryGetField(type, out var delegateField), $"{nameof(delegateField)} is not null");
        Trace.Assert(TryGetValue(delegateField, out Delegate? del), $"{nameof(del)} is not null");
        s_modState = CompileModState(del);
        Trace.Assert(TryGetField(out var keyField), $"{nameof(keyField)} is not null");
        Trace.Assert(TryGetValue(keyField, out List<Keys>? keys), $"{nameof(keys)} is not null");
        s_keys = keys;
        Trace.Assert(TryFindInvalidState(out var invalid), $"{nameof(ToState)} breaks on {invalid}");
    }
    static readonly Func<KeyMods> s_modState;
    static readonly List<Keys> s_keys;
    /// <summary>Thread-safe version of <see cref="Keyboard.GetState()"/>.</summary>
    /// <returns>The current <see cref="KeyboardState"/>.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyboardState GetState() => s_keys.AsSpan().ToState(GetModState());
    /// <summary>
    /// Converts the <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> into the summed <see cref="KeyboardState"/>.
    /// </summary>
    /// <remarks><para>
    /// This operation treats the provided <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> as a set for computation,
    /// meaning that repeated <see cref="Keys"/> of the same value have the same effect as if it appeared once.
    /// </para></remarks>
    /// <param name="keys">The <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> to process.</param>
    /// <param name="mods">The <see cref="KeyMods"/> for modifiers.</param>
    /// <returns>
    /// The <see cref="KeyboardState"/> that comes from both parameters
    /// <paramref name="keys"/> and <paramref name="mods"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyboardState ToState(this scoped in ReadOnlySpan<Keys> keys, KeyMods mods = KeyMods.None)
    {
        KeyboardState output = default;
        var reader = MemoryMarshal.Cast<Keys, int>(keys);
        ref var writer = ref Unsafe.As<KeyboardState, uint>(ref output);
        ref var bits = ref Unsafe.As<KeyMods, ushort>(ref mods);
        ref var start = ref MemoryMarshal.GetReference(reader);
        ref var end = ref Unsafe.Add(ref start, reader.Length);
        while (Unsafe.IsAddressLessThan(ref start, ref end))
            Unsafe.Add(ref writer, start >> 5 & 7) |= 1u << (start & 31);
        Unsafe.As<uint, byte>(ref Unsafe.Add(ref writer, 8)) = (byte)((bits & 4096) >> 11 | (bits & 8192) >> 13);
        return output;
    }
    /// <summary>
    /// Converts the <see cref="Span{T}"/> of <see cref="Keys"/> into the summed <see cref="KeyboardState"/>.
    /// </summary>
    /// <remarks><para>
    /// This operation treats the provided <see cref="Span{T}"/> of <see cref="Keys"/> as a set for computation,
    /// meaning that repeated <see cref="Keys"/> of the same value have the same effect as if it appeared once.
    /// </para></remarks>
    /// <param name="keys">The <see cref="ReadOnlySpan{T}"/> of <see cref="Keys"/> to process.</param>
    /// <param name="mods">The <see cref="KeyMods"/> for modifiers.</param>
    /// <returns>
    /// The <see cref="KeyboardState"/> that comes from both parameters
    /// <paramref name="keys"/> and <paramref name="mods"/>.
    /// </returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyboardState ToState(this scoped in Span<Keys> keys, KeyMods mods = KeyMods.None) =>
        keys.ReadOnly().ToState(mods);
    /// <summary>Gets the current set of key modifiers that are active.</summary>
    /// <returns>The <see cref="KeyMods"/> representing the current modifiers active.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
    public static KeyMods GetModState() => s_modState();
    [Pure]
    static bool TryFindInvalidState([NotNullWhen(false)] out Enum? invalid)
    {
        static bool IsModifierCausingInvalidState(KeyMods mod) =>
            ((ReadOnlySpan<Keys>)[]).ToState(mod) is { CapsLock: var capsLock, NumLock: var numLock } state &&
            capsLock != mod is KeyMods.CapsLock ||
            numLock != mod is KeyMods.NumLock ||
            state.GetPressedKeyCount() is not 0;
        static bool IsKeyCausingInvalidState(Keys key) =>
            Span.In(key).ToState() is not { CapsLock: false, NumLock: false } state ||
            state.IsKeyUp(key) ||
            state.GetPressedKeyCount() is not 1;
        var keyModTests = EnumMath.GetValues<KeyMods>().Where(IsModifierCausingInvalidState).Cast<Enum>();
        var keyTests = EnumMath.GetValues<Keys>().Where(IsKeyCausingInvalidState).Cast<Enum>();
        invalid = keyModTests.Concat(keyTests).Filter().FirstOrDefault();
        return invalid is null;
    }
    [MustUseReturnValue]
    static bool TryGetField([NotNullWhen(true)] out FieldInfo? field) =>
        (field = typeof(Keyboard).GetField("_keys", BindingFlags.NonPublic | BindingFlags.Static)) is not null;
    [MustUseReturnValue]
    static bool TryGetField(in Type type, [NotNullWhen(true)] out FieldInfo? field) =>
        (field = type.GetField(nameof(GetModState), BindingFlags.Public | BindingFlags.Static)) is not null;
    [MustUseReturnValue]
    static bool TryGetType([NotNullWhen(true)] out Type? type) =>
#pragma warning disable REFL037
        (type = typeof(Keyboard).Assembly.GetType("Sdl+Keyboard")) is not null;
#pragma warning restore REFL037
    [MustUseReturnValue]
    static bool TryGetValue(in FieldInfo delegateField, [NotNullWhen(true)] out Delegate? del) =>
        (del = delegateField.GetValue(null) as Delegate) is not null;
    [MustUseReturnValue]
    static bool TryGetValue(in FieldInfo field, [NotNullWhen(true)] out List<Keys>? keys) =>
        (keys = field.GetValue(null) as List<Keys>) is not null;
    [Pure]
    static Func<KeyMods> CompileModState(in Delegate del)
    {
        var constant = Expression.Constant(del);
        var invoke = Expression.Invoke(constant);
        var mods = Expression.Convert(invoke, typeof(KeyMods));
        return Expression.Lambda<Func<KeyMods>>(mods).Compile();
    }
#endif
// SPDX-License-Identifier: MPL-2.0
#if XNA
#pragma warning disable GlobalUsingsAnalyzer
// ReSharper disable once CheckNamespace
/// <summary>Provides the enumeration over <see cref="GamePad"/> instances.</summary>
[StructLayout(LayoutKind.Auto)]
public struct GamePads(PlayerIndex last = PlayerIndex.Four) : IEnumerable<GamePadState>, IEnumerator<GamePadState>
{
    readonly PlayerIndex _length = last + 1;
    PlayerIndex _index;
    /// <summary>Gets the first four <see cref="GamePadState"/> instances.</summary>
    public static (GamePadState First, GamePadState Second, GamePadState Third, GamePadState Fourth) Four =>
    (
        GamePad.GetState(PlayerIndex.One),
        GamePad.GetState(PlayerIndex.Two),
        GamePad.GetState(PlayerIndex.Three),
        GamePad.GetState(PlayerIndex.Four)
    );
    /// <inheritdoc />
    public GamePadState Current { get; private set; }
    /// <inheritdoc />
    readonly object IEnumerator.Current => Current;
    /// <inheritdoc />
    readonly void IDisposable.Dispose() { }
    /// <inheritdoc />
    public void Reset() => _index = PlayerIndex.One;
    /// <inheritdoc />
    public bool MoveNext() =>
#pragma warning disable MA0099
        _index < (_length is 0 ? PlayerIndex.Four + 1 : _length) && (Current = GamePad.GetState(_index++)) is var _;
#pragma warning restore MA0099
    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator"/>
    public readonly GamePads GetEnumerator() => new(last);
    /// <inheritdoc />
    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    /// <inheritdoc />
    readonly IEnumerator<GamePadState> IEnumerable<GamePadState>.GetEnumerator() => GetEnumerator();
}
/// <summary>Extensions for <see cref="GamePadState"/>.</summary>
#pragma warning disable MA0048
static class GamePadStateExtensions
#pragma warning restore MA0048
{
    /// <inheritdoc cref="GamePadState.IsConnected"/>
    public static bool IsConnected(this in (GamePadState, GamePadState, GamePadState, GamePadState) state) =>
        state.Item1.IsConnected || state.Item2.IsConnected || state.Item3.IsConnected || state.Item4.IsConnected;
    /// <inheritdoc cref="GamePadState.IsButtonDown"/>
    public static bool IsButtonDown(
        this in (GamePadState, GamePadState, GamePadState, GamePadState) state,
        Buttons buttons
    ) =>
        AsRef(state.Item1).IsButtonDown(buttons) ||
        AsRef(state.Item2).IsButtonDown(buttons) ||
        AsRef(state.Item3).IsButtonDown(buttons) ||
        AsRef(state.Item4).IsButtonDown(buttons);
    /// <inheritdoc cref="GamePadState.IsButtonUp"/>
    public static bool IsButtonUp(
        this in (GamePadState, GamePadState, GamePadState, GamePadState) state,
        Buttons buttons
    ) =>
        AsRef(state.Item1).IsButtonUp(buttons) ||
        AsRef(state.Item2).IsButtonUp(buttons) ||
        AsRef(state.Item3).IsButtonUp(buttons) ||
        AsRef(state.Item4).IsButtonUp(buttons);
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if XNA
// ReSharper disable once CheckNamespace
#pragma warning disable 1591, SA1602
/// <summary>Contains the set of all key modifiers.</summary>
[Flags]
public enum KeyMods : ushort
{
    None,
    LeftShift,
    RightShift,
    Shift = RightShift | LeftShift,
    LeftCtrl = 1 << 6,
    RightCtrl = 1 << 7,
    Ctrl = RightCtrl | LeftCtrl,
    LeftAlt = 1 << 8,
    RightAlt = 1 << 9,
    Alt = RightAlt | LeftAlt,
    LeftGui = 1 << 10,
    RightGui = 1 << 11,
    Gui = RightGui | LeftGui,
    NumLock = 1 << 12,
    CapsLock = 1 << 13,
    AltGr = 1 << 14,
    Reserved = 1 << 15,
}
#endif
// SPDX-License-Identifier: MPL-2.0
#if XNA
// ReSharper disable once CheckNamespace
/// <summary>Contains mouse buttons.</summary>
[Flags]
public enum MouseButtons : byte
{
    /// <summary>No mouse button.</summary>
    None,
    /// <summary>Left mouse button.</summary>
    Left,
    /// <summary>Middle mouse button.</summary>
    Middle,
    /// <summary>Right mouse button.</summary>
    Right = 1 << 2,
    /// <summary>X1 mouse button.</summary>
    X1 = 1 << 3,
    /// <summary>X2 mouse button.</summary>
    X2 = 1 << 4,
}
#endif
/// <summary>Methods that creates enumerations from individual items.</summary>
static partial class ManyQueries
{
    /// <summary>Gets the types from an assembly even if type loads occur.</summary>
    /// <param name="assembly">The assembly to get the types from.</param>
    /// <returns>
    /// The enumeration of all successfully loaded types from the parameter <paramref name="assembly"/>.
    /// </returns>
    [MustUseReturnValue]
    public static IEnumerable<Type> TryGetTypes(Assembly? assembly) => assembly.TryGetTypes();
}

/// <summary>Method to inline.</summary>
[AttributeUsage(AttributeTargets.Method)]
sealed partial class InlineAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
    /// <param name="remove">The value to set.</param>
    public InlineAttribute(bool remove = true) => Remove = remove;

    /// <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
    public bool Remove { get; }
}

/// <summary>Provides stringification methods.</summary>
static class Stringifier
{
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(T? source) => source.Stringify();
}

/// <summary>Polyfill for <c>nameof()</c>.</summary>
static class Morsels;

CatchFatalExceptions = true;
