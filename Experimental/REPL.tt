<# // SPDX-License-Identifier: MPL-2.0  #>
<#@ output extension=".csx" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text.RegularExpressions" #>
// <auto-generated/>
#pragma warning disable CS0208
#define NET70
#define NET70_OR_GREATER
#define NET60_OR_GREATER
#define NET50_OR_GREATER
#define NETCOREAPP
#define NETSTANDARD2_1_OR_GREATER
#define NETSTANDARD2_0_OR_GREATER
#define NETSTANDARD1_6_OR_GREATER
#define NETSTANDARD1_5_OR_GREATER
#define NETSTANDARD1_4_OR_GREATER
#define NETSTANDARD1_3_OR_GREATER
#define NETSTANDARD1_2_OR_GREATER
#define NETSTANDARD1_1_OR_GREATER
#define NETSTANDARD1_0_OR_GREATER
#define NETSTANDARD
#define CSHARPREPL
#define NO_ROSLYN
global using System;
global using System.Buffers;
global using System.Buffers.Binary;
global using System.Buffers.Text;
global using System.CodeDom;
global using System.CodeDom.Compiler;
global using System.Collections;
global using System.Collections.Concurrent;
global using System.Collections.Generic;
global using System.Collections.Immutable;
global using System.Collections.ObjectModel;
global using System.Collections.Specialized;
global using System.ComponentModel;
global using System.ComponentModel.DataAnnotations;
global using System.ComponentModel.DataAnnotations.Schema;
global using System.ComponentModel.Design;
global using System.ComponentModel.Design.Serialization;
global using System.Configuration;
global using System.Configuration.Assemblies;
global using System.Configuration.Internal;
global using System.Configuration.Provider;
global using System.Data;
global using System.Data.Common;
global using System.Data.Odbc;
global using System.Data.OleDb;
global using System.Data.Sql;
global using System.Data.SqlClient;
global using System.Data.SqlTypes;
global using System.Diagnostics;
global using System.Diagnostics.CodeAnalysis;
global using System.Diagnostics.Contracts;
global using System.Diagnostics.Eventing;
global using System.Diagnostics.Eventing.Reader;
global using System.Diagnostics.Metrics;
global using System.Diagnostics.PerformanceData;
global using System.Diagnostics.SymbolStore;
global using System.Diagnostics.Tracing;
global using System.Drawing;
global using System.Drawing.Configuration;
global using System.Drawing.Design;
global using System.Drawing.Drawing2D;
global using System.Drawing.Imaging;
global using System.Drawing.Printing;
global using System.Drawing.Text;
global using System.Dynamic;
global using System.Formats;
global using System.Formats.Asn1;
global using System.Globalization;
global using System.IO;
global using System.IO.Compression;
global using System.IO.Enumeration;
global using System.IO.IsolatedStorage;
global using System.IO.MemoryMappedFiles;
global using System.IO.Packaging;
global using System.IO.Pipes;
global using System.IO.Ports;
global using System.Linq;
global using System.Linq.Expressions;
global using System.Media;
global using System.Net;
global using System.Net.Cache;
global using System.Net.Http;
global using System.Net.Http.Headers;
global using System.Net.Http.Json;
global using System.Net.Mail;
global using System.Net.Mime;
global using System.Net.NetworkInformation;
global using System.Net.PeerToPeer;
global using System.Net.PeerToPeer.Collaboration;
global using System.Net.Security;
global using System.Net.Sockets;
global using System.Net.WebSockets;
global using System.Numerics;
global using System.Reflection;
global using System.Reflection.Emit;
global using System.Reflection.Metadata;
global using System.Reflection.Metadata.Ecma335;
global using System.Reflection.PortableExecutable;
global using System.Resources;
global using System.Runtime;
global using System.Runtime.CompilerServices;
global using System.Runtime.ConstrainedExecution;
global using System.Runtime.ExceptionServices;
global using System.Runtime.InteropServices;
global using System.Runtime.InteropServices.ComTypes;
global using System.Runtime.InteropServices.ObjectiveC;
global using System.Runtime.Intrinsics;
global using System.Runtime.Intrinsics.Arm;
global using System.Runtime.Intrinsics.X86;
global using System.Runtime.Loader;
global using System.Runtime.Remoting;
global using System.Runtime.Serialization;
global using System.Runtime.Serialization.Formatters;
global using System.Runtime.Serialization.Formatters.Binary;
global using System.Runtime.Serialization.Json;
global using System.Runtime.Versioning;
global using System.Security;
global using System.Security.AccessControl;
global using System.Security.Authentication;
global using System.Security.Authentication.ExtendedProtection;
global using System.Security.Claims;
global using System.Security.Cryptography;
global using System.Security.Cryptography.Pkcs;
global using System.Security.Cryptography.X509Certificates;
global using System.Security.Cryptography.Xml;
global using System.Security.Permissions;
global using System.Security.Policy;
global using System.Security.Principal;
global using System.ServiceModel;
global using System.ServiceModel.Syndication;
global using System.ServiceProcess;
global using System.Text;
global using System.Text.Encodings;
global using System.Text.Encodings.Web;
global using System.Text.Json;
global using System.Text.Json.Nodes;
global using System.Text.Json.Serialization;
global using System.Text.Json.Serialization.Metadata;
global using System.Text.RegularExpressions;
global using System.Text.Unicode;
global using System.Threading;
global using System.Threading.Channels;
global using System.Threading.Tasks;
global using System.Threading.Tasks.Dataflow;
global using System.Threading.Tasks.Sources;
global using System.Timers;
global using System.Transactions;
global using System.Web;
global using System.Windows;
global using System.Windows.Input;
global using System.Windows.Markup;
global using System.Xml;
global using System.Xml.Linq;
global using System.Xml.Resolvers;
global using System.Xml.Schema;
global using System.Xml.Serialization;
global using System.Xml.XPath;
global using System.Xml.Xsl;
global using Emik;
global using Emik.Results;
global using Emik.Results.Extensions;
global using Emik.Unions;
global using Emik.Unions.Disjoints;
global using Emik.Unions.Mappings;
global using Emik.Unions.Tagged;
global using JetBrains;
global using JetBrains.Annotations;
global using static Emik.Results.Please;
global using static Emik.Results.Result;
global using static TextCopy.ClipboardService;
global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
global using Expression = System.Linq.Expressions.Expression;
global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;

<#
    static string ToFullName(string x) => x switch
    {
        "using static Span;" => "",
        "using Range = System.Range;" => "",
        "global using static Unforgiving;" => "",
        "global using static TupleExtracts;" => "",
        "global using static MethodGroupings;" => "",
        "using static Enum;" => "using static System.Enum;",
        "using static Math;" => "using static System.Math;",
        "using Expression = System.Linq.Expressions.Expression;" => "",
        "    public static string[] Split(" => "    public static string[] Chop(",
        "using static Expression;" => "using static System.Linq.Expressions.Expression;",
        "using static SecurityAction;" => "using static System.Security.Permissions.SecurityAction;",
        "using static CollectionAccessType;" => "using static JetBrains.Annotations.CollectionAccessType;",
        "using static SecurityPermissionFlag;" => "using static System.Security.Permissions.SecurityPermissionFlag;",
        _ => x};

    const string Path = "/home/emik/RiderProjects/Emik.Morsels/Compile/Source/References/Emik/";

    var lines = Directory
        .GetFiles(Path, "*.cs", SearchOption.AllDirectories)
        .Select(File.ReadAllText)
        .Select(x => x.Replace("namespace Emik.Morsels;", "").Replace("Emik.Morsels.", "").Replace("Whitespaces.", ""))
        .Select(
            x =>
                x.Replace("CollectionAccess(None)", "CollectionAccess(JetBrains.Annotations.CollectionAccessType.None)"))
        .Select(
            x => Regex.Replace(x, @"(?<=(?<=static\s*)partial\s*class).*?\{(.*?)\n\}", "$1", RegexOptions.Singleline))
        .Select(x => x.Replace("static partial class", ""))
        .SelectMany(x => x.Split(Environment.NewLine.ToCharArray()))
        .Select(ToFullName)
        .Select(
            x =>
                new[] { "ref", "sealed", "partial", "class", "delegate", "enum", "struct", "record" }.Any(
                    x.StartsWith)
                    ? $"public {x}"
                    : x)
        .OrderByDescending(x => Regex.IsMatch(x, @"^(global\s*)?using\s*.*?;$", RegexOptions.Singleline))
        .ThenByDescending(x => x.StartsWith("global"));

    var output = string.Join(Environment.NewLine, lines);
#><#= output #>
/// <summary>Method to inline.</summary>
[AttributeUsage(AttributeTargets.Method)]
sealed partial class InlineAttribute : Attribute
{
    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
    /// <param name="remove">The value to set.</param>
    public InlineAttribute(bool remove = true) => Remove = remove;

    /// <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
    public bool Remove { get; }
}

static class Stringifier
{
    /// <summary>
    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
    /// </summary>
    /// <remarks><para>
    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
    /// unless they explicitly define a <see cref="object.ToString"/>, or implement <see cref="IEnumerable{T}"/>,
    /// in which case each item within is printed out separately.
    /// </para></remarks>
    /// <typeparam name="T">The type of the source.</typeparam>
    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
    [MustUseReturnValue]
    public static string Stringify<T>(T? source) => source.Stringify();
}

/// <summary>Gets the nothing value, used when the inner value is unspecified.</summary>
static object None => Emik.Results.Result.None;
