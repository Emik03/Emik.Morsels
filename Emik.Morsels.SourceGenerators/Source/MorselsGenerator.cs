// SPDX-License-Identifier: MPL-2.0
namespace Emik.Morsels.SourceGenerators;

/// <summary>Generates all of the files from this project.</summary>
[Generator]
public sealed class MorselsGenerator : ISourceGenerator
{
    /// <inheritdoc />
    [CLSCompliant(false)]
    public void Execute(GeneratorExecutionContext context)
    {
        if (ExtensionFromLanguage(context) is not { } lang)
            return;

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.CLSCompliant.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                [assembly: CLSCompliant(true)]
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Aliases.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable MissingBlankLines RedundantUsingDirective.Global
                #pragma warning disable GlobalUsingsAnalyzer, SA1649
                #if NETFRAMEWORK
                extern alias ms;
                #endif
                #if NET35
                extern alias unity;
                
                // Curse you Unity for making me do this. Allows Jetbrains.Annotations and UnityEngine to coexist.
                global using AssertionMethodAttribute = unity::JetBrains.Annotations.AssertionMethodAttribute;
                global using BaseTypeRequiredAttribute = unity::JetBrains.Annotations.BaseTypeRequiredAttribute;
                global using CanBeNullAttribute = unity::JetBrains.Annotations.CanBeNullAttribute;
                global using CannotApplyEqualityOperatorAttribute = unity::JetBrains.Annotations.CannotApplyEqualityOperatorAttribute;
                global using Component = unity::UnityEngine.Component;
                global using ContractAnnotationAttribute = unity::JetBrains.Annotations.ContractAnnotationAttribute;
                global using Debug = unity::UnityEngine.Debug;
                #endif
                global using DisallowNullAttribute = System.Diagnostics.CodeAnalysis.DisallowNullAttribute;
                #if NET35
                global using ImplicitUseKindFlags = unity::JetBrains.Annotations.ImplicitUseKindFlags;
                global using ImplicitUseTargetFlags = unity::JetBrains.Annotations.ImplicitUseTargetFlags;
                global using InstantHandleAttribute = unity::JetBrains.Annotations.InstantHandleAttribute;
                global using InvokerParameterNameAttribute = unity::JetBrains.Annotations.InvokerParameterNameAttribute;
                global using LinqTunnelAttribute = unity::JetBrains.Annotations.LinqTunnelAttribute;
                global using LocalizationRequiredAttribute = unity::JetBrains.Annotations.LocalizationRequiredAttribute;
                global using MeansImplicitUseAttribute = unity::JetBrains.Annotations.MeansImplicitUseAttribute;
                global using NoEnumerationAttribute = unity::JetBrains.Annotations.NoEnumerationAttribute;
                global using NotifyPropertyChangedInvocatorAttribute = unity::JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute;
                global using NotNullAttribute = unity::JetBrains.Annotations.NotNullAttribute;
                global using Object = unity::UnityEngine.Object;
                global using PathReferenceAttribute = unity::JetBrains.Annotations.PathReferenceAttribute;
                global using PublicAPIAttribute = unity::JetBrains.Annotations.PublicAPIAttribute;
                #endif
                #if NET35 && WAWA
                global using PureAttribute = unity::JetBrains.Annotations.PureAttribute;
                #elif NET40_OR_GREATER
                global using PureAttribute = ms::System.Diagnostics.Contracts.PureAttribute;
                #else
                global using PureAttribute = System.Diagnostics.Contracts.PureAttribute;
                #endif
                
                #if NET35
                global using Range = System.Range;
                global using StringFormatMethodAttribute = unity::JetBrains.Annotations.StringFormatMethodAttribute;
                global using UsedImplicitlyAttribute = unity::JetBrains.Annotations.UsedImplicitlyAttribute;
                #endif
                #if NETFRAMEWORK && !NET40_OR_GREATER || NETSTANDARD && !NETSTANDARD2_0_OR_GREATER
                #if !NET35 || !WAWA
                // ReSharper disable once CheckNamespace
                namespace System.Diagnostics.Contracts;
                
                using static AttributeTargets;
                
                /// <summary>Indicates that a type or method is pure, that is, it does not make any visible state changes.</summary>
                [AttributeUsage(Class | Constructor | Delegate | Event | Parameter | Method | Property)]
                #pragma warning disable MA0048
                sealed partial class PureAttribute : Attribute { }
                #pragma warning restore MA0048
                #endif
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.ManyQueries.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #pragma warning disable CS1574, CS1580
                /// <summary>Methods that creates enumerations from individual items.</summary>
                static partial class ManyQueries
                {
                    /// <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="item">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, MustUseReturnValue]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        this T? item,
                        [InstantHandle] Converter<T, IEnumerable<TResult>?> map
                    ) =>
                        item is not null && map(item) is { } iterable ? iterable : Enumerable.Empty<TResult>();
                
                    /// <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="item">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, MustUseReturnValue]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        this T? item,
                        [InstantHandle] Converter<T, IEnumerable<TResult>?> map
                    )
                        where T : struct =>
                        item.HasValue && map(item.Value) is { } iterable ? iterable : Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, IEnumerable<TResult?>?> map
                    ) =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, IEnumerable<TResult?>?> map
                    )
                        where T : struct =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, IEnumerable<TResult?>?> map
                    )
                        where TResult : struct =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, IEnumerable<TResult?>?> map
                    )
                        where T : struct
                        where TResult : struct =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, int, IEnumerable<TResult?>?> map
                    ) =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, int, IEnumerable<TResult?>?> map
                    )
                        where T : struct =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, int, IEnumerable<TResult?>?> map
                    )
                        where TResult : struct =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                
                    /// <summary>
                    /// <see cref="Enumerable.SelectMany{TSource, TResult}(IEnumerable{TSource}, Func{TSource, IEnumerable{TResult}})"/>
                    /// but with exhaustive null guards that fall back to empty enumerables.
                    /// </summary>
                    /// <typeparam name="T">The source of the item.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="iterator">The item to check.</param>
                    /// <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
                    /// <returns>The result of the parameter <paramref name="map"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> ManyOrEmpty<T, TResult>(
                        [NoEnumeration] this IEnumerable<T?>? iterator,
                        Func<T, int, IEnumerable<TResult?>?> map
                    )
                        where T : struct
                        where TResult : struct =>
                        iterator?.Filter().Select(map).SelectMany(x => x ?? Enumerable.Empty<TResult?>()).Filter() ??
                        Enumerable.Empty<TResult>();
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Conditionals.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods for nullable types and booleans.</summary>
                static partial class Conditionals
                {
                    /// <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
                    /// <typeparam name="T">The type of value.</typeparam>
                    /// <param name="value">The value to check.</param>
                    /// <param name="predicate">The predicate to determine the return value.</param>
                    /// <returns>
                    /// The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
                    /// and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
                    /// </returns>
                    [MustUseReturnValue]
                    public static bool IsAnd<T>([NotNullWhen(true)] this T? value, [InstantHandle] Predicate<T> predicate) =>
                        value is not null && predicate(value);
                
                    /// <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
                    /// <typeparam name="T">The type of value.</typeparam>
                    /// <param name="value">The value to check.</param>
                    /// <param name="predicate">The predicate to determine the return value.</param>
                    /// <returns>
                    /// The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
                    /// and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
                    /// </returns>
                    [MustUseReturnValue]
                    public static bool IsAnd<T>([NotNullWhen(true)] this T? value, [InstantHandle] Predicate<T> predicate)
                        where T : struct =>
                        value is { } t && predicate(t);
                
                    /// <summary>Conditionally invokes based on a condition.</summary>
                    /// <param name="that">The value that must be <see langword="false"/>.</param>
                    /// <param name="exThat">Filled by the compiler, the expression to assert.</param>
                    /// <returns>The parameter <paramref name="that"/>.</returns>
                    [AssertionMethod]
                    public static bool IsFalse(
                        [AssertionCondition(AssertionConditionType.IS_FALSE)] this bool that,
                        [CallerArgumentExpression(nameof(that))] string? exThat = null
                    ) =>
                        that ? throw new UnreachableException(exThat) : false;
                
                    /// <summary>Conditionally invokes based on a condition.</summary>
                    /// <param name="that">The value that must be <see langword="true"/>.</param>
                    /// <param name="exThat">Filled by the compiler, the expression to assert.</param>
                    /// <returns>The parameter <paramref name="that"/>.</returns>
                    [AssertionMethod]
                    public static bool IsTrue(
                        [AssertionCondition(AssertionConditionType.IS_TRUE)] this bool that,
                        [CallerArgumentExpression(nameof(that))] string? exThat = null
                    ) =>
                        that ? true : throw new UnreachableException(exThat);
                
                    /// <summary>Conditionally invokes based on a condition.</summary>
                    /// <param name="value">The value to check.</param>
                    /// <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
                    /// <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
                    /// <returns>The parameter <paramref name="value"/>.</returns>
                    public static bool Then(
                        this bool value,
                        [InstantHandle] Action ifTrue,
                        [InstantHandle] Action? ifFalse = null
                    )
                    {
                        if (value)
                            ifTrue();
                        else
                            ifFalse?.Invoke();
                
                        return value;
                    }
                
                    /// <summary>Gives an optional value based on a condition.</summary>
                    /// <remarks><para>The parameter is eagerly evaluated.</para></remarks>
                    /// <typeparam name="T">The type of value.</typeparam>
                    /// <param name="value">The value to check.</param>
                    /// <param name="onTrue">The value to return when <see langword="true"/>.</param>
                    /// <returns>
                    /// The value <paramref name="onTrue"/> if <paramref name="value"/>
                    /// is <see langword="true"/>, else <see langword="default"/>.
                    /// </returns>
                    [Pure]
                    public static T? Then<T>(this bool value, T onTrue) => value ? onTrue : default;
                
                    /// <summary>Gives an optional value based on a condition.</summary>
                    /// <remarks><para>The parameter is lazily evaluated.</para></remarks>
                    /// <typeparam name="T">The type of value.</typeparam>
                    /// <param name="value">The value to check.</param>
                    /// <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
                    /// <returns>
                    /// The value returned from <paramref name="ifTrue"/> if <paramref name="value"/>
                    /// is <see langword="true"/>, else <see langword="default"/>.
                    /// </returns>
                    [MustUseReturnValue]
                    public static T? Then<T>(this bool value, Func<T> ifTrue) => value ? ifTrue() : default;
                
                #if !NET20 && !NET30
                    /// <summary>Filters an <see cref="IEnumerable{T}"/> to only non-null values.</summary>
                    /// <typeparam name="T">The type of value to filter.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to filter.</param>
                    /// <returns>A filtered <see cref="IEnumerable{T}"/> with strictly non-null values.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Filter<T>([NoEnumeration] this IEnumerable<T?>? iterable) =>
                #pragma warning disable CS8619
                        iterable?.Where(x => x is not null) ?? Enumerable.Empty<T>();
                #pragma warning restore CS8619
                
                    /// <summary>Filters an <see cref="IEnumerable{T}"/> to only non-null values.</summary>
                    /// <typeparam name="T">The type of value to filter.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to filter.</param>
                    /// <returns>A filtered <see cref="IEnumerable{T}"/> with strictly non-null values.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Filter<T>([NoEnumeration] this IEnumerable<T?>? iterable)
                        where T : struct =>
                #pragma warning disable CS8629
                        iterable?.Where(x => x.HasValue).Select(x => x.Value) ?? Enumerable.Empty<T>();
                #pragma warning restore CS8629
                #endif
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.TupleExtracts.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #pragma warning disable GlobalUsingsAnalyzer
                
                // ReSharper disable once RedundantUsingDirective.Global
                global using static Emik.Morsels.TupleExtracts;
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Methods to get elements of a tuple.</summary>
                static partial class TupleExtracts
                {
                    /// <summary>Gets the first item of the tuple.</summary>
                    /// <typeparam name="T1">The first type of the tuple.</typeparam>
                    /// <typeparam name="T2">The second type of the tuple.</typeparam>
                    /// <param name="tuple">The tuple to get the value from.</param>
                    /// <returns>The field <see cref="ValueTuple{T1, T2}.Item1"/> from the parameter <paramref name="tuple"/>.</returns>
                    public static T1 First<T1, T2>((T1, T2) tuple) => tuple.Item1;
                
                    /// <summary>Gets the second item of the tuple.</summary>
                    /// <typeparam name="T1">The first type of the tuple.</typeparam>
                    /// <typeparam name="T2">The second type of the tuple.</typeparam>
                    /// <param name="tuple">The tuple to get the value from.</param>
                    /// <returns>The field <see cref="ValueTuple{T1, T2}.Item2"/> from the parameter <paramref name="tuple"/>.</returns>
                    public static T2 Second<T1, T2>((T1, T2) tuple) => tuple.Item2;
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.MethodGroupings.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #pragma warning disable GlobalUsingsAnalyzer
                
                // ReSharper disable once RedundantUsingDirective.Global
                global using static Emik.Morsels.MethodGroupings;
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Methods to create methods.</summary>
                static partial class MethodGroupings
                {
                    /// <summary>Invokes a method.</summary>
                    /// <param name="del">The method to invoke.</param>
                    public static void Invoke([InstantHandle] Action del) => del();
                
                    /// <summary>Create a delegate.</summary>
                    /// <param name="del">The method group.</param>
                    /// <returns>An invokable method.</returns>
                    [Pure]
                    public static Action Action(Action del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Action<T> Action1<T>(Action<T> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Action<T1, T2> Action2<T1, T2>(Action<T1, T2> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Action<T1, T2, T3> Action3<T1, T2, T3>(Action<T1, T2, T3> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Action<T1, T2, T3, T4> Action4<T1, T2, T3, T4>(Action<T1, T2, T3, T4> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Func<T> Func<T>(Func<T> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Func<T, TResult> Func1<T, TResult>(Func<T, TResult> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Func<T1, T2, TResult> Func2<T1, T2, TResult>(Func<T1, T2, TResult> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Func<T1, T2, T3, TResult> Func3<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> del) => del;
                
                    /// <inheritdoc cref="MethodGroupings.Action"/>
                    [Pure]
                    public static Func<T1, T2, T3, T4, TResult> Func4<T1, T2, T3, T4, TResult>(Func<T1, T2, T3, T4, TResult> del) =>
                        del;
                
                    /// <summary>Negates a predicate.</summary>
                    /// <typeparam name="T">The type of item for the predicate.</typeparam>
                    /// <param name="predicate">The predicate to negate.</param>
                    /// <returns>The argument <paramref name="predicate"/> wrapped in another that negates its result.</returns>
                    [Pure]
                    public static Func<T, bool> Not1<T>(Func<T, bool> predicate) => t => !predicate(t);
                
                    /// <inheritdoc cref="MethodGroupings.Not{T}(Predicate{T})"/>
                    [Pure]
                    public static Func<T, int, bool> Not2<T>(Func<T, int, bool> predicate) => (t, i) => !predicate(t, i);
                
                    /// <summary>Creates the <see cref="IComparer{T}"/> from the mapping.</summary>
                    /// <typeparam name="T">The type to compare.</typeparam>
                    /// <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
                    /// <param name="converter">The converter to use.</param>
                    /// <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
                    /// <returns>The <see cref="IComparer{T}"/> that wraps the parameter <paramref name="converter"/>.</returns>
                    public static IComparer<T> Comparing<T, TResult>(
                        Converter<T?, TResult> converter,
                        Comparer<TResult>? comparer = null
                    ) =>
                        new Comparer<T, TResult>(converter, comparer ?? Comparer<TResult>.Default);
                
                    /// <inheritdoc cref="MethodGroupings.Not{T}(Predicate{T})"/>
                    [Pure]
                    public static Predicate<T> Not<T>(Predicate<T> predicate) => t => !predicate(t);
                
                    /// <inheritdoc cref="Invoke"/>
                    public static TResult Invoke<TResult>([InstantHandle] Func<TResult> del) => del();
                
                    sealed class Comparer<T, TResult> : IComparer<T>
                    {
                        readonly Comparer<TResult> _comparer;
                
                        readonly Converter<T?, TResult> _converter;
                
                        public Comparer(Converter<T?, TResult> converter, Comparer<TResult> comparer)
                        {
                            _converter = converter;
                            _comparer = comparer;
                        }
                
                        /// <inheritdoc />
                        public int Compare(T? x, T? y) => _comparer.Compare(_converter(x), _converter(y));
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Fody.RemoveReferenceAttribute.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if NET452
                [assembly: RemoveReference("System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
                
                // ReSharper disable once CheckNamespace
                namespace RemoveReference;
                
                /// <summary>Ensures that a reference be removed from the compiled binary.</summary>
                /// <remarks><para>Declared so as to prevent a hard dependency to RemoveReference.Fody.</para></remarks>
                [AttributeUsage(AttributeTargets.Assembly)]
                sealed partial class RemoveReferenceAttribute : Attribute
                {
                    /// <summary>Initializes a new instance of the <see cref="RemoveReferenceAttribute"/> class.</summary>
                    /// <param name="fullName">The full name of an assembly to remove its reference.</param>
                    public RemoveReferenceAttribute(string fullName) => FullName = fullName;
                
                    /// <summary>Gets an assembly's full name which has been stripped from this compiled binary.</summary>
                    public string FullName { get; }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Fody.InlineAttribute.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if NETFRAMEWORK && !NET48 || NETSTANDARD && !NETSTANDARD2_0_OR_GREATER
                // ReSharper disable once CheckNamespace
                namespace InlineMethod;
                
                using static AttributeTargets;
                
                /// <summary>Method to inline.</summary>
                [AttributeUsage(Method)]
                sealed partial class InlineAttribute : Attribute
                {
                    /// <summary>Initializes a new instance of the <see cref="InlineAttribute"/> class.</summary>
                    /// <param name="remove">The value to set.</param>
                    public InlineAttribute(bool remove = true) => Remove = remove;
                
                    /// <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
                    public bool Remove { get; }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Fody.AllowNullAttribute.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if WAWA
                // ReSharper disable once CheckNamespace
                namespace NullGuard;
                
                using static AttributeTargets;
                
                /// <summary>Prevents the injection of null checking (implicit mode only).</summary>
                [AttributeUsage(Parameter | ReturnValue | Property)]
                sealed partial class AllowNullAttribute : Attribute { }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Delegates.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace EmptyNamespace
                namespace System;
                #pragma warning disable MA0048, SA1600
                #if NET20 || NET30 // ReSharper disable TypeParameterCanBeVariant
                /// <summary>Encapsulates a method that has no parameters and does not return a value.</summary>
                delegate void Action();
                
                /// <summary>Encapsulates a method that has two parameters and does not return a value.</summary>
                /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
                delegate void Action<T1, T2>(T1 arg1, T2 arg2);
                
                /// <summary>Encapsulates a method that has three parameters and does not return a value.</summary>
                /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
                delegate void Action<T1, T2, T3>(T1 arg1, T2 arg2, T3 arg3);
                
                /// <summary>Encapsulates a method that has four parameters and does not return a value.</summary>
                /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
                delegate void Action<T1, T2, T3, T4>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
                
                /// <summary>
                /// Encapsulates a method that has no parameters and returns a value of
                /// the type specified by the <typeparamref name="TResult"/> parameter.
                /// </summary>
                /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
                /// <returns>The return value of the method that this delegate encapsulates.</returns>
                delegate TResult Func<TResult>();
                
                /// <summary>
                /// Encapsulates a method that has no parameters and returns a value of
                /// the type specified by the <typeparamref name="TResult"/> parameter.
                /// </summary>
                /// <typeparam name="T">The type of the parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg">The parameter of the method that this delegate encapsulates.</param>
                /// <returns>The return value of the method that this delegate encapsulates.</returns>
                delegate TResult Func<T, TResult>(T arg);
                
                /// <summary>
                /// Encapsulates a method that has no parameters and returns a value of
                /// the type specified by the <typeparamref name="TResult"/> parameter.
                /// </summary>
                /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
                /// <returns>The return value of the method that this delegate encapsulates.</returns>
                delegate TResult Func<T1, T2, TResult>(T1 arg1, T2 arg2);
                
                /// <summary>
                /// Encapsulates a method that has no parameters and returns a value of
                /// the type specified by the <typeparamref name="TResult"/> parameter.
                /// </summary>
                /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
                /// <returns>The return value of the method that this delegate encapsulates.</returns>
                delegate TResult Func<T1, T2, T3, TResult>(T1 arg1, T2 arg2, T3 arg3);
                
                /// <summary>
                /// Encapsulates a method that has no parameters and returns a value of
                /// the type specified by the <typeparamref name="TResult"/> parameter.
                /// </summary>
                /// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
                /// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
                /// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
                /// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
                /// <returns>The return value of the method that this delegate encapsulates.</returns>
                delegate TResult Func<T1, T2, T3, T4, TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
                #elif NETSTANDARD && !NETSTANDARD2_0_OR_GREATER // ReSharper disable once RedundantBlankLines
                /// <summary>Represents a method that converts an object from one type to another type.</summary>
                /// <typeparam name="TInput">The type of object that is to be converted.</typeparam>
                /// <typeparam name="TOutput">The type the input object is to be converted to.</typeparam>
                /// <param name="input">The object to convert.</param>
                /// <returns>The <typeparamref name="TOutput"/> that represents the converted <typeparamref name="TInput"/>.</returns>
                delegate TOutput Converter<TInput, TOutput>(TInput input);
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Range.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace System;
                
                #pragma warning disable MA0008, MA0048, SA1515, SA1611, SA1615, SA1623, SA1642, SA1649
                /// <summary>Implements a <see cref="GetOffsetAndLength"/> overload that doesn't rely on tuples.</summary>
                static partial class RangeMethodsWithoutValueTuples
                {
                #pragma warning disable CS1574
                    /// <summary>Calculate the start offset and length of range object using a collection length.</summary>
                    /// <remarks><para>
                    /// For performance reasons, we don't validate the input length parameter against negative values.
                    /// It is expected Range will be used with collections which always have non negative length/count.
                    /// We validate the range is inside the length scope though.
                    /// </para></remarks>
                    /// <param name="range">The <see cref="Range"/> that contains the range of elements.</param>
                    /// <param name="length">
                    /// The length of the collection that the range will be used with.
                    /// <paramref name="length"/> has to be a positive value.
                    /// </param>
                    /// <param name="outOffset">The resulting offset.</param>
                    /// <param name="outLength">The resulting length.</param>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                #pragma warning restore CS1574
                    public static void GetOffsetAndLength(this Range range, int length, out int outOffset, out int outLength)
                    {
                        var startIndex = range.Start;
                        var start = startIndex.IsFromEnd ? length - startIndex.Value : startIndex.Value;
                
                        var endIndex = range.End;
                        var end = endIndex.IsFromEnd ? length - endIndex.Value : endIndex.Value;
                
                        if ((uint)end > (uint)length || (uint)start > (uint)end)
                            throw new ArgumentOutOfRangeException(nameof(length));
                
                        outOffset = start;
                        outLength = end - start;
                    }
                }
                
                #if !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP
                /// <summary>Represent a range has start and end indexes.</summary>
                /// <remarks><para>
                /// Range is used by the C# compiler to support the range syntax.
                /// </para><code>
                /// int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
                /// int[] subArray1 = someArray[0..2]; // { 1, 2 }
                /// int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
                /// </code></remarks>
                readonly partial struct Range : IEquatable<Range>
                {
                    /// <summary>Construct a Range object using the start and end indexes.</summary>
                    /// <param name="start">Represent the inclusive start index of the range.</param>
                    /// <param name="end">Represent the exclusive end index of the range.</param>
                    public Range(Index start, Index end)
                    {
                        Start = start;
                        End = end;
                    }
                
                    /// <summary>Create a Range object starting from first element to the end.</summary>
                    [Pure]
                    public static Range All => new(Index.Start, Index.End);
                
                    /// <summary>Represent the inclusive start index of the Range.</summary>
                    [Pure]
                    public Index Start { get; }
                
                    /// <summary>Represent the exclusive end index of the Range.</summary>
                    [Pure]
                    public Index End { get; }
                
                    /// <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
                    [Pure]
                    public static Range EndAt(Index end) => new(Index.Start, end);
                
                    /// <summary>Create a Range object starting from start index to the end of the collection.</summary>
                    [Pure]
                    public static Range StartAt(Index start) => new(start, Index.End);
                
                    /// <inheritdoc />
                    [Pure]
                    public override bool Equals([NotNullWhen(true)] object? value) =>
                        value is Range r && r.Start.Equals(Start) && r.End.Equals(End);
                
                    /// <inheritdoc />
                    [Pure]
                    public bool Equals(Range other) => other.Start.Equals(Start) && other.End.Equals(End);
                
                    /// <inheritdoc />
                    [Pure]
                    public override int GetHashCode() => Start.GetHashCode() * 31 + End.GetHashCode();
                
                    /// <inheritdoc />
                    [Pure]
                    public override string ToString() => $"{Start}..{End}";
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Index.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NETSTANDARD2_1_OR_GREATER && !NETCOREAPP
                #pragma warning disable MA0008, SA1515, SA1611, SA1615, SA1623, SA1642
                // ReSharper disable once CheckNamespace
                namespace System;
                
                /// <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
                /// <remarks><para>
                /// Index is used by the C# compiler to support the new index syntax.
                /// </para><code>
                /// int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
                /// int lastElement = someArray[^1]; // lastElement = 5
                /// </code></remarks>
                readonly partial struct Index : IEquatable<Index>
                {
                    readonly int _value;
                
                    /// <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
                    /// <param name="value">The index value. it has to be zero or positive number.</param>
                    /// <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
                    /// <remarks><para>
                    /// If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means
                    /// pointing at beyond last element.
                    /// </para></remarks>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public Index([NonNegativeValue] int value, bool fromEnd = false) =>
                        // Runtime check.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        _value = value >= 0
                            ? fromEnd ? ~value : value
                            : throw new ArgumentOutOfRangeException(nameof(value), "value must be non-negative");
                
                    // The following private constructors mainly created for perf reason to avoid the checks
                    Index([NonNegativeValue] int value) => _value = value;
                
                    /// <summary>Create an Index pointing at first element.</summary>
                    public static Index Start => new(0);
                
                    /// <summary>Create an Index pointing at beyond last element.</summary>
                    public static Index End => new(~0);
                
                    /// <summary>Indicates whether the index is from the start or the end.</summary>
                    [Pure]
                    public bool IsFromEnd => _value < 0;
                
                    /// <summary>Returns the index value.</summary>
                    [NonNegativeValue, Pure]
                    public int Value => _value < 0 ? ~_value : _value;
                
                    /// <summary>Converts integer number to an Index.</summary>
                    [Pure]
                    public static implicit operator Index([NonNegativeValue] int value) => FromStart(value);
                
                    /// <summary>Create an Index from the end at the position indicated by the value.</summary>
                    /// <param name="value">The index value from the end.</param>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static Index FromEnd([NonNegativeValue] int value) =>
                        // Runtime check.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        value >= 0
                            ? new(~value)
                            : throw new ArgumentOutOfRangeException(nameof(value), "value must be non-negative");
                
                    /// <summary>Create an Index from the start at the position indicated by the value.</summary>
                    /// <param name="value">The index value from the start.</param>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static Index FromStart([NonNegativeValue] int value) =>
                        // Runtime check.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        value >= 0
                            ? new(value)
                            : throw new ArgumentOutOfRangeException(nameof(value), "value must be non-negative");
                
                    /// <inheritdoc />
                    [Pure]
                    public override bool Equals([NotNullWhen(true)] object? value) => value is Index index && _value == index._value;
                
                    /// <inheritdoc />
                    [Pure]
                    public bool Equals(Index other) => _value == other._value;
                
                    /// <inheritdoc />
                    [Pure]
                    public override int GetHashCode() => _value;
                
                    /// <summary>Calculate the offset from the start using the giving collection length.</summary>
                    /// <param name="length">
                    /// The length of the collection that the Index will be used with. length has to be a positive value.
                    /// </param>
                    /// <remarks><para>
                    /// For performance reasons, we don't validate the input length parameter and the returned offset value against
                    /// negative values. We don't validate either the returned offset is greater than the input length.
                    /// It is expected that Index be used with collections which always have non-negative length/count.
                    /// If the returned offset is negative and then used to index a collection will get out of range exception which
                    /// will be same affect as the validation.
                    /// </para></remarks>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public int GetOffset(int length)
                    {
                        var offset = _value;
                
                        if (IsFromEnd)
                            // offset = length - (~value)
                            // offset = length + (~(~value) + 1)
                            // offset = length + value + 1
                            offset += length + 1;
                
                        return offset;
                    }
                
                    /// <inheritdoc />
                    [Pure]
                    public override string ToString() => IsFromEnd ? $"^{(uint)Value}" : ((uint)Value).ToString();
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.ValueTuple.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable ArrangeAttributes ArrangeNamespaceBody CheckNamespace EmptyNamespace FunctionComplexityOverflow InconsistentNaming SuspiciousTypeConversion.Global
                // Shamelessly stolen from https://raw.githubusercontent.com/igor-tkachev/Portable.System.ValueTuple/master/Portable.System.ValueTuple.cs
                // and creatively reworked. Which is...
                //
                // Shamelessly stolen from https://github.com/dotnet/roslyn/blob/master/src/Compilers/Test/Resources/Core/NetFX/ValueTuple/ValueTuple.cs
                // and creatively reworked.
                //
                // Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
                
                #pragma warning disable CA1200, CA1508, CA2208, CA5394, DOC100, DOC202, IDE0161, MA0012, MA0015, MA0048, MA0051, MA0097, SA1129, SA1141, SA1201, SA1202, SA1600, SA1611, SA1623, SA1642, SA1649
                namespace System
                {
                #if NETFRAMEWORK || NETSTANDARD && !NETSTANDARD2_1_OR_GREATER || NETCOREAPP && !NETCOREAPP2_0_OR_GREATER
                    /// <summary>Allows a <see cref="KeyValuePair{TKey, TValue}"/> to be deconstructed, much like a tuple.</summary>
                    static partial class KeyValuePairDeconstructors
                    {
                        /// <summary>Deconstructs a <see cref="KeyValuePair{TKey, TValue}"/> into its components.</summary>
                        /// <typeparam name="TKey">The key generic in the <see cref="KeyValuePair{TKey, TValue}"/>.</typeparam>
                        /// <typeparam name="TValue">The value generic in the <see cref="KeyValuePair{TKey, TValue}"/>.</typeparam>
                        /// <param name="kvp">The key value pair to deconstruct.</param>
                        /// <param name="key">The key value to get assigned as the key value pair's key.</param>
                        /// <param name="value">The key value to get assigned as the key value pair's value.</param>
                        public static void Deconstruct<TKey, TValue>(
                            this KeyValuePair<TKey, TValue> kvp,
                            out TKey key,
                            out TValue value
                        )
                        {
                            key = kvp.Key;
                            value = kvp.Value;
                        }
                    }
                #endif
                #if NETFRAMEWORK && !NET47_OR_GREATER || NETSTANDARD && !NETSTANDARD2_0_OR_GREATER || NETCOREAPP && !NETCOREAPP2_0_OR_GREATER
                #pragma warning disable SA1403
                    namespace Runtime.CompilerServices
                #pragma warning restore SA1403
                    {
                        /// <summary>This interface is required for types that want to be indexed into by dynamic patterns.</summary>
                        partial interface ITuple
                        {
                            /// <summary>The number of positions in this data structure.</summary>
                            [NonNegativeValue, Pure]
                            int Length { get; }
                
                            /// <summary>Get the element at position <paramref name="index"/>.</summary>
                            [Pure]
                            object? this[[NonNegativeValue] int index] { get; }
                        }
                
                        /// <summary>
                        /// Indicates that the use of <see cref="T:System.ValueTuple" /> on a member is meant to be treated as a tuple with element names.
                        /// </summary>
                        [AttributeUsage(
                            AttributeTargets.Class |
                            AttributeTargets.Struct |
                            AttributeTargets.Property |
                            AttributeTargets.Field |
                            AttributeTargets.Event |
                            AttributeTargets.Parameter |
                            AttributeTargets.ReturnValue
                        )]
                        sealed partial class TupleElementNamesAttribute : Attribute
                        {
                            readonly string[] _transformNames;
                
                            /// <summary>
                            /// Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute" /> class.
                            /// </summary>
                            /// <param name="transformNames">
                            /// Specifies, in a pre-order depth-first traversal of a type's
                            /// construction, which <see cref="T:System.ValueTuple" /> occurrences are
                            /// meant to carry element names.
                            /// </param>
                            /// <remarks><para>
                            /// This constructor is meant to be used on types that contain an
                            /// instantiation of <see cref="T:System.ValueTuple" /> that contains
                            /// element names.  For instance, if <c>C</c> is a generic type with
                            /// two type parameters, then a use of the constructed type <c>C{<see cref="T:System.ValueTuple`2" />,
                            /// <see cref="T:System.ValueTuple`3" /></c> might be intended to
                            /// treat the first type argument as a tuple with element names and the
                            /// second as a tuple without element names. In which case, the
                            /// appropriate attribute specification should use a
                            /// <paramref name="transformNames"/> value of <c>{ "name1", "name2", null, null,
                            /// null }</c>.
                            /// </para></remarks>
                            public TupleElementNamesAttribute(string[] transformNames) =>
                                _transformNames = transformNames ?? throw new ArgumentNullException(nameof(transformNames));
                
                            /// <summary>
                            /// Specifies, in a pre-order depth-first traversal of a type's
                            /// construction, which <see cref="T:System.ValueTuple" /> elements are
                            /// meant to carry element names.
                            /// </summary>
                            [Pure]
                            public IList<string> TransformNames => _transformNames;
                        }
                    }
                
                    /// <summary>
                    /// Helper so we can call some tuple methods recursively without knowing the underlying types.
                    /// </summary>
                    partial interface IValueTupleInternal : ITuple
                    {
                        [Pure]
                        int GetHashCode(IEqualityComparer comparer);
                
                        [Pure]
                        string ToStringEnd();
                    }
                
                    /// <summary>
                    /// The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
                    /// Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
                    /// The System.ValueTuple types differ from the System.Tuple types in that:
                    /// - they are structs rather than classes,
                    /// - they are mutable rather than readonly, and
                    /// - their members (such as Item1, Item2, etc) are fields rather than properties.
                    /// </summary>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    readonly partial struct ValueTuple : IEquatable<ValueTuple>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple>,
                        IValueTupleInternal
                    {
                        static readonly int s_randomSeed = new Random().Next(int.MinValue, int.MaxValue);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="ValueTuple"/>.</returns>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) => obj is ValueTuple;
                
                        /// <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
                        /// <param name="other">An instance to compare to this instance.</param>
                        /// <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
                        [Pure]
                        public bool Equals(ValueTuple other) => true;
                
                        [Pure, ValueRange(0, 1)]
                        int IComparable.CompareTo(object? other) =>
                            other switch
                            {
                                null => 1,
                                ValueTuple => 0,
                                _ => throw new ArgumentException(),
                            };
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure, ValueRange(0)]
                        public int CompareTo(ValueTuple other) => 0;
                
                        /// <summary>Returns the hash code for this instance.</summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure, ValueRange(0)]
                        public override int GetHashCode() => 0;
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer) => other is ValueTuple;
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => 0;
                
                        [Pure, ValueRange(0)]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer) =>
                            other switch
                            {
                                null => 1,
                                ValueTuple => 0,
                                _ => throw new ArgumentException(),
                            };
                
                #endif
                
                        [Pure, ValueRange(0)]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => 0;
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>()</c>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => "()";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => ")";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure]
                        int ITuple.Length => 0;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object ITuple.this[[ValueRange(0, -1)] int index]
                        {
                            [DoesNotReturn] get => throw new IndexOutOfRangeException();
                        }
                
                        /// <summary>Creates a new struct 0-tuple.</summary>
                        /// <returns>A 0-tuple.</returns>
                        [Pure]
                        public static ValueTuple Create() => new();
                
                        /// <summary>Creates a new struct 1-tuple, or singleton.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <returns>A 1-tuple (singleton) whose value is (item1).</returns>
                        [Pure]
                        public static ValueTuple<T1> Create<T1>(T1 item1) => new(item1);
                
                        /// <summary>Creates a new struct 2-tuple, or pair.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2) => new(item1, item2);
                
                        /// <summary>Creates a new struct 3-tuple, or triple.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <param name="item3">The value of the third component of the tuple.</param>
                        /// <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3) =>
                            new(item1, item2, item3);
                
                        /// <summary>Creates a new struct 4-tuple, or quadruple.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
                        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <param name="item3">The value of the third component of the tuple.</param>
                        /// <param name="item4">The value of the fourth component of the tuple.</param>
                        /// <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4) =>
                            new(item1, item2, item3, item4);
                
                        /// <summary>Creates a new struct 5-tuple, or quintuple.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
                        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
                        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <param name="item3">The value of the third component of the tuple.</param>
                        /// <param name="item4">The value of the fourth component of the tuple.</param>
                        /// <param name="item5">The value of the fifth component of the tuple.</param>
                        /// <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(
                            T1 item1,
                            T2 item2,
                            T3 item3,
                            T4 item4,
                            T5 item5
                        ) =>
                            new(item1, item2, item3, item4, item5);
                
                        /// <summary>Creates a new struct 6-tuple, or sextuple.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
                        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
                        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
                        /// <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <param name="item3">The value of the third component of the tuple.</param>
                        /// <param name="item4">The value of the fourth component of the tuple.</param>
                        /// <param name="item5">The value of the fifth component of the tuple.</param>
                        /// <param name="item6">The value of the sixth component of the tuple.</param>
                        /// <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(
                            T1 item1,
                            T2 item2,
                            T3 item3,
                            T4 item4,
                            T5 item5,
                            T6 item6
                        ) =>
                            new(item1, item2, item3, item4, item5, item6);
                
                        /// <summary>Creates a new struct 7-tuple, or septuple.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
                        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
                        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
                        /// <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
                        /// <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <param name="item3">The value of the third component of the tuple.</param>
                        /// <param name="item4">The value of the fourth component of the tuple.</param>
                        /// <param name="item5">The value of the fifth component of the tuple.</param>
                        /// <param name="item6">The value of the sixth component of the tuple.</param>
                        /// <param name="item7">The value of the seventh component of the tuple.</param>
                        /// <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(
                            T1 item1,
                            T2 item2,
                            T3 item3,
                            T4 item4,
                            T5 item5,
                            T6 item6,
                            T7 item7
                        ) =>
                            new(item1, item2, item3, item4, item5, item6, item7);
                
                        /// <summary>Creates a new struct 8-tuple, or octuple.</summary>
                        /// <typeparam name="T1">The type of the first component of the tuple.</typeparam>
                        /// <typeparam name="T2">The type of the second component of the tuple.</typeparam>
                        /// <typeparam name="T3">The type of the third component of the tuple.</typeparam>
                        /// <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
                        /// <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
                        /// <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
                        /// <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
                        /// <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
                        /// <param name="item1">The value of the first component of the tuple.</param>
                        /// <param name="item2">The value of the second component of the tuple.</param>
                        /// <param name="item3">The value of the third component of the tuple.</param>
                        /// <param name="item4">The value of the fourth component of the tuple.</param>
                        /// <param name="item5">The value of the fifth component of the tuple.</param>
                        /// <param name="item6">The value of the sixth component of the tuple.</param>
                        /// <param name="item7">The value of the seventh component of the tuple.</param>
                        /// <param name="item8">The value of the eighth component of the tuple.</param>
                        /// <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
                        [Pure]
                        public static ValueTuple<T1, T2, T3, T4, T5, T6, T7, ValueTuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(
                            T1 item1,
                            T2 item2,
                            T3 item3,
                            T4 item4,
                            T5 item5,
                            T6 item6,
                            T7 item7,
                            T8 item8
                        ) =>
                            new(
                                item1,
                                item2,
                                item3,
                                item4,
                                item5,
                                item6,
                                item7,
                                Create(item8)
                            );
                
                        [Pure]
                        public static int CombineHashCodes(int h1, int h2) => Combine(Combine(s_randomSeed, h1), h2);
                
                        [Pure]
                        public static int CombineHashCodes(int h1, int h2, int h3) => Combine(CombineHashCodes(h1, h2), h3);
                
                        [Pure]
                        public static int CombineHashCodes(int h1, int h2, int h3, int h4) => Combine(CombineHashCodes(h1, h2, h3), h4);
                
                        [Pure]
                        public static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5) =>
                            Combine(CombineHashCodes(h1, h2, h3, h4), h5);
                
                        [Pure]
                        public static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6) =>
                            Combine(CombineHashCodes(h1, h2, h3, h4, h5), h6);
                
                        [Pure]
                        public static int CombineHashCodes(
                            int h1,
                            int h2,
                            int h3,
                            int h4,
                            int h5,
                            int h6,
                            int h7
                        ) =>
                            Combine(CombineHashCodes(h1, h2, h3, h4, h5, h6), h7);
                
                        [Pure]
                        public static int CombineHashCodes(
                            int h1,
                            int h2,
                            int h3,
                            int h4,
                            int h5,
                            int h6,
                            int h7,
                            int h8
                        ) =>
                            Combine(CombineHashCodes(h1, h2, h3, h4, h5, h6, h7), h8);
                
                        [Pure]
                        static int Combine(int h1, int h2)
                        {
                            // RyuJIT optimizes this to use the ROL instruction
                            // Related GitHub pull request: dotnet/coreclr#1830
                            var rol5 = (uint)h1 << 5 | (uint)h1 >> 27;
                            return (int)rol5 + h1 ^ h2;
                        }
                    }
                
                    /// <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
                    /// <typeparam name="T1">The type of the tuple's only component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    readonly partial struct ValueTuple<T1> : IEquatable<ValueTuple<T1>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        public ValueTuple(T1 item1) => Item1 = item1;
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) => obj is ValueTuple<T1> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
                        /// is equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1> other) => EqualityComparer<T1>.Default.Equals(Item1, other.Item1);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1>)other;
                
                            return Comparer<T1>.Default.Compare(Item1, objTuple.Item1);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1> other) => Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        public override int GetHashCode() => Item1?.GetHashCode() ?? 0;
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1>)
                                return false;
                
                            var objTuple = (ValueTuple<T1>)other;
                
                            return comparer.Equals(Item1, objTuple.Item1);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => comparer.GetHashCode(Item1);
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1>)other;
                
                            return comparer.Compare(Item1, objTuple.Item1);
                        }
                
                #endif
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => comparer.GetHashCode(Item1);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1)</c>,
                        /// where <see cref="Item1"/> represents the value of <see cref="Item1"/>. If the field is <see langword="null"/>,
                        /// it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(1)]
                        int ITuple.Length => 1;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        object? ITuple.this[[ValueRange(0)] int index]
                        {
                            get
                            {
                                if (index != 0)
                                    throw new IndexOutOfRangeException();
                
                                return Item1;
                            }
                        }
                    }
                
                    /// <summary>
                    /// Represents a 2-tuple, or pair, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2> : IEquatable<ValueTuple<T1, T2>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2}"/> instance's first component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        public ValueTuple(T1 item1, T2 item2)
                        {
                            Item1 = item1;
                            Item2 = item2;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        ///
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2}"/> instance is equal to a specified <see cref="ValueTuple{T1,T2}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2>)
                                throw new ArgumentException();
                
                            return CompareTo((ValueTuple<T1, T2>)other);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                            return c != 0 ? c : Comparer<T2>.Default.Compare(Item2, other.Item2);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1, T2>)
                                return false;
                
                            var objTuple = (ValueTuple<T1, T2>)other;
                
                            return
                                comparer.Equals(Item1, objTuple.Item1) &&
                                comparer.Equals(Item2, objTuple.Item2);
                        }
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1, T2>)other;
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            return c != 0 ? c : comparer.Compare(Item2, objTuple.Item2);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode() =>
                            ValueTuple.CombineHashCodes(
                                Item1?.GetHashCode() ?? 0,
                                Item2?.GetHashCode() ?? 0
                            );
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer) =>
                            ValueTuple.CombineHashCodes(
                                comparer.GetHashCode(Item1),
                                comparer.GetHashCode(Item2)
                            );
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2)</c>,
                        /// where <see cref="Item1"/> and <see cref="Item2"/> represent the values of the <see cref="Item1"/>
                        /// and <see cref="Item2"/> fields. If either field value is <see langword="null"/>,
                        /// it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1}, {Item2})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1}, {Item2})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(2)]
                        int ITuple.Length => 2;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object? ITuple.this[[ValueRange(0, 1)] int index] =>
                            index switch
                            {
                                0 => Item1,
                                1 => Item2,
                                _ => throw new IndexOutOfRangeException(),
                            };
                    }
                
                    /// <summary>
                    /// Represents a 3-tuple, or triple, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2, T3> : IEquatable<ValueTuple<T1, T2, T3>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2, T3>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3}"/> instance's second component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3}"/> instance's third component.
                        /// </summary>
                        public readonly T3 Item3;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2,T3}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        /// <param name="item3">The value of the tuple's third component.</param>
                        public ValueTuple(T1 item1, T2 item2, T3 item3)
                        {
                            Item1 = item1;
                            Item2 = item2;
                            Item3 = item3;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2,T3}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2, T3> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1,T2,T3}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2, T3> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2) &&
                            EqualityComparer<T3>.Default.Equals(Item3, other.Item3);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3>)
                                throw new ArgumentException();
                
                            return CompareTo((ValueTuple<T1, T2, T3>)other);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2, T3> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T2>.Default.Compare(Item2, other.Item2);
                            return c != 0 ? c : Comparer<T3>.Default.Compare(Item3, other.Item3);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1, T2, T3>)
                                return false;
                
                            var objTuple = (ValueTuple<T1, T2, T3>)other;
                
                            return
                                comparer.Equals(Item1, objTuple.Item1) &&
                                comparer.Equals(Item2, objTuple.Item2) &&
                                comparer.Equals(Item3, objTuple.Item3);
                        }
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1, T2, T3>)other;
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item2, objTuple.Item2);
                            return c != 0 ? c : comparer.Compare(Item3, objTuple.Item3);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2,T3}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode() =>
                            ValueTuple.CombineHashCodes(
                                Item1?.GetHashCode() ?? 0,
                                Item2?.GetHashCode() ?? 0,
                                Item3?.GetHashCode() ?? 0
                            );
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer) =>
                            ValueTuple.CombineHashCodes(
                                comparer.GetHashCode(Item1),
                                comparer.GetHashCode(Item2),
                                comparer.GetHashCode(Item3)
                            );
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2,T3}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2,T3}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
                        /// If any field value is <see langword="null"/>, it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1}, {Item2}, {Item3})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1}, {Item2}, {Item3})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(3)]
                        int ITuple.Length => 3;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object? ITuple.this[[ValueRange(0, 2)] int index] =>
                            index switch
                            {
                                0 => Item1,
                                1 => Item2,
                                2 => Item3,
                                _ => throw new IndexOutOfRangeException(),
                            };
                    }
                
                    /// <summary>
                    /// Represents a 4-tuple, or quadruple, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
                    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2, T3, T4> : IEquatable<ValueTuple<T1, T2, T3, T4>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2, T3, T4>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4}"/> instance's second component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4}"/> instance's third component.
                        /// </summary>
                        public readonly T3 Item3;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4}"/> instance's fourth component.
                        /// </summary>
                        public readonly T4 Item4;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2,T3,T4}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        /// <param name="item3">The value of the tuple's third component.</param>
                        /// <param name="item4">The value of the tuple's fourth component.</param>
                        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4)
                        {
                            Item1 = item1;
                            Item2 = item2;
                            Item3 = item3;
                            Item4 = item4;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2,T3,T4}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2, T3, T4> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1,T2,T3,T4}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2, T3, T4> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2) &&
                            EqualityComparer<T3>.Default.Equals(Item3, other.Item3) &&
                            EqualityComparer<T4>.Default.Equals(Item4, other.Item4);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4>)
                                throw new ArgumentException();
                
                            return CompareTo((ValueTuple<T1, T2, T3, T4>)other);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2, T3, T4> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T2>.Default.Compare(Item2, other.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T3>.Default.Compare(Item3, other.Item3);
                            return c != 0 ? c : Comparer<T4>.Default.Compare(Item4, other.Item4);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1, T2, T3, T4>)
                                return false;
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4>)other;
                
                            return
                                comparer.Equals(Item1, objTuple.Item1) &&
                                comparer.Equals(Item2, objTuple.Item2) &&
                                comparer.Equals(Item3, objTuple.Item3) &&
                                comparer.Equals(Item4, objTuple.Item4);
                        }
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4>)other;
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item2, objTuple.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item3, objTuple.Item3);
                            return c != 0 ? c : comparer.Compare(Item4, objTuple.Item4);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2,T3,T4}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode() =>
                            ValueTuple.CombineHashCodes(
                                Item1?.GetHashCode() ?? 0,
                                Item2?.GetHashCode() ?? 0,
                                Item3?.GetHashCode() ?? 0,
                                Item4?.GetHashCode() ?? 0
                            );
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer) =>
                            ValueTuple.CombineHashCodes(
                                comparer.GetHashCode(Item1),
                                comparer.GetHashCode(Item2),
                                comparer.GetHashCode(Item3),
                                comparer.GetHashCode(Item4)
                            );
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2,T3,T4}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2,T3,T4}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
                        /// If any field value is <see langword="null"/>, it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1}, {Item2}, {Item3}, {Item4})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1}, {Item2}, {Item3}, {Item4})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(4)]
                        int ITuple.Length => 4;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object? ITuple.this[[ValueRange(0, 3)] int index] =>
                            index switch
                            {
                                0 => Item1,
                                1 => Item2,
                                2 => Item3,
                                3 => Item4,
                                _ => throw new IndexOutOfRangeException(),
                            };
                    }
                
                    /// <summary>
                    /// Represents a 5-tuple, or quintuple, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
                    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
                    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2, T3, T4, T5> : IEquatable<ValueTuple<T1, T2, T3, T4, T5>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2, T3, T4, T5>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance's second component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance's third component.
                        /// </summary>
                        public readonly T3 Item3;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance's fourth component.
                        /// </summary>
                        public readonly T4 Item4;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance's fifth component.
                        /// </summary>
                        public readonly T5 Item5;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        /// <param name="item3">The value of the tuple's third component.</param>
                        /// <param name="item4">The value of the tuple's fourth component.</param>
                        /// <param name="item5">The value of the tuple's fifth component.</param>
                        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5)
                        {
                            Item1 = item1;
                            Item2 = item2;
                            Item3 = item3;
                            Item4 = item4;
                            Item5 = item5;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2, T3, T4, T5> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1,T2,T3,T4,T5}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2, T3, T4, T5> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2) &&
                            EqualityComparer<T3>.Default.Equals(Item3, other.Item3) &&
                            EqualityComparer<T4>.Default.Equals(Item4, other.Item4) &&
                            EqualityComparer<T5>.Default.Equals(Item5, other.Item5);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5>)
                                throw new ArgumentException();
                
                            return CompareTo((ValueTuple<T1, T2, T3, T4, T5>)other);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2, T3, T4, T5> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T2>.Default.Compare(Item2, other.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T3>.Default.Compare(Item3, other.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T4>.Default.Compare(Item4, other.Item4);
                            return c != 0 ? c : Comparer<T5>.Default.Compare(Item5, other.Item5);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1, T2, T3, T4, T5>)
                                return false;
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4, T5>)other;
                
                            return
                                comparer.Equals(Item1, objTuple.Item1) &&
                                comparer.Equals(Item2, objTuple.Item2) &&
                                comparer.Equals(Item3, objTuple.Item3) &&
                                comparer.Equals(Item4, objTuple.Item4) &&
                                comparer.Equals(Item5, objTuple.Item5);
                        }
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4, T5>)other;
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item2, objTuple.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item3, objTuple.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item4, objTuple.Item4);
                            return c != 0 ? c : comparer.Compare(Item5, objTuple.Item5);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode() =>
                            ValueTuple.CombineHashCodes(
                                Item1?.GetHashCode() ?? 0,
                                Item2?.GetHashCode() ?? 0,
                                Item3?.GetHashCode() ?? 0,
                                Item4?.GetHashCode() ?? 0,
                                Item5?.GetHashCode() ?? 0
                            );
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer) =>
                            ValueTuple.CombineHashCodes(
                                comparer.GetHashCode(Item1),
                                comparer.GetHashCode(Item2),
                                comparer.GetHashCode(Item3),
                                comparer.GetHashCode(Item4),
                                comparer.GetHashCode(Item5)
                            );
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2,T3,T4,T5}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
                        /// If any field value is <see langword="null"/>, it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1}, {Item2}, {Item3}, {Item4}, {Item5})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1}, {Item2}, {Item3}, {Item4}, {Item5})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(5)]
                        int ITuple.Length => 5;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        object? ITuple.this[[ValueRange(0, 4)] int index] =>
                            index switch
                            {
                                0 => Item1,
                                1 => Item2,
                                2 => Item3,
                                3 => Item4,
                                4 => Item5,
                                _ => throw new IndexOutOfRangeException(),
                            };
                    }
                
                    /// <summary>
                    /// Represents a 6-tuple, or sixtuple, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
                    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
                    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
                    /// <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2, T3, T4, T5, T6> : IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2, T3, T4, T5, T6>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance's second component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance's third component.
                        /// </summary>
                        public readonly T3 Item3;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance's fourth component.
                        /// </summary>
                        public readonly T4 Item4;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance's fifth component.
                        /// </summary>
                        public readonly T5 Item5;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance's sixth component.
                        /// </summary>
                        public readonly T6 Item6;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        /// <param name="item3">The value of the tuple's third component.</param>
                        /// <param name="item4">The value of the tuple's fourth component.</param>
                        /// <param name="item5">The value of the tuple's fifth component.</param>
                        /// <param name="item6">The value of the tuple's sixth component.</param>
                        public ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6)
                        {
                            Item1 = item1;
                            Item2 = item2;
                            Item3 = item3;
                            Item4 = item4;
                            Item5 = item5;
                            Item6 = item6;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2, T3, T4, T5, T6> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2, T3, T4, T5, T6> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2) &&
                            EqualityComparer<T3>.Default.Equals(Item3, other.Item3) &&
                            EqualityComparer<T4>.Default.Equals(Item4, other.Item4) &&
                            EqualityComparer<T5>.Default.Equals(Item5, other.Item5) &&
                            EqualityComparer<T6>.Default.Equals(Item6, other.Item6);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6>)
                                throw new ArgumentException();
                
                            return CompareTo((ValueTuple<T1, T2, T3, T4, T5, T6>)other);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2, T3, T4, T5, T6> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T2>.Default.Compare(Item2, other.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T3>.Default.Compare(Item3, other.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T4>.Default.Compare(Item4, other.Item4);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T5>.Default.Compare(Item5, other.Item5);
                            return c != 0 ? c : Comparer<T6>.Default.Compare(Item6, other.Item6);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6>)
                                return false;
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4, T5, T6>)other;
                
                            return
                                comparer.Equals(Item1, objTuple.Item1) &&
                                comparer.Equals(Item2, objTuple.Item2) &&
                                comparer.Equals(Item3, objTuple.Item3) &&
                                comparer.Equals(Item4, objTuple.Item4) &&
                                comparer.Equals(Item5, objTuple.Item5) &&
                                comparer.Equals(Item6, objTuple.Item6);
                        }
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4, T5, T6>)other;
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item2, objTuple.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item3, objTuple.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item4, objTuple.Item4);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item5, objTuple.Item5);
                            return c != 0 ? c : comparer.Compare(Item6, objTuple.Item6);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode() =>
                            ValueTuple.CombineHashCodes(
                                Item1?.GetHashCode() ?? 0,
                                Item2?.GetHashCode() ?? 0,
                                Item3?.GetHashCode() ?? 0,
                                Item4?.GetHashCode() ?? 0,
                                Item5?.GetHashCode() ?? 0,
                                Item6?.GetHashCode() ?? 0
                            );
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer) =>
                            ValueTuple.CombineHashCodes(
                                comparer.GetHashCode(Item1),
                                comparer.GetHashCode(Item2),
                                comparer.GetHashCode(Item3),
                                comparer.GetHashCode(Item4),
                                comparer.GetHashCode(Item5),
                                comparer.GetHashCode(Item6)
                            );
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2,T3,T4,T5,T6}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
                        /// If any field value is <see langword="null"/>, it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(6)]
                        int ITuple.Length => 6;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object? ITuple.this[[ValueRange(0, 5)] int index] =>
                            index switch
                            {
                                0 => Item1,
                                1 => Item2,
                                2 => Item3,
                                3 => Item4,
                                4 => Item5,
                                5 => Item6,
                                _ => throw new IndexOutOfRangeException(),
                            };
                    }
                
                    /// <summary>
                    /// Represents a 7-tuple, or sentuple, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
                    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
                    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
                    /// <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
                    /// <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>,
                        IValueTupleInternal
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's second component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's third component.
                        /// </summary>
                        public readonly T3 Item3;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's fourth component.
                        /// </summary>
                        public readonly T4 Item4;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's fifth component.
                        /// </summary>
                        public readonly T5 Item5;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's sixth component.
                        /// </summary>
                        public readonly T6 Item6;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance's seventh component.
                        /// </summary>
                        public readonly T7 Item7;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        /// <param name="item3">The value of the tuple's third component.</param>
                        /// <param name="item4">The value of the tuple's fourth component.</param>
                        /// <param name="item5">The value of the tuple's fifth component.</param>
                        /// <param name="item6">The value of the tuple's sixth component.</param>
                        /// <param name="item7">The value of the tuple's seventh component.</param>
                        public ValueTuple(
                            T1 item1,
                            T2 item2,
                            T3 item3,
                            T4 item4,
                            T5 item5,
                            T6 item6,
                            T7 item7
                        )
                        {
                            Item1 = item1;
                            Item2 = item2;
                            Item3 = item3;
                            Item4 = item4;
                            Item5 = item5;
                            Item6 = item6;
                            Item7 = item7;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2, T3, T4, T5, T6, T7> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2, T3, T4, T5, T6, T7> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2) &&
                            EqualityComparer<T3>.Default.Equals(Item3, other.Item3) &&
                            EqualityComparer<T4>.Default.Equals(Item4, other.Item4) &&
                            EqualityComparer<T5>.Default.Equals(Item5, other.Item5) &&
                            EqualityComparer<T6>.Default.Equals(Item6, other.Item6) &&
                            EqualityComparer<T7>.Default.Equals(Item7, other.Item7);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6, T7>)
                                throw new ArgumentException();
                
                            return CompareTo((ValueTuple<T1, T2, T3, T4, T5, T6, T7>)other);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2, T3, T4, T5, T6, T7> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T2>.Default.Compare(Item2, other.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T3>.Default.Compare(Item3, other.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T4>.Default.Compare(Item4, other.Item4);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T5>.Default.Compare(Item5, other.Item5);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T6>.Default.Compare(Item6, other.Item6);
                            return c != 0 ? c : Comparer<T7>.Default.Compare(Item7, other.Item7);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer)
                        {
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6, T7>)
                                return false;
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4, T5, T6, T7>)other;
                
                            return
                                comparer.Equals(Item1, objTuple.Item1) &&
                                comparer.Equals(Item2, objTuple.Item2) &&
                                comparer.Equals(Item3, objTuple.Item3) &&
                                comparer.Equals(Item4, objTuple.Item4) &&
                                comparer.Equals(Item5, objTuple.Item5) &&
                                comparer.Equals(Item6, objTuple.Item6) &&
                                comparer.Equals(Item7, objTuple.Item7);
                        }
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6, T7>)
                                throw new ArgumentException();
                
                            var objTuple = (ValueTuple<T1, T2, T3, T4, T5, T6, T7>)other;
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item2, objTuple.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item3, objTuple.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item4, objTuple.Item4);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item5, objTuple.Item5);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item6, objTuple.Item6);
                            return c != 0 ? c : comparer.Compare(Item7, objTuple.Item7);
                        }
                
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode() =>
                            ValueTuple.CombineHashCodes(
                                Item1?.GetHashCode() ?? 0,
                                Item2?.GetHashCode() ?? 0,
                                Item3?.GetHashCode() ?? 0,
                                Item4?.GetHashCode() ?? 0,
                                Item5?.GetHashCode() ?? 0,
                                Item6?.GetHashCode() ?? 0,
                                Item7?.GetHashCode() ?? 0
                            );
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer) =>
                            ValueTuple.CombineHashCodes(
                                comparer.GetHashCode(Item1),
                                comparer.GetHashCode(Item2),
                                comparer.GetHashCode(Item3),
                                comparer.GetHashCode(Item4),
                                comparer.GetHashCode(Item5),
                                comparer.GetHashCode(Item6),
                                comparer.GetHashCode(Item7)
                            );
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
                        /// If any field value is <see langword="null"/>, it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() => $"({Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7})";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() => $"{Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7})";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, ValueRange(7)]
                        int ITuple.Length => 7;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object? ITuple.this[[ValueRange(0, 6)] int index] =>
                            index switch
                            {
                                0 => Item1,
                                1 => Item2,
                                2 => Item3,
                                3 => Item4,
                                4 => Item5,
                                5 => Item6,
                                6 => Item7,
                                _ => throw new IndexOutOfRangeException(),
                            };
                    }
                
                    /// <summary>
                    /// Represents an 8-tuple, or octuple, as a value type.
                    /// </summary>
                    /// <typeparam name="T1">The type of the tuple's first component.</typeparam>
                    /// <typeparam name="T2">The type of the tuple's second component.</typeparam>
                    /// <typeparam name="T3">The type of the tuple's third component.</typeparam>
                    /// <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
                    /// <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
                    /// <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
                    /// <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
                    /// <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
                #if !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
                    [Serializable]
                #endif
                    [StructLayout(LayoutKind.Auto)]
                    readonly partial struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> :
                        IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>,
                #if !NET20 && !NET30 && !NET35
                        IStructuralEquatable,
                        IStructuralComparable,
                #endif
                        IComparable,
                        IComparable<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>,
                        IValueTupleInternal
                        where TRest : struct
                    {
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's first component.
                        /// </summary>
                        public readonly T1 Item1;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's second component.
                        /// </summary>
                        public readonly T2 Item2;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's third component.
                        /// </summary>
                        public readonly T3 Item3;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's fourth component.
                        /// </summary>
                        public readonly T4 Item4;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's fifth component.
                        /// </summary>
                        public readonly T5 Item5;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's sixth component.
                        /// </summary>
                        public readonly T6 Item6;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's seventh component.
                        /// </summary>
                        public readonly T7 Item7;
                
                        /// <summary>
                        /// The current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance's eighth component.
                        /// </summary>
                        public readonly TRest Rest;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> value type.
                        /// </summary>
                        /// <param name="item1">The value of the tuple's first component.</param>
                        /// <param name="item2">The value of the tuple's second component.</param>
                        /// <param name="item3">The value of the tuple's third component.</param>
                        /// <param name="item4">The value of the tuple's fourth component.</param>
                        /// <param name="item5">The value of the tuple's fifth component.</param>
                        /// <param name="item6">The value of the tuple's sixth component.</param>
                        /// <param name="item7">The value of the tuple's seventh component.</param>
                        /// <param name="rest">The value of the tuple's eight component.</param>
                        public ValueTuple(
                            T1 item1,
                            T2 item2,
                            T3 item3,
                            T4 item4,
                            T5 item5,
                            T6 item6,
                            T7 item7,
                            TRest rest
                        )
                        {
                            if (rest is not IValueTupleInternal)
                                throw new ArgumentException();
                
                            Item1 = item1;
                            Item2 = item2;
                            Item3 = item3;
                            Item4 = item4;
                            Item5 = item5;
                            Item6 = item6;
                            Item7 = item7;
                            Rest = rest;
                        }
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance is equal to a specified object.
                        /// </summary>
                        /// <param name="obj">The object to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
                        /// <list type="bullet">
                        ///     <item><description>It is a <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> value type.</description></item>
                        ///     <item><description>Its components are of the same types as those of the current instance.</description></item>
                        ///     <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
                        /// </list>
                        /// </remarks>
                        [Pure]
                        public override bool Equals([NotNullWhen(true)] object? obj) =>
                            obj is ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> tuple && Equals(tuple);
                
                        /// <summary>
                        /// Returns a value that indicates whether the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/>
                        /// instance is equal to a specified <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/>.
                        /// </summary>
                        /// <param name="other">The tuple to compare with this instance.</param>
                        /// <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
                        /// <remarks>
                        /// The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
                        /// are equal to that of the current instance, using the default comparer for that field's type.
                        /// </remarks>
                        [Pure]
                        public bool Equals(ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other) =>
                            EqualityComparer<T1>.Default.Equals(Item1, other.Item1) &&
                            EqualityComparer<T2>.Default.Equals(Item2, other.Item2) &&
                            EqualityComparer<T3>.Default.Equals(Item3, other.Item3) &&
                            EqualityComparer<T4>.Default.Equals(Item4, other.Item4) &&
                            EqualityComparer<T5>.Default.Equals(Item5, other.Item5) &&
                            EqualityComparer<T6>.Default.Equals(Item6, other.Item6) &&
                            EqualityComparer<T7>.Default.Equals(Item7, other.Item7) &&
                            EqualityComparer<TRest>.Default.Equals(Rest, other.Rest);
                
                        [Pure]
                        int IComparable.CompareTo(object? other)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> tuple)
                                throw new ArgumentException();
                
                            return CompareTo(tuple);
                        }
                
                        /// <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
                        /// <param name="other">An instance to compare.</param>
                        /// <returns>
                        /// A signed number indicating the relative values of this instance and <paramref name="other"/>.
                        /// Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
                        /// instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
                        /// than <paramref name="other"/>.
                        /// </returns>
                        [Pure]
                        public int CompareTo(ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other)
                        {
                            var c = Comparer<T1>.Default.Compare(Item1, other.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T2>.Default.Compare(Item2, other.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T3>.Default.Compare(Item3, other.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T4>.Default.Compare(Item4, other.Item4);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T5>.Default.Compare(Item5, other.Item5);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T6>.Default.Compare(Item6, other.Item6);
                
                            if (c != 0)
                                return c;
                
                            c = Comparer<T7>.Default.Compare(Item7, other.Item7);
                            return c != 0 ? c : Comparer<TRest>.Default.Compare(Rest, other.Rest);
                        }
                
                #if !NET20 && !NET30 && !NET35
                        [Pure]
                        bool IStructuralEquatable.Equals(object? other, IEqualityComparer comparer) =>
                            other is ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> objTuple &&
                            comparer.Equals(Item1, objTuple.Item1) &&
                            comparer.Equals(Item2, objTuple.Item2) &&
                            comparer.Equals(Item3, objTuple.Item3) &&
                            comparer.Equals(Item4, objTuple.Item4) &&
                            comparer.Equals(Item5, objTuple.Item5) &&
                            comparer.Equals(Item6, objTuple.Item6) &&
                            comparer.Equals(Item7, objTuple.Item7) &&
                            comparer.Equals(Rest, objTuple.Rest);
                
                        [Pure]
                        int IStructuralComparable.CompareTo(object? other, IComparer comparer)
                        {
                            if (other == null)
                                return 1;
                
                            if (other is not ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> objTuple)
                                throw new ArgumentException();
                
                            var c = comparer.Compare(Item1, objTuple.Item1);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item2, objTuple.Item2);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item3, objTuple.Item3);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item4, objTuple.Item4);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item5, objTuple.Item5);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item6, objTuple.Item6);
                
                            if (c != 0)
                                return c;
                
                            c = comparer.Compare(Item7, objTuple.Item7);
                            return c != 0 ? c : comparer.Compare(Rest, objTuple.Rest);
                        }
                
                        [Pure]
                        int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                #endif
                
                        /// <summary>
                        /// Returns the hash code for the current <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance.
                        /// </summary>
                        /// <returns>A 32-bit signed integer hash code.</returns>
                        [Pure]
                        public override int GetHashCode()
                        {
                            // We want to have a limited hash in this case.  We'll use the last 8 elements of the tuple
                            if (Rest is not IValueTupleInternal rest)
                                return ValueTuple.CombineHashCodes(
                                    Item1?.GetHashCode() ?? 0,
                                    Item2?.GetHashCode() ?? 0,
                                    Item3?.GetHashCode() ?? 0,
                                    Item4?.GetHashCode() ?? 0,
                                    Item5?.GetHashCode() ?? 0,
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0
                                );
                
                            var size = rest.Length;
                
                            if (size >= 8)
                                return rest.GetHashCode();
                
                            // In this case, the rest member has less than 8 elements so we need to combine some our elements with the elements in rest
                            var k = 8 - size;
                
                            return k switch
                            {
                                1 => ValueTuple.CombineHashCodes(
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                2 => ValueTuple.CombineHashCodes(
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                3 => ValueTuple.CombineHashCodes(
                                    Item5?.GetHashCode() ?? 0,
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                4 => ValueTuple.CombineHashCodes(
                                    Item4?.GetHashCode() ?? 0,
                                    Item5?.GetHashCode() ?? 0,
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                5 => ValueTuple.CombineHashCodes(
                                    Item3?.GetHashCode() ?? 0,
                                    Item4?.GetHashCode() ?? 0,
                                    Item5?.GetHashCode() ?? 0,
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                6 => ValueTuple.CombineHashCodes(
                                    Item2?.GetHashCode() ?? 0,
                                    Item3?.GetHashCode() ?? 0,
                                    Item4?.GetHashCode() ?? 0,
                                    Item5?.GetHashCode() ?? 0,
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                7 or 8 => ValueTuple.CombineHashCodes(
                                    Item1?.GetHashCode() ?? 0,
                                    Item2?.GetHashCode() ?? 0,
                                    Item3?.GetHashCode() ?? 0,
                                    Item4?.GetHashCode() ?? 0,
                                    Item5?.GetHashCode() ?? 0,
                                    Item6?.GetHashCode() ?? 0,
                                    Item7?.GetHashCode() ?? 0,
                                    rest.GetHashCode()
                                ),
                                _ => throw new InvalidOperationException("Missed all cases for computing ValueTuple hash code"),
                            };
                        }
                
                        [Pure]
                        int GetHashCodeCore(IEqualityComparer comparer)
                        {
                            // We want to have a limited hash in this case.  We'll use the last 8 elements of the tuple
                            if (Rest is not IValueTupleInternal rest)
                                return ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item1),
                                    comparer.GetHashCode(Item2),
                                    comparer.GetHashCode(Item3),
                                    comparer.GetHashCode(Item4),
                                    comparer.GetHashCode(Item5),
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7)
                                );
                
                            var size = rest.Length;
                
                            if (size >= 8)
                                return rest.GetHashCode(comparer);
                
                            // In this case, the rest member has less than 8 elements so we need to combine some our elements with the elements in rest
                            var k = 8 - size;
                
                            return k switch
                            {
                                1 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                2 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                3 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item5),
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                4 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item4),
                                    comparer.GetHashCode(Item5),
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                5 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item3),
                                    comparer.GetHashCode(Item4),
                                    comparer.GetHashCode(Item5),
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                6 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item2),
                                    comparer.GetHashCode(Item3),
                                    comparer.GetHashCode(Item4),
                                    comparer.GetHashCode(Item5),
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                7 or 8 => ValueTuple.CombineHashCodes(
                                    comparer.GetHashCode(Item1),
                                    comparer.GetHashCode(Item2),
                                    comparer.GetHashCode(Item3),
                                    comparer.GetHashCode(Item4),
                                    comparer.GetHashCode(Item5),
                                    comparer.GetHashCode(Item6),
                                    comparer.GetHashCode(Item7),
                                    rest.GetHashCode(comparer)
                                ),
                                _ => throw new InvalidOperationException("Missed all cases for computing ValueTuple hash code"),
                            };
                        }
                
                        [Pure]
                        int IValueTupleInternal.GetHashCode(IEqualityComparer comparer) => GetHashCodeCore(comparer);
                
                        /// <summary>
                        /// Returns a string that represents the value of this <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance.
                        /// </summary>
                        /// <returns>The string representation of this <see cref="ValueTuple{T1,T2,T3,T4,T5,T6,T7, TRest}"/> instance.</returns>
                        /// <remarks>
                        /// The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
                        /// If any field value is <see langword="null"/>, it is represented as <see cref="string.Empty"/>.
                        /// </remarks>
                        [Pure]
                        public override string ToString() =>
                            Rest is not IValueTupleInternal rest
                                ? $"({Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7}, {Rest})"
                                : $"({Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7}, {rest.ToStringEnd()}";
                
                        [Pure]
                        string IValueTupleInternal.ToStringEnd() =>
                            Rest is not IValueTupleInternal rest
                                ? $"{Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7}, {Rest})"
                                : $"{Item1}, {Item2}, {Item3}, {Item4}, {Item5}, {Item6}, {Item7}, {rest.ToStringEnd()}";
                
                        /// <summary>
                        /// The number of positions in this data structure.
                        /// </summary>
                        [Pure, NonNegativeValue]
                        int ITuple.Length => Rest is not IValueTupleInternal rest ? 8 : 7 + rest.Length;
                
                        /// <summary>
                        /// Get the element at position <param name="index"/>.
                        /// </summary>
                        [Pure]
                        object? ITuple.this[[NonNegativeValue] int index]
                        {
                            get
                            {
                                switch (index)
                                {
                                    case 0: return Item1;
                                    case 1: return Item2;
                                    case 2: return Item3;
                                    case 3: return Item4;
                                    case 4: return Item5;
                                    case 5: return Item6;
                                    case 6: return Item7;
                                }
                
                                if (Rest is IValueTupleInternal rest)
                                    return rest[index - 7];
                
                                if (index == 7)
                                    return Rest;
                
                                throw new IndexOutOfRangeException();
                            }
                        }
                    }
                #endif
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Span.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace EmptyNamespace
                namespace System;
                #if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
                #pragma warning disable 0660, 0661, 0809, 8500, CA1066, MA0048
                /// <summary>Provides a type-safe and memory-safe representation of a contiguous region of arbitrary memory.</summary>
                /// <remarks><para>This type delegates the responsibility of pinning the pointer to the consumer.</para></remarks>
                /// <typeparam name="T">The type of items in the <see cref="Span{T}"/>.</typeparam>
                [DebuggerTypeProxy(typeof(SpanDebugView<>)), DebuggerDisplay("{ToString(),raw}"), StructLayout(LayoutKind.Auto)]
                readonly unsafe
                #if !NO_REF_STRUCTS
                    ref
                #endif
                    partial struct Span<T>
                #if UNMANAGED_SPAN
                    where T : unmanaged
                #endif
                {
                    /// <summary>
                    /// Initializes a new instance of the <see cref="Span{T}"/> struct from a specified number of
                    /// <typeparamref name="T"/> elements starting at a specified memory address.
                    /// </summary>
                    /// <param name="pointer">A pointer to the starting address of a specified number of T elements in memory.</param>
                    /// <param name="length">The length of the buffer.</param>
                    /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/> is negative.</exception>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public Span(void* pointer, [NonNegativeValue] int length)
                    {
                        ValidateLength(length);
                
                        Pointer = (T*)pointer;
                        Length = length;
                    }
                
                    /// <summary>Gets the element at the specified zero-based index.</summary>
                    /// <param name="index">The zero-based index of the element.</param>
                    /// <exception cref="ArgumentOutOfRangeException">
                    /// <paramref name="index"/> is less than zero or is greater than or equal to <see cref="Length"/>.
                    /// </exception>
                    public T this[[NonNegativeValue] int index]
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                        get
                        {
                            ValidateIndex(index);
                            return ((T*)Pointer)[index];
                        }
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        set
                        {
                            ValidateIndex(index);
                            ((T*)Pointer)[index] = value;
                        }
                    }
                
                    /// <summary>Gets an empty <see cref="Span{T}"/> object.</summary>
                #pragma warning disable CA1000
                    public static Span<T> Empty
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => default;
                    }
                #pragma warning restore CA1000
                
                    /// <summary>Gets a value indicating whether the current <see cref="Span{T}"/> is empty.</summary>
                    public bool IsEmpty
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Length is 0;
                    }
                
                    /// <summary>Gets the length of the current span.</summary>
                    public int Length { [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure] get; }
                
                    /// <summary>Gets the pointer representing the first element in the buffer.</summary>
                    /// <remarks><para>
                    /// This property does not normally exist, and is used as a workaround polyfill for <c>GetPinnableReference</c>.
                    /// When using this property, ensure you have the appropriate preprocessors for using a fixed expression instead.
                    /// </para><para>
                    /// Due to a specific runtime issue, this property cannot be generic, as this causes some JITs
                    /// (notably .NET Framework) to be upset from its metadata and refuse to load. It is therefore expected of the
                    /// caller to cast the returned pointer every time if needed.
                    /// </para></remarks>
                    public void* Pointer
                    {
                        [EditorBrowsable(EditorBrowsableState.Never), MethodImpl(MethodImplOptions.AggressiveInlining),
                         NonNegativeValue, Pure]
                        get;
                    }
                
                    /// <summary>Returns a value that indicates whether two <see cref="Span{T}"/> objects are equal.</summary>
                    /// <remarks><para>
                    /// Two <see cref="Span{T}"/> objects are equal if they have the same length and the corresponding elements of
                    /// <paramref name="left"/> and <paramref name="right"/> point to the same memory. Note that the test for equality
                    /// does <i>not</i> attempt to determine whether the contents are equal.
                    /// </para></remarks>
                    /// <param name="left">The first span to compare.</param>
                    /// <param name="right">The second span to compare.</param>
                    /// <returns>
                    /// <see langword="true"/> if the two <see cref="Span{T}"/> objects are equal; otherwise, <see langword="false"/>.
                    /// </returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static bool operator ==(Span<T> left, Span<T> right) =>
                        left.Length == right.Length && left.Pointer == right.Pointer;
                
                    /// <summary>Returns a value that indicates whether two <see cref="Span{T}"/> objects are not equal.</summary>
                    /// <remarks><para>
                    /// Two <see cref="Span{T}"/> objects are equal if they have the same length and the corresponding elements of
                    /// <paramref name="left"/> and <paramref name="right"/> point to the same memory.
                    /// </para></remarks>
                    /// <param name="left">The first span to compare.</param>
                    /// <param name="right">The second span to compare.</param>
                    /// <returns>
                    /// <see langword="true"/> if the two <see cref="Span{T}"/> objects are not equal;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static bool operator !=(Span<T> left, Span<T> right) => !(left == right);
                
                    /// <summary>Defines an implicit conversion of a <see cref="Span{T}"/> to a <see cref="ReadOnlySpan{T}"/>.</summary>
                    /// <param name="span">The object to convert to a <see cref="ReadOnlySpan{T}"/>.</param>
                    /// <returns>A read-only span that corresponds to the current instance.</returns>
                    public static implicit operator ReadOnlySpan<T>(Span<T> span) => new(span.Pointer, span.Length);
                
                    /// <summary>Clears the contents of this <see cref="Span{T}"/> object.</summary>
                    /// <remarks><para>
                    /// The <see cref="Clear"/> method sets the items in the <see cref="Span{T}"/> object to their default values.
                    /// It does not remove items from the <see cref="Span{T}"/>.
                    /// </para></remarks>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                #pragma warning disable CS8604
                    public void Clear() => Fill(default);
                #pragma warning restore CS8604
                
                    /// <summary>Copies the contents of this <see cref="Span{T}"/> into a destination <see cref="Span{T}"/>.</summary>
                    /// <param name="destination">The destination <see cref="Span{T}"/> object.</param>
                    /// <exception cref="ArgumentException">
                    /// <paramref name="destination"/> is shorter than the source <see cref="Span{T}"/>.
                    /// </exception>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public void CopyTo(Span<T> destination)
                    {
                        ValidateDestination(destination.Length);
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                    }
                
                    /// <summary>Copies the contents of this <see cref="Span{T}"/> into a destination <see cref="IList{T}"/>.</summary>
                    /// <param name="destination">The destination <see cref="IList{T}"/> object.</param>
                    /// <exception cref="ArgumentException">
                    /// <paramref name="destination"/> is shorter than the source <see cref="Span{T}"/>.
                    /// </exception>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public void CopyTo(IList<T> destination)
                    {
                        ValidateDestination(destination.Count);
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                    }
                
                    /// <summary>Fills the elements of this span with a specified value.</summary>
                    /// <param name="value">The value to assign to each element of the span.</param>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public void Fill(T value)
                    {
                        for (var i = 0; i < Length; i++)
                            ((T*)Pointer)[i] = value;
                    }
                
                #if !NO_REF_STRUCTS
                    /// <inheritdoc />
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     MethodImpl(MethodImplOptions.AggressiveInlining),
                     Obsolete("Equals() on Span will always throw an exception. Use the equality operator instead.")]
                    public override bool Equals(object? obj) => throw new NotSupportedException();
                #endif
                
                    /// <summary>
                    /// Attempts to copy the current <see cref="Span{T}"/> to a destination <see cref="Span{T}"/>
                    /// and returns a value that indicates whether the copy operation succeeded.
                    /// </summary>
                    /// <remarks><para>
                    /// This method copies all of <c>source</c> to <paramref name="destination"/> even if
                    /// <c>source</c> and <paramref name="destination"/> overlap.
                    /// If <paramref name="destination"/> is shorter than the source <see cref="Span{T}"/>, this method returns
                    /// <see langword="false"/>, and no data is written to <paramref name="destination"/>.
                    /// </para></remarks>
                    /// <param name="destination">The target of the copy operation.</param>
                    /// <returns><see langword="true"/> if the copy operation succeeded; otherwise, <see langword="false"/>.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public bool TryCopyTo(Span<T> destination)
                    {
                        if ((uint)Length > (uint)destination.Length)
                            return false;
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                
                        return true;
                    }
                
                    /// <inheritdoc cref="TryCopyTo(Span{T})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public bool TryCopyTo(IList<T> destination)
                    {
                        if ((uint)Length > (uint)destination.Count)
                            return false;
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                
                        return true;
                    }
                
                #if !NO_REF_STRUCTS
                    /// <inheritdoc />
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     MethodImpl(MethodImplOptions.AggressiveInlining),
                     Obsolete("Equals() on Span will always throw an exception. Use the equality operator instead.")]
                    public override int GetHashCode() => throw new NotSupportedException();
                #endif
                
                    /// <inheritdoc />
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public override string ToString() =>
                        typeof(T) == typeof(char) ? CharsToString() : $"System.Span<{typeof(T).Name}>[{Length}]";
                
                    /// <summary>Returns an enumerator of this <see cref="Span{T}"/>.</summary>
                    /// <returns>An enumerator for this span.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public Enumerator GetEnumerator() => new(this);
                
                    /// <summary>Forms a slice out of the current span that begins at a specified index.</summary>
                    /// <param name="start">The index at which to begin the slice.</param>
                    /// <exception cref="ArgumentOutOfRangeException">
                    /// <paramref name="start"/> is less than zero or greater than <see cref="Length"/>.
                    /// </exception>
                    /// <returns>
                    /// A span that consists of all elements of the current span from <paramref name="start"/> to the end of the span.
                    /// </returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public Span<T> Slice([NonNegativeValue] int start) =>
                        (uint)start > (uint)Length
                            ? throw new ArgumentOutOfRangeException(nameof(start))
                            : new((T*)Pointer + start, Length - start);
                
                    /// <summary>Creates the slice of this buffer.</summary>
                    /// <param name="start">The start of the slice from this buffer.</param>
                    /// <param name="length">The length of the slice from this buffer.</param>
                    /// <exception cref="ArgumentOutOfRangeException">An out-of-range buffer is created.</exception>
                    /// <returns>The <see cref="Span{T}"/> which is a slice of this buffer.</returns>
                #pragma warning disable CA2208, MA0015
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public Span<T> Slice([NonNegativeValue] int start, [NonNegativeValue] int length) =>
                        (ulong)(uint)start + (uint)length > (uint)Length
                            ? throw new ArgumentOutOfRangeException()
                            : new((T*)Pointer + start, length);
                #pragma warning restore CA2208, MA0015
                
                    /// <summary>Copies the contents of this span into a new array.</summary>
                    /// <remarks><para>
                    /// This method performs a heap allocation and therefore should be avoided if possible.
                    /// Heap allocations are expected in APIs that work with arrays.
                    /// Using such APIs is unavoidable if an alternative API overhead that takes a <see cref="Span{T}"/> does not exist.
                    /// </para></remarks>
                    /// <returns>An array containing the data in the current span.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public T[] ToArray()
                    {
                        if (IsEmpty)
                #if NETFRAMEWORK && NET46_OR_GREATER || NETSTANDARD && NETSTANDARD1_3_OR_GREATER || NETCOREAPP
                            return Array.Empty<T>();
                #else
                            return new T[0];
                #endif
                
                        var destination = new T[Length];
                        CopyTo(destination);
                        return destination;
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    static void ValidateLength(int length)
                    {
                        if (length < 0)
                            throw new ArgumentOutOfRangeException(nameof(length), length, "Non-negative");
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void ValidateDestination(int destination)
                    {
                        if ((uint)Length > (uint)destination)
                            throw new ArgumentException(
                                $"Destination length \"{destination}\" shorter than source \"{Length}\".",
                                nameof(destination)
                            );
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void ValidateIndex(int index)
                    {
                        if ((uint)index >= (uint)Length)
                            throw new ArgumentOutOfRangeException(nameof(index), index, $"must be non-zero and below length {Length}");
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    string CharsToString()
                    {
                        var ptr = (char*)Pointer;
                        StringBuilder sb = new(Length);
                
                        for (var i = 0; i < Length; i++)
                            sb[i] = ptr[i];
                
                        return $"{sb}";
                    }
                
                    /// <summary>Enumerates the elements of a <see cref="Span{T}"/>.</summary>
                    [StructLayout(LayoutKind.Auto)]
                #pragma warning disable CA1034
                    public
                #if !NO_REF_STRUCTS
                        ref
                #endif
                        partial struct Enumerator
                #pragma warning restore CA1034
                    {
                        readonly Span<T> _span;
                
                        [ValueRange(-1, int.MaxValue)]
                        int _index;
                
                        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
                        /// <param name="span">The buffer to peek through.</param>
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public Enumerator(Span<T> span)
                        {
                            _span = span;
                            _index = -1;
                        }
                
                        /// <inheritdoc cref="IEnumerator{T}.Current" />
                        public readonly T Current
                        {
                            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _span[_index];
                        }
                
                        /// <inheritdoc cref="IEnumerator.Reset" />
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public void Reset() => _index = -1;
                
                        /// <inheritdoc cref="IEnumerator.MoveNext" />
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public bool MoveNext()
                        {
                            var index = _index + 1;
                
                            if (index >= _span.Length)
                                return false;
                
                            _index = index;
                            return true;
                        }
                    }
                }
                
                /// <summary>Provides a type-safe and memory-safe representation of a contiguous region of arbitrary memory.</summary>
                /// <remarks><para>This type delegates the responsibility of pinning the pointer to the consumer.</para></remarks>
                /// <typeparam name="T">The type of items in the <see cref="ReadOnlySpan{T}"/>.</typeparam>
                [DebuggerTypeProxy(typeof(SpanDebugView<>)), DebuggerDisplay("{ToString(),raw}"), StructLayout(LayoutKind.Auto)]
                readonly unsafe
                #if !NO_REF_STRUCTS
                    ref
                #endif
                    partial struct ReadOnlySpan<T>
                #if UNMANAGED_SPAN
                    where T : unmanaged
                #endif
                {
                    /// <summary>
                    /// Initializes a new instance of the <see cref="ReadOnlySpan{T}"/> struct from a specified number of
                    /// <typeparamref name="T"/> elements starting at a specified memory address.
                    /// </summary>
                    /// <param name="pointer">A pointer to the starting address of a specified number of T elements in memory.</param>
                    /// <param name="length">The length of the buffer.</param>
                    /// <exception cref="ArgumentOutOfRangeException"><paramref name="length"/> is negative.</exception>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public ReadOnlySpan(void* pointer, [NonNegativeValue] int length)
                    {
                        ValidateLength(length);
                
                        Pointer = (T*)pointer;
                        Length = length;
                    }
                
                    /// <summary>Gets the element at the specified zero-based index.</summary>
                    /// <param name="index">The zero-based index of the element.</param>
                    /// <exception cref="ArgumentOutOfRangeException">
                    /// <paramref name="index"/> is less than zero or is greater than or equal to <see cref="Length"/>.
                    /// </exception>
                    public T this[[NonNegativeValue] int index]
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                        get
                        {
                            ValidateIndex(index);
                            return ((T*)Pointer)[index];
                        }
                    }
                
                    /// <summary>Gets an empty <see cref="ReadOnlySpan{T}"/> object.</summary>
                #pragma warning disable CA1000
                    public static ReadOnlySpan<T> Empty
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => default;
                    }
                #pragma warning restore CA1000
                
                    /// <summary>Gets a value indicating whether the current <see cref="ReadOnlySpan{T}"/> is empty.</summary>
                    public bool IsEmpty
                    {
                        [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => Length is 0;
                    }
                
                    /// <summary>Gets the length of the current span.</summary>
                    public int Length { [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure] get; }
                
                    /// <summary>Gets the pointer representing the first element in the buffer.</summary>
                    /// <remarks><para>
                    /// This property does not normally exist, and is used as a workaround polyfill for <c>GetPinnableReference</c>.
                    /// When using this property, ensure you have the appropriate preprocessors for using a fixed expression instead.
                    /// </para><para>
                    /// Due to a specific runtime issue, this property cannot be generic, as this causes some JITs
                    /// (notably .NET Framework) to be upset from its metadata and refuse to load. It is therefore expected of the
                    /// caller to cast the returned pointer every time if needed.
                    /// </para></remarks>
                    public void* Pointer
                    {
                        [EditorBrowsable(EditorBrowsableState.Never), MethodImpl(MethodImplOptions.AggressiveInlining),
                         NonNegativeValue, Pure]
                        get;
                    }
                
                    /// <summary>Returns a value that indicates whether two <see cref="ReadOnlySpan{T}"/> objects are equal.</summary>
                    /// <remarks><para>
                    /// Two <see cref="ReadOnlySpan{T}"/> objects are equal if they have the same length and the corresponding elements
                    /// of <paramref name="left"/> and <paramref name="right"/> point to the same memory. Note that the test for
                    /// equality does <i>not</i> attempt to determine whether the contents are equal.
                    /// </para></remarks>
                    /// <param name="left">The first span to compare.</param>
                    /// <param name="right">The second span to compare.</param>
                    /// <returns>
                    /// <see langword="true"/> if the two <see cref="ReadOnlySpan{T}"/> objects are equal;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static bool operator ==(ReadOnlySpan<T> left, ReadOnlySpan<T> right) =>
                        left.Length == right.Length && left.Pointer == right.Pointer;
                
                    /// <summary>
                    /// Returns a value that indicates whether two <see cref="ReadOnlySpan{T}"/> objects are not equal.
                    /// </summary>
                    /// <remarks><para>
                    /// Two <see cref="ReadOnlySpan{T}"/> objects are equal if they have the same length and the corresponding elements
                    /// of <paramref name="left"/> and <paramref name="right"/> point to the same memory.
                    /// </para></remarks>
                    /// <param name="left">The first span to compare.</param>
                    /// <param name="right">The second span to compare.</param>
                    /// <returns>
                    /// <see langword="true"/> if the two <see cref="ReadOnlySpan{T}"/> objects are not equal;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static bool operator !=(ReadOnlySpan<T> left, ReadOnlySpan<T> right) => !(left == right);
                
                    /// <summary>
                    /// Copies the contents of this <see cref="ReadOnlySpan{T}"/> into a destination <see cref="Span{T}"/>.
                    /// </summary>
                    /// <param name="destination">The destination <see cref="Span{T}"/> object.</param>
                    /// <exception cref="ArgumentException">
                    /// <paramref name="destination"/> is shorter than the source <see cref="ReadOnlySpan{T}"/>.
                    /// </exception>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public void CopyTo(Span<T> destination)
                    {
                        ValidateDestination(destination.Length);
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                    }
                
                    /// <summary>Copies the contents of this <see cref="ReadOnlySpan{T}"/> into a destination <see cref="IList{T}"/>.</summary>
                    /// <param name="destination">The destination <see cref="IList{T}"/> object.</param>
                    /// <exception cref="ArgumentException">
                    /// <paramref name="destination"/> is shorter than the source <see cref="ReadOnlySpan{T}"/>.
                    /// </exception>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public void CopyTo(IList<T> destination)
                    {
                        ValidateDestination(destination.Count);
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                    }
                
                #if !NO_REF_STRUCTS
                    /// <inheritdoc />
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     MethodImpl(MethodImplOptions.AggressiveInlining),
                     Obsolete("Equals() on ReadOnlySpan will always throw an exception. Use the equality operator instead.")]
                    public override bool Equals(object? obj) => throw new NotSupportedException();
                #endif
                
                    /// <summary>
                    /// Attempts to copy the current <see cref="ReadOnlySpan{T}"/> to a destination <see cref="Span{T}"/>
                    /// and returns a value that indicates whether the copy operation succeeded.
                    /// </summary>
                    /// <remarks><para>
                    /// This method copies all of <c>source</c> to <paramref name="destination"/> even if
                    /// <c>source</c> and <paramref name="destination"/> overlap.
                    /// If <paramref name="destination"/> is shorter than the source <see cref="ReadOnlySpan{T}"/>, this method returns
                    /// <see langword="false"/>, and no data is written to <paramref name="destination"/>.
                    /// </para></remarks>
                    /// <param name="destination">The target of the copy operation.</param>
                    /// <returns><see langword="true"/> if the copy operation succeeded; otherwise, <see langword="false"/>.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public bool TryCopyTo(Span<T> destination)
                    {
                        if ((uint)Length > (uint)destination.Length)
                            return false;
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                
                        return true;
                    }
                
                    /// <inheritdoc cref="TryCopyTo(Span{T})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public bool TryCopyTo(IList<T> destination)
                    {
                        if ((uint)Length > (uint)destination.Count)
                            return false;
                
                        for (var i = 0; i < Length; i++)
                            destination[i] = this[i];
                
                        return true;
                    }
                
                #if !NO_REF_STRUCTS
                    /// <inheritdoc />
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     MethodImpl(MethodImplOptions.AggressiveInlining),
                     Obsolete("Equals() on ReadOnlySpan will always throw an exception. Use the equality operator instead.")]
                    public override int GetHashCode() => throw new NotSupportedException();
                #endif
                
                    /// <inheritdoc />
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public override string ToString() =>
                        typeof(T) == typeof(char) ? CharsToString() : $"System.ReadOnlySpan<{typeof(T).Name}>[{Length}]";
                
                    /// <summary>Returns an enumerator of this <see cref="ReadOnlySpan{T}"/>.</summary>
                    /// <returns>An enumerator for this span.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public Enumerator GetEnumerator() => new(this);
                
                    /// <summary>Forms a slice out of the current span that begins at a specified index.</summary>
                    /// <param name="start">The index at which to begin the slice.</param>
                    /// <exception cref="ArgumentOutOfRangeException">
                    /// <paramref name="start"/> is less than zero or greater than <see cref="Length"/>.
                    /// </exception>
                    /// <returns>
                    /// A span that consists of all elements of the current span from <paramref name="start"/> to the end of the span.
                    /// </returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public ReadOnlySpan<T> Slice([NonNegativeValue] int start) =>
                        (uint)start > (uint)Length
                            ? throw new ArgumentOutOfRangeException(nameof(start))
                            : new((T*)Pointer + start, Length - start);
                
                    /// <summary>Creates the slice of this buffer.</summary>
                    /// <param name="start">The start of the slice from this buffer.</param>
                    /// <param name="length">The length of the slice from this buffer.</param>
                    /// <exception cref="ArgumentOutOfRangeException">An out-of-range buffer is created.</exception>
                    /// <returns>The <see cref="ReadOnlySpan{T}"/> which is a slice of this buffer.</returns>
                #pragma warning disable CA2208, MA0015
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public ReadOnlySpan<T> Slice([NonNegativeValue] int start, [NonNegativeValue] int length) =>
                        (ulong)(uint)start + (uint)length > (uint)Length
                            ? throw new ArgumentOutOfRangeException()
                            : new((T*)Pointer + start, length);
                #pragma warning restore CA2208, MA0015
                
                    /// <summary>Copies the contents of this span into a new array.</summary>
                    /// <remarks><para>
                    /// This method performs a heap allocation and therefore should be avoided if possible.
                    /// Heap allocations are expected in APIs that work with arrays.
                    /// Using such APIs is unavoidable if an alternative API overhead
                    /// that takes a <see cref="ReadOnlySpan{T}"/> does not exist.
                    /// </para></remarks>
                    /// <returns>An array containing the data in the current span.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public T[] ToArray()
                    {
                        if (IsEmpty)
                #if NETFRAMEWORK && NET46_OR_GREATER || NETSTANDARD && NETSTANDARD1_3_OR_GREATER || NETCOREAPP
                            return Array.Empty<T>();
                #else
                            return new T[0];
                #endif
                
                        var destination = new T[Length];
                        CopyTo(destination);
                        return destination;
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    static void ValidateLength(int length)
                    {
                        if (length < 0)
                            throw new ArgumentOutOfRangeException(nameof(length), length, "Non-negative");
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void ValidateDestination(int destination)
                    {
                        if ((uint)Length > (uint)destination)
                            throw new ArgumentException(
                                $"Destination length \"{destination}\" shorter than source \"{Length}\".",
                                nameof(destination)
                            );
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void ValidateIndex(int index)
                    {
                        if ((uint)index >= (uint)Length)
                            throw new ArgumentOutOfRangeException(nameof(index), index, $"must be non-zero and below length {Length}");
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    string CharsToString()
                    {
                        var ptr = (char*)Pointer;
                        StringBuilder sb = new(Length);
                
                        for (var i = 0; i < Length; i++)
                            sb[i] = ptr[i];
                
                        return $"{sb}";
                    }
                
                    /// <summary>Enumerates the elements of a <see cref="Span{T}"/>.</summary>
                    [StructLayout(LayoutKind.Auto)]
                #pragma warning disable CA1034
                    public
                #if !NO_REF_STRUCTS
                        ref
                #endif
                        partial struct Enumerator
                #pragma warning restore CA1034
                    {
                        readonly ReadOnlySpan<T> _span;
                
                        [ValueRange(-1, int.MaxValue)]
                        int _index;
                
                        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
                        /// <param name="span">The buffer to peek through.</param>
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public Enumerator(ReadOnlySpan<T> span)
                        {
                            _span = span;
                            _index = -1;
                        }
                
                        /// <inheritdoc cref="IEnumerator{T}.Current" />
                        public readonly T Current
                        {
                            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get => _span[_index];
                        }
                
                        /// <inheritdoc cref="IEnumerator.Reset" />
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public void Reset() => _index = -1;
                
                        /// <inheritdoc cref="IEnumerator.MoveNext" />
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public bool MoveNext()
                        {
                            var index = _index + 1;
                
                            if (index >= _span.Length)
                                return false;
                
                            _index = index;
                            return true;
                        }
                    }
                }
                
                /// <summary>Represents a debug view to this span.</summary>
                /// <typeparam name="T">The type of element in the span.</typeparam>
                sealed class SpanDebugView<T>
                #if UNMANAGED_SPAN
                    where T : unmanaged
                #endif
                {
                    /// <summary>Initializes a new instance of the <see cref="SpanDebugView{T}"/> class.</summary>
                    /// <param name="span">The span to collect.</param>
                    public SpanDebugView(Span<T> span) => Items = span.ToArray();
                
                    /// <summary>Initializes a new instance of the <see cref="SpanDebugView{T}"/> class.</summary>
                    /// <param name="span">The span to collect.</param>
                    public SpanDebugView(ReadOnlySpan<T> span) => Items = span.ToArray();
                
                    /// <summary>Gets the items of this span.</summary>
                    [DebuggerBrowsable(DebuggerBrowsableState.RootHidden), Pure]
                    public T[] Items { get; }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Numerics.EnumMath.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NETFRAMEWORK || NET35_OR_GREATER
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static Enum;
                using static Expression;
                
                /// <summary>Provides methods to do math on enums without overhead from boxing.</summary>
                [UsedImplicitly]
                static partial class EnumMath
                {
                    static readonly Dictionary<Type, IList> s_dictionary = new();
                
                    /// <summary>Checks if the left-hand side implements the right-hand side.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>
                    /// The value <see langword="true"/> if the parameter <paramref name="left"/> has the values
                    /// of the parameter <paramref name="right"/>; otherwise, <see langword="false"/>.
                    /// </returns>
                    [Pure]
                    public static bool Has<T>(this T left, T right)
                        where T : Enum =>
                        left.Op(right, static (x, y) => (x & y) == x);
                
                    /// <summary>Performs a conversion operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <returns>The <see cref="int"/> cast of <paramref name="value"/>.</returns>
                    [Pure]
                    public static int AsInt<T>(this T value)
                        where T : Enum =>
                        Caching<T>.From(value);
                
                    /// <summary>Gets the values of an enum cached and strongly-typed.</summary>
                    /// <typeparam name="T">The type of enum to get the values from.</typeparam>
                    /// <returns>All values in the type parameter <typeparamref name="T"/>.</returns>
                    public static IList<T> GetValues<T>()
                        where T : Enum =>
                        s_dictionary.TryGetValue(typeof(T), out var list)
                            ? (IList<T>)list
                            : (T[])(s_dictionary[typeof(T)] = Enum.GetValues(typeof(T)));
                
                    /// <summary>Performs a conversion operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <returns>The <typeparamref name="T"/> cast of <paramref name="value"/>.</returns>
                    [Pure]
                    public static T As<T>(this int value)
                        where T : Enum =>
                        Caching<T>.To(value);
                
                    /// <summary>Performs a negation operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
                    [Pure]
                    public static T Negate<T>(this T value)
                        where T : Enum =>
                        value.Op(static x => unchecked(-x));
                
                    /// <summary>Performs an decrement operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately before it.</returns>
                    [Pure]
                    public static T Predecessor<T>(this T value)
                        where T : Enum =>
                        value.Op(static x => unchecked(--x));
                
                    /// <summary>Performs a increment operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately after it.</returns>
                    [Pure]
                    public static T Successor<T>(this T value)
                        where T : Enum =>
                        value.Op(static x => unchecked(++x));
                
                    /// <summary>Performs an addition operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>The sum of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
                    [Pure]
                    public static T Add<T>(this T left, T right)
                        where T : Enum =>
                        left.Op(right, static (x, y) => unchecked(x + y));
                
                    /// <summary>Performs a subtraction operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>The difference of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
                    [Pure]
                    public static T Subtract<T>(this T left, T right)
                        where T : Enum =>
                        left.Op(right, static (x, y) => unchecked(x - y));
                
                    /// <summary>Performs a multiplication operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>The product of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
                    [Pure]
                    public static T Multiply<T>(this T left, T right)
                        where T : Enum =>
                        left.Op(right, static (x, y) => unchecked(x * y));
                
                    /// <summary>Performs a division operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>The quotient of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
                    [Pure]
                    public static T Divide<T>(this T left, T right)
                        where T : Enum =>
                        left.Op(right, static (x, y) => x / y);
                
                    /// <summary>Performs a modulo operation.</summary>
                    /// <remarks><para>The conversion and operation are unchecked, and treated as <see cref="int"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>The remainder of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
                    [Pure]
                    public static T Modulo<T>(this T left, T right)
                        where T : Enum =>
                        left.Op(right, static (x, y) => x % y);
                
                    /// <summary>Computes the product of a sequence of <typeparamref name="T"/> values.</summary>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="source">A sequence of <typeparamref name="T"/> values to calculate the product of.</param>
                    /// <returns>The product of the values in the sequence.</returns>
                    [Pure]
                    public static T Product<T>(this IEnumerable<T> source)
                        where T : Enum =>
                        source.Aggregate(Multiply);
                
                    /// <summary>Computes the sum of a sequence of <typeparamref name="T"/> values.</summary>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="source">A sequence of <typeparamref name="T"/> values to calculate the sum of.</param>
                    /// <returns>The sum of the values in the sequence.</returns>
                    [Pure]
                    public static T Sum<T>(this IEnumerable<T> source)
                        where T : Enum =>
                        source.Aggregate(Add);
                
                    [Pure]
                    static T Op<T>(this T value, [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int> op)
                        where T : Enum =>
                        op(value.AsInt()).As<T>();
                
                    [Pure]
                    static T Op<T>(this T left, T right, [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int, int> op)
                        where T : Enum =>
                        op(left.AsInt(), right.AsInt()).As<T>();
                
                    [Pure]
                    static TResult Op<T, TResult>(
                        this T left,
                        T right,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<int, int, TResult> op
                    )
                        where T : Enum =>
                        op(left.AsInt(), right.AsInt());
                
                    static class Caching<T>
                        where T : Enum
                    {
                        public static Converter<T, int> From { get; } = Make<Converter<T, int>>(false);
                
                        public static Converter<int, T> To { get; } = Make<Converter<int, T>>(true);
                
                        static TFunc Make<TFunc>(bool isReverse)
                            where TFunc : Delegate
                        {
                            var parameter = Parameter(isReverse ? typeof(int) : typeof(T), nameof(T));
                            var underlying = GetUnderlyingType(typeof(T));
                            var cast = isReverse ? (Expression)parameter : Convert(parameter, underlying);
                
                            cast = underlying != typeof(int) ? Convert(parameter, isReverse ? underlying : typeof(int)) : cast;
                            cast = isReverse ? Convert(cast, typeof(T)) : cast;
                
                            return Lambda<TFunc>(cast, parameter).Compile();
                        }
                    }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Numerics.Clamped.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods to clamp numbers.</summary>
                static partial class Clamped
                {
                #if !NET7_0_OR_GREATER
                    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
                    /// <param name="number">The number to clip.</param>
                    /// <param name="min">If specified, the smallest number to return.</param>
                    /// <param name="max">If specified, the greatest number to return.</param>
                    /// <returns>
                    /// The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
                    /// otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
                    /// <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
                    /// </returns>
                    [Pure]
                    public static int Clamp(this int number, int? min = null, int? max = null) =>
                        (min ?? number) is var small &&
                        (max ?? number) is var big &&
                        number <= small ? small :
                        number >= big ? big : number;
                
                    /// <inheritdoc cref="Clamp(int, int?, int?)"/>
                    [Pure]
                    public static float Clamp(this float number, float? min = null, float? max = null) =>
                        (min ?? number) is var small &&
                        (max ?? number) is var big &&
                        number <= small ? small :
                        number >= big ? big : number;
                #else
                    /// <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
                    /// <typeparam name="T">The type of numeric value for comparisons.</typeparam>
                    /// <param name="number">The number to clip.</param>
                    /// <param name="min">If specified, the smallest number to return.</param>
                    /// <param name="max">If specified, the greatest number to return.</param>
                    /// <returns>
                    /// The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
                    /// otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
                    /// <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
                    /// </returns>
                    [Pure]
                    public static T Clamp<T>(this T number, T? min = null, T? max = null)
                        where T : class, IComparisonOperators<T, T, bool> =>
                        (min ?? number) is var small &&
                        (max ?? number) is var big &&
                        number <= small ? small :
                        number >= big ? big : number;
                
                    /// <inheritdoc cref="Clamp{T}(T, T?, T?)"/>
                    [Pure]
                    public static T Clamp<T>(this T number, T? min = null, T? max = null)
                        where T : struct, IComparisonOperators<T, T, bool> =>
                        (min ?? number) is var small &&
                        (max ?? number) is var big &&
                        number <= small ? small :
                        number >= big ? big : number;
                
                #endif
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Runtime.Heap.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Provides methods for heap-allocation analysis.</summary>
                static partial class Heap
                {
                    /// <summary>
                    /// A <see langword="string"/> to use in an <see cref="ObsoleteAttribute"/> to indicate that the API isn't meant
                    /// for production, but not for deprecated reasons.
                    /// </summary>
                    const string NotForProduction = "NOT deprecated. While this can be used in Release builds to run this on " +
                        "optimized code; This API exists for debugging builds and should be excluded from final production builds.";
                
                    /// <summary>Swallows all exceptions from a callback; Use with caution.</summary>
                    /// <param name="action">The dangerous callback.</param>
                    [Inline, Obsolete(NotForProduction)]
                    public static void Swallow([InstantHandle] this Action action)
                    {
                        try
                        {
                            action();
                        }
                #pragma warning disable CA1031
                        catch
                #pragma warning restore CA1031
                        {
                            // ignored
                        }
                    }
                
                    /// <summary>Gets the amount of bytes a callback uses.</summary>
                    /// <remarks><para>
                    /// This method temporarily tunes the <see cref="GC"/> to <see cref="GCLatencyMode.LowLatency"/>
                    /// for accurate results. As such, the parameter <paramref name="heap"/> should not cause
                    /// substantial allocation such that collecting mid-way is required.
                    /// </para></remarks>
                    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
                    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
                    /// <returns>The number of bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.</returns>
                    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
                    public static long CountAllocation([InstantHandle, RequireStaticDelegate] Action heap, bool willWarmup = true)
                    {
                        if (willWarmup)
                            heap.Swallow();
                #if !(NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER)
                        var mode = GCSettings.LatencyMode;
                #endif
                        try
                        {
                #if NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
                            GC.TryStartNoGCRegion(ushort.MaxValue, ushort.MaxValue);
                #else
                            GCSettings.LatencyMode = GCLatencyMode.LowLatency;
                #endif
                #if NETCOREAPP3_0_OR_GREATER
                            var before = GC.GetTotalAllocatedBytes(true);
                #else
                            var before = GC.GetTotalMemory(true);
                #endif
                            heap.Swallow();
                #if NETCOREAPP3_0_OR_GREATER
                            var after = GC.GetTotalAllocatedBytes(true);
                #else
                            var after = GC.GetTotalMemory(false); // Prevents last-second garbage collection.
                #endif
                
                            return after - before;
                        }
                        finally
                        {
                #if NET46_OR_GREATER || NETSTANDARD2_0_OR_GREATER || NETCOREAPP2_0_OR_GREATER
                            if (GCSettings.LatencyMode is GCLatencyMode.NoGCRegion)
                                GC.EndNoGCRegion();
                #else
                            GCSettings.LatencyMode = mode;
                #endif
                        }
                    }
                
                    /// <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
                    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
                    /// <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
                    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
                    /// <returns>
                    /// An <see cref="Array"/> where each entry is a separate test of the number of
                    /// bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.
                    /// </returns>
                    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
                    public static long[] CountAllocations(
                        [InstantHandle, RequireStaticDelegate] Action heap,
                        [NonNegativeValue] int times = 256,
                        bool willWarmup = true
                    )
                    {
                        if (willWarmup)
                            heap.Swallow();
                
                        var all = new long[times];
                
                        for (var i = 0; i < times; i++)
                            all[i] += CountAllocation(heap, false);
                
                        return all;
                    }
                
                    /// <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
                    /// <param name="heap">The callback that causes some amount of heap allocation.</param>
                    /// <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
                    /// <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
                    /// <returns>
                    /// An <see cref="Array"/> where each entry is a separate test of the number of
                    /// bytes the <see cref="GC"/> allocated from calling <paramref name="heap"/>.
                    /// </returns>
                    [Inline, MustUseReturnValue, NonNegativeValue, Obsolete(NotForProduction)]
                    public static bool HasAllocations(
                        [InstantHandle, RequireStaticDelegate] Action heap,
                        [NonNegativeValue] int times = 256,
                        bool willWarmup = true
                    )
                    {
                        if (willWarmup)
                            heap.Swallow();
                
                        for (var i = 0; i < times; i++)
                            if (CountAllocation(heap, false) is not 0)
                                return true;
                
                        return false;
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Text.CharacterInvariance.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Provides extension methods for <see cref="char"/>.</summary>
                static partial class CharacterInvariance
                {
                    /// <inheritdoc cref="char.IsControl(char)"/>
                    [Pure]
                    public static bool IsControl(this char c) => char.IsControl(c);
                
                    /// <inheritdoc cref="char.IsDigit(char)"/>
                    [Pure]
                    public static bool IsDigit(this char c) => char.IsDigit(c);
                
                    /// <inheritdoc cref="char.IsHighSurrogate(char)"/>
                    [Pure]
                    public static bool IsHighSurrogate(this char c) => char.IsHighSurrogate(c);
                
                    /// <inheritdoc cref="char.IsLetter(char)"/>
                    [Pure]
                    public static bool IsLetter(this char c) => char.IsLetter(c);
                
                    /// <inheritdoc cref="char.IsLetterOrDigit(char)"/>
                    [Pure]
                    public static bool IsLetterOrDigit(this char c) => char.IsLetterOrDigit(c);
                
                    /// <inheritdoc cref="char.IsLower(char)"/>
                    [Pure]
                    public static bool IsLower(this char c) => char.IsLower(c);
                
                    /// <inheritdoc cref="char.IsLowSurrogate(char)"/>
                    [Pure]
                    public static bool IsLowSurrogate(this char c) => char.IsLowSurrogate(c);
                
                    /// <inheritdoc cref="string.IsNullOrEmpty(string)"/>
                    [Pure]
                    public static bool IsNullOrEmpty([NotNullWhen(false)] this string? value) => string.IsNullOrEmpty(value);
                
                #if NET35
                    /// <summary>
                    /// Indicates whether a specified string is <see langword="null"/>,
                    /// empty, or consists only of white-space characters.
                    /// </summary>
                    /// <param name="value">The string to test.</param>
                    /// <returns>
                    /// <see langword="true"/> if the <paramref name="value"/> parameter is <see langword="null"/>,
                    /// or <see cref="string.Empty"/>, or if <paramref name="value"/> consists exclusively of white-space characters.
                    /// </returns>
                    [Pure]
                    public static bool IsNullOrWhitespace([NotNullWhen(false)] this string? value) =>
                        value is null || value.All(char.IsWhiteSpace);
                #elif !NET20 && !NET30
                    /// <inheritdoc cref="string.IsNullOrWhiteSpace(string)"/>
                    [Pure]
                    public static bool IsNullOrWhitespace([NotNullWhen(false)] this string? value) => string.IsNullOrWhiteSpace(value);
                #endif
                
                    /// <inheritdoc cref="char.IsNumber(char)"/>
                    [Pure]
                    public static bool IsNumber(this char c) => char.IsNumber(c);
                
                    /// <inheritdoc cref="char.IsPunctuation(char)"/>
                    [Pure]
                    public static bool IsPunctuation(this char c) => char.IsPunctuation(c);
                
                    /// <inheritdoc cref="char.IsSeparator(char)"/>
                    [Pure]
                    public static bool IsSeparator(this char c) => char.IsSeparator(c);
                
                    /// <inheritdoc cref="char.IsSurrogate(char)"/>
                    [Pure]
                    public static bool IsSurrogate(this char c) => char.IsSurrogate(c);
                
                    /// <inheritdoc cref="char.IsSymbol(char)"/>
                    [Pure]
                    public static bool IsSymbol(this char c) => char.IsSymbol(c);
                
                    /// <inheritdoc cref="char.IsUpper(char)"/>
                    public static bool IsUpper(this char c) => char.IsUpper(c);
                
                    /// <inheritdoc cref="char.IsWhiteSpace(char)"/>
                    [Pure]
                    public static bool IsWhitespace(this char c) => char.IsWhiteSpace(c);
                
                    /// <summary>Converts the character to the byte-equivalent, 0-9.</summary>
                    /// <param name="c">The character to convert.</param>
                    /// <exception cref="ArgumentOutOfRangeException">
                    /// The parameter <paramref name="c"/> isn't between '0' and '9', inclusively on both ends.
                    /// </exception>
                    /// <returns>The number 0-9 representing the character.</returns>
                    [Pure]
                    public static byte AsDigit(this char c) =>
                        c is >= '0' and <= '9'
                            ? (byte)(c - '0')
                            : throw new ArgumentOutOfRangeException(nameof(c), c, "Character must be 0-9.");
                
                    /// <summary>Attempts to convert the character to the byte-equivalent, 0-9.</summary>
                    /// <param name="c">The character to convert.</param>
                    /// <returns>The number 0-9 representing the character, or <see langword="null"/>.</returns>
                    [Pure]
                    public static byte? TryAsDigit(this char c) => c is >= '0' and <= '9' ? (byte)(c - '0') : null;
                
                    /// <inheritdoc cref="char.ToLower(char)"/>
                    [Pure]
                    public static char ToLower(this char c) => char.ToLowerInvariant(c);
                
                    /// <inheritdoc cref="char.ToUpper(char)"/>
                    [Pure]
                    public static char ToUpper(this char c) => char.ToUpperInvariant(c);
                
                    /// <inheritdoc cref="char.GetNumericValue(char)"/>
                    [Pure]
                    public static double GetNumericValue(this char c) => char.GetNumericValue(c);
                
                    /// <inheritdoc cref="string.Trim(char[])"/>
                    [Pure]
                    public static string Trim(this string s, string trim)
                    {
                        int start = 0, end = 1;
                
                        for (; start < s.Length; start++)
                            if (start >= trim.Length || s[start] != trim[start])
                                break;
                
                        for (; end <= s.Length; end++)
                            if (end > trim.Length || s[^end] != trim[^end])
                                return s[..^(end - 1)];
                
                        return s[start..^end];
                    }
                
                    /// <inheritdoc cref="string.TrimEnd(char[])"/>
                    [Pure]
                    public static string TrimEnd(this string s, string trim)
                    {
                        for (var i = 1; i <= s.Length; i++)
                            if (i > trim.Length || s[^i] != trim[^i])
                                return s[..^(i - 1)];
                
                        return "";
                    }
                
                    /// <inheritdoc cref="string.TrimStart(char[])"/>
                    [Pure]
                    public static string TrimStart(this string s, string trim)
                    {
                        for (var i = 0; i < s.Length; i++)
                            if (i >= trim.Length || s[i] != trim[i])
                                return s[i..];
                
                        return "";
                    }
                
                    /// <inheritdoc cref="char.GetUnicodeCategory(char)"/>
                    [Pure]
                    public static UnicodeCategory GetUnicodeCategory(this char c) => char.GetUnicodeCategory(c);
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Text.Whitespaces.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Contains a myriad of strings that list all whitespace characters.</summary>
                static partial class Whitespaces
                {
                    /// <summary>All unicode characters where <c>White_Space=yes</c>, and are line breaks.</summary>
                    public const string Breaking = "\n\v\f\r\u0085\u2028\u2029";
                
                    /// <summary>All unicode characters where <c>White_Space=yes</c>, and are not a line break.</summary>
                    public const string NonBreaking =
                        "\u0009\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000";
                
                    /// <summary>All unicode characters where <c>White_Space=no</c>, but appears to be whitespace.</summary>
                    public const string Related = "\u180E\u200B\u200C\u200D\u2060\uFEFF";
                
                    /// <summary>All unicode characters where <c>White_Space=yes</c>.</summary>
                    public const string Unicode = $"{Breaking}{NonBreaking}";
                
                    /// <summary>All unicode characters that appear to be whitespace.</summary>
                    public const string All = $"{Unicode}{Related}";
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Text.Stringifier.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if NET35 && WAWA
                namespace Wawa.Modules;
                #else
                // ReSharper disable CheckNamespace
                namespace Emik.Morsels;
                #endif
                
                /// <summary>Provides stringification methods.</summary>
                // ReSharper disable once BadPreprocessorIndent
                #if NET35 && WAWA
                public
                #endif
                static partial class Stringifier
                {
                    // ReSharper disable UnusedMember.Local
                #pragma warning disable CA1823, IDE0051
                    const string
                        Else = "th",
                        False = "false",
                        First = "st",
                        KeyValueSeparator = ": ",
                        Negative = "-",
                        Null = "null",
                        Second = "nd",
                        Separator = ", ",
                        Third = "rd",
                        True = "true";
                #pragma warning restore CA1823, IDE0051
                
                #if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
                    static readonly Dictionary<Type, bool> s_hasMethods = new();
                
                    static readonly Dictionary<Type, Delegate> s_stringifiers = new();
                
                    static readonly Dictionary<Type, string> s_unfoldedNames = new()
                    {
                        [typeof(byte)] = "byte",
                        [typeof(char)] = "char",
                        [typeof(decimal)] = "decimal",
                        [typeof(double)] = "double",
                        [typeof(float)] = "float",
                        [typeof(int)] = "int",
                        [typeof(long)] = "long",
                        [typeof(nint)] = "nint",
                        [typeof(nuint)] = "nuint",
                        [typeof(object)] = "object",
                        [typeof(sbyte)] = "sbyte",
                        [typeof(short)] = "short",
                        [typeof(string)] = "string",
                        [typeof(uint)] = "uint",
                        [typeof(ulong)] = "ulong",
                        [typeof(ushort)] = "ushort",
                        [typeof(void)] = "void",
                    };
                
                    static readonly ConstantExpression
                        s_exEmpty = Expression.Constant(""),
                        s_exFalse = Expression.Constant(false),
                        s_exSeparator = Expression.Constant(Separator),
                        s_exTrue = Expression.Constant(true);
                
                    static readonly MethodInfo
                        s_combine = ((Func<string, string, string>)string.Concat).Method,
                        s_stringify = ((Func<bool, bool, bool, bool, string>)Stringify).Method.GetGenericMethodDefinition();
                #endif
                #if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
                    static readonly MethodInfo s_toString = ((Func<string?>)s_hasMethods.ToString).Method;
                #endif
                
                #if !NET35 // This method purely exists to take advantage of .NET 5's blazingly fast alternative.
                    /// <summary>Concatenates an enumeration of <see cref="char"/> into a <see cref="string"/>.</summary>
                    /// <remarks><para>
                    /// This method is more efficient than using <see cref="Conjoin"/> for <see cref="char"/> enumerations.
                    /// </para></remarks>
                    /// <param name="chars">The enumeration of characters.</param>
                    /// <returns>A <see cref="string"/> built from concatenating <paramref name="chars"/>.</returns>
                    [Pure]
                    public static string Conjoin(this IEnumerable<char> chars) => string.Concat(chars);
                #endif
                
                    /// <summary>Joins a set of values into one long <see cref="string"/>.</summary>
                    /// <remarks><para>
                    /// This method is more efficient than using
                    /// <see cref="Conjoin{T}(IEnumerable{T}, string)"/> for <see cref="char"/> separators.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of each item in the collection.</typeparam>
                    /// <param name="values">The values to join.</param>
                    /// <param name="separator">The separator between each item.</param>
                    /// <returns>One long <see cref="string"/>.</returns>
                    // ReSharper disable BadPreprocessorIndent
                    [Pure]
                    public static string Conjoin<T>(
                #if !WAWA
                        this
                #endif
                        IEnumerable<T> values,
                        char separator
                    )
                    {
                        StringBuilder stringBuilder = new();
                        using var enumerator = values.GetEnumerator();
                
                        if (enumerator.MoveNext())
                            stringBuilder.Append(enumerator.Current);
                        else
                            return "";
                
                        while (enumerator.MoveNext())
                            stringBuilder.Append(separator).Append(enumerator.Current);
                
                        return stringBuilder.ToString();
                    }
                
                    /// <summary>Joins a set of values into one long <see cref="string"/>.</summary>
                    /// <typeparam name="T">The type of each item in the collection.</typeparam>
                    /// <param name="values">The values to join.</param>
                    /// <param name="separator">The separator between each item.</param>
                    /// <returns>One long <see cref="string"/>.</returns>
                    [Pure]
                    public static string Conjoin<T>(
                #if !WAWA
                        this
                #endif
                        IEnumerable<T> values,
                        string separator = Separator
                    )
                    {
                        StringBuilder stringBuilder = new();
                        using var enumerator = values.GetEnumerator();
                
                        if (enumerator.MoveNext())
                            stringBuilder.Append(enumerator.Current);
                        else
                            return "";
                
                        while (enumerator.MoveNext())
                            stringBuilder.Append(separator).Append(enumerator.Current);
                
                        return stringBuilder.ToString();
                    }
                
                    /// <summary>Gets the type name, with its generics extended.</summary>
                    /// <param name="type">The <see cref="Type"/> to get the name of.</param>
                    /// <returns>The name of the parameter <paramref name="type"/>.</returns>
                    [Pure]
                    public static string UnfoldedName(
                #if !WAWA
                        this
                #endif
                        Type? type
                    ) =>
                        type is null ? Null :
                        s_unfoldedNames.TryGetValue(type, out var val) ? val :
                        s_unfoldedNames[type] = type.IsGenericType ? $"{type.UnfoldedName(new())}" : type.Name;
                
                    /// <summary>Converts a number to an ordinal.</summary>
                    /// <param name="i">The number to convert.</param>
                    /// <param name="indexByZero">Determines whether to index from zero or one.</param>
                    /// <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
                    [Pure]
                    public static string Nth(
                #if !WAWA
                        this
                #endif
                        int i,
                        bool indexByZero = false
                    ) =>
                        indexByZero ? (i + 1).ToOrdinal() : i.ToOrdinal();
                
                    /// <inheritdoc cref="string.Split(string[], StringSplitOptions)"/>
                    // ReSharper disable once ReturnTypeCanBeEnumerable.Global
                    public static string[] Split(
                #if !WAWA
                        this
                #endif
                        string source,
                        string separator
                    ) =>
                        source.Split(new[] { separator }, StringSplitOptions.RemoveEmptyEntries);
                
                #if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
                    /// <summary>
                    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
                    /// </summary>
                    /// <remarks><para>
                    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
                    /// unless they explicitly define a <see cref="object.ToString"/>, or inherit <see cref="IEnumerable"/>,
                    /// in which case each item within is printed out separately.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of the source.</typeparam>
                    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
                    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
                    [MustUseReturnValue]
                    public static string Stringify<T>(
                #if !WAWA
                        this
                #endif
                        T? source
                    ) =>
                        Stringify(source, false, true, false);
                
                    /// <summary>
                    /// Converts <paramref name="source"/> into a <see cref="string"/> representation of <paramref name="source"/>.
                    /// </summary>
                    /// <remarks><para>
                    /// Unlike <see cref="object.ToString"/>, the values of all properties are printed out,
                    /// unless they explicitly define a <see cref="object.ToString"/>, or inherit <see cref="IEnumerable"/>,
                    /// in which case each item within is printed out separately.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of the source.</typeparam>
                    /// <param name="source">The item to get a <see cref="string"/> representation of.</param>
                    /// <param name="isSurrounded">
                    /// Determines whether <see cref="string"/> and <see cref="char"/> have a " and ' surrounding them.
                    /// </param>
                    /// <param name="isRecursive">
                    /// Determines whether it re-calls <see cref="Stringify{T}(T, bool, bool, bool)"/>
                    /// on each property in <paramref name="source"/>.
                    /// </param>
                    /// <param name="forceReflection">
                    /// Determines whether it uses its own reflective stringification regardless of type.
                    /// </param>
                    /// <returns><paramref name="source"/> as <see cref="string"/>.</returns>
                    [MustUseReturnValue]
                    public static string Stringify<T>(
                #if !WAWA
                        this
                #endif
                        T? source,
                        bool isSurrounded,
                        bool isRecursive = true,
                        bool forceReflection = true
                    ) =>
                        source switch
                        {
                            _ when forceReflection => source.UseStringifier(),
                            null => Null,
                            bool b => b ? True : False,
                            char c => isSurrounded ? $"'{c}'" : $"{c}",
                            string s => isSurrounded ? $@"""{s}""" : s,
                #if NET35 && WAWA
                            Object o => o.name,
                #endif
                            IFormattable i => i.ToString(null, CultureInfo.InvariantCulture),
                            IDictionary d => $"{{ {d.DictionaryStringifier()} }}",
                            ICollection l => $"{l.Count} [{l.GetEnumerator().EnumeratorStringifier()}]",
                            IEnumerable e => $"[{e.GetEnumerator().EnumeratorStringifier()}]",
                            _ => source.StringifyObject(isRecursive),
                        };
                
                    static void AppendKeyValuePair(this StringBuilder builder, string key, string value) =>
                        builder.Append(key).Append(KeyValueSeparator).Append(value);
                #endif
                
                    // ReSharper disable once ConditionalAccessQualifierIsNonNullableAccordingToAPIContract
                    [MustUseReturnValue]
                    static bool CanUse(PropertyInfo p) =>
                        p.CanRead &&
                        p.GetIndexParameters().Length is 0 &&
                        p.GetCustomAttributes(true).All(x => x?.GetType() != typeof(ObsoleteAttribute));
                
                    [Pure]
                    static int Mod(this in int i) => Math.Abs(i) / 10 % 10 == 1 ? 0 : Math.Abs(i) % 10;
                
                    [Pure]
                    static string ToOrdinal(this int i) =>
                        $@"{(i < 0 ? Negative : "")}{i}{Mod(i) switch
                        {
                            1 => First,
                            2 => Second,
                            3 => Third,
                            _ => Else,
                        }}";
                #if !NET20 && !NET30 && !NETSTANDARD || NETSTANDARD2_0_OR_GREATER
                
                    [Pure]
                    static StringBuilder EnumeratorStringifier(this IEnumerator iterator)
                    {
                        StringBuilder builder = new();
                
                        if (iterator.MoveNext())
                            builder.Append(Stringify(iterator.Current));
                
                        while (iterator.MoveNext())
                            builder.Append(Separator).Append(Stringify(iterator.Current));
                
                        return builder;
                    }
                
                    [MustUseReturnValue]
                    static string StringifyObject<T>(this T source, bool isRecursive)
                    {
                        if (typeof(T) == typeof(object))
                            return source?.ToString() ?? Null;
                
                        if (!s_hasMethods.ContainsKey(typeof(T)))
                #pragma warning disable CS0253
                            s_hasMethods[typeof(T)] =
                                typeof(object) == typeof(T).GetMethod(nameof(ToString), Type.EmptyTypes)?.DeclaringType;
                #pragma warning restore CS0253
                
                        if (s_hasMethods[typeof(T)] || !isRecursive)
                            return source?.ToString() ?? Null;
                
                        return UseStringifier(source);
                    }
                
                    [MustUseReturnValue]
                    static string UseStringifier<T>(this T source)
                    {
                        if (!s_stringifiers.ContainsKey(typeof(T)))
                            s_stringifiers[typeof(T)] = GenerateStringifier<T>();
                
                        var name = source?.GetType() is { } type && type != typeof(T)
                            ? $"{UnfoldedName(type)} as {UnfoldedName(typeof(T))}"
                            : UnfoldedName(typeof(T));
                
                        return $"{name} {{ {((Func<T, string>)s_stringifiers[typeof(T)])(source)} }}";
                    }
                
                    [MustUseReturnValue]
                    static Func<T, string> GenerateStringifier<T>()
                    {
                        var exParam = Expression.Parameter(typeof(T), nameof(T));
                
                        // ReSharper disable ArrangeStaticMemberQualifier ConditionalAccessQualifierIsNonNullableAccordingToAPIContract
                        var array = typeof(T)
                           .GetProperties(BindingFlags.Instance | BindingFlags.Public)
                           .Where(CanUse)
                           .Select(p => GetMethodCaller(p, exParam))
                           .ToCollectionLazily();
                
                        static MethodCallExpression Combine(MethodCallExpression prev, MethodCallExpression curr)
                        {
                            var call = Expression.Call(s_combine, prev, s_exSeparator);
                            return Expression.Call(s_combine, call, curr);
                        }
                
                        Expression exResult = array.Any()
                            ? array.Aggregate(Combine)
                            : s_exEmpty;
                
                        return Expression
                           .Lambda<Func<T, string>>(exResult, exParam)
                           .Compile();
                    }
                
                    [MustUseReturnValue]
                    static MethodCallExpression GetMethodCaller(PropertyInfo info, Expression param)
                    {
                        var exConstant = Expression.Constant($"{info.Name}{KeyValueSeparator}");
                
                #if NETSTANDARD2_1_OR_GREATER || NETCOREAPP
                        if (info.PropertyType.IsByRefLike)
                            return Expression.Call(s_combine, exConstant, Expression.Call(param, s_toString));
                #endif
                
                        var method = s_stringify.MakeGenericMethod(info.PropertyType);
                
                        Expression
                            exMember = Expression.MakeMemberAccess(param, info),
                            exCall = Expression.Call(method, exMember, s_exTrue, s_exFalse, s_exFalse);
                
                        return Expression.Call(s_combine, exConstant, exCall);
                    }
                
                    [Pure]
                    static StringBuilder DictionaryStringifier(this IDictionary dictionary)
                    {
                        var iterator = dictionary.GetEnumerator();
                        StringBuilder builder = new();
                
                        if (iterator.MoveNext())
                            builder.AppendKeyValuePair(Stringify(iterator.Key), Stringify(iterator.Value));
                
                        while (iterator.MoveNext())
                            builder.Append(Separator).AppendKeyValuePair(Stringify(iterator.Key), Stringify(iterator.Value));
                
                        return builder;
                    }
                
                    static StringBuilder UnfoldedName(this Type? type, StringBuilder sb)
                    {
                        StringBuilder Append(Type x)
                        {
                            sb.Append(',').Append(' ');
                            return x.UnfoldedName(sb);
                        }
                
                        if (type is null)
                            return sb;
                
                        if (s_unfoldedNames.TryGetValue(type, out var val))
                            return sb.Append(val);
                
                        var name = type.Name;
                
                        if (!type.IsGenericType)
                            return sb.Append(name);
                
                        var len = name.IndexOf('`') is var i && i is -1 ? name.Length : i;
                        var types = type.GetGenericArguments();
                
                        types.FirstOrDefault()?.UnfoldedName(sb.Append(name, 0, len).Append('<'));
                        _ = types.Skip(1).Select(Append).LastOrDefault(_ => false);
                
                        return sb.Append('>');
                    }
                #endif
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Text.EnumStrings.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NETFRAMEWORK || NET40_OR_GREATER
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static Expression;
                
                /// <summary>Provides methods to do math on enums without overhead from boxing.</summary>
                [UsedImplicitly]
                static partial class EnumStrings
                {
                    /// <summary>Converts the value to a constant <see cref="string"/>.</summary>
                    /// <remarks><para>
                    /// Combinations via <see cref="FlagsAttribute"/> are ignored. Only explicit fields count.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <exception cref="ArgumentOutOfRangeException">The value doesn't represent an exact value.</exception>
                    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
                    [Pure]
                    public static string AsString<T>(this T value)
                        where T : Enum =>
                        Caching<T>.From(value);
                
                    /// <summary>Converts the <see cref="string"/> to a constant value.</summary>
                    /// <remarks><para>
                    /// Combinations via <see cref="FlagsAttribute"/> are ignored. Only explicit fields count.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of <see cref="Enum"/> to perform the operation on.</typeparam>
                    /// <param name="value">The value.</param>
                    /// <exception cref="ArgumentOutOfRangeException">The value doesn't represent an exact value.</exception>
                    /// <returns>The negated value of the parameter <paramref name="value"/>.</returns>
                    [Pure]
                    public static T As<T>(this string value)
                        where T : Enum =>
                        Caching<T>.To(value);
                
                    static class Caching<T>
                        where T : Enum
                    {
                        public static Converter<T, string> From { get; } = Make<Converter<T, string>>(false);
                
                        public static Converter<string, T> To { get; } = Make<Converter<string, T>>(true);
                
                        static TFunc Make<TFunc>(bool inReverse)
                            where TFunc : Delegate
                        {
                            var parameter = Parameter(typeof(string), nameof(T));
                            var thrower = Thrower(nameof(T));
                            var cases = Cases(inReverse);
                            var ret = Switch(parameter, thrower, cases);
                
                            return Lambda<TFunc>(ret, parameter).Compile();
                        }
                
                        static SwitchCase Case(FieldInfo x, bool inReverse)
                        {
                            var str = Constant(x.Name, typeof(string));
                            var t = Constant(x.GetValue(null), typeof(T));
                            var from = inReverse ? str : t;
                            var to = inReverse ? t : str;
                
                            return SwitchCase(from, to);
                        }
                
                        static SwitchCase[] Cases(bool inReverse) => typeof(T).GetFields().Select(x => Case(x, inReverse)).ToArray();
                
                        static UnaryExpression Thrower(string paramName) =>
                            Throw(Constant(new ArgumentOutOfRangeException(paramName), typeof(ArgumentOutOfRangeException)));
                    }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.NullableItems.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable UnusedMember.Local
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                #pragma warning disable CA1508
                /// <summary>Extension methods for improving nullability awareness for enumerables.</summary>
                static partial class NullableItems
                {
                #pragma warning disable CS8619
                    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
                    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
                    /// <param name="iterable">The item to return with adjusted nullability.</param>
                    /// <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static IEnumerable<T?>? ItemCanBeNull<T>(this IEnumerable<T>? iterable) => iterable;
                
                    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
                    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
                    /// <param name="iterator">The item to return with adjusted nullability.</param>
                    /// <returns>The parameter <paramref name="iterator"/>, with <see cref="ItemCanBeNullAttribute"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterator))]
                    public static IEnumerator<T?>? ItemCanBeNull<T>(this IEnumerator<T>? iterator) => iterator;
                
                #if !NET20 && !NET30
                    /// <summary>Returns the list if all items are non-null.</summary>
                    /// <typeparam name="T">The type of list.</typeparam>
                    /// <param name="list">The list to filter.</param>
                    /// <returns>
                    /// The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
                    /// otherwise <see langword="null"/>.
                    /// </returns>
                    [Pure]
                    public static IList<T>? ItemNotNull<T>(this IList<T?>? list) =>
                        list?.All(x => x is not null) ?? false ? list : null;
                #endif
                
                    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
                    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
                    /// <param name="collection">The item to return with adjusted nullability.</param>
                    /// <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(collection))]
                    public static IReadOnlyCollection<T?>? ItemCanBeNull<T>(this IReadOnlyCollection<T>? collection) => collection;
                
                    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
                    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
                    /// <param name="list">The item to return with adjusted nullability.</param>
                    /// <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(list))]
                    public static IReadOnlyList<T?>? ItemCanBeNull<T>(this IReadOnlyList<T>? list) => list;
                
                    /// <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
                    /// <typeparam name="T">The type of item to adjust nullability.</typeparam>
                    /// <param name="set">The item to return with adjusted nullability.</param>
                    /// <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(set))]
                    public static IReadOnlySet<T?>? ItemCanBeNull<T>(this IReadOnlySet<T>? set) => set;
                #pragma warning restore CS8619
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Similarity.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #pragma warning disable 8500, SA1114
                using static Math;
                using static Span;
                
                /// <summary>Provides methods for determining similarity between two sequences.</summary>
                static partial class Similarity
                {
                    /// <summary>Calculates the Jaro similarity between two strings.</summary>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro(this string? left, string? right) => left.Jaro(right, EqualityComparer<char>.Default);
                
                    /// <summary>Calculates the Jaro similarity between two strings.</summary>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro(this string? left, string? right, [InstantHandle] Func<char, char, bool>? comparer) =>
                        ReferenceEquals(left, right) ? 1 :
                        left is null || right is null ? 0 :
                        Jaro(left, right, static x => x.Length, static (x, i) => x[i], comparer);
                
                    /// <summary>Calculates the Jaro similarity between two strings.</summary>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro(this string? left, string? right, IEqualityComparer<char>? comparer) =>
                        left.Jaro(right, comparer is null ? null : comparer.Equals);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
                    /// <remarks><para>Like <see cref="Jaro(string, string)"/>, but with a bias to common prefixes.</para></remarks>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler(this string? left, string? right) =>
                        left.JaroWinkler(right, EqualityComparer<char>.Default);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro(string, string, Func{char, char, bool})"/>, but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler(
                        this string? left,
                        string? right,
                        [InstantHandle] Func<char, char, bool>? comparer
                    ) =>
                        ReferenceEquals(left, right) ? 1 :
                        left is null || right is null ? 0 :
                        JaroWinkler(left, right, static x => x.Length, static (x, i) => x[i], comparer);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro(string, string, IEqualityComparer{char})"/>, but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler(
                        this string? left,
                        string? right,
                        IEqualityComparer<char>? comparer
                    ) =>
                        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);
                
                    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro<T>(this IList<T>? left, IList<T>? right) => left.Jaro(right, EqualityComparer<T>.Default);
                
                    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro<T>(this IList<T>? left, IList<T>? right, [InstantHandle] Func<T, T, bool>? comparer) =>
                        ReferenceEquals(left, right) ? 1 :
                        left is null || right is null ? 0 :
                        Jaro(left, right, static x => x.Count, static (x, i) => x[i], comparer);
                
                    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
                        left.Jaro(right, comparer is null ? null : comparer.Equals);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(IList{T}, IList{T})"/>, but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right) =>
                        left.JaroWinkler(right, EqualityComparer<T>.Default);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, Func{T, T, bool})"/>, but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right, [InstantHandle] Func<T, T, bool>? comparer) =>
                        ReferenceEquals(left, right) ? 1 :
                        left is null || right is null ? 0 :
                        JaroWinkler(left, right, static x => x.Count, static (x, i) => x[i], comparer);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(IList{T}, IList{T}, IEqualityComparer{T})"/>, but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler<T>(this IList<T>? left, IList<T>? right, IEqualityComparer<T>? comparer) =>
                        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
                    /// but with a bias to common prefixes.
                    /// </para></remarks>
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double Jaro<T>(this ReadOnlySpan<T> left, ReadOnlySpan<T> right, IEqualityComparer<T>? comparer) =>
                        left.Jaro(right, comparer is null ? null : comparer.Equals);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
                    /// but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static unsafe double Jaro<T>(
                        this ReadOnlySpan<T> left,
                        ReadOnlySpan<T> right,
                        [InstantHandle] Func<T, T, bool>? comparer = null
                    )
                #if UNMANAGED_SPAN
                        where T : unmanaged
                #endif
                    {
                        // ReSharper disable once WrongIndentSize
                #if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
                        var l = left.Pointer;
                        var r = right.Pointer;
                #else
                        fixed (T* l = left)
                        fixed (T* r = right)
                #endif
                        return Jaro(
                            new Fat<T>(l, left.Length),
                            new(r, right.Length),
                            static x => x.Length,
                            static (x, i) => x[i],
                            comparer
                        );
                    }
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>,
                    /// but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static double JaroWinkler<T>(
                        this ReadOnlySpan<T> left,
                        ReadOnlySpan<T> right,
                        IEqualityComparer<T>? comparer
                    ) =>
                        left.JaroWinkler(right, comparer is null ? null : comparer.Equals);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, Func{T, T, bool})"/>,
                    /// but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [Pure, ValueRange(0, 1)]
                    public static unsafe double JaroWinkler<T>(
                        this ReadOnlySpan<T> left,
                        ReadOnlySpan<T> right,
                        [InstantHandle] Func<T, T, bool>? comparer = null
                    )
                #if UNMANAGED_SPAN
                        where T : unmanaged
                #endif
                    {
                        // ReSharper disable once WrongIndentSize
                #if !(NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) || NO_SYSTEM_MEMORY
                        var l = left.Pointer;
                        var r = right.Pointer;
                #else
                        fixed (T* l = left)
                        fixed (T* r = right)
                #endif
                        return JaroWinkler(
                            new Fat<T>(l, left.Length),
                            new(r, right.Length),
                            static x => x.Length,
                            static (x, i) => x[i],
                            comparer
                        );
                    }
                
                    /// <summary>Calculates the Jaro similarity between two sequences.</summary>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="counter">The function that gets the count.</param>
                    /// <param name="indexer">The function that acts as an indexer.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [MustUseReturnValue, ValueRange(0, 1)]
                    public static double Jaro<T, TItem>(
                        T left,
                        T right,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
                    ) =>
                        Jaro(left, right, counter(left), counter(right), indexer, comparer);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T, TItem}(T, T, Func{T, int}, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
                    /// but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of sequence.</typeparam>
                    /// <typeparam name="TItem">The type of item within the sequence.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="counter">The function that gets the count.</param>
                    /// <param name="indexer">The function that acts as an indexer.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [MustUseReturnValue, ValueRange(0, 1)]
                    public static double JaroWinkler<T, TItem>(
                        T left,
                        T right,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int> counter,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
                    ) =>
                        JaroWinkler(left, right, counter(left), counter(right), indexer, comparer);
                
                    /// <summary>Calculates the Jaro similarity between two instances.</summary>
                    /// <typeparam name="T">The type of instance.</typeparam>
                    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="leftLength">The left-hand side's length.</param>
                    /// <param name="rightLength">The right-hand side's length.</param>
                    /// <param name="indexer">The function that acts as an indexer.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [MustUseReturnValue, ValueRange(0, 1)]
                    public static double Jaro<T, TItem>(
                        T left,
                        T right,
                        [NonNegativeValue] int leftLength,
                        [NonNegativeValue] int rightLength,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
                    ) =>
                        JaroInner(left, right, leftLength, rightLength, indexer, comparer ?? EqualityComparer<TItem>.Default.Equals);
                
                    /// <summary>Calculates the Jaro-Winkler similarity between two instances.</summary>
                    /// <remarks><para>
                    /// Like <see cref="Jaro{T, TItem}(T, T, int, int, Func{T, int, TItem}, Func{TItem, TItem, bool})"/>,
                    /// but with a bias to common prefixes.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of instance.</typeparam>
                    /// <typeparam name="TItem">The type of item within the instance.</typeparam>
                    /// <param name="left">The left-hand side.</param>
                    /// <param name="right">The right-hand side.</param>
                    /// <param name="leftLength">The left-hand side's length.</param>
                    /// <param name="rightLength">The right-hand side's length.</param>
                    /// <param name="indexer">The function that acts as an indexer.</param>
                    /// <param name="comparer">The comparer to determine equality, or <see cref="EqualityComparer{T}.Default"/>.</param>
                    /// <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
                    [MustUseReturnValue, ValueRange(0, 1)]
                    public static double JaroWinkler<T, TItem>(
                        T left,
                        T right,
                        [NonNegativeValue] int leftLength,
                        [NonNegativeValue] int rightLength,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [InstantHandle] Func<TItem, TItem, bool>? comparer = null
                    )
                    {
                        comparer ??= EqualityComparer<TItem>.Default.Equals;
                
                        var jaroDistance = JaroInner(left, right, leftLength, rightLength, indexer, comparer);
                        var prefixLength = NumberOfEquals(left, right, leftLength, rightLength, indexer, comparer);
                        var distance = JaroWinklerDistance(jaroDistance, prefixLength);
                
                        return Min(distance, 1);
                    }
                
                    [MustUseReturnValue, ValueRange(0, 1)]
                    static double JaroAllocated<T, TItem>(
                        in Span<byte> visited,
                        (T, T, int, int, Func<T, int, TItem>, Func<TItem, TItem, bool>) args
                    )
                    {
                        var (left, right, leftLength, rightLength, indexer, comparer) = args;
                        int rightPreviousIndex = 0, transpositionCount = 0;
                        double matchCount = 0;
                        visited.Clear();
                
                        for (var i = 0; i < leftLength; i++)
                            if (InBounds(leftLength, rightLength, i))
                                rightPreviousIndex = Next(
                                    visited,
                                    left,
                                    right,
                                    leftLength,
                                    rightLength,
                                    i,
                                    rightPreviousIndex,
                                    comparer,
                                    indexer,
                                    ref matchCount,
                                    ref transpositionCount
                                );
                
                        return matchCount is 0 ? 0 : JaroDistance(leftLength, rightLength, matchCount, transpositionCount);
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, ValueRange(0, 1)]
                    static double JaroInner<T, TItem>(
                        T left,
                        T right,
                        [NonNegativeValue] int leftLength,
                        [NonNegativeValue] int rightLength,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [InstantHandle] Func<TItem, TItem, bool> comparer
                    ) =>
                        leftLength is 0 && rightLength is 0 ? 1 :
                            leftLength is 0 || rightLength is 0 ? 0 :
                                leftLength is 1 && rightLength is 1 ?
                                    comparer(indexer(left, 0), indexer(right, 0)) ? 1 : 0 :
                                    Allocate(rightLength, (left, right, leftLength, rightLength, indexer, comparer), Fun<T, TItem>());
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    static SpanFunc<byte, (T, T, int, int, Func<T, int, TItem>, Func<TItem, TItem, bool>), double> Fun<T, TItem>() =>
                        static (span, tuple) => JaroAllocated(span, tuple);
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
                    static int Next<T, TItem>(
                        in Span<byte> visited,
                        T left,
                        T right,
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [NonNegativeValue] int leftIndex,
                        [NonNegativeValue] int rightPreviousIndex,
                        [InstantHandle] Func<TItem, TItem, bool> comparer,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [NonNegativeValue] ref double matchCount,
                        [NonNegativeValue] ref int transpositionCount
                    )
                    {
                        for (var rightIndex = 0; rightIndex < rightLength; rightIndex++)
                        {
                            if (!ShouldProceed(visited, left, right, leftLength, rightLength, leftIndex, rightIndex, comparer, indexer))
                                continue;
                
                            visited[rightIndex]++;
                            matchCount++;
                
                            if (rightIndex < rightPreviousIndex)
                                transpositionCount++;
                
                            return rightIndex;
                        }
                
                        return rightPreviousIndex;
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
                    static bool ShouldProceed<T, TItem>(
                        in Span<byte> visited,
                        T leftLength,
                        T rightLength,
                        [ValueRange(2, int.MaxValue)] int aLen,
                        [ValueRange(2, int.MaxValue)] int bLen,
                        [NonNegativeValue] int leftIndex,
                        [NonNegativeValue] int rightIndex,
                        [InstantHandle] Func<TItem, TItem, bool> comparer,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer
                    ) =>
                        InBounds(aLen, bLen, leftIndex, rightIndex) &&
                        visited[rightIndex] is 0 &&
                        EqualsAt(leftLength, rightLength, leftIndex, rightIndex, comparer, indexer);
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue]
                    static bool EqualsAt<T, TItem>(
                        T left,
                        T right,
                        [NonNegativeValue] int leftIndex,
                        [NonNegativeValue] int rightIndex,
                        [InstantHandle] Func<TItem, TItem, bool> comparer,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer
                    ) =>
                        comparer(indexer(left, leftIndex), indexer(right, rightIndex));
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), MustUseReturnValue, NonNegativeValue]
                    static int NumberOfEquals<T, TItem>(
                        T left,
                        T right,
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [InstantHandle, RequireStaticDelegate(IsError = true)] Func<T, int, TItem> indexer,
                        [InstantHandle] Func<TItem, TItem, bool> comparer
                    )
                    {
                        var sharedLength = Min(leftLength, rightLength);
                
                        for (var sharedIndex = 0; sharedIndex < sharedLength; sharedIndex++)
                            if (!comparer(indexer(left, sharedIndex), indexer(right, sharedIndex)))
                                return sharedIndex;
                
                        return sharedLength;
                    }
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    static bool InBounds(
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [NonNegativeValue] int leftIndex
                    ) =>
                        MinBound(leftLength, rightLength, leftIndex) <= MaxBound(leftLength, rightLength, leftIndex);
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    static bool InBounds(
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [NonNegativeValue] int leftIndex,
                        [NonNegativeValue] int rightIndex
                    ) =>
                        MinBound(leftLength, rightLength, leftIndex) <= rightIndex &&
                        rightIndex <= MaxBound(leftLength, rightLength, leftIndex);
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
                    static int MaxBound(
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [NonNegativeValue] int leftIndex
                    ) =>
                        Min(SearchRange(leftLength, rightLength) + leftIndex, rightLength - 1);
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
                    static int MinBound(
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [NonNegativeValue] int leftIndex
                    ) =>
                        SearchRange(leftLength, rightLength) < leftIndex ? Max(0, leftIndex - SearchRange(leftLength, rightLength)) : 0;
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure]
                    static int SearchRange([ValueRange(2, int.MaxValue)] int leftLength, [ValueRange(2, int.MaxValue)] int rightLength) =>
                        Max(leftLength, rightLength) / 2 - 1;
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(0, 1)]
                    static double JaroDistance(
                        [ValueRange(2, int.MaxValue)] int leftLength,
                        [ValueRange(2, int.MaxValue)] int rightLength,
                        [NonNegativeValue] double matchCount,
                        [NonNegativeValue] int transpositionCount
                    ) =>
                        1 / 3.0 * (matchCount / leftLength + matchCount / rightLength + (matchCount - transpositionCount) / matchCount);
                
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure, ValueRange(0, 1)]
                    static double JaroWinklerDistance([ValueRange(0, 1)] double jaroDistance, [NonNegativeValue] int prefixLength) =>
                        jaroDistance + 0.1 * prefixLength * (1.0 - jaroDistance);
                
                    /// <summary>Represents a pointer with a length.</summary>
                    [StructLayout(LayoutKind.Auto)]
                    readonly unsafe partial struct Fat<T>
                    {
                        const string E = "Value must be non-negative and less than the length.";
                
                        readonly void* _pointer;
                
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public Fat(void* pointer, [NonNegativeValue] int length)
                        {
                            _pointer = pointer;
                            Length = length;
                        }
                
                        public T this[int i]
                        {
                            [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                            get => (uint)i < (uint)Length ? ((T*)_pointer)[i] : throw new ArgumentOutOfRangeException(nameof(i), i, E);
                        }
                
                        public int Length { [MethodImpl(MethodImplOptions.AggressiveInlining), NonNegativeValue, Pure] get; }
                    }
                }
                #pragma warning restore SA1114
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.RandomizedGetters.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods for randomized getters.</summary>
                static partial class RandomizedGetters
                {
                    /// <summary>Shuffles a collection.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to shuffle.</param>
                    /// <param name="selector">The indices to swap with, when left unspecified, uses <see cref="Rand"/>.</param>
                    /// <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
                    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
                    public static IList<T> Shuffle<T>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        [InstantHandle] Func<int, int, int>? selector = null
                    )
                    {
                        selector ??= Rand();
                
                        var list = iterable.ToListLazily();
                
                        for (var j = list.Count; j >= 1; j--)
                        {
                            var item = selector(0, j);
                
                            if (item >= j - 1)
                                continue;
                
                            // Tuples might not necessarily be imported.
                #pragma warning disable IDE0180 // ReSharper disable once SwapViaDeconstruction
                            var t = list[item];
                            list[item] = list[j - 1];
                            list[j - 1] = t;
                #pragma warning restore IDE0180
                        }
                
                        return list;
                    }
                
                    /// <summary>Shuffles a collection.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to shuffle.</param>
                    /// <param name="selector">The indices to swap with, when left unspecified, uses <see cref="Rand"/>.</param>
                    /// <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
                    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
                    public static T PickRandom<T>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        [InstantHandle] Func<int, int, int>? selector = null
                    )
                    {
                        selector ??= Rand();
                
                        return iterable switch
                        {
                            IList<T> list => list[selector(0, list.Count)],
                            IReadOnlyList<T> list => list[selector(0, list.Count)],
                            _ when iterable.ToList() is var list => list[selector(0, list.Count)],
                            _ => throw Unreachable,
                        };
                    }
                
                    [Pure]
                    static Func<int, int, int> Rand() =>
                #if NET35
                        UnityEngine.Random.Range;
                #elif NET6_0_OR_GREATER
                        Random.Shared.Next;
                #else
                        // ReSharper disable once RedundantNameQualifier
                        new Random().Next;
                #endif
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Diagnostics.Exit.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #pragma warning disable CS8632, MA0048, SA1629, SYSLIB0003, GlobalUsingsAnalyzer
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                using SecurityAction = System.Security.Permissions.SecurityAction;
                #endif
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                using static SecurityAction;
                using static SecurityPermissionFlag;
                #endif
                
                /// <summary>Provides methods for exiting the program.</summary>
                static partial class Exit
                {
                    /// <remarks><para>This method represents the exit code 0, indicating success.</para></remarks>
                    /// <inheritdoc cref="With"/>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                    public static Exception Success(string? message = null) => throw With(0, message);
                
                    /// <remarks><para>This method represents the exit code 1, indicating failure.</para></remarks>
                    /// <inheritdoc cref="With"/>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                    public static Exception Failure(string? message = null) => throw With(1, message);
                
                    /// <remarks><para>This method represents the exit code 2, indicating invalid parameters.</para></remarks>
                    /// <inheritdoc cref="With"/>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                    public static Exception Usage(string? message = null) => throw With(2, message);
                
                    /// <typeparam name="T">Only used for type coercion.</typeparam>
                    /// <inheritdoc cref="Success"/>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                    public static T Success<T>(string? message = null) => throw With(0, message);
                
                    /// <typeparam name="T">Only used for type coercion.</typeparam>
                    /// <inheritdoc cref="Failure"/>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                    public static T Failure<T>(string? message = null) => throw With(1, message);
                
                    /// <typeparam name="T">Only used for type coercion.</typeparam>
                    /// <inheritdoc cref="Usage"/>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                    public static T Usage<T>(string? message = null) => throw With(2, message);
                
                    /// <summary>Terminates this process and returns the exit code to the operating system.</summary>
                    /// <param name="message">The message to print into the standard output/error, if specified.</param>
                    /// <exception cref="SecurityException">
                    /// The caller does not have sufficient security permission to perform this function.
                    /// </exception>
                    /// <returns>This method does not return. Specified to allow <see keyword="throw"/> expressions.</returns>
                    [ContractAnnotation("=> halt"),
                     DoesNotReturn,
                     SecuritySafeCritical,
                #if NETFRAMEWORK || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
                     SecurityPermission(Demand, Flags = UnmanagedCode),
                #endif
                    ]
                #pragma warning disable CS1573
                    static Exception With(byte exitCode, string? message)
                #pragma warning restore CS1573
                    {
                        if (message is not null)
                            (exitCode is 0 ? Console.Out : Console.Error).WriteLine(message);
                
                        Environment.Exit(exitCode);
                        throw Unreachable;
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Diagnostics.Unforgiving.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #pragma warning disable GlobalUsingsAnalyzer
                
                global using static Emik.Morsels.Unforgiving;
                
                // ReSharper disable once CheckNamespace RedundantUsingDirective.Global
                namespace Emik.Morsels;
                
                /// <summary>Provides a reference for an <c>UnreachableException</c>.</summary>
                #pragma warning disable MA0048
                static partial class Unforgiving
                #pragma warning restore MA0048
                {
                    /// <summary>Gets the <see cref="Exception"/> that a collection cannot be empty.</summary>
                    public static InvalidOperationException CannotBeEmpty { get; } = new("Buffer is empty.");
                
                    /// <summary>Gets the <see cref="Exception"/> that represents unfinished logic.</summary>
                    public static NotImplementedException Todo { get; } = new();
                
                    /// <summary>Gets the <see cref="Exception"/> that represents an unreachable state.</summary>
                    public static UnreachableException Unreachable { get; } = new();
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Diagnostics.Peeks.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #pragma warning disable CS8632, RCS1196
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Provides methods to use callbacks within a statement.</summary>
                #pragma warning disable MA0048
                static partial class Peeks
                #pragma warning restore MA0048
                {
                    /// <summary>An event that is invoked every time <see cref="Write"/> is called.</summary>
                    // ReSharper disable RedundantCast
                    // ReSharper disable once EventNeverSubscribedTo.Global
                    public static event Action<string> OnWrite =
                #if NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2
                        Shout;
                #else
                        (Action<string>)Shout +
                #if NET35
                        (Action<string>)UnityEngine.Debug.Log +
                #endif
                        (Action<string>)Console.WriteLine;
                #endif
                
                #pragma warning disable CS1574
                    /// <summary>
                    /// Invokes <see cref="System.Diagnostics.Debug.WriteLine(string)"/>, and <see cref="Trace.WriteLine(string)"/>.
                    /// </summary>
                    /// <remarks><para>
                    /// This method exists to be able to hook both conditional methods in <see cref="OnWrite"/>,
                    /// and to allow the consumer to be able to remove this method to the same <see cref="OnWrite"/>.
                    /// </para></remarks>
                    /// <param name="message">The value to send a message.</param>
                #pragma warning restore CS1574
                    public static void Shout(string message)
                    {
                        // ReSharper disable once InvocationIsSkipped
                        System.Diagnostics.Debug.WriteLine(message);
                #if !(NETSTANDARD && !NETSTANDARD2_0_OR_GREATER)
                        Trace.WriteLine(message);
                #endif
                    }
                
                    /// <summary>Quick and dirty debugging function, invokes <see cref="OnWrite"/>.</summary>
                    /// <param name="message">The value to send a message.</param>
                    /// <exception cref="InvalidOperationException">
                    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
                    /// every callback has been manually removed as it is always valid by default.
                    /// </exception>
                    public static void Write(this string message) => (OnWrite ?? throw new InvalidOperationException(message))(message);
                
                    /// <summary>Quick and dirty debugging function, invokes <see cref="OnWrite"/>.</summary>
                    /// <typeparam name="T">The type of value.</typeparam>
                    /// <param name="value">The value to stringify.</param>
                    /// <exception cref="InvalidOperationException">
                    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
                    /// every callback has been manually removed as it is always valid by default.
                    /// </exception>
                    // ReSharper disable once InvokeAsExtensionMethod
                    public static void Write<T>(T value) => Write(Stringifier.Stringify(value));
                
                    /// <summary>Quick and dirty debugging function.</summary>
                    /// <typeparam name="T">The type of value.</typeparam>
                    /// <param name="value">The value to stringify and return.</param>
                    /// <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
                    /// <param name="map">The map callback.</param>
                    /// <param name="filter">The filter callback.</param>
                    /// <param name="logger">The logging callback.</param>
                    /// <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
                    /// <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
                    /// <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
                    /// <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
                    /// <exception cref="InvalidOperationException">
                    /// <see cref="OnWrite"/> is <see langword="null"/>, which can only happen if
                    /// every callback has been manually removed as it is always valid by default.
                    /// </exception>
                    /// <returns>The parameter <paramref name="value"/>.</returns>
                    [return: NotNullIfNotNull(nameof(value))]
                    public static T Debug<T>(
                        this T value,
                        bool shouldLogExpression = false,
                        [InstantHandle] Converter<T, object?>? map = null,
                        [InstantHandle] Predicate<T>? filter = null,
                        [InstantHandle] Action<string>? logger = null,
                        [CallerArgumentExpression(nameof(value))] string? expression = null,
                        [CallerFilePath] string? path = null,
                        [CallerLineNumber] int line = default,
                        [CallerMemberName] string? member = null
                    )
                    {
                        // ReSharper disable once InvokeAsExtensionMethod
                        if ((filter ?? (_ => true))(value))
                            (logger ?? Write)(
                                @$"{Stringifier.Stringify((map ?? (x => x))(value))}{(shouldLogExpression ? @$"
                        of {expression}" : "")}
                        at {member} in {Path.GetFileName(path)}:line {line}"
                            );
                
                        return value;
                    }
                
                    /// <summary>Executes an <see cref="Action{T}"/>, and returns the argument.</summary>
                    /// <typeparam name="T">The type of value and action parameter.</typeparam>
                    /// <param name="value">The value to pass into the callback.</param>
                    /// <param name="action">The callback to perform.</param>
                    /// <returns>The parameter <paramref name="value"/>.</returns>
                    public static T Peek<T>(this T value, [InstantHandle] Action<T> action)
                    {
                        action(value);
                
                        return value;
                    }
                
                #if !NETFRAMEWORK
                    /// <summary>Executes a <see langword="delegate"/> pointer, and returns the argument.</summary>
                    /// <typeparam name="T">The type of value and delegate pointer parameter.</typeparam>
                    /// <param name="value">The value to pass into the callback.</param>
                    /// <param name="call">The callback to perform.</param>
                    /// <exception cref="ArgumentNullException">
                    /// The value <paramref name="call"/> points to <see langword="null"/>.
                    /// </exception>
                    /// <returns>The parameter <paramref name="value"/>.</returns>
                    public static unsafe T Peek<T>(this T value, [InstantHandle, NonNegativeValue] delegate*<T, void> call)
                    {
                        (call is null ? throw new ArgumentNullException(nameof(call)) : call)(value);
                
                        return value;
                    }
                
                #endif
                
                    /// <summary>Executes the function, and returns the result.</summary>
                    /// <typeparam name="T">The type of value and input parameter.</typeparam>
                    /// <typeparam name="TResult">The type of output and return value.</typeparam>
                    /// <param name="value">The value to pass into the callback.</param>
                    /// <param name="converter">The callback to perform.</param>
                    /// <returns>The return value of <paramref name="converter"/> after passing in <paramref name="value"/>.</returns>
                    public static TResult Then<T, TResult>(this T value, [InstantHandle] Converter<T, TResult> converter) =>
                        converter(value);
                #if NET20 || NET30 || NETSTANDARD && !NETSTANDARD2_0_OR_GREATER
                    static string Stringify<T>(this T value) => value?.ToString() ?? "";
                #endif
                }
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.Sequencer.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                /// Defines functions for creating sequences.
                module internal Emik.Morsels.Sequencer
                
                /// Determines whether any element in the sequence is equal to the argument.
                let contains i s = s |> Seq.exists ((=) i)
                
                /// Determines whether the coordinates are in range for a 2D array.
                let inBounds y x a =
                    Array2D.base1 a <= y && Array2D.base2 a <= x && y < Array2D.length1 a && x < Array2D.length2 a
                
                /// Determines whether the coordinates are in range for a 3D array.
                let inBounds3 z y x a =
                    z < Array3D.length1 a
                    && y < Array3D.length2 a
                    && x < Array3D.length3 a
                    && a.GetLowerBound 0 <= z
                    && a.GetLowerBound 1 <= y
                    && a.GetLowerBound 2 <= x
                
                /// Determines whether the coordinates are in range for a 4D array.
                let inBounds4 w z y x a =
                    w < Array4D.length1 a
                    && z < Array4D.length2 a
                    && y < Array4D.length3 a
                    && x < Array4D.length4 a
                    && a.GetLowerBound 0 <= w
                    && a.GetLowerBound 1 <= z
                    && a.GetLowerBound 2 <= y
                    && a.GetLowerBound 3 <= x
                
                /// Gets the jagged array from the 2D array.
                let toJagged (a : _[,]) =
                    [| for y in a.GetLowerBound 0 .. a.GetLength 0 - 1 do
                           yield [| for x in a.GetLowerBound 1 .. a.GetLength 1 - 1 -> a[y, x] |] |]
                
                /// Gets the jagged array from the 3D array.
                let toJagged3 (a : _[,,]) =
                    [| for z in a.GetLowerBound 0 .. a.GetLength 0 - 1 do
                           yield
                               [| for y in a.GetLowerBound 1 .. a.GetLength 1 - 1 do
                                      yield [| for x in a.GetLowerBound 2 .. a.GetLength 2 - 1 -> a[z, y, x] |] |] |]
                
                /// Gets the jagged array from the 4D array.
                let toJagged4 (a : _[,,,]) =
                    [| for w in a.GetLowerBound 0 .. a.GetLength 0 - 1 do
                           yield
                               [| for z in a.GetLowerBound 1 .. a.GetLength 1 - 1 do
                                      yield
                                          [| for y in a.GetLowerBound 2 .. a.GetLength 2 - 1 do
                                                 yield
                                                     [| for x in a.GetLowerBound 3 .. a.GetLength 3 - 1 ->
                                                            a[w, z, y, x] |] |] |] |]
                
                /// Gets the sequence from the 2D array.
                let toSeq (a : _[,]) =
                    seq {
                        for y in a.GetLowerBound 0 .. a.GetLength 0 - 1 do
                            for x in a.GetLowerBound 1 .. a.GetLength 1 - 1 do
                                yield a[y, x]
                    }
                
                /// Gets the sequence from the 3D array.
                let toSeq3 (a : _[,,]) =
                    seq {
                        for z in a.GetLowerBound 0 .. a.GetLength 0 - 1 do
                            for y in a.GetLowerBound 1 .. a.GetLength 1 - 1 do
                                for x in a.GetLowerBound 2 .. a.GetLength 2 - 1 do
                                    yield a[z, y, x]
                    }
                
                /// Gets the sequence from the 4D array.
                let toSeq4 (a : _[,,,]) =
                    seq {
                        for w in a.GetLowerBound 0 .. a.GetLength 0 - 1 do
                            for z in a.GetLowerBound 1 .. a.GetLength 1 - 1 do
                                for y in a.GetLowerBound 2 .. a.GetLength 2 - 1 do
                                    for x in a.GetLowerBound 3 .. a.GetLength 3 - 1 do
                                        yield a[w, z, y, x]
                    }
                
                /// Returns the corresponding index if in range for a 2D array, else None.
                let tryGet y x a = if a |> inBounds y x then Some (a[y, x]) else None
                
                /// Returns the corresponding index if in range for a 3D array, else None.
                let tryGet3 z y x a = if a |> inBounds3 z y x then Some (a[z, y, x]) else None
                
                /// Returns the corresponding index if in range for a 4D array, else None.
                let tryGet4 w z y x a = if a |> inBounds4 w z y x then Some (a[w, z, y, x]) else None
                
                /// Removes the item from the list. Only the first occurence of the item will be removed.
                let remove n list =
                    let rec go n list acc =
                        match list with
                        | h :: tl when h = n -> acc @ tl
                        | h :: tl -> h :: acc |> go n tl
                        | [] -> acc
                
                    go n list []
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.FunctionWrappers.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                /// Declares higher-order functions that decorate pre-existing functions.
                module internal Emik.Morsels.FunctionWrappers
                
                open System.Collections.Generic
                open System.Diagnostics
                
                /// Wraps the function around a dictionary such that subsequent
                /// calls to the returned memoized function will retrieve a cached
                /// result if the argument given has been evaluated before.
                /// The function argument is assumed to be deterministic.
                let memoize f =
                    let dict = Dictionary<_, _> ()
                
                    let fn n =
                        match dict.TryGetValue n with
                        | true, v -> v
                        | _ ->
                            let temp = f n
                            dict.Add (n, temp)
                            temp
                
                    fn
                
                /// Discards the result of the function and instead gives the execution time.
                let time f =
                    let watch = Stopwatch ()
                    watch.Start ()
                    let _ = f ()
                    watch.Stop ()
                    watch.Elapsed
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.Courier.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                /// Provides functions to convert tupled functions into curried.
                module internal Emik.Morsels.Courier
                
                /// Converts the 2-tupled function with the curried equivalent.
                let inline curry fn a b = fn (a, b)
                
                /// Converts the 3-tupled function with the curried equivalent.
                let inline curry3 fn a b c = fn (a, b, c)
                
                /// Converts the 4-tupled function with the curried equivalent.
                let inline curry4 fn a b c d = fn (a, b, c, d)
                
                /// Converts the 5-tupled function with the curried equivalent.
                let inline curry5 fn a b c d e = fn (a, b, c, d, e)
                
                /// Converts the 6-tupled function with the curried equivalent.
                let inline curry6 fn a b c d e f = fn (a, b, c, d, e, f)
                
                /// Converts the 7-tupled function with the curried equivalent.
                let inline curry7 fn a b c d e f g = fn (a, b, c, d, e, f, g)
                
                /// Maps the 2 arguments into a tuple.
                let inline tuple a b = (a, b)
                
                /// Maps the 3 arguments into a tuple.
                let inline tuple3 a b c = (a, b, c)
                
                /// Maps the 4 arguments into a tuple.
                let inline tuple4 a b c d = (a, b, c, d)
                
                /// Maps the 5 arguments into a tuple.
                let inline tuple5 a b c d e = (a, b, c, d, e)
                
                /// Maps the 6 arguments into a tuple.
                let inline tuple6 a b c d e f = (a, b, c, d, e, f)
                
                /// Maps the 7 arguments into a tuple.
                let inline tuple7 a b c d e f g = (a, b, c, d, e, f, g)
                
                /// Converts the 2-argument curried function with the tupled equivalent.
                let inline uncurry fn (a, b) = fn a b
                
                /// Converts the 3-argument curried function with the tupled equivalent.
                let inline uncurry3 fn (a, b, c) = fn a b c
                
                /// Converts the 4-argument curried function with the tupled equivalent.
                let inline uncurry4 fn (a, b, c, d) = fn a b c d
                
                /// Converts the 5-argument curried function with the tupled equivalent.
                let inline uncurry5 fn (a, b, c, d, e) = fn a b c d e
                
                /// Converts the 6-argument curried function with the tupled equivalent.
                let inline uncurry6 fn (a, b, c, d, e, f) = fn a b c d e f
                
                /// Converts the 7-argument curried function with the tupled equivalent.
                let inline uncurry7 fn (a, b, c, d, e, f, g) = fn a b c d e f g
                
                /// Invokes the function.
                let inline invoke fn = fn ()
                
                /// Drops the first element from the tuple.
                let inline dropLeft (_, b, c) = (b, c)
                
                /// Drops the second element from the tuple.
                let inline dropMiddle (a, _, c) = (a, c)
                
                /// Drops the third element from the tuple.
                let inline dropRight (a, b, _) = (a, b)
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.FunctionOperators.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                /// Defines operators for functions.
                module internal Emik.Morsels.FunctionOperators
                
                /// Combines two predicate functions together in eager AND form.
                let inline (<&&>) f g = (fun x -> f x && g x)
                
                /// Combines two predicate functions together in eager OR form.
                let inline (<||>) f g = (fun x -> f x || g x)
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.TargetFrameworkAttribute.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                namespace System.Runtime.Versioning
                #if NETFRAMEWORK && !NET40_OR_GREATER
                
                open System
                
                /// Identifies the version of .NET that a particular assembly was compiled against.
                [<AttributeUsage(AttributeTargets.Assembly); Sealed>]
                type private TargetFrameworkAttribute (frameworkName : string) =
                    inherit Attribute ()
                    let mutable _frameworkDisplayName = null
                    let _frameworkName = frameworkName
                
                    /// Gets the display name of the .NET version against which an assembly was built.
                    member this.FrameworkDisplayName
                        with get () = _frameworkName
                        and set (value : string) = _frameworkDisplayName <- value
                
                    /// Gets the name of the .NET version against which a particular assembly was compiled.
                    member this.FrameworkName = _frameworkName
                #endif
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.Randomizer.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                /// Defines operators for functions.
                module internal Emik.Morsels.Randomizer
                
                open System
                
                /// Shuffles the sequence based on the function.
                let shuffle fn xs = xs |> Seq.sortBy (fun _ -> fn Int32.MinValue Int32.MaxValue)
                
                /// Picks the random element from the sequence based on the function.
                #if NETFRAMEWORK && !NET40_OR_GREATER
                let pickRandom fn xs = xs |> shuffle fn |> Seq.nth 0
                #else
                let pickRandom fn xs = xs |> shuffle fn |> Seq.item 0
                #endif
                
                /// Picks the random index from the sequence based on the function.
                let pickIndex fn (xs : _[]) = fn (xs.GetLowerBound 0) xs.Length
                
                /// Picks the random index from the sequence based on the function.
                let pickIndex2 fn (xs : _[,]) =
                    (fn (xs.GetLowerBound 0) (xs.GetLength 0), fn (xs.GetLowerBound 1) (xs.GetLength 1))
                
                /// Picks the random index from the sequence based on the function.
                let pickIndex3 fn (xs : _[,,]) =
                    (fn (xs.GetLowerBound 0) (xs.GetLength 0),
                     fn (xs.GetLowerBound 1) (xs.GetLength 1),
                     fn (xs.GetLowerBound 2) (xs.GetLength 2))
                
                /// Picks the random index from the sequence based on the function.
                let pickIndex4 fn (xs : _[,,,]) =
                    (fn (xs.GetLowerBound 0) (xs.GetLength 0),
                     fn (xs.GetLowerBound 1) (xs.GetLength 1),
                     fn (xs.GetLowerBound 2) (xs.GetLength 2),
                     fn (xs.GetLowerBound 3) (xs.GetLength 3))
                
                /// Makes the boolean generator out of the number generator.
                let toBoolRng fn = (fun _ -> fn 0 2 = 0)
                
                /// Attempts to pick a random element from a sequence based on a function.
                /// Returns None if the sequence is empty.
                #if NETFRAMEWORK && !NET40_OR_GREATER
                let tryPickRandom fn xs = if xs |> Seq.isEmpty then None else Some (xs |> shuffle fn |> Seq.nth 0)
                #else
                let tryPickRandom fn xs = if xs |> Seq.isEmpty then None else Some (xs |> shuffle fn |> Seq.item 0)
                #endif
                """"
            );

        if (lang is ".fs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.FSharp.OptionExtensions.g.fs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                /// Extension methods for option types.
                module internal Emik.Morsels.OptionExtensions
                
                type Microsoft.FSharp.Core.Option<'a> with
                
                    /// Gets the value, or the fallback.
                    member this.getOr f =
                        match this with
                        | Some x -> x
                        | None -> f
                
                    /// Gets the value, or invokes the callback.
                    member this.getOr f =
                        match this with
                        | Some x -> x
                        | None -> f ()
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Pancake.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Provides methods to flatten <see cref="IEnumerable{T}"/> instances.</summary>
                static partial class Pancake
                {
                    /// <summary>Flattens the nested collection.</summary>
                    /// <typeparam name="T">The type of collection.</typeparam>
                    /// <param name="enumerable">The collection to flatten.</param>
                    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Flatten<T>(this IEnumerable<IEnumerable<T>> enumerable) =>
                        enumerable.SelectMany(Enumerable.AsEnumerable);
                
                    /// <summary>Flattens the nested collection.</summary>
                    /// <typeparam name="T">The type of collection.</typeparam>
                    /// <param name="enumerable">The collection to flatten.</param>
                    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Flatten2<T>(this IEnumerable<IEnumerable<IEnumerable<T>>> enumerable) =>
                        enumerable.SelectMany(Enumerable.AsEnumerable).SelectMany(Enumerable.AsEnumerable);
                
                    /// <summary>Flattens the nested collection.</summary>
                    /// <typeparam name="T">The type of collection.</typeparam>
                    /// <param name="enumerable">The collection to flatten.</param>
                    /// <returns>The flattened collection of the parameter <paramref name="enumerable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Flatten3<T>(this IEnumerable<IEnumerable<IEnumerable<IEnumerable<T>>>> enumerable) =>
                        enumerable
                           .SelectMany(Enumerable.AsEnumerable)
                           .SelectMany(Enumerable.AsEnumerable)
                           .SelectMany(Enumerable.AsEnumerable);
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Indexers.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
                static partial class Indexers
                {
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
                    /// <returns>An enumeration from a range's start to end.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<int> For(this Index index) => (index.IsFromEnd ? ~index.Value : index.Value).For();
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
                    /// <returns>An enumeration from a range's start to end.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<int> For(this Range range) =>
                        range.Start.Value is var start &&
                        range.End.Value is var end &&
                        start == end ? Enumerable.Empty<int>() :
                        Math.Abs(start - end) is var len &&
                        start < end ? Enumerable.Range(start, len) : Enumerable.Repeat(start, len).Select((x, i) => x - i - 1);
                
                    /// <summary>Separates the head from the tail of an <see cref="IEnumerable{T}"/>.</summary>
                    /// <remarks><para>
                    /// The tail is not guaranteed to be able to be enumerated over multiple times.
                    /// As such, use a method like <see cref="Collected.ToCollectionLazily{T}"/> if multiple enumerations are needed.
                    /// </para></remarks>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="enumerable">The enumerable to split.</param>
                    /// <param name="head">The first element of the parameter <paramref name="enumerable"/>.</param>
                    /// <param name="tail">The rest of the parameter <paramref name="enumerable"/>.</param>
                    public static void Deconstruct<T>(this IEnumerable<T>? enumerable, out T? head, out IEnumerable<T> tail)
                    {
                        head = default;
                        tail = Enumerable.Empty<T>();
                
                        if (enumerable?.GetEnumerator() is not { } enumerator)
                            return;
                
                        head = enumerator.MoveNext() ? enumerator.Current : default;
                        tail = enumerator.AsEnumerable();
                    }
                
                    /// <summary>Gets a specific item from a collection.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
                    /// <param name="index">The index to get.</param>
                    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
                    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
                    public static T? Nth<T>([InstantHandle] this IEnumerable<T> iterable, Index index) =>
                        index.IsFromEnd ? iterable.NthLast(index.Value) : iterable.Nth(index.Value);
                
                    /// <summary>Gets a range of items from a collection.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get a range of items from.</param>
                    /// <param name="range">The ranges to get.</param>
                    /// <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Nth<T>([InstantHandle] this IEnumerable<T> iterable, Range range)
                    {
                        [LinqTunnel, Pure]
                        static IEnumerable<TT> Sub<TT>([InstantHandle] IEnumerable<TT> iterable, Range range) =>
                            iterable.Skip(range.Start.Value).Take(range.End.Value - range.Start.Value);
                
                        if (!range.Start.IsFromEnd && !range.End.IsFromEnd)
                            return Sub(iterable, range);
                
                        if (iterable.TryCount() is { } count && RangeStart(range, count) is var startRange)
                            return Sub(iterable, startRange);
                
                        var arr = iterable.ToList();
                        var arrRange = RangeStart(range, arr.Count);
                        return Sub(arr, arrRange);
                    }
                
                    /// <summary>Gets an enumeration of an index.</summary>
                    /// <param name="index">The index to count up or down to.</param>
                    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
                    [Pure]
                    public static IEnumerator<int> GetEnumerator(this Index index) => index.For().GetEnumerator();
                
                    /// <summary>Gets an enumeration of a range.</summary>
                    /// <param name="range">The range to iterate over.</param>
                    /// <returns>An enumeration from the range's start to end.</returns>
                    [Pure]
                    public static IEnumerator<int> GetEnumerator(this Range range) => range.For().GetEnumerator();
                
                    [Pure]
                    static Index IndexStart(Index index, int length) => index.IsFromEnd ? length - index.Value - 1 : index;
                
                    [Pure]
                    static Range RangeStart(Range range, int length) =>
                        new(IndexStart(range.Start, length), IndexStart(range.End, length));
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Force.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable InvertIf
                #pragma warning disable IDE0059
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods to force full enumerations.</summary>
                static partial class Force
                {
                    /// <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    public static void Enumerate([InstantHandle] this IEnumerable? iterable)
                    {
                        if (iterable is not null)
                            foreach (var unused in iterable) { }
                    }
                
                    /// <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    public static void Enumerate<T>([InstantHandle] this IEnumerable<T>? iterable)
                    {
                        if (iterable is not null)
                            foreach (var unused in iterable) { }
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Each.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
                static partial class Each
                {
                #if !NET7_0_OR_GREATER
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int For([NonNegativeValue] this int upper, [InstantHandle] Action action)
                    {
                        for (var i = 0; i < upper; i++)
                            action();
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int For([NonNegativeValue] this int upper, [InstantHandle] Action<int> action)
                    {
                        for (var i = 0; i < upper; i++)
                            action(i);
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int For<TExternal>(
                        [NonNegativeValue] this int upper,
                        TExternal external,
                        [InstantHandle] Action<TExternal> action
                    )
                    {
                        for (var i = 0; i < upper; i++)
                            action(external);
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int For<TExternal>(
                        [NonNegativeValue] this int upper,
                        TExternal external,
                        [InstantHandle] Action<int, TExternal> action
                    )
                    {
                        for (var i = 0; i < upper; i++)
                            action(i, external);
                
                        return upper;
                    }
                #endif
                #if !NET20 && !NET30
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> For<T>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        [InstantHandle] Action<T> action
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                
                        foreach (var item in list)
                            action(item);
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> For<T, TExternal>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        TExternal external,
                        [InstantHandle] Action<T, TExternal> action
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                
                        foreach (var item in list)
                            action(item, external);
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> For<T>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        [InstantHandle] Action<T, int> action
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                        var i = 0;
                
                        foreach (var item in list)
                            action(item, checked(i++));
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> For<T, TExternal>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        TExternal external,
                        [InstantHandle] Action<T, int, TExternal> action
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                        var i = 0;
                
                        foreach (var item in list)
                            action(item, checked(i++), external);
                
                        return list;
                    }
                #endif
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> For<TKey, TValue>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        [InstantHandle] Action<TKey, TValue> action
                    )
                    {
                        foreach (var kvp in dictionary)
                            action(kvp.Key, kvp.Value);
                
                        return dictionary;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> For<TKey, TValue, TExternal>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        TExternal external,
                        [InstantHandle] Action<TKey, TValue, TExternal> action
                    )
                    {
                        foreach (var kvp in dictionary)
                            action(kvp.Key, kvp.Value, external);
                
                        return dictionary;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> For<TKey, TValue>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        [InstantHandle] Action<TKey, TValue, int> action
                    )
                    {
                        var i = 0;
                
                        foreach (var kvp in dictionary)
                            action(kvp.Key, kvp.Value, checked(i++));
                
                        return dictionary;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> For<TKey, TValue, TExternal>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        TExternal external,
                        [InstantHandle] Action<TKey, TValue, int, TExternal> action
                    )
                    {
                        var i = 0;
                
                        foreach (var kvp in dictionary)
                            action(kvp.Key, kvp.Value, checked(i++), external);
                
                        return dictionary;
                    }
                #if !NET20 && !NET30
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
                    /// <returns>An enumeration from a range's start to end.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<int> For(this int num) =>
                        Math.Abs(num) is var abs && num < 0
                            ? Enumerable.Repeat(abs, abs).Select((x, i) => x - i - 1)
                            : Enumerable.Range(0, num);
                
                    /// <summary>Gets an enumeration of a number.</summary>
                    /// <param name="num">The index to count up or down to.</param>
                    /// <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
                    [Pure]
                    public static IEnumerator<int> GetEnumerator(this int num) => num.For().GetEnumerator();
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <returns>An <see cref="IEnumerable{T}"/> of <see cref="int"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TExternal> For<TExternal>([NonNegativeValue] this int upper, TExternal external) =>
                        Enumerable.Repeat(external, upper);
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TResult">The type of iterator.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="func">The function for each loop.</param>
                    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> For<TResult>(
                        [NonNegativeValue] this int upper,
                        [InstantHandle] Func<TResult> func
                    ) =>
                        Enumerable.Repeat(func, upper).Select(x => x());
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TResult">The type of iterator.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="func">The function for each loop.</param>
                    /// <returns>All instances that <paramref name="func"/> used in an <see cref="IEnumerable{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<TResult> For<TResult>(
                        [NonNegativeValue] this int upper,
                        [InstantHandle] Converter<int, TResult> func
                    ) =>
                        Enumerable.Repeat(func, upper).Select((x, i) => x(i));
                #endif
                #if NET7_0_OR_GREATER
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T For<T>([NonNegativeValue] this T upper, [InstantHandle] Action action)
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            action();
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T For<T>([NonNegativeValue] this T upper, [InstantHandle] Action<T> action)
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            action(i);
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T For<T, TExternal>(
                        [NonNegativeValue] this T upper,
                        TExternal external,
                        [InstantHandle] Action<TExternal> action
                    )
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            action(external);
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T For<T, TExternal>(
                        [NonNegativeValue] this T upper,
                        TExternal external,
                        [InstantHandle] Action<T, TExternal> action
                    )
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            action(i, external);
                
                        return upper;
                    }
                #endif
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.TryTake.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods to attempt to grab values from enumerables.</summary>
                static partial class TryTake
                {
                    /// <summary>Attempts to determine the number of elements in a sequence without forcing an enumeration.</summary>
                    /// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
                    /// <param name="source">A sequence that contains elements to be counted.</param>
                    /// <remarks><para>
                    /// The method performs a series of type tests, identifying common subtypes whose
                    /// count can be determined without enumerating; this includes <see cref="ICollection{T}"/>,
                    /// <see cref="ICollection"/>, and <see cref="IReadOnlyCollection{T}"/>.
                    /// </para><para>
                    /// The method is typically a constant-time operation, but ultimately this depends on the complexity
                    /// characteristics of the underlying collection implementation.
                    /// </para></remarks>
                    /// <returns>The length of the collection if pre-computed, or <see langword="null"/>.</returns>
                    [Pure]
                    public static int? TryCount<TSource>([NoEnumeration] this IEnumerable<TSource> source) =>
                        source switch
                        {
                            IReadOnlyCollection<TSource> col => col.Count,
                            ICollection<TSource> col => col.Count,
                            ICollection col => col.Count,
                            _ => null,
                        };
                
                    /// <summary>Takes the last item lazily, or a fallback value.</summary>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="fallback">The fallback item.</param>
                    /// <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
                    [Pure]
                    public static T EnumerateOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback)
                    {
                        using var iterator = iterable.GetEnumerator();
                
                        if (!iterator.MoveNext())
                            return fallback;
                
                        var last = iterator.Current;
                
                        while (iterator.MoveNext())
                            last = iterator.Current;
                
                        return last;
                    }
                
                    /// <summary>Takes the first item, or a fallback value.</summary>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="fallback">The fallback item.</param>
                    /// <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
                    [MustUseReturnValue]
                    public static T FirstOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback)
                    {
                        if (iterable is IList<T> list)
                            return list.Count is 0 ? fallback : list[0];
                
                        using var iterator = iterable.GetEnumerator();
                        return iterator.MoveNext() ? iterator.Current : fallback;
                    }
                
                    /// <summary>Takes the last item, or a fallback value.</summary>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="fallback">The fallback item.</param>
                    /// <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
                    [MustUseReturnValue]
                    public static T LastOr<T>([InstantHandle] this IEnumerable<T> iterable, T fallback) =>
                        iterable is IList<T> list // ReSharper disable once UseIndexFromEndExpression
                            ? list.Count is 0 ? fallback : list[list.Count - 1]
                            : iterable.EnumerateOr(fallback);
                
                    /// <summary>Gets a specific item from a collection.</summary>
                    /// <typeparam name="TKey">The key item in the collection.</typeparam>
                    /// <typeparam name="TValue">The value item in the collection.</typeparam>
                    /// <param name="dictionary">The <see cref="IEnumerable{T}"/> to get an item from.</param>
                    /// <param name="key">The key to use to get the value.</param>
                    /// <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
                    [MustUseReturnValue]
                    public static TValue? Nth<TKey, TValue>([InstantHandle] this IDictionary<TKey, TValue> dictionary, TKey key)
                        where TKey : notnull =>
                        dictionary.TryGetValue(key, out var value) ? value : default;
                
                #if !NET20 && !NET30
                    /// <summary>Returns the item, or a fallback.</summary>
                    /// <typeparam name="T">The type of item.</typeparam>
                    /// <param name="self">The item to potentially return.</param>
                    /// <param name="fallback">The fallback item.</param>
                    /// <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
                    [Pure]
                    public static T Or<T>(this T? self, T fallback)
                        where T : class =>
                        self ?? fallback;
                
                    /// <summary>Returns the item, or a fallback.</summary>
                    /// <typeparam name="T">The type of item.</typeparam>
                    /// <param name="self">The item to potentially return.</param>
                    /// <param name="fallback">The fallback item.</param>
                    /// <returns>The parameter <paramref name="self"/>, or <paramref name="fallback"/>.</returns>
                    [Pure]
                    public static T Or<T>(this T? self, T fallback)
                        where T : struct =>
                        self ?? fallback;
                
                    /// <summary>Returns the item, or a fallback.</summary>
                    /// <typeparam name="T">The type of item.</typeparam>
                    /// <param name="self">The item to potentially return.</param>
                    /// <returns>The parameter <paramref name="self"/>, or a new instance.</returns>
                    [Pure]
                    public static T OrNew<T>(this T? self)
                        where T : class, new() =>
                        self ?? new();
                
                    /// <summary>Returns the string, or an empty string.</summary>
                    /// <param name="str">The string to potentially return.</param>
                    /// <returns>The parameter <paramref name="str"/>, or <see cref="string.Empty"/>.</returns>
                    [Pure]
                    public static string OrEmpty(this string? str) => str ?? "";
                
                    /// <summary>Returns the enumeration, or an empty enumeration.</summary>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The enumeration to potentially return.</param>
                    /// <returns>The parameter <paramref name="iterable"/>, or <see cref="Enumerable.Empty{T}"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> OrEmpty<T>([NoEnumeration] this IEnumerable<T>? iterable) =>
                        iterable ?? Enumerable.Empty<T>();
                
                    /// <summary>Gets a specific item from a collection.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
                    /// <param name="index">The index to get.</param>
                    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
                    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
                    public static T? Nth<T>([InstantHandle] this IEnumerable<T> iterable, [NonNegativeValue] int index)
                    {
                        // Runtime check.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        if (index < 0)
                            return default;
                
                        return iterable switch
                        {
                            IList<T> list => index < list.Count ? list[index] : default,
                            IReadOnlyList<T> re => index < re.Count ? re[index] : default,
                            _ => iterable.Skip(index).FirstOrDefault(),
                        };
                    }
                
                    /// <summary>Gets a specific item from a collection.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to get an item from.</param>
                    /// <param name="index">The index to get.</param>
                    /// <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
                    [MustUseReturnValue] // ReSharper disable once ReturnTypeCanBeEnumerable.Global
                    public static T? NthLast<T>([InstantHandle] this IEnumerable<T> iterable, [NonNegativeValue] int index)
                    {
                        // Runtime check.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        if (index < 0)
                            return default;
                
                        return iterable switch
                        {
                            IList<T> list => index < list.Count ? list[list.Count - index - 1] : default,
                            IReadOnlyList<T> list => index < list.Count ? list[list.Count - index - 1] : default,
                            _ when iterable.ToList() is var list => list[list.Count - index - 1],
                            _ => throw Unreachable,
                        };
                    }
                #endif
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Enumerators.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #pragma warning disable MA0048
                /// <summary>Provides methods to convert <see cref="IEnumerator{T}"/> to <see cref="IEnumerable{T}"/>.</summary>
                static partial class EnumeratorToEnumerable
                {
                    /// <summary>Wraps the <see cref="IEnumerator"/> inside a <see cref="IEnumerable{T}"/>.</summary>
                    /// <param name="enumerator">The <see cref="IEnumerator"/> to encapsulate.</param>
                    /// <returns>
                    /// The <see cref="IEnumerator{T}"/> instance that returns the parameter <paramref name="enumerator"/>.
                    /// </returns>
                    [Pure]
                    public static IEnumerator<object?> AsGeneric(this IEnumerator enumerator) => new Enumerator(enumerator);
                
                    /// <summary>Wraps the <see cref="IEnumerator"/> inside a <see cref="IEnumerable{T}"/>.</summary>
                    /// <param name="enumerator">The <see cref="IEnumerator"/> to encapsulate.</param>
                    /// <returns>
                    /// The <see cref="IEnumerator{T}"/> instance that returns the parameter <paramref name="enumerator"/>.
                    /// </returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<object?> AsEnumerable(this IEnumerator enumerator) =>
                #pragma warning disable IDISP004
                        enumerator.AsGeneric().AsEnumerable();
                #pragma warning restore IDISP004
                
                    /// <summary>Wraps the <see cref="IEnumerator{T}"/> inside a <see cref="IEnumerable{T}"/>.</summary>
                    /// <typeparam name="T">The type of item to enumerate.</typeparam>
                    /// <param name="enumerator">The <see cref="IEnumerator{T}"/> to encapsulate.</param>
                    /// <returns>
                    /// The <see cref="IEnumerator{T}"/> instance that returns the parameter <paramref name="enumerator"/>.
                    /// </returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> AsEnumerable<T>(this IEnumerator<T> enumerator) => new Enumerable<T>(enumerator);
                
                    /// <summary>Wraps an <see cref="IEnumerator{T}"/> and exposes it from an <see cref="IEnumerable{T}"/> context.</summary>
                    /// <typeparam name="T">The type of item to enumerate.</typeparam>
                    sealed partial class Enumerable<T> : IEnumerable<T>
                    {
                        [ProvidesContext]
                        readonly IEnumerator<T> _enumerator;
                
                        /// <summary>Initializes a new instance of the <see cref="Enumerable{T}"/> class.</summary>
                        /// <param name="e">The <see cref="IEnumerator{T}"/> to encapsulate.</param>
                        public Enumerable(IEnumerator<T> e) => _enumerator = e;
                
                        /// <inheritdoc />
                        [CollectionAccess(CollectionAccessType.Read), Pure]
                        public IEnumerator<T> GetEnumerator() => _enumerator;
                
                        /// <inheritdoc />
                        [CollectionAccess(CollectionAccessType.Read), Pure]
                        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                
                        /// <summary>Finalizes an instance of the <see cref="Enumerable{T}"/> class.</summary>
                #pragma warning disable MA0055, IDISP007, IDISP023
                        ~Enumerable() => _enumerator.Dispose();
                #pragma warning restore MA0055, IDISP007, IDISP023
                    }
                
                    /// <summary>Wraps an <see cref="IEnumerator{T}"/> and exposes it from an <see cref="IEnumerable{T}"/> context.</summary>
                    sealed partial class Enumerator : IEnumerator<object?>
                    {
                        [ProvidesContext]
                        readonly IEnumerator _enumerator;
                
                        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> class.</summary>
                        /// <param name="e">The <see cref="IEnumerator"/> to encapsulate.</param>
                        public Enumerator(IEnumerator e) => _enumerator = e;
                
                        /// <inheritdoc cref="IEnumerator{T}.Current" />
                        [Pure]
                        public object? Current => _enumerator.Current;
                
                        /// <inheritdoc />
                        public void Reset() => _enumerator.Reset();
                
                        /// <inheritdoc />
                        public void Dispose() { }
                
                        /// <inheritdoc />
                        public bool MoveNext() => _enumerator.MoveNext();
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.NegatedEnumerable.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #pragma warning disable CS1574, CS1580
                /// <summary>Extension methods that negate functions from <see cref="Enumerable"/>.</summary>
                static partial class NegatedEnumerable
                {
                    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
                    /// <remarks><para>
                    /// Filters out unique elements within an <see cref="Enumerable{T}"/>.
                    /// Each duplicate appears exactly once within the returned value.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
                    /// <param name="source">The source to filter.</param>
                    /// <param name="comparer">The comparer to assess distinctiveness.</param>
                    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> DistinctDuplicates<T>(
                        this IEnumerable<T> source,
                        IEqualityComparer<T>? comparer = null
                    ) =>
                        source.GroupDuplicates(comparer).Select(x => x.Key);
                
                    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
                    /// <remarks><para>
                    /// Filters out unique elements within an <see cref="Enumerable{T}"/>.
                    /// Each duplicate appears two or more times within the returned value.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
                    /// <param name="source">The source to filter.</param>
                    /// <param name="comparer">The comparer to assess distinctiveness.</param>
                    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Duplicates<T>(this IEnumerable<T> source, IEqualityComparer<T>? comparer = null) =>
                        source.GroupDuplicates(comparer).SelectMany(x => x);
                
                    /// <summary>Negated <see cref="Enumerable.Distinct{T}(IEnumerable{T}, IEqualityComparer{T})"/>.</summary>
                    /// <remarks><para>Filters out unique elements within an <see cref="Enumerable{T}"/>.</para></remarks>
                    /// <typeparam name="T">The type of <see cref="IEnumerable{T}"/> and <see cref="IEqualityComparer{T}"/>.</typeparam>
                    /// <param name="source">The source to filter.</param>
                    /// <param name="comparer">The comparer to assess distinctiveness.</param>
                    /// <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
                    public static IEnumerable<IGrouping<T, T>> GroupDuplicates<T>(
                        this IEnumerable<T> source,
                        IEqualityComparer<T>? comparer = null
                    ) =>
                        source.GroupBy(x => x, comparer).Where(x => x.Skip(1).Any());
                
                    /// <summary>Negated <see cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
                    /// <returns>
                    /// An <see cref="IEnumerable{T}" /> that contains the elements from the input sequence starting at
                    /// the first element in the linear series that does pass the test specified by the predicate.
                    /// </returns>
                    /// <inheritdoc cref="Enumerable.SkipWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> SkipUntil<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
                        source.SkipWhile(Not1(predicate));
                
                    /// <summary>Negated <see cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
                    /// <returns>
                    /// An <see cref="IEnumerable{T}" /> that contains the elements from the input
                    /// sequence that occur before the element at which the test no longer fails.
                    /// </returns>
                    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> TakeUntil<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
                        source.TakeWhile(Not1(predicate));
                
                    /// <summary>Negated <see cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
                    /// <returns>
                    /// An <see cref="IEnumerable{T}" /> that contains elements from
                    /// the input sequence that do not satisfy the condition.
                    /// </returns>
                    /// <inheritdoc cref="Enumerable.TakeWhile{T}(IEnumerable{T}, Func{T, int, bool})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> TakeUntil<T>(
                        [NoEnumeration] this IEnumerable<T> source,
                        Func<T, int, bool> predicate
                    ) =>
                        source.TakeWhile(Not2(predicate));
                
                    /// <summary>Negated <see cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>.</summary>
                    /// <returns>
                    /// An <see cref="IEnumerable{T}" /> that contains elements from
                    /// the input sequence that do not satisfy the condition.
                    /// </returns>
                    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, bool})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Omit<T>([NoEnumeration] this IEnumerable<T> source, Func<T, bool> predicate) =>
                        source.Where(Not1(predicate));
                
                    /// <summary>Negated <see cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, int, bool})"/>.</summary>
                    /// <returns>
                    /// An <see cref="IEnumerable{T}" /> that contains elements from
                    /// the input sequence that do not satisfy the condition.
                    /// </returns>
                    /// <inheritdoc cref="Enumerable.Where{T}(IEnumerable{T}, Func{T, int, bool})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Omit<T>(
                        [NoEnumeration] this IEnumerable<T> source,
                        Func<T, int, bool> predicate
                    ) =>
                        source.Where(Not2(predicate));
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.EachLazy.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
                static partial class EachLazy
                {
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Lazily<T>([NoEnumeration] this IEnumerable<T> iterable, Action<T> action) =>
                        new Enumerable<T, object?>(iterable, null, action);
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Lazily<T, TExternal>(
                        [NoEnumeration] this IEnumerable<T> iterable,
                        TExternal external,
                        Action<T, TExternal> action
                    ) =>
                        new Enumerable<T, TExternal>(iterable, external, action);
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Lazily<T>([NoEnumeration] this IEnumerable<T> iterable, Action<T, int> action) =>
                        new Enumerable<T, object?>(iterable, null, action);
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> Lazily<T, TExternal>(
                        [NoEnumeration] this IEnumerable<T> iterable,
                        TExternal external,
                        Action<T, int, TExternal> action
                    ) =>
                        new Enumerable<T, TExternal>(iterable, external, action);
                }
                
                /// <summary>
                /// Defines an <see cref="IEnumerable{T}"/> with a <see cref="Delegate"/> that is invoked on iteration.
                /// </summary>
                /// <typeparam name="T">The type of item in the <see cref="IEnumerable{T}"/>.</typeparam>
                /// <typeparam name="TExternal">The context element to pass into the <see cref="Delegate"/>.</typeparam>
                #pragma warning disable MA0048
                sealed partial class Enumerable<T, TExternal> : IEnumerable<T>
                #pragma warning restore MA0048
                {
                    readonly Delegate _action;
                
                    readonly IEnumerable<T> _enumerable;
                
                    readonly TExternal _external;
                
                    /// <inheritdoc />
                    public Enumerable(IEnumerable<T> enumerable, TExternal external, Action<T> action)
                        : this(enumerable, external, (Delegate)action) { }
                
                    /// <inheritdoc />
                    public Enumerable(IEnumerable<T> enumerable, TExternal external, Action<T, int> action)
                        : this(enumerable, external, (Delegate)action) { }
                
                    /// <inheritdoc />
                    public Enumerable(IEnumerable<T> enumerable, TExternal external, Action<T, TExternal> action)
                        : this(enumerable, external, (Delegate)action) { }
                
                    /// <inheritdoc />
                    public Enumerable(IEnumerable<T> enumerable, TExternal external, Action<T, int, TExternal> action)
                        : this(enumerable, external, (Delegate)action) { }
                
                    /// <summary>Initializes a new instance of the <see cref="Enumerable{T, TExternal}"/> class.</summary>
                    /// <param name="enumerable">
                    /// The <see cref="IEnumerable{T}"/> to create an <see cref="IEnumerator{T}"/> from.
                    /// </param>
                    /// <param name="external">The context element.</param>
                    /// <param name="action">The <see cref="Delegate"/> to invoke on iteration.</param>
                    Enumerable(IEnumerable<T> enumerable, TExternal external, Delegate action)
                    {
                        _enumerable = enumerable;
                        _external = external;
                        _action = action;
                    }
                
                    /// <inheritdoc />
                    [CollectionAccess(CollectionAccessType.Read), Pure]
                    public IEnumerator<T> GetEnumerator() => new Enumerator(_enumerable.GetEnumerator(), _external, _action);
                
                    /// <inheritdoc />
                    [CollectionAccess(CollectionAccessType.Read), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                
                    sealed class Enumerator : IEnumerator<T>
                    {
                        readonly Delegate _action;
                
                        readonly IEnumerator<T> _enumerator;
                
                        readonly TExternal _external;
                
                        int _index;
                
                        public Enumerator(IEnumerator<T> enumerator, TExternal external, Delegate action)
                        {
                            _enumerator = enumerator;
                            _external = external;
                            _action = action;
                        }
                
                        /// <inheritdoc />
                        public T Current => _enumerator.Current;
                
                        /// <inheritdoc />
                        object? IEnumerator.Current => ((IEnumerator)_enumerator).Current;
                
                        /// <inheritdoc />
                        public void Reset()
                        {
                            _enumerator.Reset();
                            _index = 0;
                        }
                
                        /// <inheritdoc />
                #pragma warning disable IDISP007
                        public void Dispose() => _enumerator.Dispose();
                #pragma warning restore IDISP007
                
                        /// <inheritdoc />
                        public bool MoveNext()
                        {
                            if (!_enumerator.MoveNext())
                                return false;
                
                            var current = Current;
                
                            switch (_action)
                            {
                                case Action<T> action:
                                    action(current);
                                    break;
                                case Action<T, int> action:
                                    action(current, _index);
                                    break;
                                case Action<T, TExternal> action:
                                    action(current, _external);
                                    break;
                                case Action<T, int, TExternal> action:
                                    action(current, _index, _external);
                                    break;
                            }
                
                            _index++;
                            return true;
                        }
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Collected.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
                static partial class Collected
                {
                    /// <summary>Returns a fallback enumeration if the collection given is null or empty.</summary>
                    /// <typeparam name="T">The type of item within the enumeration.</typeparam>
                    /// <param name="iterable">The potentially empty collection.</param>
                    /// <param name="fallback">The fallback value.</param>
                    /// <returns>The parameter <paramref name="iterable"/> if non-empty, or <paramref name="fallback"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<T> DefaultIfEmpty<T>(this IEnumerable<T>? iterable, IEnumerable<T> fallback)
                    {
                        using var a = iterable?.GetEnumerator();
                
                        if (a?.MoveNext() ?? false)
                            do
                                yield return a.Current;
                            while (a.MoveNext());
                        else
                            foreach (var b in fallback)
                                yield return b;
                    }
                
                    /// <summary>Upcasts or creates an <see cref="ICollection{T}"/>.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
                    /// <returns>Itself as <see cref="ICollection{T}"/>, or a collected <see cref="Array"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static ICollection<T>? ToCollectionLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
                        iterable is null ? null : iterable as ICollection<T> ?? iterable.ToList();
                
                    /// <summary>Upcasts or creates an <see cref="IList{T}"/>.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to upcast or encapsulate.</param>
                    /// <returns>Itself as <see cref="IList{T}"/>, or a collected <see cref="Array"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static IList<T>? ToListLazily<T>([InstantHandle] this IEnumerable<T>? iterable) =>
                        iterable is null ? null : iterable as IList<T> ?? iterable.ToList();
                
                    /// <summary>Attempts to create a list from an <see cref="IEnumerable{T}"/>.</summary>
                    /// <typeparam name="T">The type of item in the <see cref="IEnumerable{T}"/>.</typeparam>
                    /// <typeparam name="TList">The destination type.</typeparam>
                    /// <param name="iterable">The <see cref="IEnumerable{T}"/> to convert.</param>
                    /// <param name="converter">The <see cref="IList{T}"/> to convert it to.</param>
                    /// <returns>
                    /// A <typeparamref name="TList"/> from <paramref name="converter"/>, as long as every element returned
                    /// is not <paramref langword="null"/>, otherwise <paramref langword="default"/>.
                    /// </returns>
                    [MustUseReturnValue]
                    public static TList? Collect<T, TList>(
                        [InstantHandle] this IEnumerable<T?> iterable,
                        [InstantHandle] Converter<IEnumerable<T>, TList> converter
                    )
                        where TList : IList<T> => // ReSharper disable once NullableWarningSuppressionIsUsed
                #pragma warning disable CS8620 // Checked later, technically could cause problems, but most factory methods are fine.
                        (TList?)converter(iterable);
                #pragma warning restore CS8620
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.PowerSetFactories.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods to create power sets.</summary>
                static partial class PowerSetFactories
                {
                    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<IEnumerable<object>> PowerSet(this ICollection collection) =>
                        collection.Cast<object>().PowerSetInner(collection.Count);
                
                    /// <summary>Creates a power set from a collection.</summary>
                    /// <remarks><para>
                    /// The power set is defined as the set of all subsets, including the empty set and the set itself.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of item in the set.</typeparam>
                    /// <exception cref="ArgumentOutOfRangeException">
                    /// The argument <paramref name="collection"/> has 32 or more elements.
                    /// </exception>
                    /// <param name="collection">The set to create a power set.</param>
                    /// <returns>The power set of the parameter <paramref name="collection"/>.</returns>
                    [LinqTunnel, Pure]
                    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this ICollection<T> collection) =>
                        collection.PowerSetInner(collection.Count);
                
                    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this IReadOnlyCollection<T> collection) =>
                        collection.PowerSetInner(collection.Count);
                
                    /// <inheritdoc cref="PowerSet{T}(ICollection{T})"/>
                    [LinqTunnel, Pure]
                    public static IEnumerable<IEnumerable<T>> PowerSet<T>(this T[] collection) =>
                        ((ICollection<T>)collection).PowerSet();
                
                    [LinqTunnel, Pure]
                    static IEnumerable<IEnumerable<T>> PowerSetInner<T>(this IEnumerable<T> iterable, int count) =>
                        count < 32
                            ? Enumerable.Range(0, 1 << count).Select(mask => iterable.Where((_, j) => (1 << j & mask) is not 0))
                            : throw new ArgumentOutOfRangeException(nameof(count), count, $"Cannot exceed bits in {nameof(Int32)}.");
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.Attachments.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace EmptyNamespace
                namespace Emik.Morsels;
                #if !NET20 && !NET30 && !NET471_OR_GREATER && !NETSTANDARD1_6_OR_GREATER && !NETCOREAPP
                /// <summary>Adds support for Append and Prepend in lower frameworks.</summary>
                static partial class Attachments
                {
                    /// <summary>Appends a value to the end of the sequence.</summary>
                    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
                    /// <param name="source">A sequence of values.</param>
                    /// <param name="element">The value to append to <paramref name="source"/>.</param>
                    /// <returns>A new sequence that ends with <paramref name="element"/>.</returns>
                    public static IEnumerable<TSource> Append<TSource>(this IEnumerable<TSource> source, TSource element) =>
                        source.Concat(element.Yield());
                
                    /// <summary>Prepends a value to the end of the sequence.</summary>
                    /// <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
                    /// <param name="source">A sequence of values.</param>
                    /// <param name="element">The value to prepend to <paramref name="source"/>.</param>
                    /// <returns>A new sequence that starts with <paramref name="element"/>.</returns>
                    public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element) =>
                        element.Yield().Concat(source);
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Linq.EachWithControlFlow.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Similar to <see cref="Each"/>, but with control flow, using <see cref="ControlFlow"/>.</summary>
                // ReSharper disable LoopCanBePartlyConvertedToQuery
                static partial class EachWithControlFlow
                {
                #if !NET7_0_OR_GREATER
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int BreakableFor([NonNegativeValue] this int upper, [InstantHandle] Func<ControlFlow> func)
                    {
                        for (var i = 0; i < upper; i++)
                            if (func() is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int BreakableFor([NonNegativeValue] this int upper, [InstantHandle] Func<int, ControlFlow> func)
                    {
                        for (var i = 0; i < upper; i++)
                            if (func(i) is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int BreakableFor<TExternal>(
                        [NonNegativeValue] this int upper,
                        TExternal external,
                        [InstantHandle] Func<TExternal, ControlFlow> func
                    )
                    {
                        for (var i = 0; i < upper; i++)
                            if (func(external) is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static int BreakableFor<TExternal>(
                        [NonNegativeValue] this int upper,
                        TExternal external,
                        [InstantHandle] Func<int, TExternal, ControlFlow> func
                    )
                    {
                        for (var i = 0; i < upper; i++)
                            if (func(i, external) is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                #endif
                #if !NET20 && !NET30
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> BreakableFor<T>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        [InstantHandle] Func<T, ControlFlow> func
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                
                        foreach (var item in list)
                            if (func(item) is ControlFlow.Break)
                                break;
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> BreakableFor<T, TExternal>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        TExternal external,
                        [InstantHandle] Func<T, TExternal, ControlFlow> func
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                
                        foreach (var item in list)
                            if (func(item, external) is ControlFlow.Break)
                                break;
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> BreakableFor<T>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        [InstantHandle] Func<T, int, ControlFlow> func
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                        var i = 0;
                
                        foreach (var item in list)
                            if (func(item, checked(i++)) is ControlFlow.Break)
                                break;
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="T">The type of iterator.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="iterable">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
                    /// <returns>The parameter <paramref name="iterable"/>.</returns>
                    public static ICollection<T> BreakableFor<T, TExternal>(
                        [InstantHandle] this IEnumerable<T> iterable,
                        TExternal external,
                        [InstantHandle] Func<T, int, TExternal, ControlFlow> func
                    )
                    {
                        var list = iterable.ToCollectionLazily();
                        var i = 0;
                
                        foreach (var item in list)
                            if (func(item, checked(i++), external) is ControlFlow.Break)
                                break;
                
                        return list;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        [InstantHandle] Func<TKey, TValue, ControlFlow> func
                    )
                    {
                        foreach (var kvp in dictionary)
                            if (func(kvp.Key, kvp.Value) is ControlFlow.Break)
                                break;
                
                        return dictionary;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue, TExternal>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        TExternal external,
                        [InstantHandle] Func<TKey, TValue, TExternal, ControlFlow> func
                    )
                    {
                        foreach (var kvp in dictionary)
                            if (func(kvp.Key, kvp.Value, external) is ControlFlow.Break)
                                break;
                
                        return dictionary;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        [InstantHandle] Func<TKey, TValue, int, ControlFlow> func
                    )
                    {
                        var i = 0;
                
                        foreach (var kvp in dictionary)
                            if (func(kvp.Key, kvp.Value, checked(i++)) is ControlFlow.Break)
                                break;
                
                        return dictionary;
                    }
                
                    /// <summary>
                    /// The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
                    /// instance of the type that implements the <see cref="IEnumerable"/> or <see cref="IEnumerable{T}"/> interface.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
                    /// <typeparam name="TKey">The type of key in the dictionary.</typeparam>
                    /// <typeparam name="TValue">The type of value in the dictionary.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="dictionary">The collection of items to go through one-by-one.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
                    /// <returns>The parameter <paramref name="dictionary"/>.</returns>
                    public static IDictionary<TKey, TValue> BreakableFor<TKey, TValue, TExternal>(
                        [InstantHandle] this IDictionary<TKey, TValue> dictionary,
                        TExternal external,
                        [InstantHandle] Func<TKey, TValue, int, TExternal, ControlFlow> func
                    )
                    {
                        var i = 0;
                
                        foreach (var kvp in dictionary)
                            if (func(kvp.Key, kvp.Value, checked(i++), external) is ControlFlow.Break)
                                break;
                
                        return dictionary;
                    }
                #endif
                #if NET7_0_OR_GREATER
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T BreakableFor<T>([NonNegativeValue] this T upper, [InstantHandle] Func<ControlFlow> func)
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            if (func() is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T BreakableFor<T>([NonNegativeValue] this T upper, [InstantHandle] Func<T, ControlFlow> func)
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            if (func(i) is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T BreakableFor<T, TExternal>(
                        [NonNegativeValue] this T upper,
                        TExternal external,
                        [InstantHandle] Func<TExternal, ControlFlow> func
                    )
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            if (func(external) is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                
                    /// <summary>
                    /// The <see langword="for"/> statement executes a statement or a block of statements while a specified
                    /// Boolean expression evaluates to <see langword="true"/>.
                    /// </summary>
                    /// <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
                    /// <typeparam name="T">The type of number for the loop.</typeparam>
                    /// <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
                    /// <param name="upper">The length to reach to in the for loop.</param>
                    /// <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
                    /// <param name="func">The action for each loop.</param>
                    /// <returns>The parameter <paramref name="upper"/>.</returns>
                    [NonNegativeValue]
                    public static T BreakableFor<T, TExternal>(
                        [NonNegativeValue] this T upper,
                        TExternal external,
                        [InstantHandle] Func<T, TExternal, ControlFlow> func
                    )
                        where T : IComparisonOperators<T, T, bool>, INumberBase<T>
                    {
                        for (var i = T.Zero; i < upper; i++)
                            if (func(i, external) is ControlFlow.Break)
                                break;
                
                        return upper;
                    }
                #endif
                }
                
                /// <summary>Determines control flow for loops in <see cref="Each"/>.</summary>
                #pragma warning disable MA0048
                enum ControlFlow
                #pragma warning restore MA0048
                {
                    /// <summary>The value indicating that the loop should continue.</summary>
                    Continue,
                
                    /// <summary>The value indicating that the loop should break.</summary>
                    Break,
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Buffers.SplitSpan.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #if (NET45_OR_GREATER || NETSTANDARD1_1_OR_GREATER || NETCOREAPP2_1_OR_GREATER) && !NO_SYSTEM_MEMORY
                /// <summary>Methods to split spans into multiple spans.</summary>
                #pragma warning disable MA0048
                static partial class SplitFactory
                #pragma warning restore MA0048
                {
                    /// <inheritdoc cref="SplitLines(ReadOnlySpan{char})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitLines(this string s) => s.AsSpan().SplitLines();
                
                    /// <summary>Splits a span by line breaks.</summary>
                    /// <remarks><para>Line breaks are considered any character in <see cref="Whitespaces.Breaking"/>.</para></remarks>
                    /// <param name="s">The span to split.</param>
                    /// <returns>The enumerable object that references the parameter <paramref name="s"/>.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitLines(this ReadOnlySpan<char> s) => new(s, Whitespaces.Breaking.AsSpan());
                
                    /// <inheritdoc cref="SplitLines(ReadOnlySpan{char})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitLines(this Span<char> s) => ((ReadOnlySpan<char>)s).SplitLines();
                
                    /// <inheritdoc cref="SplitTerminated{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitTerminated(
                        this string s,
                        string sep,
                        IEqualityComparer<char>? comparer = null
                    ) =>
                        s.AsSpan().SplitTerminated(sep.AsSpan(), comparer);
                
                    /// <inheritdoc cref="SplitWhitespace(ReadOnlySpan{char})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitWhitespace(this string s) => s.AsSpan().SplitWhitespace();
                
                    /// <summary>Splits a span by whitespace.</summary>
                    /// <remarks><para>Whitespace is considered any character in <see cref="Whitespaces.Unicode"/>.</para></remarks>
                    /// <param name="s">The span to split.</param>
                    /// <returns>The enumerable object that references the parameter <paramref name="s"/>.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitWhitespace(this ReadOnlySpan<char> s) => new(s, Whitespaces.Unicode.AsSpan());
                
                    /// <inheritdoc cref="SplitWhitespace(ReadOnlySpan{char})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<char> SplitWhitespace(this Span<char> s) => ((ReadOnlySpan<char>)s).SplitWhitespace();
                
                    /// <summary>Splits a span by the specified separator.</summary>
                    /// <typeparam name="T">The type of element from the span.</typeparam>
                    /// <param name="s">The span to split.</param>
                    /// <param name="sep">The separator.</param>
                    /// <param name="comparer">The comparer to use.</param>
                    /// <returns>The enumerable object that references the parameter <paramref name="s"/>.</returns>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<T> SplitTerminated<T>(
                        this ReadOnlySpan<T> s,
                        ReadOnlySpan<T> sep,
                        Func<T, T, bool>? comparer = null
                    ) =>
                        new(s, sep, comparer);
                
                    /// <inheritdoc cref="SplitTerminated{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<T> SplitTerminated<T>(
                        this ReadOnlySpan<T> s,
                        ReadOnlySpan<T> sep,
                        IEqualityComparer<T>? comparer
                    ) =>
                        s.SplitTerminated(sep, comparer is null ? null : comparer.Equals);
                
                    /// <inheritdoc cref="SplitTerminated{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<T> SplitTerminated<T>(
                        this Span<T> s,
                        ReadOnlySpan<T> sep,
                        Func<T, T, bool>? comparer = null
                    ) =>
                        ((ReadOnlySpan<T>)s).SplitTerminated(sep, comparer);
                
                    /// <inheritdoc cref="SplitTerminated{T}(ReadOnlySpan{T}, ReadOnlySpan{T}, IEqualityComparer{T})"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public static SplitSpan<T> SplitTerminated<T>(
                        this Span<T> s,
                        ReadOnlySpan<T> sep,
                        IEqualityComparer<T>? comparer
                    ) =>
                        ((ReadOnlySpan<T>)s).SplitTerminated(sep, comparer is null ? null : comparer.Equals);
                }
                #endif
                
                /// <summary>Represents a split entry.</summary>
                /// <typeparam name="T">The type of element from the span.</typeparam>
                [StructLayout(LayoutKind.Auto)]
                readonly
                #if !NO_REF_STRUCTS
                    ref
                #endif
                    partial struct SplitSpan<T>
                #if UNMANAGED_SPAN
                    where T : unmanaged
                #endif
                {
                    /// <summary>Initializes a new instance of the <see cref="SplitSpan{T}"/> struct.</summary>
                    /// <param name="span">The line to split.</param>
                    /// <param name="separator">The characters for separation.</param>
                    /// <param name="comparer">The comparison to determine when to split.</param>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    public SplitSpan(
                        ReadOnlySpan<T> span,
                        ReadOnlySpan<T> separator,
                        Func<T, T, bool>? comparer = null
                    )
                    {
                        Comparer = comparer ?? EqualityComparer<T>.Default.Equals;
                        Span = span;
                        Separator = separator;
                    }
                
                    /// <summary>Gets the comparer that determines when to split.</summary>
                    public Func<T, T, bool> Comparer { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
                
                    /// <summary>Gets the line.</summary>
                    public ReadOnlySpan<T> Span { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
                
                    /// <summary>Gets the separator.</summary>
                    public ReadOnlySpan<T> Separator { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; }
                
                    /// <inheritdoc cref="IEnumerable{T}.GetEnumerator"/>
                    [MethodImpl(MethodImplOptions.AggressiveInlining), Pure]
                    public Enumerator GetEnumerator() => new(this);
                
                    /// <summary>Represents the enumeration object that views <see cref="SplitSpan{T}"/>.</summary>
                    [StructLayout(LayoutKind.Auto)]
                    public
                #if !NO_REF_STRUCTS
                        ref
                #endif
                        partial struct Enumerator
                    {
                        readonly SplitSpan<T> _split;
                
                        [ValueRange(-1, int.MaxValue)]
                        int _end = -1;
                
                        /// <summary>Initializes a new instance of the <see cref="Enumerator"/> struct.</summary>
                        /// <param name="split">Tne entry to enumerate.</param>
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public Enumerator(SplitSpan<T> split) => _split = split;
                
                        /// <inheritdoc cref="IEnumerator{T}.Current"/>
                        public ReadOnlySpan<T> Current { [MethodImpl(MethodImplOptions.AggressiveInlining), Pure] get; private set; }
                
                        /// <inheritdoc cref="IEnumerator.Reset"/>
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public void Reset() => _end = -1;
                
                        /// <inheritdoc cref="IEnumerator.MoveNext"/>
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        public bool MoveNext()
                        {
                            while (true)
                            {
                                var start = ++_end;
                                Terminate();
                
                                if (_end > _split.Span.Length)
                                    return false;
                
                                Current = _split.Span[start.._end];
                
                                if (Current.IsEmpty)
                                    continue;
                
                                return true;
                            }
                        }
                
                        [MethodImpl(MethodImplOptions.AggressiveInlining)]
                        void Terminate()
                        {
                            for (; _end < _split.Span.Length; _end++)
                                foreach (var t in _split.Separator)
                                    if (_split.Comparer(_split.Span[_end], t))
                                        return;
                        }
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Buffers.Span.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Defines methods for callbacks with spans. Methods here do not clear the allocated buffer.</summary>
                /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                static partial class Span
                {
                    /// <summary>A callback for a span.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    public delegate void SpanAction<TSpan>(Span<TSpan> span)
                        where TSpan : unmanaged;
                
                    /// <summary>A callback for a span with a reference parameter.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <param name="param">The parameter.</param>
                    public delegate void SpanAction<TSpan, in TParam>(Span<TSpan> span, TParam param)
                        where TSpan : unmanaged;
                
                    /// <summary>A callback for a span with a reference parameter that is also a span, but immutable.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <param name="param">The span parameter.</param>
                    public delegate void SpanActionReadOnlySpan<TSpan, TParam>(Span<TSpan> span, ReadOnlySpan<TParam> param)
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        where TSpan : unmanaged;
                
                    /// <summary>A callback for a span with a reference parameter that is also a span.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TParam">The inner type of the span parameter.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <param name="param">The span parameter.</param>
                    public delegate void SpanActionSpan<TSpan, TParam>(Span<TSpan> span, Span<TParam> param)
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        where TSpan : unmanaged;
                
                    /// <summary>A callback for a span with a return value.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <returns>The returned value of this delegate.</returns>
                    public delegate TResult SpanFunc<TSpan, out TResult>(Span<TSpan> span)
                        where TSpan : unmanaged;
                
                    /// <summary>A callback for a span with a reference parameter with a return value.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <param name="param">The parameter.</param>
                    /// <returns>The returned value of this delegate.</returns>
                    public delegate TResult SpanFunc<TSpan, in TParam, out TResult>(Span<TSpan> span, TParam param)
                        where TSpan : unmanaged;
                
                    /// <summary>A callback for a span with a reference parameter that is also a span, with a return value.</summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <param name="param">The span parameter.</param>
                    /// <returns>The returned value of this delegate.</returns>
                    public delegate TResult SpanFuncReadOnlySpan<TSpan, TParam, out TResult>(
                        Span<TSpan> span,
                        ReadOnlySpan<TParam> param
                    )
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        where TSpan : unmanaged;
                
                    /// <summary>
                    /// A callback for a span with a reference parameter that is also a span, but immutable, with a return value.
                    /// </summary>
                    /// <typeparam name="TSpan">The inner type of the span.</typeparam>
                    /// <typeparam name="TParam">The inner type of the immutable span parameter.</typeparam>
                    /// <typeparam name="TResult">The resulting type.</typeparam>
                    /// <param name="span">The allocated span.</param>
                    /// <param name="param">The span parameter.</param>
                    /// <returns>The returned value of this delegate.</returns>
                    public delegate TResult SpanFuncSpan<TSpan, TParam, out TResult>(Span<TSpan> span, Span<TParam> param)
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        where TSpan : unmanaged;
                
                    /// <summary>The maximum size for the number of bytes a stack allocation will occur in this class.</summary>
                    /// <remarks><para>
                    /// Stack allocating arrays is an incredibly powerful tool that gets rid of a lot of the overhead that comes from
                    /// instantiating arrays normally. Notably, that all classes (such as <see cref="Array"/> or <see cref="List{T}"/>)
                    /// are heap allocated, and moreover are garbage collected. This can put a strain in methods that are called often.
                    /// </para><para>
                    /// However, there isn't as much stack memory available as there is heap, which can cause a DoS (Denial of Service)
                    /// vulnerability if you aren't careful. The methods in <c>Span</c> will automatically switch to unmanaged heap
                    /// allocation if the type argument and length create an array that exceeds 1kB (1024 bytes).
                    /// </para></remarks>
                    public const int Stackalloc = 1 << 10;
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static void Allocate(
                        [NonNegativeValue] int length,
                        [InstantHandle, RequireStaticDelegate] SpanAction<byte> del
                    ) =>
                        Allocate<byte>(length, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static unsafe void Allocate<TSpan>(
                        int length,
                        [InstantHandle, RequireStaticDelegate] SpanAction<TSpan> del
                    )
                        where TSpan : unmanaged
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                        {
                            del(stackalloc TSpan[value]);
                            return;
                        }
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        del(span);
                
                        Marshal.FreeHGlobal(array);
                    }
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TParam">The type of the parameter.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static void Allocate<TParam>(
                        int length,
                        TParam param,
                        [InstantHandle, RequireStaticDelegate] SpanAction<byte, TParam> del
                    ) =>
                        Allocate<byte, TParam>(length, param, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static unsafe void Allocate<TSpan, TParam>(
                        int length,
                        TParam param,
                        [InstantHandle, RequireStaticDelegate] SpanAction<TSpan, TParam> del
                    )
                        where TSpan : unmanaged
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                        {
                            del(stackalloc TSpan[value], param);
                            return;
                        }
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        del(span, param);
                
                        Marshal.FreeHGlobal(array);
                    }
                
                    /// <summary>Determines if a given length and type should be stack-allocated.</summary>
                    /// <remarks><para>
                    /// See <see cref="Stackalloc"/> for details about stack- and heap-allocation.
                    /// </para></remarks>
                    /// <typeparam name="T">The type of array.</typeparam>
                    /// <param name="length">The amount of items.</param>
                    /// <returns>
                    /// The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
                    /// </returns>
                    [Pure]
                    public static bool IsStack<T>(int length)
                        where T : unmanaged =>
                        InBytes<T>(length) <= Stackalloc;
                
                    /// <summary>Gets the byte length needed to allocate the current length, used in <see cref="IsStack{T}"/>.</summary>
                    /// <typeparam name="T">The type of array.</typeparam>
                    /// <param name="length">The amount of items.</param>
                    /// <returns>
                    /// The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
                    /// </returns>
                    [NonNegativeValue, Pure]
                    public static unsafe int InBytes<T>(int length)
                        where T : unmanaged =>
                        length * sizeof(T);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static TResult Allocate<TResult>(
                        int length,
                        [InstantHandle, RequireStaticDelegate] SpanFunc<byte, TResult> del
                    ) =>
                        Allocate<byte, TResult>(length, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static unsafe TResult Allocate<TSpan, TResult>(
                        int length,
                        [InstantHandle, RequireStaticDelegate] SpanFunc<TSpan, TResult> del
                    )
                        where TSpan : unmanaged
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                            return del(stackalloc TSpan[value]);
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        var result = del(span);
                
                        Marshal.FreeHGlobal(array);
                
                        return result;
                    }
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TParam">The type of the parameter.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static TResult Allocate<TParam, TResult>(
                        int length,
                        TParam param,
                        [InstantHandle, RequireStaticDelegate] SpanFunc<byte, TParam, TResult> del
                    ) =>
                        Allocate<byte, TParam, TResult>(length, param, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static unsafe TResult Allocate<TSpan, TParam, TResult>(
                        int length,
                        TParam param,
                        [InstantHandle, RequireStaticDelegate] SpanFunc<TSpan, TParam, TResult> del
                    )
                        where TSpan : unmanaged
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                            return del(stackalloc TSpan[value], param);
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        var result = del(span, param);
                
                        Marshal.FreeHGlobal(array);
                
                        return result;
                    }
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static void Allocate<TParam>(
                        int length,
                        ReadOnlySpan<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanActionReadOnlySpan<byte, TParam> del
                    )
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        =>
                            Allocate<byte, TParam>(length, param, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static unsafe void Allocate<TSpan, TParam>(
                        int length,
                        ReadOnlySpan<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanActionReadOnlySpan<TSpan, TParam> del
                    )
                        where TSpan : unmanaged
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                        {
                            del(stackalloc TSpan[value], param);
                            return;
                        }
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        del(span, param);
                
                        Marshal.FreeHGlobal(array);
                    }
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static void Allocate<TParam>(
                        int length,
                        Span<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanActionSpan<byte, TParam> del
                    )
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        =>
                            Allocate<byte, TParam>(length, param, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    public static unsafe void Allocate<TSpan, TParam>(
                        int length,
                        Span<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanActionSpan<TSpan, TParam> del
                    )
                        where TSpan : unmanaged
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                        {
                            del(stackalloc TSpan[value], param);
                            return;
                        }
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        del(span, param);
                
                        Marshal.FreeHGlobal(array);
                    }
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static TResult Allocate<TParam, TResult>(
                        int length,
                        ReadOnlySpan<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanFuncReadOnlySpan<byte, TParam, TResult> del
                    )
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        =>
                            Allocate<byte, TParam, TResult>(length, param, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static unsafe TResult Allocate<TSpan, TParam, TResult>(
                        int length,
                        ReadOnlySpan<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanFuncReadOnlySpan<TSpan, TParam, TResult> del
                    )
                        where TSpan : unmanaged
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                            return del(stackalloc TSpan[value], param);
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        var result = del(span, param);
                
                        Marshal.FreeHGlobal(array);
                
                        return result;
                    }
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static TResult Allocate<TParam, TResult>(
                        int length,
                        Span<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanFuncSpan<byte, TParam, TResult> del
                    )
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                        =>
                            Allocate<byte, TParam, TResult>(length, param, del);
                
                    /// <summary>Allocates memory and calls the callback, passing in the <see cref="Span{T}"/>.</summary>
                    /// <remarks><para>See <see cref="Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
                    /// <typeparam name="TSpan">The type of parameter in the span.</typeparam>
                    /// <typeparam name="TParam">The type of the parameter within the span.</typeparam>
                    /// <typeparam name="TResult">The return type.</typeparam>
                    /// <param name="length">The length of the buffer.</param>
                    /// <param name="param">The parameter to pass in.</param>
                    /// <param name="del">The callback to invoke.</param>
                    /// <returns>The returned value from invoking <paramref name="del"/>.</returns>
                    [MustUseReturnValue]
                    public static unsafe TResult Allocate<TSpan, TParam, TResult>(
                        int length,
                        Span<TParam> param,
                        [InstantHandle, RequireStaticDelegate] SpanFuncSpan<TSpan, TParam, TResult> del
                    )
                        where TSpan : unmanaged
                #if UNMANAGED_SPAN
                        where TParam : unmanaged
                #endif
                    {
                        var value = Math.Max(length, 0);
                
                        if (IsStack<TSpan>(length))
                            return del(stackalloc TSpan[value], param);
                
                        var array = Marshal.AllocHGlobal(value);
                        Span<TSpan> span = new((void*)array, value);
                        var result = del(span, param);
                
                        Marshal.FreeHGlobal(array);
                
                        return result;
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Runtime.RuntimeHelpers.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !(NETSTANDARD2_1_OR_GREATER || NETCOREAPP)
                namespace System.Runtime.CompilerServices;
                
                /// <summary>
                /// Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.
                /// </summary>
                static partial class RuntimeHelpers
                {
                    /// <summary>Slices the specified array using the specified range.</summary>
                    /// <typeparam name="T">The type of elements in the array.</typeparam>
                    /// <param name="array">The array to slice.</param>
                    /// <param name="range">
                    /// An object that determines the portion of <paramref name="array"/> to include in the slice.
                    /// </param>
                    /// <returns>The subarray defined by <paramref name="range"/>.</returns>
                    [Pure]
                    public static T[] GetSubArray<T>(T[] array, Range range)
                    {
                        range.GetOffsetAndLength(array.Length, out var offset, out var length);
                
                        var isArrayTypeEqual = default(T) is not null || typeof(T[]) == array.GetType();
                
                        if (isArrayTypeEqual && length is 0)
                #if NET46_OR_GREATER || NETSTANDARD1_3_OR_GREATER || NETCOREAPP
                            return Array.Empty<T>();
                #else
                            return new T[0];
                #endif
                
                        var dest = isArrayTypeEqual ? new T[length] :
                            array.GetType().GetElementType() is { } element ? (T[])Array.CreateInstance(element, length) :
                            throw Unreachable;
                
                        Array.Copy(array, offset, dest, 0, length);
                        return dest;
                    }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Collections.IReadOnly.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable CheckNamespace EmptyNamespace
                namespace System.Collections.Generic;
                #pragma warning disable CA1710, SA1649, MA0048
                #if NETFRAMEWORK && !NET45_OR_GREATER
                /// <summary>Provides a read-only, covariant view of a generic list.</summary>
                /// <typeparam name="T">The type of item on the list.</typeparam>
                partial interface IReadOnlyCollection<
                #if NET40_OR_GREATER
                    out
                #endif
                    T> : IEnumerable<T>
                {
                    /// <summary>Gets the amount of items on the list.</summary>
                    int Count { get; }
                }
                
                /// <summary>Represents a generic read-only collection of key/value pairs.</summary>
                /// <typeparam name="TKey">The type of keys in the read-only dictionary.</typeparam>
                /// <typeparam name="TValue">The type of values in the read-only dictionary.</typeparam>
                partial interface IReadOnlyDictionary<TKey, TValue> : IReadOnlyCollection<KeyValuePair<TKey, TValue>>
                {
                    /// <summary>Gets an enumerable collection that contains the keys in the read-only dictionary.</summary>
                    IEnumerable<TKey> Keys { get; }
                
                    /// <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary>
                    IEnumerable<TValue> Values { get; }
                
                    /// <summary>Gets the element that has the specified key in the read-only dictionary.</summary>
                    /// <param name="key">The key to locate.</param>
                    TValue this[TKey key] { get; }
                
                    /// <summary>Determines whether the read-only dictionary contains an element that has the specified key.</summary>
                    /// <param name="key">The key to locate.</param>
                    /// <returns>
                    /// <see langword="true"/> if the read-only dictionary contains an element that has the specified key;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool ContainsKey(TKey key);
                
                    /// <summary>Gets the value that is associated with the specified key.</summary>
                    /// <param name="key">The key to locate.</param>
                    /// <param name="value">
                    /// When this method returns, the value associated with the specified key, if the key is found;
                    /// otherwise, the default value for the type of the <paramref name="value"/> parameter.
                    /// This parameter is passed uninitialized.
                    /// </param>
                    /// <returns>
                    /// <see langword="true"/> if the object that implements the <see cref="IReadOnlyDictionary{TKey,TValue}"/>
                    /// interface contains an element that has the specified key; otherwise, <see langword="false"/>.
                    /// </returns>
                    bool TryGetValue(TKey key, out TValue value);
                }
                
                /// <summary>Represents a read-only collection of elements that can be accessed by index.</summary>
                /// <typeparam name="T">The type of elements in the read-only list.</typeparam>
                partial interface IReadOnlyList<
                #if NET40_OR_GREATER
                    out
                #endif
                    T> : IReadOnlyCollection<T>
                {
                    /// <summary>Performs an index operation on the list.</summary>
                    /// <param name="index">The item to retrieve.</param>
                    T this[int index] { get; }
                }
                #endif
                #if !NET5_0_OR_GREATER
                /// <summary>Provides a readonly abstraction of a set.</summary>
                /// <typeparam name="T">The type of elements in the set.</typeparam>
                partial interface IReadOnlySet<T> : IReadOnlyCollection<T>
                {
                    /// <summary>Determines if the set contains a specific item.</summary>
                    /// <param name="item">The item to check if the set contains.</param>
                    /// <returns><see langword="true"/> if found; otherwise <see langword="false"/>.</returns>
                    [Pure]
                    bool Contains(T item);
                
                    /// <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <returns>
                    /// <see langword="true"/> if the current set is a proper subset of other; otherwise <see langword="false"/>.
                    /// </returns>
                    /// <exception cref="ArgumentNullException">other is <see langword="null"/>.</exception>
                    bool IsProperSubsetOf(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <returns>
                    /// <see langword="true"/> if the collection is a proper superset of other; otherwise <see langword="false"/>.
                    /// </returns>
                    /// <exception cref="ArgumentNullException">other is <see langword="null"/>.</exception>
                    bool IsProperSupersetOf(IEnumerable<T> other);
                
                    /// <summary>Determine whether the current set is a subset of a specified collection.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
                    /// <exception cref="ArgumentNullException">other is <see langword="null"/>.</exception>
                    bool IsSubsetOf(IEnumerable<T> other);
                
                    /// <summary>Determine whether the current set is a super set of a specified collection.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
                    /// <exception cref="ArgumentNullException">other is <see langword="null"/>.</exception>
                    bool IsSupersetOf(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set overlaps with the specified collection.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <returns>
                    /// <see langword="true"/> if the current set and other share at least one common element;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    /// <exception cref="ArgumentNullException">other is <see langword="null"/>.</exception>
                    bool Overlaps(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <returns>
                    /// <see langword="true"/> if the current set is equal to other; otherwise, <see langword="false"/>.
                    /// </returns>
                    /// <exception cref="ArgumentNullException">other is <see langword="null"/>.</exception>
                    bool SetEquals(IEnumerable<T> other);
                }
                #endif
                #if NETFRAMEWORK && !NET40_OR_GREATER
                /// <summary>Provides the base interface for the abstraction of sets.</summary>
                /// <remarks><para>
                /// This interface provides methods for implementing sets,
                /// which are collections that have unique elements and specific operations.
                /// </para></remarks>
                /// <typeparam name="T">The type of elements in the set.</typeparam>
                partial interface ISet<T> : ICollection<T>
                {
                    /// <summary>Removes all elements in the specified collection from the current set.</summary>
                    /// <remarks><para>
                    /// This method is an O(<c>n</c>) operation,
                    /// where <c>n</c> is the number of elements in the <paramref name="other"/> parameter.
                    /// </para></remarks>
                    /// <param name="other">The collection of items to remove from the set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    void ExceptWith(IEnumerable<T> other);
                
                    /// <summary>
                    /// Modifies the current set so that it contains only elements that are also in a specified collection.
                    /// </summary>
                    /// <remarks><para>This method ignores any duplicate elements in other.</para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    void IntersectWith(IEnumerable<T> other);
                
                    /// <summary>
                    /// Modifies the current set so that it contains only elements that are present
                    /// either in the current set or in the specified collection, but not both.
                    /// </summary>
                    /// <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    void SymmetricExceptWith(IEnumerable<T> other);
                
                    /// <summary>
                    /// Modifies the current set so that it contains all elements that are present in the current set,
                    /// in the specified collection, or in both.
                    /// </summary>
                    /// <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    void UnionWith(IEnumerable<T> other);
                
                    /// <summary>
                    /// Adds an element to the current set and returns a value to indicate if the element was successfully added.
                    /// </summary>
                    /// <param name="item">The element to add to the set.</param>
                    /// <returns>
                    /// <see langword="true"/> if the element is added to the set;
                    /// <see langword="false"/> if the element is already in the set.
                    /// </returns>
                    new bool Add(T item);
                
                    /// <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
                    /// <remarks><para>
                    /// If the current set is a proper superset of <paramref name="other"/>,
                    /// <paramref name="other"/> must have at least one element that the current set does not have.
                    /// </para><para>
                    /// An empty set is a proper superset of any other collection. Therefore, this method returns <see langword="true"/>
                    /// if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
                    /// </para><para>
                    /// This method always returns <see langword="false"/> if the current set is
                    /// less than or equal to the number of elements in <paramref name="other"/>.
                    /// </para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    /// <returns>
                    /// <see langword="true"/> if the current set is a proper superset of <paramref name="other"/>;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool IsProperSupersetOf(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
                    /// <remarks><para>
                    /// If the current set is a proper subset of <paramref name="other"/>,
                    /// <paramref name="other"/> must have at least one element that the current set does not have.
                    /// </para><para>
                    /// An empty set is a proper subset of any other collection. Therefore, this method returns <see langword="true"/>
                    /// if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
                    /// </para><para>
                    /// This method always returns <see langword="false"/> if the current set has
                    /// more or the same number of elements than <paramref name="other"/>.
                    /// </para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    /// <returns>
                    /// <see langword="true"/> if the current set is a proper subset of <paramref name="other"/>;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool IsProperSubsetOf(IEnumerable<T> other);
                
                    /// <summary>Determines whether a set is a subset of a specified collection.</summary>
                    /// <remarks><para>
                    /// If <paramref name="other"/> contains the same elements as the current set,
                    /// the current set is still considered a subset of <paramref name="other"/>.
                    /// </para><para>
                    /// This method always returns <see langword="false"/> if the current
                    /// set has elements that are not in <paramref name="other"/>.
                    /// </para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    /// <returns>
                    /// <see langword="true"/> if the current set is a subset of <paramref name="other"/>;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool IsSubsetOf(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set is a superset of a specified collection.</summary>
                    /// <remarks><para>
                    /// If <paramref name="other"/> contains the same elements as the current set,
                    /// the current set is still considered a superset of <paramref name="other"/>.
                    /// </para><para>
                    /// This method always returns <see langword="false"/> if the current
                    /// set has fewer elements than <paramref name="other"/>.
                    /// </para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    /// <returns>
                    /// <see langword="true"/> if the current set is a superset of <paramref name="other"/>;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool IsSupersetOf(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set overlaps with the specified collection.</summary>
                    /// <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    /// <returns>
                    /// <see langword="true"/> if the current set and <paramref name="other"/> share at least one common element;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool Overlaps(IEnumerable<T> other);
                
                    /// <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
                    /// <param name="other">The collection to compare to the current set.</param>
                    /// <exception cref="ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
                    /// <returns>
                    /// <see langword="true"/> if the current set is equal to <paramref name="other"/>;
                    /// otherwise, <see langword="false"/>.
                    /// </returns>
                    bool SetEquals(IEnumerable<T> other);
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Diagnostics.Attributes.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable ArrangeStaticMemberQualifier CheckNamespace ClassNeverInstantiated.Global EmptyNamespace RedundantUsingDirective
                #pragma warning disable CA1019, GlobalUsingsAnalyzer, MA0047, MA0048, SA1114, SA1216, SA1402, SA1403, SA1649
                
                #if !NET35
                global using NotNullAttribute = System.Diagnostics.CodeAnalysis.NotNullAttribute;
                #endif
                
                namespace System.Diagnostics.CodeAnalysis
                {
                #if NETFRAMEWORK || NETSTANDARD && !NETSTANDARD2_1_OR_GREATER
                #if !WAWA
                    /// <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
                    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]
                    sealed partial class AllowNullAttribute : Attribute { }
                #endif
                
                    /// <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
                    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]
                    sealed partial class DisallowNullAttribute : Attribute { }
                
                    /// <summary>Applied to a method that will never return under any circumstance.</summary>
                    [AttributeUsage(AttributeTargets.Method, Inherited = false)]
                    sealed partial class DoesNotReturnAttribute : Attribute { }
                
                    /// <summary>
                    /// Specifies that the method will not return if the associated Boolean parameter is passed the specified value.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class DoesNotReturnIfAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="DoesNotReturnIfAttribute"/> class
                        /// with the specified parameter value.
                        /// </summary>
                        /// <param name="parameterValue">
                        /// The condition parameter value. Code after the method will be considered unreachable
                        /// by diagnostics if the argument to the associated parameter matches this value.
                        /// </param>
                        public DoesNotReturnIfAttribute(bool parameterValue) => ParameterValue = parameterValue;
                
                        /// <summary>
                        /// Gets a value indicating whether the condition parameter value
                        /// is <see langword="true"/> or <see langword="false"/>.
                        /// </summary>
                        public bool ParameterValue { get; }
                    }
                
                    /// <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
                    [AttributeUsage(
                        AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue
                    )]
                    sealed partial class MaybeNullAttribute : Attribute { }
                
                    /// <summary>
                    /// Specifies that an output will not be null even if the corresponding type allows it.
                    /// Specifies that an input argument was not null when the call returns.
                    /// </summary>
                    [AttributeUsage(
                        AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue
                    )]
                    sealed partial class NotNullAttribute : Attribute { }
                
                    /// <summary>
                    /// Specifies that when a method returns <see cref="ReturnValue"/>,
                    /// the parameter may be null even if the corresponding type disallows it.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class MaybeNullWhenAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="MaybeNullWhenAttribute"/> class
                        /// with the specified return value condition.
                        /// </summary>
                        /// <param name="returnValue">
                        /// The return value condition. If the method returns this value, the associated parameter may be null.
                        /// </param>
                        public MaybeNullWhenAttribute(bool returnValue) => ReturnValue = returnValue;
                
                        /// <summary>
                        /// Gets a value indicating whether the return value condition
                        /// is <see langword="true"/> or <see langword="false"/>.
                        /// </summary>
                        public bool ReturnValue { get; }
                    }
                
                    /// <summary>
                    /// Specifies that when a method returns <see cref="ReturnValue"/>,
                    /// the parameter will not be null even if the corresponding type allows it.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class NotNullWhenAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="NotNullWhenAttribute"/> class
                        /// with the specified return value condition.
                        /// </summary>
                        /// <param name="returnValue">
                        /// The return value condition. If the method returns this value, the associated parameter will not be null.
                        /// </param>
                        public NotNullWhenAttribute(bool returnValue) => ReturnValue = returnValue;
                
                        /// <summary>
                        /// Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
                        /// </summary>
                        public bool ReturnValue { get; }
                    }
                
                    /// <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
                    [AttributeUsage(
                        AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue,
                        AllowMultiple = true
                    )]
                    sealed partial class NotNullIfNotNullAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="NotNullIfNotNullAttribute"/> class
                        /// with the associated parameter name.
                        /// </summary>
                        /// <param name="parameterName">
                        /// The associated parameter name.
                        /// The output will be non-null if the argument to the parameter specified is non-null.
                        /// </param>
                        public NotNullIfNotNullAttribute(string parameterName) => ParameterName = parameterName;
                
                        /// <summary>Gets the associated parameter name.</summary>
                        public string ParameterName { get; }
                    }
                #endif
                #if NETFRAMEWORK || NETSTANDARD
                    /// <summary>
                    /// Specifies that the method or property will ensure that the
                    /// listed field and property members have not-null values.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
                    sealed partial class MemberNotNullAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="MemberNotNullAttribute"/>
                        /// class with a field or property member.
                        /// </summary>
                        /// <param name="member">
                        /// The field or property member that is promised to be not-null.
                        /// </param>
                        public MemberNotNullAttribute(string member) => Members = new[] { member };
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="MemberNotNullAttribute"/> class
                        /// with the list of field and property members.
                        /// </summary>
                        /// <param name="members">
                        /// The list of field and AttributeTargets.Property members that are promised to be not-null.
                        /// </param>
                        public MemberNotNullAttribute(params string[] members) => Members = members;
                
                        /// <summary>Gets field or AttributeTargets.Property member names.</summary>
                        public string[] Members { get; }
                    }
                
                    /// <summary>
                    /// Specifies that the method or property will ensure that the listed field and property members
                    /// have not-null values when returning with the specified return value condition.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
                    sealed partial class MemberNotNullWhenAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="MemberNotNullWhenAttribute"/> class
                        /// with the specified return value condition and a field or property member.
                        /// </summary>
                        /// <param name="returnValue">
                        /// The return value condition. If the method returns this value, the associated parameter will not be null.
                        /// </param>
                        /// <param name="member">The field or property member that is promised to be not-null.</param>
                        public MemberNotNullWhenAttribute(bool returnValue, string member)
                        {
                            ReturnValue = returnValue;
                            Members = new[] { member };
                        }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="MemberNotNullWhenAttribute"/> class
                        /// with the specified return value condition and list of field and property members.
                        /// </summary>
                        /// <param name="returnValue">
                        /// The return value condition. If the method returns this value, the associated parameter will not be null.
                        /// </param>
                        /// <param name="members">
                        /// The list of field and property members that are promised to be not-null.
                        /// </param>
                        public MemberNotNullWhenAttribute(bool returnValue, params string[] members)
                        {
                            ReturnValue = returnValue;
                            Members = members;
                        }
                
                        /// <summary>
                        /// Gets a value indicating whether the return value condition
                        /// is <see langword="true"/> or <see langword="false"/>.
                        /// </summary>
                        public bool ReturnValue { get; }
                
                        /// <summary>Gets field or property member names.</summary>
                        public string[] Members { get; }
                    }
                #endif
                #if !NET7_0_OR_GREATER
                    /// <summary>
                    /// Specifies that this constructor sets all required members for the current type,
                    /// and callers do not need to set any required members themselves.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Constructor)]
                    sealed partial class SetsRequiredMembersAttribute : Attribute { }
                
                    /// <summary>Specifies the syntax used in a string.</summary>
                    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Field | AttributeTargets.Property)]
                    sealed partial class StringSyntaxAttribute : Attribute
                    {
                        /// <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
                        public const string CompositeFormat = nameof(CompositeFormat);
                
                        /// <summary>The syntax identifier for strings containing date format specifiers.</summary>
                        public const string DateOnlyFormat = nameof(DateOnlyFormat);
                
                        /// <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
                        public const string DateTimeFormat = nameof(DateTimeFormat);
                
                        /// <summary>The syntax identifier for strings containing <see cref="Enum"/> format specifiers.</summary>
                        public const string EnumFormat = nameof(EnumFormat);
                
                        /// <summary>The syntax identifier for strings containing <see cref="Guid"/> format specifiers.</summary>
                        public const string GuidFormat = nameof(GuidFormat);
                
                        /// <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
                        public const string Json = nameof(Json);
                
                        /// <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
                        public const string NumericFormat = nameof(NumericFormat);
                
                        /// <summary>The syntax identifier for strings containing regular expressions.</summary>
                        public const string Regex = nameof(Regex);
                
                        /// <summary>The syntax identifier for strings containing time format specifiers.</summary>
                        public const string TimeOnlyFormat = nameof(TimeOnlyFormat);
                
                        /// <summary>The syntax identifier for strings containing <see cref="TimeSpan"/> format specifiers.</summary>
                        public const string TimeSpanFormat = nameof(TimeSpanFormat);
                
                        /// <summary>The syntax identifier for strings containing URIs.</summary>
                        public const string Uri = nameof(Uri);
                
                        /// <summary>The syntax identifier for strings containing XML.</summary>
                        public const string Xml = nameof(Xml);
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="StringSyntaxAttribute"/> class
                        /// with the identifier of the syntax used.
                        /// </summary>
                        /// <param name="syntax">The syntax identifier.</param>
                        public StringSyntaxAttribute(string syntax)
                        {
                            Syntax = syntax;
                
                            Arguments =
                #if NET46_OR_GREATER || NETSTANDARD1_3_OR_GREATER || NETCOREAPP
                                Array.Empty<object?>();
                #else
                                new object?[] { null };
                #endif
                        }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="StringSyntaxAttribute"/> class
                        /// with the identifier of the syntax used.
                        /// </summary>
                        /// <param name="syntax">The syntax identifier.</param>
                        /// <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
                        public StringSyntaxAttribute(string syntax, params object?[] arguments)
                        {
                            Syntax = syntax;
                            Arguments = arguments;
                        }
                
                        /// <summary>Gets the identifier of the syntax used.</summary>
                        public string Syntax { get; }
                
                        /// <summary>Gets the optional arguments associated with the specific syntax employed.</summary>
                        public object?[] Arguments { get; }
                    }
                
                    /// <summary>Used to indicate a byref escapes and is not scoped.</summary>
                    [AttributeUsage(
                        AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Parameter,
                        Inherited = false
                    )]
                    sealed partial class UnscopedRefAttribute : Attribute { }
                #endif
                }
                
                namespace System.Runtime.CompilerServices
                {
                #if !NET5_0_OR_GREATER
                    /// <summary>
                    /// Reserved to be used by the compiler for tracking metadata.
                    /// This class should not be used by developers in source code.
                    /// </summary>
                    [
                #if !(NETFRAMEWORK && !NET40_OR_GREATER || NETSTANDARD && !NETSTANDARD2_0_OR_GREATER)
                        ExcludeFromCodeCoverage,
                #endif
                        DebuggerNonUserCode]
                    static class IsExternalInit { }
                #endif
                #if NETFRAMEWORK || NETSTANDARD && !NETSTANDARD2_1_OR_GREATER
                    /// <summary>
                    /// Indicates the type of the async method builder that should be used by a language compiler to
                    /// build the attributed async method or to build the attributed type when used as the return type
                    /// of an async method.
                    /// </summary>
                    [AttributeUsage(
                        AttributeTargets.Class |
                        AttributeTargets.Struct |
                        AttributeTargets.Interface |
                        AttributeTargets.Delegate |
                        AttributeTargets.Enum |
                        AttributeTargets.Method,
                        Inherited = false
                    )]
                    sealed partial class AsyncMethodBuilderAttribute : Attribute
                    {
                        /// <summary>Initializes a new instance of the <see cref="AsyncMethodBuilderAttribute"/> class.</summary>
                        /// <param name="builderType">The <see cref="Type"/> of the associated builder.</param>
                        public AsyncMethodBuilderAttribute(Type builderType) => BuilderType = builderType;
                
                        /// <summary>Gets the <see cref="Type"/> of the associated builder.</summary>
                        public Type BuilderType { get; }
                    }
                #endif
                #if NET20 || NET30
                    /// <summary>
                    /// Indicates that a method is an extension method, or that a class or assembly contains extension methods.
                    /// </summary>
                    [AttributeUsage(Method | Class | AttributeTargets.Assembly)]
                    sealed partial class ExtensionAttribute : Attribute { }
                #endif
                #if !NET6_0_OR_GREATER
                    /// <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
                    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false)]
                    sealed partial class InterpolatedStringHandlerAttribute : Attribute { }
                
                    /// <summary>
                    /// Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class InterpolatedStringHandlerArgumentAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="InterpolatedStringHandlerArgumentAttribute"/> class.
                        /// </summary>
                        /// <remarks><para>
                        /// The empty string may be used as the name of the receiver in an instance method.
                        /// </para></remarks>
                        /// <param name="argument">The name of the argument that should be passed to the handler.</param>
                        public InterpolatedStringHandlerArgumentAttribute(string argument) => Arguments = new[] { argument };
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="InterpolatedStringHandlerArgumentAttribute"/> class.
                        /// </summary>
                        /// <remarks><para>
                        /// The empty string may be used as the name of the receiver in an instance method.
                        /// </para></remarks>
                        /// <param name="arguments">The names of the arguments that should be passed to the handler.</param>
                        public InterpolatedStringHandlerArgumentAttribute(params string[] arguments) => Arguments = arguments;
                
                        /// <summary>Gets the names of the arguments that should be passed to the handler.</summary>
                        /// <remarks><para>
                        /// The empty string may be used as the name of the receiver in an instance method.
                        /// </para></remarks>
                        public string[] Arguments { get; }
                    }
                #endif
                #if !NET5_0_OR_GREATER
                    /// <summary>
                    /// Used to indicate to the compiler that a method should be called in its containing module's initializer.
                    /// </summary>
                    /// <remarks><para>
                    /// When one or more valid methods with this attribute are found in a compilation,
                    /// the compiler will emit a module initializer that calls each of the attributed methods.<br />
                    /// Certain requirements are imposed on any method targeted with this attribute:
                    /// </para><list type="bullet">
                    /// <item><description>The method must be <see langword="static"/>.</description></item>
                    /// <item><description>
                    /// The method must be an ordinary member method, as opposed to a property accessor,
                    /// constructor, local function, and so on.
                    /// </description></item>
                    /// <item><description>The method must be parameterless..</description></item>
                    /// <item><description>The method must return <see langword="void"/>.</description></item>
                    /// <item><description>The method must not be generic or be contained in a generic type.</description></item>
                    /// <item><description>
                    /// The method's effective accessibility must be <see langword="internal"/> or <see langword="public"/>.
                    /// </description></item>
                    /// </list><para>
                    /// For more information, see
                    /// https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer.
                    /// </para></remarks>
                    [AttributeUsage(AttributeTargets.Method, Inherited = false)]
                    sealed partial class ModuleInitializerAttribute : Attribute { }
                #endif
                #if NETFRAMEWORK
                    /// <summary>
                    /// Allows you to obtain the full path of the source file that contains the caller.
                    /// This is the file path at the time of compile.
                    /// </summary>
                    /// <remarks><para>
                    /// You apply the <see cref="CallerFilePathAttribute"/> attribute to an optional parameter that has a default value.
                    /// You must specify an explicit default value for the optional parameter.
                    /// You can't apply this attribute to parameters that aren't specified as optional.
                    /// </para></remarks>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class CallerFilePathAttribute : Attribute { }
                
                    /// <summary>Allows you to obtain the line number in the source file at which the method is called.</summary>
                    /// <remarks><para>
                    /// You apply the <see cref="CallerLineNumberAttribute"/> attribute to an optional parameter that
                    /// has a default value. You must specify an explicit default value for the optional parameter.
                    /// You can't apply this attribute to parameters that aren't specified as optional.
                    /// </para></remarks>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class CallerLineNumberAttribute : Attribute { }
                
                    /// <summary>Allows you to obtain the method or property name of the caller to the method.</summary>
                    /// <remarks><para>
                    /// You apply the <see cref="CallerMemberNameAttribute"/> attribute to an optional parameter that
                    /// has a default value. You must specify an explicit default value for the optional parameter.
                    /// You can't apply this attribute to parameters that aren't specified as optional.
                    /// </para></remarks>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class CallerMemberNameAttribute : Attribute { }
                #endif
                #if NETFRAMEWORK || NETSTANDARD
                    /// <summary>Indicates that a parameter captures the expression passed for another parameter as a string.</summary>
                    /// <remarks><para>This attribute is implemented in the compiler for C# 10 and later versions only.</para></remarks>
                    [AttributeUsage(AttributeTargets.Parameter)]
                    sealed partial class CallerArgumentExpressionAttribute : Attribute
                    {
                        /// <summary>Initializes a new instance of the <see cref="CallerArgumentExpressionAttribute"/> class.</summary>
                        /// <param name="parameterName">
                        /// The name of the parameter whose expression should be captured as a string.
                        /// </param>
                        public CallerArgumentExpressionAttribute([InvokerParameterName] string parameterName) =>
                            ParameterName = parameterName;
                
                        /// <summary>Gets the name of the parameter whose expression should be captured as a string.</summary>
                        public string ParameterName { [Pure] get; }
                    }
                #endif
                #if !NET5_0_OR_GREATER
                    /// <summary>
                    /// Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
                    /// </summary>
                    /// <remarks><para>
                    /// This attribute is unsafe because it may reveal uninitialized memory to the application in certain
                    /// instances (e.g., reading from uninitialized stackalloc'd memory). If applied to a method directly,
                    /// the attribute applies to that method and all nested functions (lambdas, local functions) below it.
                    /// If applied to a type or module, it applies to all methods nested inside. This attribute is intentionally
                    /// not permitted on assemblies. Use at the module level instead to apply to multiple type declarations.
                    /// </para></remarks>
                    [AttributeUsage(
                        AttributeTargets.Class |
                        AttributeTargets.Constructor |
                        AttributeTargets.Event |
                        AttributeTargets.Interface |
                        AttributeTargets.Method |
                        AttributeTargets.Module |
                        AttributeTargets.Property |
                        AttributeTargets.Struct,
                        Inherited = false
                    )]
                    sealed partial class SkipLocalsInitAttribute : Attribute { }
                #endif
                #if !NET7_0_OR_GREATER
                    /// <summary>
                    /// Indicates that compiler support for a particular feature is
                    /// required for the location where this attribute is applied.
                    /// </summary>
                    [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]
                    sealed partial class CompilerFeatureRequiredAttribute : Attribute
                    {
                        /// <summary>The <see cref="FeatureName"/> used for the ref structs C# feature.</summary>
                        public const string RefStructs = nameof(RefStructs);
                
                        /// <summary>The <see cref="FeatureName"/> used for the required members C# feature.</summary>
                        public const string RequiredMembers = nameof(RequiredMembers);
                
                        /// <summary>Initializes a new instance of the <see cref="CompilerFeatureRequiredAttribute"/> class.</summary>
                        /// <param name="featureName">The name of the compiler feature.</param>
                        public CompilerFeatureRequiredAttribute(string featureName) => FeatureName = featureName;
                
                        /// <summary>Gets the name of the compiler feature.</summary>
                        public string FeatureName { [Pure] get; }
                
                        /// <summary>
                        /// Gets or sets a value indicating whether the compiler can choose to allow access to the location
                        /// where this attribute is applied if it does not understand <see cref="FeatureName"/>.
                        /// </summary>
                        public bool IsOptional { [Pure] get; set; }
                    }
                
                    /// <summary>Specifies that a type has required members or that a member is required.</summary>
                    [AttributeUsage(AttributeTargets.Constructor)]
                    sealed partial class RequiredMemberAttribute : Attribute { }
                #endif
                }
                
                namespace System.Runtime.CompilerServices
                {
                #if !NET6_0_OR_GREATER
                    /// <summary>
                    /// Indicates that an API is in preview. This attribute allows call sites to be
                    /// flagged with a diagnostic that indicates that a preview feature is used.
                    /// Authors can use this attribute to ship preview features in their assemblies.
                    /// </summary>
                    [AttributeUsage(
                        AttributeTargets.Assembly |
                        AttributeTargets.Class |
                        AttributeTargets.Constructor |
                        AttributeTargets.Delegate |
                        AttributeTargets.Enum |
                        AttributeTargets.Event |
                        AttributeTargets.Field |
                        AttributeTargets.Interface |
                        AttributeTargets.Method |
                        AttributeTargets.Module |
                        AttributeTargets.Property |
                        AttributeTargets.Struct,
                        Inherited = false
                    )]
                    sealed partial class RequiresPreviewFeaturesAttribute : Attribute
                    {
                        /// <summary>Initializes a new instance of the <see cref="RequiresPreviewFeaturesAttribute"/> class.</summary>
                        public RequiresPreviewFeaturesAttribute() { }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="RequiresPreviewFeaturesAttribute"/> class
                        /// with the specified message.
                        /// </summary>
                        /// <param name="message">An optional message associated with this attribute instance.</param>
                        public RequiresPreviewFeaturesAttribute(string? message) => Message = message;
                
                        /// <summary>Gets the optional message associated with this attribute instance.</summary>
                        public string? Message { get; }
                
                        /// <summary>Gets or sets the optional URL associated with this attribute instance.</summary>
                        public string? Url { get; set; }
                    }
                #endif
                }
                #if !NET7_0_OR_GREATER
                namespace System.Text.RegularExpressions
                {
                    /// <summary>
                    /// Instructs the System.Text.RegularExpressions source generator to
                    /// generate an implementation of the specified regular expression.
                    /// </summary>
                    /// <remarks>
                    /// <para>
                    /// The generator associated with this attribute only supports C#. It only supplies an implementation when applied
                    /// to static, partial, parameterless, non-generic methods that are typed to return <see cref="Regex"/>.
                    /// </para>
                    /// <para>
                    /// When the <see cref="Regex"/> supports case-insensitive matches (either by passing
                    /// <see cref="RegexOptions.IgnoreCase"/> or using the inline <c>(?i)</c> switch in the pattern) the regex engines
                    /// will use an internal casing table to transform the passed in pattern into an equivalent case-sensitive one.
                    /// For example, given the pattern <c>abc</c>, the engines will transform it to the equivalent pattern
                    /// <c>[Aa][Bb][Cc]</c>. The equivalences found in this internal casing table can change over time, for example in
                    /// the case new characters are added to a new version of Unicode. When using the source generator, this
                    /// transformation happens at compile time, which means the casing table used to find the equivalences will depend
                    /// on the target framework at compile time. This differs from the rest of the <see cref="Regex"/> engines, which
                    /// perform this transformation at run-time, meaning they will always use casing table for the current runtime.
                    /// </para></remarks>
                    [AttributeUsage(AttributeTargets.Method, Inherited = false)]
                    sealed partial class GeneratedRegexAttribute : Attribute
                    {
                        /// <summary>
                        /// Initializes a new instance of the <see cref="GeneratedRegexAttribute"/> class with the specified pattern.
                        /// </summary>
                        /// <param name="pattern">The regular expression pattern to match.</param>
                        public GeneratedRegexAttribute([StringSyntax(StringSyntaxAttribute.Regex)] string pattern)
                            : this(pattern, RegexOptions.None) { }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="GeneratedRegexAttribute"/>
                        /// class with the specified pattern and options.
                        /// </summary>
                        /// <param name="pattern">The regular expression pattern to match.</param>
                        /// <param name="options">
                        /// A bitwise combination of the enumeration values that modify the regular expression.
                        /// </param>
                        public GeneratedRegexAttribute(
                            [StringSyntax(StringSyntaxAttribute.Regex, nameof(options))] string pattern,
                            RegexOptions options
                        )
                            : this(pattern, options, Timeout.Infinite) { }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="GeneratedRegexAttribute"/>
                        /// class with the specified pattern and options.
                        /// </summary>
                        /// <param name="pattern">The regular expression pattern to match.</param>
                        /// <param name="options">
                        /// A bitwise combination of the enumeration values that modify the regular expression.
                        /// </param>
                        /// <param name="cultureName">
                        /// The name of a culture to be used for case sensitive comparisons.
                        /// <paramref name="cultureName"/> is not case-sensitive.
                        /// </param>
                        /// <remarks><para>
                        /// For a list of predefined culture names on Windows systems, see the Language tag column in the
                        /// list of language/region names supported by Windows
                        /// (https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c).
                        /// Culture names follow the standard defined by BCP 47 (https://tools.ietf.org/html/bcp47). In addition,
                        /// starting with Windows 10, <paramref name="cultureName"/> can be any valid BCP-47 language tag.
                        /// </para><para>
                        /// If <paramref name="cultureName"/> is <see cref="string.Empty"/>, the invariant culture will be used.
                        /// </para></remarks>
                        public GeneratedRegexAttribute(
                            [StringSyntax(StringSyntaxAttribute.Regex, nameof(options))] string pattern,
                            RegexOptions options,
                            string cultureName
                        )
                            : this(pattern, options, Timeout.Infinite, cultureName) { }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="GeneratedRegexAttribute"/>
                        /// class with the specified pattern, options, and timeout.
                        /// </summary>
                        /// <param name="pattern">The regular expression pattern to match.</param>
                        /// <param name="options">
                        /// A bitwise combination of the enumeration values that modify the regular expression.
                        /// </param>
                        /// <param name="matchTimeoutMilliseconds">
                        /// A time-out interval (milliseconds), or <see cref="Timeout.Infinite"/>
                        /// to indicate that the method should not time out.
                        /// </param>
                        public GeneratedRegexAttribute(
                            [StringSyntax(StringSyntaxAttribute.Regex, nameof(options))] string pattern,
                            RegexOptions options,
                            int matchTimeoutMilliseconds
                        )
                            : this(pattern, options, matchTimeoutMilliseconds, "") { }
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="GeneratedRegexAttribute"/>
                        /// class with the specified pattern, options, and timeout.
                        /// </summary>
                        /// <param name="pattern">The regular expression pattern to match.</param>
                        /// <param name="options">
                        /// A bitwise combination of the enumeration values that modify the regular expression.
                        /// </param>
                        /// <param name="matchTimeoutMilliseconds">
                        /// A time-out interval (milliseconds), or <see cref="Timeout.Infinite"/>
                        /// to indicate that the method should not time out.</param>
                        /// <param name="cultureName">
                        /// The name of a culture to be used for case sensitive comparisons.
                        /// <paramref name="cultureName"/> is not case-sensitive.
                        /// </param>
                        /// <remarks><para>
                        /// For a list of predefined culture names on Windows systems, see the Language tag column in the list of
                        /// language/region names supported by Windows
                        /// (https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c).
                        /// Culture names follow the standard defined by BCP 47 (https://tools.ietf.org/html/bcp47). In addition,
                        /// starting with Windows 10, <paramref name="cultureName"/> can be any valid BCP-47 language tag.
                        /// </para><para>
                        /// If <paramref name="cultureName"/> is <see cref="string.Empty"/>, the invariant culture will be used.
                        /// </para></remarks>
                        public GeneratedRegexAttribute(
                            [StringSyntax(StringSyntaxAttribute.Regex, nameof(options))] string pattern,
                            RegexOptions options,
                            int matchTimeoutMilliseconds,
                            string cultureName
                        )
                        {
                            Pattern = pattern;
                            Options = options;
                            MatchTimeoutMilliseconds = matchTimeoutMilliseconds;
                            CultureName = cultureName;
                        }
                
                        /// <summary>
                        /// Gets a time-out interval (milliseconds), or <see cref="Timeout.Infinite"/>
                        /// to indicate that the method should not time out.
                        /// </summary>
                        public int MatchTimeoutMilliseconds { [Pure] get; }
                
                        /// <summary>Gets the name of the culture to be used for case sensitive comparisons.</summary>
                        public string CultureName { [Pure] get; }
                
                        /// <summary>Gets the regular expression pattern to match.</summary>
                        public string Pattern { [Pure] get; }
                
                        /// <summary>Gets a bitwise combination of the enumeration values that modify the regular expression.</summary>
                        public RegexOptions Options { [Pure] get; }
                    }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Diagnostics.UnreachableException.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET7_0_OR_GREATER
                // ReSharper disable once CheckNamespace
                #pragma warning disable CA1064
                namespace System.Diagnostics;
                
                /// <summary>Exception thrown when the program executes an instruction that was thought to be unreachable.</summary>
                #if !(NETSTANDARD && !NETSTANDARD2_0_OR_GREATER)
                [Serializable]
                #endif
                sealed partial class UnreachableException : Exception
                {
                    const string Arg = "The program executed an instruction that was thought to be unreachable.";
                
                    /// <summary>
                    /// Initializes a new instance of the <see cref="UnreachableException"/> class with the default error message.
                    /// </summary>
                    public UnreachableException()
                        : base(Arg) { }
                
                    /// <summary>
                    /// Initializes a new instance of the <see cref="UnreachableException"/> class with a specified error message.
                    /// </summary>
                    /// <param name="message">The error message that explains the reason for the exception.</param>
                    public UnreachableException(string? message)
                        : base(message) { }
                
                    /// <summary>
                    /// Initializes a new instance of the <see cref="UnreachableException"/> class with a specified error message
                    /// and a reference to the inner exception that is the cause of this exception.
                    /// </summary>
                    /// <param name="message">The error message that explains the reason for the exception.</param>
                    /// <param name="innerException">The exception that is the cause of the current exception.</param>
                    public UnreachableException(string? message, Exception? innerException)
                        : base(message, innerException) { }
                
                #if !(NETSTANDARD && !NETSTANDARD2_0_OR_GREATER)
                    UnreachableException(SerializationInfo info, StreamingContext context)
                        : base(info, context) { }
                #endif
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Diagnostics.MethodImplOptions.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if NETFRAMEWORK
                #pragma warning disable GlobalUsingsAnalyzer
                
                extern alias ms;
                using Options = ms::System.Runtime.CompilerServices.MethodImplOptions;
                
                // ReSharper disable once CheckNamespace
                namespace System.Runtime.CompilerServices;
                
                /// <summary>
                /// Specifies constants that define the details of how a method is implemented.
                /// This enumeration supports a bitwise combination of its member values.
                /// </summary>
                /// <remarks><para>
                /// This enumeration is used with the <see cref="MethodImplAttribute"/> attribute.
                /// You can specify multiple <see cref="MethodImplOptions"/> values by using the bitwise OR operator.
                /// </para></remarks>
                [ComVisible(true), Serializable]
                static partial class MethodImplOptions
                {
                    /// <summary>The method is implemented in unmanaged code.</summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions Unmanaged =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 2);
                
                    /// <summary>
                    /// The method cannot be inlined.
                    /// Inlining is an optimization by which a method call is replaced with the method body.
                    /// </summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions NoInlining =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 3);
                
                    /// <summary>The method is declared, but its implementation is provided elsewhere.</summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions ForwardRef =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 4);
                
                    /// <summary>
                    /// The method can be executed by only one thread at a time.
                    /// Static methods lock on the type, whereas instance methods lock on the instance.
                    /// Only one thread can execute in any of the instance functions,
                    /// and only one thread can execute in any of a class's static functions.
                    /// </summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions Synchronized =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 5);
                
                    /// <summary>
                    /// The method is not optimized by the just-in-time (JIT) compiler or by native code generation (see Ngen.exe)
                    /// when debugging possible code generation problems.
                    /// </summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions NoOptimization =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 6);
                
                    /// <summary>The method signature is exported exactly as declared.</summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions PreserveSig =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 7);
                
                    /// <summary>The method should be inlined if possible.</summary>
                    [ComVisible(false)]
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions AggressiveInlining =
                #if NO_AGGRESSIVE_INLINING
                        0;
                #else
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 8);
                #endif
                
                    /// <summary>The method contains code that should always be optimized by the just-in-time (JIT) compiler.</summary>
                    /// <remarks><para>
                    /// Use this attribute if running an unoptimized version of the method has undesirable effects,
                    /// for instance causing too much overhead or extra memory allocation.
                    /// </para><para>
                    /// Methods with this attribute may not have optimal code generation.
                    /// They bypass the first tier of Tiered Compilation and therefore can't benefit from optimizations that rely on
                    /// tiering, for example, Dynamic PGO or optimizations based on initialized classes.
                    /// </para></remarks>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions AggressiveOptimization =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 9);
                
                    /// <summary>
                    /// The call is internal, that is, it calls a method that's implemented within the common language runtime.
                    /// </summary>
                    public const ms::System.Runtime.CompilerServices.MethodImplOptions InternalCall =
                        (ms::System.Runtime.CompilerServices.MethodImplOptions)(1 << 10);
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.System.Linq.EnumerableZip.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace EmptyNamespace
                namespace System.Linq;
                
                #if !NETCOREAPP3_0_OR_GREATER
                /// <summary>The backport of Zip methods for <see cref="IEnumerable{T}"/>.</summary>
                static partial class EnumerableZip
                {
                    /// <summary>
                    /// Produces a sequence of tuples with elements from the two specified sequences.
                    /// </summary>
                    /// <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
                    /// <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
                    /// <param name="first">The first sequence to merge.</param>
                    /// <param name="second">The second sequence to merge.</param>
                    /// <returns>A sequence of tuples with elements taken from the first and second sequence, in that order.</returns>
                    public static IEnumerable<(TFirst First, TSecond Second)> Zip<TFirst, TSecond>(
                        this IEnumerable<TFirst> first,
                        IEnumerable<TSecond> second
                    )
                    {
                        using var e1 = first.GetEnumerator();
                        using var e2 = second.GetEnumerator();
                
                        while (e1.MoveNext() && e2.MoveNext())
                            yield return (e1.Current, e2.Current);
                    }
                
                    /// <summary>
                    /// Applies a specified function to the corresponding elements of two sequences,
                    /// producing a sequence of the results.
                    /// </summary>
                    /// <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
                    /// <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
                    /// <typeparam name="TResult">The type of the elements of the result sequence.</typeparam>
                    /// <param name="first">The first sequence to merge.</param>
                    /// <param name="second">The second sequence to merge.</param>
                    /// <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
                    /// <returns>An <see cref="IEnumerable{T}"/> that contains merged elements of two input sequences.</returns>
                    public static IEnumerable<TResult> Zip<TFirst, TSecond, TResult>(
                        this IEnumerable<TFirst> first,
                        IEnumerable<TSecond> second,
                        Func<TFirst, TSecond, TResult> resultSelector
                    )
                    {
                        using var e1 = first.GetEnumerator();
                
                        using var e2 = second.GetEnumerator();
                
                        while (e1.MoveNext() && e2.MoveNext())
                            yield return resultSelector(e1.Current, e2.Current);
                    }
                
                    /// <summary>
                    /// Produces a sequence of tuples with elements from the three specified sequences.
                    /// </summary>
                    /// <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
                    /// <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
                    /// <typeparam name="TThird">The type of the elements of the third input sequence.</typeparam>
                    /// <param name="first">The first sequence to merge.</param>
                    /// <param name="second">The second sequence to merge.</param>
                    /// <param name="third">The third sequence to merge.</param>
                    /// <returns>
                    /// A sequence of tuples with elements taken from the first, second, and third sequences, in that order.
                    /// </returns>
                    public static IEnumerable<(TFirst First, TSecond Second, TThird Third)> Zip<TFirst, TSecond, TThird>(
                        this IEnumerable<TFirst> first,
                        IEnumerable<TSecond> second,
                        IEnumerable<TThird> third
                    )
                    {
                        using var e1 = first.GetEnumerator();
                        using var e2 = second.GetEnumerator();
                        using var e3 = third.GetEnumerator();
                
                        while (e1.MoveNext() && e2.MoveNext() && e3.MoveNext())
                            yield return (e1.Current, e2.Current, e3.Current);
                    }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Immutable.ReadOnlyList.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static CollectionAccessType;
                
                #if !NET20 && !NET30
                /// <summary>Extension methods that act as factories for <see cref="IReadOnlyList{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class ReadOnlyFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="IReadOnlyList{T}"/>.</summary>
                    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
                    /// <param name="iterable">The collection to turn into a <see cref="IReadOnlyList{T}"/>.</param>
                    /// <returns>A <see cref="IReadOnlyList{T}"/> of <paramref name="iterable"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static IReadOnlyList<T>? ToReadOnly<T>(this IEnumerable<T>? iterable) =>
                        iterable is null
                            ? null
                            : iterable as IReadOnlyList<T> ?? new ReadOnlyList<T>(iterable as IList<T> ?? iterable.ToList());
                }
                #endif
                
                /// <summary>Encapsulates an <see cref="IList{T}"/> and make all mutating methods a no-op.</summary>
                /// <typeparam name="T">The type of element in the list.</typeparam>
                sealed partial class ReadOnlyList<T> : IList<T>, IReadOnlyList<T>
                {
                    [ProvidesContext]
                    readonly IList<T> _list;
                
                    /// <summary>Initializes a new instance of the <see cref="ReadOnlyList{T}"/> class.</summary>
                    /// <param name="list">The list to encapsulate.</param>
                    public ReadOnlyList([ProvidesContext] IList<T> list) => _list = list;
                
                    /// <inheritdoc />
                    [Pure]
                    public bool IsReadOnly => true;
                
                    /// <inheritdoc cref="ICollection{T}.Count"/>
                    [CollectionAccess(Read), Pure]
                    public int Count => _list.Count;
                
                    /// <inheritdoc cref="IList{T}.this" />
                    [Pure]
                    public T this[int index]
                    {
                        [CollectionAccess(Read)] get => _list[index];
                        [CollectionAccess(None)] set { }
                    }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    public void Add(T item) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    public void Clear() { }
                
                    /// <inheritdoc />
                    [CollectionAccess(Read)]
                    public void CopyTo(T[] array, int arrayIndex) => _list.CopyTo(array, arrayIndex);
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    public void Insert(int index, T item) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    public void RemoveAt(int index) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    public bool Contains(T item) => _list.Contains(item);
                
                    /// <inheritdoc />
                    [CollectionAccess(None), Pure]
                    public bool Remove(T item) => false;
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    public int IndexOf(T item) => _list.IndexOf(item);
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    public IEnumerator<T> GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
                    public override string? ToString() => _list.ToString();
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Immutable.Once.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                #pragma warning disable CA1710, CA1815
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static CollectionAccessType;
                
                /// <summary>Extension methods that act as factories for <see cref="Once{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class OnceFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Creates a <see cref="Once{T}"/> from an item.</summary>
                    /// <typeparam name="T">The type of item.</typeparam>
                    /// <param name="source">The item.</param>
                    /// <returns>The <see cref="Once{T}"/> instance that can be yielded once.</returns>
                    [Pure]
                    public static Once<T> Yield<T>(this T source) => source;
                }
                
                /// <summary>A factory for creating iterator types that yields an item once.</summary>
                /// <typeparam name="T">The type of the item to yield.</typeparam>
                [StructLayout(LayoutKind.Auto)]
                readonly partial struct Once<T> : IList<T>, IReadOnlyList<T>, IReadOnlySet<T>, ISet<T>
                {
                    /// <summary>
                    /// Initializes a new instance of the <see cref="Once{T}"/> struct. Prepares enumeration of a single item forever.
                    /// </summary>
                    /// <param name="value">The item to use.</param>
                    public Once([ProvidesContext] T value) => Current = value;
                
                    /// <inheritdoc cref="ICollection{T}.IsReadOnly"/>
                    [CollectionAccess(None), Pure]
                    bool ICollection<T>.IsReadOnly => true;
                
                    /// <inheritdoc cref="IReadOnlyCollection{T}.Count"/>
                    [CollectionAccess(None), Pure]
                    int IReadOnlyCollection<T>.Count => 1;
                
                    /// <inheritdoc cref="ICollection{T}.Count"/>
                    [CollectionAccess(None), Pure]
                    int ICollection<T>.Count => 1;
                
                    /// <summary>Gets the item to use.</summary>
                    [CollectionAccess(Read), ProvidesContext, Pure]
                    public T Current { get; }
                
                    /// <inheritdoc cref="IList{T}.this"/>
                    [Pure]
                    T IList<T>.this[int _]
                    {
                        [CollectionAccess(Read)] get => Current;
                        [CollectionAccess(None)] set { }
                    }
                
                    /// <inheritdoc cref="IReadOnlyList{T}.this[int]"/>
                    [CollectionAccess(Read), Pure]
                    T IReadOnlyList<T>.this[int _] => Current;
                
                    /// <summary>Implicitly calls the constructor.</summary>
                    /// <param name="value">The value to pass into the constructor.</param>
                    /// <returns>A new instance of <see cref="Yes{T}"/> with <paramref name="value"/> passed in.</returns>
                    [CollectionAccess(None), Pure]
                    public static implicit operator Once<T>([ProvidesContext] T value) => new(value);
                
                    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
                    /// <param name="value">The value to call <see cref="Current"/>.</param>
                    /// <returns>The value that was passed in to this instance.</returns>
                    [CollectionAccess(Read), Pure]
                    public static implicit operator T(Once<T> value) => value.Current;
                
                    /// <inheritdoc />
                    [CollectionAccess(Read)]
                    public void CopyTo(T[] array, int arrayIndex) => array[arrayIndex] = Current;
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void ICollection<T>.Add(T item) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void ICollection<T>.Clear() { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void IList<T>.Insert(int index, T item) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void IList<T>.RemoveAt(int index) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void ISet<T>.ExceptWith(IEnumerable<T> other) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void ISet<T>.IntersectWith(IEnumerable<T> other) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void ISet<T>.SymmetricExceptWith(IEnumerable<T> other) { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void ISet<T>.UnionWith(IEnumerable<T> other) { }
                
                    /// <inheritdoc cref="ICollection{T}.Contains"/>
                    [CollectionAccess(Read), Pure]
                    public bool Contains(T item) => EqualityComparer<T>.Default.Equals(Current, item);
                
                    /// <inheritdoc cref="ISet{T}.IsProperSubsetOf" />
                    [CollectionAccess(Read), Pure]
                    public bool IsProperSubsetOf([InstantHandle] IEnumerable<T> other) =>
                        other.ToCollectionLazily() is { Count: > 1 } c && Overlaps(c);
                
                    /// <inheritdoc cref="ISet{T}.IsProperSupersetOf" />
                    [CollectionAccess(Read), Pure]
                    public bool IsProperSupersetOf([InstantHandle] IEnumerable<T> other) => !other.Any();
                
                    /// <inheritdoc cref="ISet{T}.IsSubsetOf" />
                    [CollectionAccess(Read), Pure]
                    public bool IsSubsetOf([InstantHandle] IEnumerable<T> other) => Overlaps(other);
                
                    /// <inheritdoc cref="ISet{T}.IsSupersetOf" />
                    [CollectionAccess(Read), Pure]
                    public bool IsSupersetOf([InstantHandle] IEnumerable<T> other) =>
                        other.ToCollectionLazily() is { Count: <= 1 } c && Overlaps(c);
                
                    /// <inheritdoc cref="ISet{T}.Overlaps" />
                    [CollectionAccess(Read), Pure]
                    public bool Overlaps([InstantHandle] IEnumerable<T> other) => other.Contains(Current);
                
                    /// <inheritdoc cref="ISet{T}.SetEquals" />
                    [CollectionAccess(Read), Pure]
                    public bool SetEquals([InstantHandle] IEnumerable<T> other) => other.SequenceEqual(this);
                
                    /// <inheritdoc />
                    [CollectionAccess(None), Pure]
                    bool ICollection<T>.Remove(T item) => false;
                
                    /// <inheritdoc />
                    [CollectionAccess(None), Pure]
                    bool ISet<T>.Add(T item) => false;
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    public int IndexOf(T item) => Contains(item) ? 0 : -1;
                
                    /// <summary>
                    /// Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
                    /// </summary>
                    /// <returns>Itself.</returns>
                    [CollectionAccess(Read), Pure]
                    public Enumerator GetEnumerator() => new(Current);
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                
                    /// <summary>An enumerator over <see cref="Once{T}"/>.</summary>
                    [StructLayout(LayoutKind.Auto)]
                    public partial struct Enumerator : IEnumerator<T>
                    {
                        bool _hasMoved;
                
                        /// <summary>
                        /// Initializes a new instance of the <see cref="Enumerator"/> struct.
                        /// Prepares enumeration of a single item forever.
                        /// </summary>
                        /// <param name="value">The item to use.</param>
                        public Enumerator(T value) => Current = value;
                
                        /// <inheritdoc />
                        [CollectionAccess(Read), Pure]
                        public T Current { get; }
                
                        /// <inheritdoc />
                        [CollectionAccess(Read), Pure]
                        readonly object? IEnumerator.Current => Current;
                
                        /// <summary>Implicitly calls the constructor.</summary>
                        /// <param name="value">The value to pass into the constructor.</param>
                        /// <returns>A new instance of <see cref="Yes{T}"/> with <paramref name="value"/> passed in.</returns>
                        [CollectionAccess(None), Pure]
                        public static implicit operator Enumerator(T value) => new(value);
                
                        /// <summary>Implicitly calls <see cref="Current"/>.</summary>
                        /// <param name="value">The value to call <see cref="Current"/>.</param>
                        /// <returns>The value that was passed in to this instance.</returns>
                        [CollectionAccess(Read), Pure]
                        public static implicit operator T(Enumerator value) => value.Current;
                
                        /// <inheritdoc />
                        [CollectionAccess(None)]
                        readonly void IDisposable.Dispose() { }
                
                        /// <inheritdoc />
                        [CollectionAccess(None)]
                        public bool MoveNext() => !_hasMoved && (_hasMoved = true);
                
                        /// <inheritdoc />
                        [CollectionAccess(None)]
                        public void Reset() => _hasMoved = false;
                    }
                }
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Immutable.Yes.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static CollectionAccessType;
                
                /// <summary>Extension methods that act as factories for <see cref="Yes{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class YesFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Creates a <see cref="Yes{T}"/> from an item.</summary>
                    /// <typeparam name="T">The type of item.</typeparam>
                    /// <param name="source">The item.</param>
                    /// <returns>The <see cref="Yes{T}"/> instance that can be yielded forever.</returns>
                    [Pure]
                    public static Yes<T> Forever<T>(this T source) => source;
                }
                
                /// <summary>A factory for creating iterator types that yield the same item forever.</summary>
                /// <typeparam name="T">The type of the item to yield.</typeparam>
                [StructLayout(LayoutKind.Auto)]
                readonly partial struct Yes<T> : IEnumerable<T>, IEnumerator<T>
                {
                    /// <summary>
                    /// Initializes a new instance of the <see cref="Yes{T}"/> struct. Prepares enumeration of a single item forever.
                    /// </summary>
                    /// <param name="value">The item to use.</param>
                    public Yes([ProvidesContext] T value) => Current = value;
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), ProvidesContext, Pure]
                    public T Current { get; }
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure]
                    object? IEnumerator.Current => Current;
                
                    /// <summary>Implicitly calls the constructor.</summary>
                    /// <param name="value">The value to pass into the constructor.</param>
                    /// <returns>A new instance of <see cref="Yes{T}"/> with <paramref name="value"/> passed in.</returns>
                    [CollectionAccess(Read), Pure]
                    public static implicit operator Yes<T>([ProvidesContext] T value) => new(value);
                
                    /// <summary>Implicitly calls <see cref="Current"/>.</summary>
                    /// <param name="value">The value to call <see cref="Current"/>.</param>
                    /// <returns>The value that was passed in to this instance.</returns>
                    [CollectionAccess(Read), Pure]
                    public static implicit operator T(Yes<T> value) => value.Current;
                
                    /// <summary>Returns itself.</summary>
                    /// <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="Yes{T}"/>.</para></remarks>
                    /// <returns>Itself.</returns>
                    [CollectionAccess(None), Pure]
                    public Yes<T> GetEnumerator() => this;
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void IDisposable.Dispose() { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None)]
                    void IEnumerator.Reset() { }
                
                    /// <inheritdoc />
                    [CollectionAccess(None), Pure]
                    bool IEnumerator.MoveNext() => true;
                
                    /// <inheritdoc />
                    [CollectionAccess(None), Pure]
                    IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(None), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Generics.CircularList.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static CollectionAccessType;
                
                #if !NET20 && !NET30
                /// <summary>Extension methods that act as factories for <see cref="CircularList{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class CircularFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="CircularList{T}"/>.</summary>
                    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
                    /// <param name="iterable">The collection to turn into a <see cref="CircularList{T}"/>.</param>
                    /// <returns>A <see cref="CircularList{T}"/> of <paramref name="iterable"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static CircularList<T>? ToCircularLazily<T>(this IEnumerable<T>? iterable) =>
                        iterable is null ? null : iterable as CircularList<T> ?? new(iterable.ToListLazily());
                }
                #endif
                
                /// <summary>
                /// Encapsulates an <see cref="IList{T}"/> where elements are treated as circular;
                /// indices wrap around and will therefore never be out of range.
                /// </summary>
                /// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
                sealed partial class CircularList<T> : IList<T>, IReadOnlyList<T>
                {
                    [ProvidesContext]
                    readonly IList<T> _list;
                
                    /// <summary>Initializes a new instance of the <see cref="CircularList{T}"/> class.</summary>
                    /// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
                    /// <exception cref="ArgumentOutOfRangeException"><see cref="Count"/> returns a non-positive number.</exception>
                    public CircularList([ProvidesContext] IList<T> list) => _list = list;
                
                    /// <inheritdoc/>
                    [CollectionAccess(None), Pure]
                    public bool IsReadOnly => _list.IsReadOnly;
                
                    /// <inheritdoc cref="ICollection{T}.Count"/>
                    [CollectionAccess(None), Pure, ValueRange(1, int.MaxValue)]
                    public int Count => _list.Count;
                
                    /// <inheritdoc cref="IList{T}.this"/>
                    [Pure]
                    public T this[int index]
                    {
                        [CollectionAccess(Read)] get => _list[Mod(index)];
                        [CollectionAccess(ModifyExistingContent)] set => _list[Mod(index)] = value;
                    }
                
                    /// <inheritdoc/>
                    [CollectionAccess(UpdatedContent)]
                    public void Add(T item) => _list.Add(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(ModifyExistingContent)]
                    public void Clear() => _list.Clear();
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read)]
                    public void CopyTo(T[] array, int arrayIndex) => _list.CopyTo(array, arrayIndex);
                
                    /// <inheritdoc/>
                    [CollectionAccess(UpdatedContent)]
                    public void Insert(int index, T item) => _list.Insert(Mod(index), item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(ModifyExistingContent)]
                    public void RemoveAt(int index) => _list.RemoveAt(Mod(index));
                
                    /// <inheritdoc cref="ICollection{T}.Contains"/>
                    [CollectionAccess(Read), Pure]
                    public bool Contains(T item) => _list.Contains(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read | ModifyExistingContent), Pure]
                    public bool Remove(T item) => _list.Remove(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    public int IndexOf(T item) => _list.IndexOf(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    public IEnumerator<T> GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
                    public override string? ToString() => _list.ToString();
                
                    [NonNegativeValue, Pure]
                    int Mod(int index) => Count is var i && i is not 0 ? (index % i + i) % i : throw CannotBeEmpty;
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Generics.ClippedList.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static CollectionAccessType;
                
                #if !NET20 && !NET30
                /// <summary>Extension methods that act as factories for <see cref="ClippedList{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class ClippedFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="ClippedList{T}"/>.</summary>
                    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
                    /// <param name="iterable">The collection to turn into a <see cref="ClippedList{T}"/>.</param>
                    /// <returns>A <see cref="ClippedList{T}"/> of <paramref name="iterable"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static ClippedList<T>? ToClippedLazily<T>(this IEnumerable<T>? iterable) =>
                        iterable is null ? null : iterable as ClippedList<T> ?? new(iterable.ToListLazily());
                }
                #endif
                
                /// <summary>
                /// Encapsulates an <see cref="IList{T}"/> where indices are always clamped and therefore never be out of range.
                /// </summary>
                /// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
                sealed partial class ClippedList<T> : IList<T>, IReadOnlyList<T>
                {
                    [ProvidesContext]
                    readonly IList<T> _list;
                
                    /// <summary>Initializes a new instance of the <see cref="ClippedList{T}"/> class.</summary>
                    /// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
                    /// <exception cref="ArgumentOutOfRangeException"><see cref="Count"/> returns a non-positive number.</exception>
                    public ClippedList([ProvidesContext] IList<T> list) => _list = list;
                
                    /// <inheritdoc/>
                    [CollectionAccess(None), Pure]
                    public bool IsReadOnly => _list.IsReadOnly;
                
                    /// <inheritdoc cref="ICollection{T}.Count"/>
                    [CollectionAccess(None), Pure, ValueRange(1, int.MaxValue)]
                    public int Count => _list.Count;
                
                    /// <inheritdoc cref="IList{T}.this"/>
                    [Pure]
                    public T this[int index]
                    {
                        [CollectionAccess(Read)] get => _list[Clamp(index)];
                        [CollectionAccess(ModifyExistingContent)] set => _list[Clamp(index)] = value;
                    }
                
                    /// <inheritdoc/>
                    [CollectionAccess(UpdatedContent)]
                    public void Add(T item) => _list.Add(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(ModifyExistingContent)]
                    public void Clear() => _list.Clear();
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read)]
                    public void CopyTo(T[] array, int arrayIndex) => _list.CopyTo(array, arrayIndex);
                
                    /// <inheritdoc/>
                    [CollectionAccess(UpdatedContent)]
                    public void Insert(int index, T item) => _list.Insert(Clamp(index), item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(ModifyExistingContent)]
                    public void RemoveAt(int index) => _list.RemoveAt(Clamp(index));
                
                    /// <inheritdoc cref="ICollection{T}.Contains"/>
                    [CollectionAccess(Read), Pure]
                    public bool Contains(T item) => _list.Contains(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read | ModifyExistingContent), Pure]
                    public bool Remove(T item) => _list.Remove(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    public int IndexOf(T item) => _list.IndexOf(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    public IEnumerator<T> GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
                    public override string? ToString() => _list.ToString();
                
                    [NonNegativeValue, Pure]
                    int Clamp(int index) => Count is var i && i is not 0 ? index.Clamp(0, i) : throw CannotBeEmpty;
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Generics.GuardedList.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                using static CollectionAccessType;
                
                #if !NET20 && !NET30
                /// <summary>Extension methods that act as factories for <see cref="GuardedList{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class GuardedFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Wraps an <see cref="IList{T}"/> (upcasted/created) to <see cref="GuardedList{T}"/>.</summary>
                    /// <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
                    /// <param name="iterable">The collection to turn into a <see cref="GuardedList{T}"/>.</param>
                    /// <returns>A <see cref="GuardedList{T}"/> of <paramref name="iterable"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterable))]
                    public static GuardedList<T>? ToGuardedLazily<T>(this IEnumerable<T>? iterable) =>
                        iterable is null ? null : iterable as GuardedList<T> ?? new(iterable.ToListLazily());
                }
                #endif
                
                /// <summary>
                /// Encapsulates an <see cref="IList{T}"/> where applying an index will always result in an optional value;
                /// an out of range value will always give the <see langword="default"/> value.
                /// </summary>
                /// <typeparam name="T">The generic type of the encapsulated <see cref="IList{T}"/>.</typeparam>
                sealed partial class GuardedList<T> : IList<T?>, IReadOnlyList<T?>
                {
                    [ProvidesContext]
                    readonly IList<T> _list;
                
                    /// <summary>Initializes a new instance of the <see cref="GuardedList{T}"/> class.</summary>
                    /// <param name="list">The <see cref="IList{T}"/> to encapsulate.</param>
                    public GuardedList([ProvidesContext] IList<T> list) => _list = list;
                
                    /// <inheritdoc/>
                    [CollectionAccess(None), Pure]
                    public bool IsReadOnly => _list.IsReadOnly;
                
                    /// <inheritdoc cref="ICollection{T}.Count"/>
                    [CollectionAccess(None), NonNegativeValue, Pure]
                    public int Count => _list.Count;
                
                    /// <inheritdoc cref="IList{T}.this"/>
                    [Pure]
                    public T? this[int index]
                    {
                        [CollectionAccess(Read)] get => IsIn(index) ? _list[index] : default;
                        [CollectionAccess(ModifyExistingContent)]
                        set
                        {
                            if (value is not null && IsIn(index))
                                _list[index] = value;
                        }
                    }
                
                    /// <inheritdoc/>
                    [CollectionAccess(UpdatedContent)]
                    public void Add(T? item)
                    {
                        if (item is not null)
                            _list.Add(item);
                    }
                
                    /// <inheritdoc/>
                    [CollectionAccess(ModifyExistingContent)]
                    public void Clear() => _list.Clear();
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read)]
                    public void CopyTo(T?[] array, int arrayIndex)
                    {
                        if (Count <= array.Length - arrayIndex)
                #pragma warning disable CS8620
                            _list.CopyTo(array, arrayIndex);
                #pragma warning restore CS8620
                    }
                
                    /// <inheritdoc/>
                    [CollectionAccess(UpdatedContent)]
                    public void Insert(int index, T? item)
                    {
                        if (item is not null && IsIn(index))
                            _list.Insert(index, item);
                    }
                
                    /// <inheritdoc/>
                    [CollectionAccess(ModifyExistingContent)]
                    public void RemoveAt(int index)
                    {
                        if (IsIn(index))
                            _list.RemoveAt(index);
                    }
                
                    /// <inheritdoc cref="ICollection{T}.Contains"/>
                    [CollectionAccess(Read), Pure]
                    public bool Contains(T? item) => item is not null && _list.Contains(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read | ModifyExistingContent), Pure]
                    public bool Remove(T? item) => item is not null && _list.Remove(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    public int IndexOf(T? item) => item is null ? -1 : _list.IndexOf(item);
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                #if NETFRAMEWORK && !NET40_OR_GREATER // Good job .NET 2.0 - 3.5 Nullable Analysis.
                #pragma warning disable CS8619
                #endif
                    public IEnumerator<T?> GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc/>
                    [CollectionAccess(Read), Pure]
                    IEnumerator IEnumerable.GetEnumerator() => _list.GetEnumerator();
                
                    /// <inheritdoc />
                    [CollectionAccess(Read), Pure] // ReSharper disable once ReturnTypeCanBeNotNullable
                    public override string? ToString() => _list.ToString();
                
                    [Pure]
                    bool IsIn(int index) => index >= 0 && index < Count;
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Generics.Matrix.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                #if !NET20 && !NET30
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Extension methods that act as factories for <see cref="Matrix{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class MatrixFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Wraps an <see cref="IList{T}"/> in a <see cref="Matrix{T}"/>.</summary>
                    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
                    /// <param name="iterator">The collection to turn into a <see cref="Matrix{T}"/>.</param>
                    /// <param name="countPerList">The length per count.</param>
                    /// <returns>A <see cref="Matrix{T}"/> that wraps the parameter <paramref name="iterator"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterator))]
                    public static Matrix<T>? AsMatrix<T>(this IEnumerable<T>? iterator, [NonNegativeValue] int countPerList) =>
                        iterator is null ? null : new(iterator.ToListLazily(), countPerList);
                
                    /// <summary>Wraps an <see cref="IList{T}"/> in a <see cref="Matrix{T}"/>.</summary>
                    /// <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
                    /// <param name="iterator">The collection to turn into a <see cref="Matrix{T}"/>.</param>
                    /// <param name="countPerList">The length per count.</param>
                    /// <returns>A <see cref="Matrix{T}"/> that wraps the parameter <paramref name="iterator"/>.</returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(iterator))]
                    public static Matrix<T>? AsMatrix<T>(this IEnumerable<T>? iterator, Func<int> countPerList) =>
                        iterator is null ? null : new(iterator.ToListLazily(), countPerList);
                }
                
                /// <summary>Maps a 1-dimensional collection as 2-dimensional.</summary>
                /// <typeparam name="T">The type of item within the list.</typeparam>
                sealed partial class Matrix<T> : IList<IList<T>>
                {
                    readonly int _countPerListEager;
                
                    readonly Func<int>? _countPerListLazy;
                
                    readonly IList<T>? _listEager;
                
                    readonly Func<IList<T>>? _listLazy;
                
                    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
                    /// <param name="list">The list to encapsulate.</param>
                    /// <param name="countPerList">The length per count.</param>
                    public Matrix(IList<T> list, [NonNegativeValue] int countPerList)
                    {
                        // Explicitly check, in case someone ignores the warning, or uses a variable.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        _countPerListEager = countPerList > 0
                            ? countPerList
                            : throw new ArgumentOutOfRangeException(nameof(countPerList), countPerList, "Value must be at least 1.");
                
                        _listEager = list;
                    }
                
                    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
                    /// <param name="list">The list to encapsulate.</param>
                    /// <param name="countPerList">The length per count.</param>
                    public Matrix(IList<T> list, Func<int> countPerList)
                    {
                        _countPerListLazy = countPerList;
                        _listEager = list;
                    }
                
                    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
                    /// <param name="list">The list to encapsulate.</param>
                    /// <param name="countPerList">The length per count.</param>
                    public Matrix(Func<IList<T>> list, [NonNegativeValue] int countPerList)
                    {
                        // Explicitly check, in case someone ignores the warning, or uses a variable.
                        // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                        _countPerListEager = countPerList > 0
                            ? countPerList
                            : throw new ArgumentOutOfRangeException(nameof(countPerList), countPerList, "Value must be at least 1.");
                
                        _listLazy = list;
                    }
                
                    /// <summary>Initializes a new instance of the <see cref="Matrix{T}"/> class.</summary>
                    /// <param name="list">The list to encapsulate.</param>
                    /// <param name="countPerList">The length per count.</param>
                    public Matrix(Func<IList<T>> list, Func<int> countPerList)
                    {
                        _countPerListLazy = countPerList;
                        _listLazy = list;
                    }
                
                    /// <summary>Gets the amount of items per list.</summary>
                    public int CountPerList
                    {
                        [Pure] get => _countPerListLazy?.Invoke() ?? _countPerListEager;
                    }
                
                    /// <summary>Gets the encapsulated list.</summary>
                    [ProvidesContext]
                #pragma warning disable CS8603 // Unreachable.
                    public IList<T> List
                    {
                        [Pure] // ReSharper disable once AssignNullToNotNullAttribute
                        get => _listLazy?.Invoke() ?? _listEager;
                    }
                #pragma warning restore CS8603
                
                    /// <inheritdoc />
                    public IList<T> this[[NonNegativeValue] int index]
                    {
                        [Pure] get => new Slice(this, index);
                        set => Add(value);
                    }
                
                    /// <inheritdoc />
                    public bool IsReadOnly
                    {
                        [Pure] get => List.IsReadOnly;
                    }
                
                    /// <inheritdoc />
                    [NonNegativeValue]
                    public int Count
                    {
                        [Pure] get => List.Count / CountPerList;
                    }
                
                    /// <inheritdoc />
                    public void Add(IList<T>? item) =>
                        item?.ToList()
                #pragma warning disable SA1110
                #if NETSTANDARD && !NETSTANDARD1_3_OR_GREATER
                           .For
                #else
                           .ForEach
                #endif
                                (List.Add);
                #pragma warning restore SA1110
                
                    /// <inheritdoc />
                    public void Clear() => List.Clear();
                
                    /// <inheritdoc />
                    [Pure]
                    public bool Contains(IList<T>? item) => item?.All(List.Contains) ?? false;
                
                    /// <inheritdoc />
                    public void CopyTo(IList<T>[] array, [NonNegativeValue] int arrayIndex)
                    {
                        for (var i = 0; i < Count; i++)
                            array[arrayIndex + i] = this[i];
                    }
                
                    /// <inheritdoc />
                    public void Insert([NonNegativeValue] int index, IList<T>? item)
                    {
                        if (item is not null)
                            this[index] = item;
                    }
                
                    /// <inheritdoc />
                    public void RemoveAt([NonNegativeValue] int index) => this[index].Clear();
                
                    /// <inheritdoc />
                    public bool Remove(IList<T>? item) => item?.Select(List.Remove).Any() ?? false;
                
                    /// <inheritdoc />
                    [Pure, ValueRange(-1, int.MaxValue)]
                    public int IndexOf(IList<T>? item) => item is null or { Count: 0 } ? -1 : List.IndexOf(item[0]);
                
                    /// <inheritdoc />
                    [Pure]
                    public IEnumerator<IList<T>> GetEnumerator() =>
                        Enumerable.Range(0, Count).Select(x => (IList<T>)new Slice(this, x)).GetEnumerator();
                
                    /// <inheritdoc />
                    [Pure]
                    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                
                    /// <summary>Represents a slice of a matrix.</summary>
                    sealed class Slice : IList<T>
                    {
                        [ProvidesContext]
                        readonly Matrix<T> _matrix;
                
                        [NonNegativeValue]
                        readonly int _ordinal;
                
                        /// <summary>Initializes a new instance of the <see cref="Slice"/> class.</summary>
                        /// <param name="matrix">The matrix to reference.</param>
                        /// <param name="ordinal">The first index of the matrix.</param>
                        public Slice(Matrix<T> matrix, [NonNegativeValue] int ordinal)
                        {
                            _matrix = matrix;
                
                            // Explicitly check, in case someone ignores the warning, or uses a variable.
                            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                            _ordinal = ordinal >= 0
                                ? ordinal
                                : throw new ArgumentOutOfRangeException(nameof(ordinal), ordinal, "Value must be at least 0.");
                        }
                
                        /// <inheritdoc />
                        public bool IsReadOnly
                        {
                            [Pure] get => _matrix.List.IsReadOnly;
                        }
                
                        /// <inheritdoc />
                        public int Count
                        {
                            [Pure] get => _matrix.CountPerList;
                        }
                
                        /// <inheritdoc />
                        public T this[[NonNegativeValue] int index]
                        {
                            [Pure] get => _matrix.List[Count * _ordinal + index];
                            set => _matrix.List[Count * _ordinal + index] = value;
                        }
                
                        /// <inheritdoc />
                        public void Add(T item) => _matrix.List.Add(item);
                
                        /// <inheritdoc />
                        public void Clear()
                        {
                            for (var i = 0; i < Count; i++)
                                _matrix.List.RemoveAt(Count * _ordinal);
                        }
                
                        /// <inheritdoc />
                        public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
                        {
                            for (var i = 0; i < Count; i++)
                                array[arrayIndex + i] = this[i];
                        }
                
                        /// <inheritdoc />
                        public void Insert([NonNegativeValue] int index, T item) => _matrix.List.Insert(Count * _ordinal + index, item);
                
                        /// <inheritdoc />
                        public void RemoveAt([NonNegativeValue] int index) => _matrix.List.RemoveAt(Count * _ordinal + index);
                
                        /// <inheritdoc />
                        [Pure]
                        public bool Contains(T item) =>
                            Enumerable.Range(0, Count).Any(x => EqualityComparer<T>.Default.Equals(_matrix.List[Count * _ordinal + x]));
                
                        /// <inheritdoc />
                        public bool Remove(T item) => Contains(item) && _matrix.List.Remove(item);
                
                        /// <inheritdoc />
                        [Pure, ValueRange(-1, int.MaxValue)]
                        public int IndexOf(T item) => Contains(item) ? _matrix.List.IndexOf(item) - Count * _ordinal : -1;
                
                        /// <inheritdoc />
                        [Pure]
                        public IEnumerator<T> GetEnumerator() => _matrix.List.Skip(Count * _ordinal).Take(Count).GetEnumerator();
                
                        /// <inheritdoc />
                        [Pure]
                        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                    }
                }
                
                #endif
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Specialized.Headless.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                
                /// <summary>Provides the deconstruction to extract the head and tail of a collection.</summary>
                static partial class Headless
                {
                    /// <summary>Separates the head from the tail of an <see cref="ICollection{T}"/>.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="collection">The enumerable to split.</param>
                    /// <param name="head">The first element of the parameter <paramref name="collection"/>.</param>
                    /// <param name="tail">The rest of the parameter <paramref name="collection"/>.</param>
                    public static void Deconstruct<T>(
                        this IList<T>? collection,
                        out T? head,
                        [NotNullIfNotNull(nameof(collection))] out IList<T>? tail
                    )
                    {
                        head = collection is null ? default : collection.FirstOrDefault();
                        tail = collection.Tail();
                    }
                
                    /// <summary>Gets the tail of the <see cref="ICollection{T}"/>.</summary>
                    /// <typeparam name="T">The item in the collection.</typeparam>
                    /// <param name="collection">The collection to extract the tail from.</param>
                    /// <returns>
                    /// The encapsulation of the parameter <paramref name="collection"/> that prevents the head from being accessed.
                    /// </returns>
                    [Pure]
                    [return: NotNullIfNotNull(nameof(collection))]
                    public static HeadlessList<T>? Tail<T>(this IList<T>? collection) => collection is null ? null : new(collection);
                }
                
                /// <summary>Represents a list with no head.</summary>
                /// <typeparam name="T">The type of list to encapsulate.</typeparam>
                #pragma warning disable MA0048
                sealed partial class HeadlessList<T> : IList<T>
                #pragma warning restore MA0048
                {
                    readonly IList<T> _list;
                
                    /// <summary>Initializes a new instance of the <see cref="HeadlessList{T}"/> class.</summary>
                    /// <param name="list">The list to encapsulate.</param>
                    public HeadlessList(IList<T> list) => _list = list;
                
                    /// <inheritdoc />
                    public T this[int index]
                    {
                        get => index is not -1 ? _list[index + 1] : throw new ArgumentOutOfRangeException(nameof(index));
                        set => _list[index + 1] = index is not -1 ? value : throw new ArgumentOutOfRangeException(nameof(index));
                    }
                
                    /// <inheritdoc />
                    public bool IsReadOnly => _list.IsReadOnly;
                
                    /// <inheritdoc />
                    public int Count => _list.Count - 1;
                
                    /// <inheritdoc />
                    public void Add(T item) => _list.Add(item);
                
                    /// <inheritdoc />
                    public void Clear() => _list.Clear();
                
                    /// <inheritdoc />
                    public void CopyTo(T[] array, int arrayIndex)
                    {
                        for (var i = 0; i < Count && arrayIndex + i < array.Length; i++)
                            array[arrayIndex + i] = this[i];
                    }
                
                    /// <inheritdoc />
                    public void Insert(int index, T item)
                    {
                        if (index is -1)
                            throw new ArgumentOutOfRangeException(nameof(index));
                
                        _list.Insert(index + 1, item);
                    }
                
                    /// <inheritdoc />
                    public void RemoveAt(int index)
                    {
                        if (index is not -1)
                            throw new ArgumentOutOfRangeException(nameof(index));
                
                        _list.RemoveAt(index + 1);
                    }
                
                    /// <inheritdoc />
                    public bool Contains(T item) => _list.Contains(item);
                
                    /// <inheritdoc />
                    public bool Remove(T item) => _list.Remove(item);
                
                    /// <inheritdoc />
                    public int IndexOf(T item) => _list.IndexOf(item) is var result && result is -1 ? -1 : result - 1;
                
                    /// <inheritdoc />
                    IEnumerator IEnumerable.GetEnumerator()
                    {
                        var ret = ((IEnumerable)_list).GetEnumerator();
                        ret.MoveNext();
                        return ret;
                    }
                
                    /// <inheritdoc />
                    public IEnumerator<T> GetEnumerator()
                    {
                        var ret = _list.GetEnumerator();
                        ret.MoveNext();
                        return ret;
                    }
                }
                """"
            );

        if (lang is ".cs")
            Make(
                context,
                "Emik.Morsels.Source.References.Emik.Collections.Specialized.Split.g.cs",
                """"
                // <auto-generated/>
                // SPDX-License-Identifier: MPL-2.0
                
                // ReSharper disable once CheckNamespace
                namespace Emik.Morsels;
                #if !NET20 && !NET30
                /// <summary>Extension methods that act as factories for <see cref="Split{T}"/>.</summary>
                #pragma warning disable MA0048
                static partial class SplitFactory
                #pragma warning restore MA0048
                {
                    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a number.</summary>
                    /// <typeparam name="T">The type of the collection.</typeparam>
                    /// <param name="source">The collection to split.</param>
                    /// <param name="count">The number of elements in the first half.</param>
                    /// <returns>
                    /// A <see cref="Split{T}"/> instance that contains 2 enumerables containing the two halves of the underlying
                    /// collection. The first half is as long as the parameter <paramref name="count"/> or shorter.
                    /// </returns>
                    [Pure]
                    public static Split<IEnumerable<T>> SplitAt<T>(this ICollection<T> source, [NonNegativeValue] int count) =>
                        new(source.Take(count), source.Skip(count));
                
                    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
                    /// <typeparam name="T">The type of the collection.</typeparam>
                    /// <param name="source">The collection to split.</param>
                    /// <param name="predicate">The method that decides where the item ends up.</param>
                    /// <returns>
                    /// A <see cref="Split{T}"/> instance that contains 2 lists containing the elements that returned
                    /// <see langword="true"/> and <see langword="false"/>.
                    /// </returns>
                    [MustUseReturnValue]
                    public static Split<List<T>> SplitBy<T>(this IEnumerable<T> source, [InstantHandle] Predicate<T> predicate)
                    {
                        List<T> t = new(), f = new();
                
                        foreach (var item in source)
                #pragma warning disable RCS1235 // While AddRange is faster, the item is required for context.
                            (predicate(item) ? t : f).Add(item);
                #pragma warning restore RCS1235
                
                        return new(t, f);
                    }
                
                    /// <summary>Splits an <see cref="IEnumerable{T}"/> in two based on a method provided.</summary>
                    /// <typeparam name="T">The type of the collection.</typeparam>
                    /// <param name="source">The collection to split.</param>
                    /// <param name="predicate">The method that decides where the item ends up.</param>
                    /// <returns>
                    /// A <see cref="Split{T}"/> instance that contains 2 enumerables containing the two halves of the underlying
                    /// collection. The first half lasts until the first element that returned <see langword="true"/>.
                    /// </returns>
                    [Pure]
                    public static Split<IEnumerable<T>> SplitWhen<T>(
                        this ICollection<T> source,
                        [InstantHandle] Func<T, bool> predicate
                    )
                    {
                        var index = source.TakeWhile(Not1(predicate)).Count();
                        return source.SplitAt(index);
                    }
                }
                #endif
                
                /// <summary>Represents a fixed collection of 2 items.</summary>
                /// <typeparam name="T">The type of item in the collection.</typeparam>
                sealed partial class Split<T> : ICollection<T>,
                    IDictionary<bool, T>,
                    IReadOnlyCollection<T>,
                    IReadOnlyDictionary<bool, T>
                {
                    [ProvidesContext]
                    static readonly bool[] s_booleans = { true, false };
                
                    /// <summary>Initializes a new instance of the <see cref="Split{T}"/> class.</summary>
                    /// <param name="value">The value representing both values.</param>
                    public Split(T value)
                        : this(value, value) { }
                
                    /// <summary>Initializes a new instance of the <see cref="Split{T}"/> class.</summary>
                    /// <param name="truthy">The value representing a <see langword="true"/> value.</param>
                    /// <param name="falsy">The value representing a <see langword="false"/> value.</param>
                    public Split(T truthy, T falsy)
                    {
                        Truthy = truthy;
                        Falsy = falsy;
                    }
                
                    /// <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
                    [Pure]
                    public T Falsy { get; set; }
                
                    /// <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
                    [Pure]
                    public T Truthy { get; set; }
                
                    /// <inheritdoc cref="ICollection{T}.IsReadOnly" />
                    [Pure]
                    bool ICollection<T>.IsReadOnly => false;
                
                    /// <inheritdoc cref="ICollection{T}.Count" />
                    [Pure, ValueRange(2)]
                    int ICollection<T>.Count => 2;
                
                    /// <inheritdoc />
                    public void CopyTo(T[] array, [NonNegativeValue] int arrayIndex)
                    {
                        array[arrayIndex] = Truthy;
                        array[arrayIndex + 1] = Falsy;
                    }
                
                    /// <inheritdoc />
                    [Pure]
                    public bool Contains(T item) =>
                        EqualityComparer<T>.Default.Equals(Truthy, item) ||
                        EqualityComparer<T>.Default.Equals(Falsy, item);
                
                    /// <inheritdoc />
                    [Pure]
                    public IEnumerator<T> GetEnumerator()
                    {
                        yield return Truthy;
                        yield return Falsy;
                    }
                
                    /// <inheritdoc />
                    void ICollection<T>.Add(T item) { }
                
                    /// <inheritdoc cref="ICollection{T}.Clear" />
                    void ICollection<T>.Clear() { }
                
                    /// <inheritdoc />
                    [Pure]
                    bool ICollection<T>.Remove(T item) => false;
                
                    /// <inheritdoc />
                    [Pure]
                    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
                
                    /// <inheritdoc />
                    [Pure]
                    public ICollection<T> Values => this;
                
                    /// <inheritdoc cref="ICollection{T}.IsReadOnly" />
                    [Pure]
                    bool ICollection<KeyValuePair<bool, T>>.IsReadOnly => false;
                
                    /// <inheritdoc cref="ICollection{T}.Count" />
                    [Pure, ValueRange(2)]
                    int ICollection<KeyValuePair<bool, T>>.Count => 2;
                
                    /// <inheritdoc />
                    [Pure]
                    ICollection<bool> IDictionary<bool, T>.Keys => s_booleans;
                
                    /// <inheritdoc cref="IDictionary{TKey, TValue}.this" />
                    [Pure]
                    public T this[bool key]
                    {
                        get => key ? Truthy : Falsy;
                        set => _ = key ? Truthy = value : Falsy = value;
                    }
                
                    /// <inheritdoc />
                    public void Add(bool key, T value) => _ = key ? Truthy = value : Falsy = value;
                
                    /// <inheritdoc />
                    public void Add(KeyValuePair<bool, T> item) => _ = item.Key ? Truthy = item.Value : Falsy = item.Value;
                
                    /// <inheritdoc />
                    public void CopyTo(KeyValuePair<bool, T>[] array, [NonNegativeValue] int arrayIndex)
                    {
                        array[arrayIndex] = new(true, Truthy);
                        array[arrayIndex + 1] = new(false, Falsy);
                    }
                
                    /// <inheritdoc />
                    [Pure]
                    public bool Contains(KeyValuePair<bool, T> item) =>
                        item.Key
                            ? EqualityComparer<T>.Default.Equals(Truthy, item.Value)
                            : EqualityComparer<T>.Default.Equals(Falsy, item.Value);
                
                    /// <inheritdoc cref="IDictionary{TKey, TValue}.TryGetValue" />
                    [Pure]
                    public bool TryGetValue(bool key, out T value)
                    {
                        value = key ? Truthy : Falsy;
                        return true;
                    }
                
                    /// <inheritdoc cref="ICollection{T}.Clear" />
                    void ICollection<KeyValuePair<bool, T>>.Clear() { }
                
                    /// <inheritdoc />
                    [Pure]
                    bool ICollection<KeyValuePair<bool, T>>.Remove(KeyValuePair<bool, T> item) => false;
                
                    /// <inheritdoc />
                    [Pure]
                    bool IDictionary<bool, T>.Remove(bool key) => false;
                
                    /// <inheritdoc cref="IDictionary{TKey, TValue}.ContainsKey" />
                    [Pure]
                    bool IDictionary<bool, T>.ContainsKey(bool key) => true;
                
                    /// <inheritdoc />
                    [Pure]
                    IEnumerator<KeyValuePair<bool, T>> IEnumerable<KeyValuePair<bool, T>>.GetEnumerator()
                    {
                        yield return new(true, Truthy);
                        yield return new(false, Falsy);
                    }
                
                    /// <inheritdoc cref="IReadOnlyCollection{T}.Count" />
                    [Pure, ValueRange(2)]
                    int IReadOnlyCollection<T>.Count => 2;
                
                    /// <inheritdoc cref="IReadOnlyCollection{T}.Count" />
                    [Pure, ValueRange(2)]
                    int IReadOnlyCollection<KeyValuePair<bool, T>>.Count => 2;
                
                    /// <inheritdoc />
                    [Pure]
                    IEnumerable<bool> IReadOnlyDictionary<bool, T>.Keys => s_booleans;
                
                    /// <inheritdoc />
                    [Pure]
                    IEnumerable<T> IReadOnlyDictionary<bool, T>.Values => Values;
                
                    /// <inheritdoc cref="IReadOnlyDictionary{TKey, TValue}.ContainsKey" />
                    [Pure]
                    bool IReadOnlyDictionary<bool, T>.ContainsKey(bool key) => true;
                
                    /// <summary>Deconstructs a <see cref="Split{T}"/> into its components.</summary>
                    /// <param name="truthy">The value to get assigned as <see cref="Truthy"/>.</param>
                    /// <param name="falsy">The value to get assigned as <see cref="Falsy"/>.</param>
                    public void Deconstruct(out T truthy, out T falsy)
                    {
                        truthy = Truthy;
                        falsy = Falsy;
                    }
                
                    /// <inheritdoc />
                    [Pure]
                    public override string ToString() => $"Split({Truthy}, {Falsy})";
                }
                """"
            );

}

    /// <inheritdoc />
    [CLSCompliant(false)]
    public void Initialize(GeneratorInitializationContext context) { }

    static void Make(
        GeneratorExecutionContext context,
        [PathReference] string file,
        [StringSyntax("C#")] string content
    ) =>
        context.AddSource(file, content);

    [Pure]
    static string? ExtensionFromLanguage(GeneratorExecutionContext context) => context.Compilation.Language switch
    {
        "C#" => ".cs",
        "F#" => ".fs",
        "Visual Basic" => ".vb",
        _ => null,
    };
}
